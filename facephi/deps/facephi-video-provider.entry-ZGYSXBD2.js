import {
  LicenseComponents,
  onChange
} from "./chunk-Z6DSV6CQ.js";
import {
  Host,
  createEvent,
  getElement,
  h,
  registerInstance
} from "./chunk-HZFM5WJ6.js";
import {
  __commonJS,
  __toESM
} from "./chunk-PNDESK4O.js";

// node_modules/@facephi/sdk-video-recording/node_modules/agora-rtc-sdk-ng/AgoraRTC_N-production.js
var require_AgoraRTC_N_production = __commonJS({
  "node_modules/@facephi/sdk-video-recording/node_modules/agora-rtc-sdk-ng/AgoraRTC_N-production.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).AgoraRTC = t();
    }(exports, function() {
      "use strict";
      function e(e2, t2) {
        return t2.forEach(function(t3) {
          t3 && "string" != typeof t3 && !Array.isArray(t3) && Object.keys(t3).forEach(function(i2) {
            if ("default" !== i2 && !(i2 in e2)) {
              var n2 = Object.getOwnPropertyDescriptor(t3, i2);
              Object.defineProperty(e2, i2, n2.get ? n2 : { enumerable: true, get: function() {
                return t3[i2];
              } });
            }
          });
        }), Object.freeze(e2);
      }
      var t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
      function i(e2) {
        return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
      }
      var n = function(e2) {
        try {
          return !!e2();
        } catch (e3) {
          return true;
        }
      }, r = !n(function() {
        var e2 = (function() {
        }).bind();
        return "function" != typeof e2 || e2.hasOwnProperty("prototype");
      }), s = r, o = Function.prototype, a = o.call, c = s && o.bind.bind(a, a), d = s ? c : function(e2) {
        return function() {
          return a.apply(e2, arguments);
        };
      }, l = d({}.isPrototypeOf), u = function(e2) {
        return e2 && e2.Math == Math && e2;
      }, h2 = u("object" == typeof globalThis && globalThis) || u("object" == typeof window && window) || u("object" == typeof self && self) || u("object" == typeof t && t) || /* @__PURE__ */ function() {
        return this;
      }() || t || Function("return this")(), p = r, _ = Function.prototype, E = _.apply, m = _.call, f = "object" == typeof Reflect && Reflect.apply || (p ? m.bind(E) : function() {
        return m.apply(E, arguments);
      }), g = d, T = g({}.toString), S = g("".slice), R = function(e2) {
        return S(T(e2), 8, -1);
      }, C = R, I = d, v = function(e2) {
        if ("Function" === C(e2)) return I(e2);
      }, y = "object" == typeof document && document.all, A = { all: y, IS_HTMLDDA: void 0 === y && void 0 !== y }, b = A.all, w = A.IS_HTMLDDA ? function(e2) {
        return "function" == typeof e2 || e2 === b;
      } : function(e2) {
        return "function" == typeof e2;
      }, O = {}, N = !n(function() {
        return 7 != Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1];
      }), D = r, P = Function.prototype.call, L = D ? P.bind(P) : function() {
        return P.apply(P, arguments);
      }, k = {}, M = {}.propertyIsEnumerable, U = Object.getOwnPropertyDescriptor, x = U && !M.call({ 1: 2 }, 1);
      k.f = x ? function(e2) {
        var t2 = U(this, e2);
        return !!t2 && t2.enumerable;
      } : M;
      var V, F, B = function(e2, t2) {
        return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t2 };
      }, j = n, G = R, W = Object, H = d("".split), K = j(function() {
        return !W("z").propertyIsEnumerable(0);
      }) ? function(e2) {
        return "String" == G(e2) ? H(e2, "") : W(e2);
      } : W, Y = function(e2) {
        return null == e2;
      }, q = Y, z = TypeError, J = function(e2) {
        if (q(e2)) throw z("Can't call method on " + e2);
        return e2;
      }, X = K, Q = J, Z = function(e2) {
        return X(Q(e2));
      }, $ = w, ee = A.all, te = A.IS_HTMLDDA ? function(e2) {
        return "object" == typeof e2 ? null !== e2 : $(e2) || e2 === ee;
      } : function(e2) {
        return "object" == typeof e2 ? null !== e2 : $(e2);
      }, ie = {}, ne = ie, re = h2, se = w, oe = function(e2) {
        return se(e2) ? e2 : void 0;
      }, ae = function(e2, t2) {
        return arguments.length < 2 ? oe(ne[e2]) || oe(re[e2]) : ne[e2] && ne[e2][t2] || re[e2] && re[e2][t2];
      }, ce = "undefined" != typeof navigator && String(navigator.userAgent) || "", de = h2, le = ce, ue = de.process, he = de.Deno, pe = ue && ue.versions || he && he.version, _e = pe && pe.v8;
      _e && (F = (V = _e.split("."))[0] > 0 && V[0] < 4 ? 1 : +(V[0] + V[1])), !F && le && (!(V = le.match(/Edge\/(\d+)/)) || V[1] >= 74) && (V = le.match(/Chrome\/(\d+)/)) && (F = +V[1]);
      var Ee = F, me = Ee, fe = n, ge = h2.String, Te = !!Object.getOwnPropertySymbols && !fe(function() {
        var e2 = Symbol();
        return !ge(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && me && me < 41;
      }), Se = Te && !Symbol.sham && "symbol" == typeof Symbol.iterator, Re = ae, Ce = w, Ie = l, ve = Object, ye = Se ? function(e2) {
        return "symbol" == typeof e2;
      } : function(e2) {
        var t2 = Re("Symbol");
        return Ce(t2) && Ie(t2.prototype, ve(e2));
      }, Ae = String, be = function(e2) {
        try {
          return Ae(e2);
        } catch (e3) {
          return "Object";
        }
      }, we = w, Oe = be, Ne = TypeError, De = function(e2) {
        if (we(e2)) return e2;
        throw Ne(Oe(e2) + " is not a function");
      }, Pe = De, Le = Y, ke = function(e2, t2) {
        var i2 = e2[t2];
        return Le(i2) ? void 0 : Pe(i2);
      }, Me = L, Ue = w, xe = te, Ve = TypeError, Fe = { exports: {} }, Be = h2, je = Object.defineProperty, Ge = function(e2, t2) {
        try {
          je(Be, e2, { value: t2, configurable: true, writable: true });
        } catch (i2) {
          Be[e2] = t2;
        }
        return t2;
      }, We = "__core-js_shared__", He = h2[We] || Ge(We, {}), Ke = He;
      (Fe.exports = function(e2, t2) {
        return Ke[e2] || (Ke[e2] = void 0 !== t2 ? t2 : {});
      })("versions", []).push({ version: "3.31.1", mode: "pure", copyright: "Â© 2014-2023 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.31.1/LICENSE", source: "https://github.com/zloirock/core-js" });
      var Ye = Fe.exports, qe = J, ze = Object, Je = function(e2) {
        return ze(qe(e2));
      }, Xe = Je, Qe = d({}.hasOwnProperty), Ze = Object.hasOwn || function(e2, t2) {
        return Qe(Xe(e2), t2);
      }, $e = d, et = 0, tt = Math.random(), it = $e(1 .toString), nt = function(e2) {
        return "Symbol(" + (void 0 === e2 ? "" : e2) + ")_" + it(++et + tt, 36);
      }, rt = Ye, st = Ze, ot = nt, at = Te, ct = Se, dt = h2.Symbol, lt = rt("wks"), ut = ct ? dt.for || dt : dt && dt.withoutSetter || ot, ht = function(e2) {
        return st(lt, e2) || (lt[e2] = at && st(dt, e2) ? dt[e2] : ut("Symbol." + e2)), lt[e2];
      }, pt = L, _t = te, Et = ye, mt = ke, ft = function(e2, t2) {
        var i2, n2;
        if ("string" === t2 && Ue(i2 = e2.toString) && !xe(n2 = Me(i2, e2))) return n2;
        if (Ue(i2 = e2.valueOf) && !xe(n2 = Me(i2, e2))) return n2;
        if ("string" !== t2 && Ue(i2 = e2.toString) && !xe(n2 = Me(i2, e2))) return n2;
        throw Ve("Can't convert object to primitive value");
      }, gt = TypeError, Tt = ht("toPrimitive"), St = function(e2, t2) {
        if (!_t(e2) || Et(e2)) return e2;
        var i2, n2 = mt(e2, Tt);
        if (n2) {
          if (void 0 === t2 && (t2 = "default"), i2 = pt(n2, e2, t2), !_t(i2) || Et(i2)) return i2;
          throw gt("Can't convert object to primitive value");
        }
        return void 0 === t2 && (t2 = "number"), ft(e2, t2);
      }, Rt = ye, Ct = function(e2) {
        var t2 = St(e2, "string");
        return Rt(t2) ? t2 : t2 + "";
      }, It = te, vt = h2.document, yt = It(vt) && It(vt.createElement), At = function(e2) {
        return yt ? vt.createElement(e2) : {};
      }, bt = At, wt = !N && !n(function() {
        return 7 != Object.defineProperty(bt("div"), "a", { get: function() {
          return 7;
        } }).a;
      }), Ot = N, Nt = L, Dt = k, Pt = B, Lt = Z, kt = Ct, Mt = Ze, Ut = wt, xt = Object.getOwnPropertyDescriptor;
      O.f = Ot ? xt : function(e2, t2) {
        if (e2 = Lt(e2), t2 = kt(t2), Ut) try {
          return xt(e2, t2);
        } catch (e3) {
        }
        if (Mt(e2, t2)) return Pt(!Nt(Dt.f, e2, t2), e2[t2]);
      };
      var Vt = n, Ft = w, Bt = /#|\.prototype\./, jt = function(e2, t2) {
        var i2 = Wt[Gt(e2)];
        return i2 == Kt || i2 != Ht && (Ft(t2) ? Vt(t2) : !!t2);
      }, Gt = jt.normalize = function(e2) {
        return String(e2).replace(Bt, ".").toLowerCase();
      }, Wt = jt.data = {}, Ht = jt.NATIVE = "N", Kt = jt.POLYFILL = "P", Yt = jt, qt = De, zt = r, Jt = v(v.bind), Xt = function(e2, t2) {
        return qt(e2), void 0 === t2 ? e2 : zt ? Jt(e2, t2) : function() {
          return e2.apply(t2, arguments);
        };
      }, Qt = {}, Zt = N && n(function() {
        return 42 != Object.defineProperty(function() {
        }, "prototype", { value: 42, writable: false }).prototype;
      }), $t = te, ei = String, ti = TypeError, ii = function(e2) {
        if ($t(e2)) return e2;
        throw ti(ei(e2) + " is not an object");
      }, ni = N, ri = wt, si = Zt, oi = ii, ai = Ct, ci = TypeError, di = Object.defineProperty, li = Object.getOwnPropertyDescriptor, ui = "enumerable", hi = "configurable", pi = "writable";
      Qt.f = ni ? si ? function(e2, t2, i2) {
        if (oi(e2), t2 = ai(t2), oi(i2), "function" == typeof e2 && "prototype" === t2 && "value" in i2 && pi in i2 && !i2[pi]) {
          var n2 = li(e2, t2);
          n2 && n2[pi] && (e2[t2] = i2.value, i2 = { configurable: hi in i2 ? i2[hi] : n2[hi], enumerable: ui in i2 ? i2[ui] : n2[ui], writable: false });
        }
        return di(e2, t2, i2);
      } : di : function(e2, t2, i2) {
        if (oi(e2), t2 = ai(t2), oi(i2), ri) try {
          return di(e2, t2, i2);
        } catch (e3) {
        }
        if ("get" in i2 || "set" in i2) throw ci("Accessors not supported");
        return "value" in i2 && (e2[t2] = i2.value), e2;
      };
      var _i = Qt, Ei = B, mi = N ? function(e2, t2, i2) {
        return _i.f(e2, t2, Ei(1, i2));
      } : function(e2, t2, i2) {
        return e2[t2] = i2, e2;
      }, fi = h2, gi = f, Ti = v, Si = w, Ri = O.f, Ci = Yt, Ii = ie, vi = Xt, yi = mi, Ai = Ze, bi = function(e2) {
        var t2 = function(i2, n2, r2) {
          if (this instanceof t2) {
            switch (arguments.length) {
              case 0:
                return new e2();
              case 1:
                return new e2(i2);
              case 2:
                return new e2(i2, n2);
            }
            return new e2(i2, n2, r2);
          }
          return gi(e2, this, arguments);
        };
        return t2.prototype = e2.prototype, t2;
      }, wi = function(e2, t2) {
        var i2, n2, r2, s2, o2, a2, c2, d2, l2, u2 = e2.target, h3 = e2.global, p2 = e2.stat, _2 = e2.proto, E2 = h3 ? fi : p2 ? fi[u2] : (fi[u2] || {}).prototype, m2 = h3 ? Ii : Ii[u2] || yi(Ii, u2, {})[u2], f2 = m2.prototype;
        for (s2 in t2) n2 = !(i2 = Ci(h3 ? s2 : u2 + (p2 ? "." : "#") + s2, e2.forced)) && E2 && Ai(E2, s2), a2 = m2[s2], n2 && (c2 = e2.dontCallGetSet ? (l2 = Ri(E2, s2)) && l2.value : E2[s2]), o2 = n2 && c2 ? c2 : t2[s2], n2 && typeof a2 == typeof o2 || (d2 = e2.bind && n2 ? vi(o2, fi) : e2.wrap && n2 ? bi(o2) : _2 && Si(o2) ? Ti(o2) : o2, (e2.sham || o2 && o2.sham || a2 && a2.sham) && yi(d2, "sham", true), yi(m2, s2, d2), _2 && (Ai(Ii, r2 = u2 + "Prototype") || yi(Ii, r2, {}), yi(Ii[r2], s2, o2), e2.real && f2 && (i2 || !f2[s2]) && yi(f2, s2, o2)));
      }, Oi = Math.ceil, Ni = Math.floor, Di = Math.trunc || function(e2) {
        var t2 = +e2;
        return (t2 > 0 ? Ni : Oi)(t2);
      }, Pi = function(e2) {
        var t2 = +e2;
        return t2 != t2 || 0 === t2 ? 0 : Di(t2);
      }, Li = Pi, ki = Math.max, Mi = Math.min, Ui = function(e2, t2) {
        var i2 = Li(e2);
        return i2 < 0 ? ki(i2 + t2, 0) : Mi(i2, t2);
      }, xi = Pi, Vi = Math.min, Fi = function(e2) {
        return e2 > 0 ? Vi(xi(e2), 9007199254740991) : 0;
      }, Bi = function(e2) {
        return Fi(e2.length);
      }, ji = Z, Gi = Ui, Wi = Bi, Hi = function(e2) {
        return function(t2, i2, n2) {
          var r2, s2 = ji(t2), o2 = Wi(s2), a2 = Gi(n2, o2);
          if (e2 && i2 != i2) {
            for (; o2 > a2; ) if ((r2 = s2[a2++]) != r2) return true;
          } else for (; o2 > a2; a2++) if ((e2 || a2 in s2) && s2[a2] === i2) return e2 || a2 || 0;
          return !e2 && -1;
        };
      }, Ki = { includes: Hi(true), indexOf: Hi(false) }, Yi = Ki.includes;
      wi({ target: "Array", proto: true, forced: n(function() {
        return !Array(1).includes();
      }) }, { includes: function(e2) {
        return Yi(this, e2, arguments.length > 1 ? arguments[1] : void 0);
      } });
      var qi = ie, zi = function(e2) {
        return qi[e2 + "Prototype"];
      }, Ji = zi("Array").includes, Xi = te, Qi = R, Zi = ht("match"), $i = function(e2) {
        var t2;
        return Xi(e2) && (void 0 !== (t2 = e2[Zi]) ? !!t2 : "RegExp" == Qi(e2));
      }, en = TypeError, tn = {};
      tn[ht("toStringTag")] = "z";
      var nn = "[object z]" === String(tn), rn = nn, sn = w, on = R, an = ht("toStringTag"), cn = Object, dn = "Arguments" == on(/* @__PURE__ */ function() {
        return arguments;
      }()), ln = rn ? on : function(e2) {
        var t2, i2, n2;
        return void 0 === e2 ? "Undefined" : null === e2 ? "Null" : "string" == typeof (i2 = function(e3, t3) {
          try {
            return e3[t3];
          } catch (e4) {
          }
        }(t2 = cn(e2), an)) ? i2 : dn ? on(t2) : "Object" == (n2 = on(t2)) && sn(t2.callee) ? "Arguments" : n2;
      }, un = ln, hn = String, pn = function(e2) {
        if ("Symbol" === un(e2)) throw TypeError("Cannot convert a Symbol value to a string");
        return hn(e2);
      }, _n = ht("match"), En = wi, mn = function(e2) {
        if ($i(e2)) throw en("The method doesn't accept regular expressions");
        return e2;
      }, fn = J, gn = pn, Tn = function(e2) {
        var t2 = /./;
        try {
          "/./"[e2](t2);
        } catch (i2) {
          try {
            return t2[_n] = false, "/./"[e2](t2);
          } catch (e3) {
          }
        }
        return false;
      }, Sn = d("".indexOf);
      En({ target: "String", proto: true, forced: !Tn("includes") }, { includes: function(e2) {
        return !!~Sn(gn(fn(this)), gn(mn(e2)), arguments.length > 1 ? arguments[1] : void 0);
      } });
      var Rn = zi("String").includes, Cn = l, In = Ji, vn = Rn, yn = Array.prototype, An = String.prototype, bn = i(function(e2) {
        var t2 = e2.includes;
        return e2 === yn || Cn(yn, e2) && t2 === yn.includes ? In : "string" == typeof e2 || e2 === An || Cn(An, e2) && t2 === An.includes ? vn : t2;
      });
      let wn = true, On = true;
      function Nn(e2, t2, i2) {
        const n2 = e2.match(t2);
        return n2 && n2.length >= i2 && parseInt(n2[i2], 10);
      }
      function Dn(e2, t2, i2) {
        if (!e2.RTCPeerConnection) return;
        const n2 = e2.RTCPeerConnection.prototype, r2 = n2.addEventListener;
        n2.addEventListener = function(e3, n3) {
          if (e3 !== t2) return r2.apply(this, arguments);
          const s3 = (e4) => {
            const t3 = i2(e4);
            t3 && (n3.handleEvent ? n3.handleEvent(t3) : n3(t3));
          };
          return this._eventMap = this._eventMap || {}, this._eventMap[t2] || (this._eventMap[t2] = /* @__PURE__ */ new Map()), this._eventMap[t2].set(n3, s3), r2.apply(this, [e3, s3]);
        };
        const s2 = n2.removeEventListener;
        n2.removeEventListener = function(e3, i3) {
          if (e3 !== t2 || !this._eventMap || !this._eventMap[t2]) return s2.apply(this, arguments);
          if (!this._eventMap[t2].has(i3)) return s2.apply(this, arguments);
          const n3 = this._eventMap[t2].get(i3);
          return this._eventMap[t2].delete(i3), 0 === this._eventMap[t2].size && delete this._eventMap[t2], 0 === Object.keys(this._eventMap).length && delete this._eventMap, s2.apply(this, [e3, n3]);
        }, Object.defineProperty(n2, "on" + t2, { get() {
          return this["_on" + t2];
        }, set(e3) {
          this["_on" + t2] && (this.removeEventListener(t2, this["_on" + t2]), delete this["_on" + t2]), e3 && this.addEventListener(t2, this["_on" + t2] = e3);
        }, enumerable: true, configurable: true });
      }
      function Pn(e2) {
        return "boolean" != typeof e2 ? new Error("Argument type: " + typeof e2 + ". Please use a boolean.") : (wn = e2, e2 ? "adapter.js logging disabled" : "adapter.js logging enabled");
      }
      function Ln(e2) {
        return "boolean" != typeof e2 ? new Error("Argument type: " + typeof e2 + ". Please use a boolean.") : (On = !e2, "adapter.js deprecation warnings " + (e2 ? "disabled" : "enabled"));
      }
      function kn() {
        if ("object" == typeof window) {
          if (wn) return;
          "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments);
        }
      }
      function Mn(e2, t2) {
        On && console.warn(e2 + " is deprecated, please use " + t2 + " instead.");
      }
      function Un(e2) {
        return "[object Object]" === Object.prototype.toString.call(e2);
      }
      function xn(e2) {
        return Un(e2) ? Object.keys(e2).reduce(function(t2, i2) {
          const n2 = Un(e2[i2]), r2 = n2 ? xn(e2[i2]) : e2[i2], s2 = n2 && !Object.keys(r2).length;
          return void 0 === r2 || s2 ? t2 : Object.assign(t2, { [i2]: r2 });
        }, {}) : e2;
      }
      function Vn(e2, t2, i2) {
        t2 && !i2.has(t2.id) && (i2.set(t2.id, t2), Object.keys(t2).forEach((n2) => {
          n2.endsWith("Id") ? Vn(e2, e2.get(t2[n2]), i2) : n2.endsWith("Ids") && t2[n2].forEach((t3) => {
            Vn(e2, e2.get(t3), i2);
          });
        }));
      }
      function Fn(e2, t2, i2) {
        const n2 = i2 ? "outbound-rtp" : "inbound-rtp", r2 = /* @__PURE__ */ new Map();
        if (null === t2) return r2;
        const s2 = [];
        return e2.forEach((e3) => {
          "track" === e3.type && e3.trackIdentifier === t2.id && s2.push(e3);
        }), s2.forEach((t3) => {
          e2.forEach((i3) => {
            i3.type === n2 && i3.trackId === t3.id && Vn(e2, i3, r2);
          });
        }), r2;
      }
      const Bn = kn;
      function jn(e2, t2) {
        const i2 = e2 && e2.navigator;
        if (!i2.mediaDevices) return;
        const n2 = function(e3) {
          if ("object" != typeof e3 || e3.mandatory || e3.optional) return e3;
          const t3 = {};
          return Object.keys(e3).forEach((i3) => {
            if ("require" === i3 || "advanced" === i3 || "mediaSource" === i3) return;
            const n3 = "object" == typeof e3[i3] ? e3[i3] : { ideal: e3[i3] };
            void 0 !== n3.exact && "number" == typeof n3.exact && (n3.min = n3.max = n3.exact);
            const r3 = function(e4, t4) {
              return e4 ? e4 + t4.charAt(0).toUpperCase() + t4.slice(1) : "deviceId" === t4 ? "sourceId" : t4;
            };
            if (void 0 !== n3.ideal) {
              t3.optional = t3.optional || [];
              let e4 = {};
              "number" == typeof n3.ideal ? (e4[r3("min", i3)] = n3.ideal, t3.optional.push(e4), e4 = {}, e4[r3("max", i3)] = n3.ideal, t3.optional.push(e4)) : (e4[r3("", i3)] = n3.ideal, t3.optional.push(e4));
            }
            void 0 !== n3.exact && "number" != typeof n3.exact ? (t3.mandatory = t3.mandatory || {}, t3.mandatory[r3("", i3)] = n3.exact) : ["min", "max"].forEach((e4) => {
              void 0 !== n3[e4] && (t3.mandatory = t3.mandatory || {}, t3.mandatory[r3(e4, i3)] = n3[e4]);
            });
          }), e3.advanced && (t3.optional = (t3.optional || []).concat(e3.advanced)), t3;
        }, r2 = function(e3, r3) {
          if (t2.version >= 61) return r3(e3);
          if ((e3 = JSON.parse(JSON.stringify(e3))) && "object" == typeof e3.audio) {
            const t3 = function(e4, t4, i3) {
              t4 in e4 && !(i3 in e4) && (e4[i3] = e4[t4], delete e4[t4]);
            };
            t3((e3 = JSON.parse(JSON.stringify(e3))).audio, "autoGainControl", "googAutoGainControl"), t3(e3.audio, "noiseSuppression", "googNoiseSuppression"), e3.audio = n2(e3.audio);
          }
          if (e3 && "object" == typeof e3.video) {
            let s3 = e3.video.facingMode;
            s3 = s3 && ("object" == typeof s3 ? s3 : { ideal: s3 });
            const o2 = t2.version < 66;
            if (s3 && ("user" === s3.exact || "environment" === s3.exact || "user" === s3.ideal || "environment" === s3.ideal) && (!i2.mediaDevices.getSupportedConstraints || !i2.mediaDevices.getSupportedConstraints().facingMode || o2)) {
              let t3;
              if (delete e3.video.facingMode, "environment" === s3.exact || "environment" === s3.ideal ? t3 = ["back", "rear"] : "user" !== s3.exact && "user" !== s3.ideal || (t3 = ["front"]), t3) return i2.mediaDevices.enumerateDevices().then((i3) => {
                let o3 = (i3 = i3.filter((e4) => "videoinput" === e4.kind)).find((e4) => t3.some((t4) => e4.label.toLowerCase().includes(t4)));
                return !o3 && i3.length && t3.includes("back") && (o3 = i3[i3.length - 1]), o3 && (e3.video.deviceId = s3.exact ? { exact: o3.deviceId } : { ideal: o3.deviceId }), e3.video = n2(e3.video), Bn("chrome: " + JSON.stringify(e3)), r3(e3);
              });
            }
            e3.video = n2(e3.video);
          }
          return Bn("chrome: " + JSON.stringify(e3)), r3(e3);
        }, s2 = function(e3) {
          return t2.version >= 64 ? e3 : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[e3.name] || e3.name, message: e3.message, constraint: e3.constraint || e3.constraintName, toString() {
            return this.name + (this.message && ": ") + this.message;
          } };
        };
        if (i2.getUserMedia = (function(e3, t3, n3) {
          r2(e3, (e4) => {
            i2.webkitGetUserMedia(e4, t3, (e5) => {
              n3 && n3(s2(e5));
            });
          });
        }).bind(i2), i2.mediaDevices.getUserMedia) {
          const e3 = i2.mediaDevices.getUserMedia.bind(i2.mediaDevices);
          i2.mediaDevices.getUserMedia = function(t3) {
            return r2(t3, (t4) => e3(t4).then((e4) => {
              if (t4.audio && !e4.getAudioTracks().length || t4.video && !e4.getVideoTracks().length) throw e4.getTracks().forEach((e5) => {
                e5.stop();
              }), new DOMException("", "NotFoundError");
              return e4;
            }, (e4) => Promise.reject(s2(e4))));
          };
        }
      }
      function Gn(e2) {
        e2.MediaStream = e2.MediaStream || e2.webkitMediaStream;
      }
      function Wn(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection && !("ontrack" in e2.RTCPeerConnection.prototype)) {
          Object.defineProperty(e2.RTCPeerConnection.prototype, "ontrack", { get() {
            return this._ontrack;
          }, set(e3) {
            this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e3);
          }, enumerable: true, configurable: true });
          const t2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
          e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
            return this._ontrackpoly || (this._ontrackpoly = (t3) => {
              t3.stream.addEventListener("addtrack", (i2) => {
                let n2;
                n2 = e2.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e3) => e3.track && e3.track.id === i2.track.id) : { track: i2.track };
                const r2 = new Event("track");
                r2.track = i2.track, r2.receiver = n2, r2.transceiver = { receiver: n2 }, r2.streams = [t3.stream], this.dispatchEvent(r2);
              }), t3.stream.getTracks().forEach((i2) => {
                let n2;
                n2 = e2.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e3) => e3.track && e3.track.id === i2.id) : { track: i2 };
                const r2 = new Event("track");
                r2.track = i2, r2.receiver = n2, r2.transceiver = { receiver: n2 }, r2.streams = [t3.stream], this.dispatchEvent(r2);
              });
            }, this.addEventListener("addstream", this._ontrackpoly)), t2.apply(this, arguments);
          };
        } else Dn(e2, "track", (e3) => (e3.transceiver || Object.defineProperty(e3, "transceiver", { value: { receiver: e3.receiver } }), e3));
      }
      function Hn(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection && !("getSenders" in e2.RTCPeerConnection.prototype) && "createDTMFSender" in e2.RTCPeerConnection.prototype) {
          const t2 = function(e3, t3) {
            return { track: t3, get dtmf() {
              return void 0 === this._dtmf && ("audio" === t3.kind ? this._dtmf = e3.createDTMFSender(t3) : this._dtmf = null), this._dtmf;
            }, _pc: e3 };
          };
          if (!e2.RTCPeerConnection.prototype.getSenders) {
            e2.RTCPeerConnection.prototype.getSenders = function() {
              return this._senders = this._senders || [], this._senders.slice();
            };
            const i3 = e2.RTCPeerConnection.prototype.addTrack;
            e2.RTCPeerConnection.prototype.addTrack = function(e3, n4) {
              let r2 = i3.apply(this, arguments);
              return r2 || (r2 = t2(this, e3), this._senders.push(r2)), r2;
            };
            const n3 = e2.RTCPeerConnection.prototype.removeTrack;
            e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
              n3.apply(this, arguments);
              const t3 = this._senders.indexOf(e3);
              -1 !== t3 && this._senders.splice(t3, 1);
            };
          }
          const i2 = e2.RTCPeerConnection.prototype.addStream;
          e2.RTCPeerConnection.prototype.addStream = function(e3) {
            this._senders = this._senders || [], i2.apply(this, [e3]), e3.getTracks().forEach((e4) => {
              this._senders.push(t2(this, e4));
            });
          };
          const n2 = e2.RTCPeerConnection.prototype.removeStream;
          e2.RTCPeerConnection.prototype.removeStream = function(e3) {
            this._senders = this._senders || [], n2.apply(this, [e3]), e3.getTracks().forEach((e4) => {
              const t3 = this._senders.find((t4) => t4.track === e4);
              t3 && this._senders.splice(this._senders.indexOf(t3), 1);
            });
          };
        } else if ("object" == typeof e2 && e2.RTCPeerConnection && "getSenders" in e2.RTCPeerConnection.prototype && "createDTMFSender" in e2.RTCPeerConnection.prototype && e2.RTCRtpSender && !("dtmf" in e2.RTCRtpSender.prototype)) {
          const t2 = e2.RTCPeerConnection.prototype.getSenders;
          e2.RTCPeerConnection.prototype.getSenders = function() {
            const e3 = t2.apply(this, []);
            return e3.forEach((e4) => e4._pc = this), e3;
          }, Object.defineProperty(e2.RTCRtpSender.prototype, "dtmf", { get() {
            return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;
          } });
        }
      }
      function Kn(e2) {
        if (!e2.RTCPeerConnection) return;
        const t2 = e2.RTCPeerConnection.prototype.getStats;
        e2.RTCPeerConnection.prototype.getStats = function() {
          const [e3, i2, n2] = arguments;
          if (arguments.length > 0 && "function" == typeof e3) return t2.apply(this, arguments);
          if (0 === t2.length && (0 === arguments.length || "function" != typeof e3)) return t2.apply(this, []);
          const r2 = function(e4) {
            const t3 = {};
            return e4.result().forEach((e5) => {
              const i3 = { id: e5.id, timestamp: e5.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e5.type] || e5.type };
              e5.names().forEach((t4) => {
                i3[t4] = e5.stat(t4);
              }), t3[i3.id] = i3;
            }), t3;
          }, s2 = function(e4) {
            return new Map(Object.keys(e4).map((t3) => [t3, e4[t3]]));
          };
          if (arguments.length >= 2) {
            const n3 = function(e4) {
              i2(s2(r2(e4)));
            };
            return t2.apply(this, [n3, e3]);
          }
          return new Promise((e4, i3) => {
            t2.apply(this, [function(t3) {
              e4(s2(r2(t3)));
            }, i3]);
          }).then(i2, n2);
        };
      }
      function Yn(e2) {
        if (!("object" == typeof e2 && e2.RTCPeerConnection && e2.RTCRtpSender && e2.RTCRtpReceiver)) return;
        if (!("getStats" in e2.RTCRtpSender.prototype)) {
          const t3 = e2.RTCPeerConnection.prototype.getSenders;
          t3 && (e2.RTCPeerConnection.prototype.getSenders = function() {
            const e3 = t3.apply(this, []);
            return e3.forEach((e4) => e4._pc = this), e3;
          });
          const i2 = e2.RTCPeerConnection.prototype.addTrack;
          i2 && (e2.RTCPeerConnection.prototype.addTrack = function() {
            const e3 = i2.apply(this, arguments);
            return e3._pc = this, e3;
          }), e2.RTCRtpSender.prototype.getStats = function() {
            const e3 = this;
            return this._pc.getStats().then((t4) => Fn(t4, e3.track, true));
          };
        }
        if (!("getStats" in e2.RTCRtpReceiver.prototype)) {
          const t3 = e2.RTCPeerConnection.prototype.getReceivers;
          t3 && (e2.RTCPeerConnection.prototype.getReceivers = function() {
            const e3 = t3.apply(this, []);
            return e3.forEach((e4) => e4._pc = this), e3;
          }), Dn(e2, "track", (e3) => (e3.receiver._pc = e3.srcElement, e3)), e2.RTCRtpReceiver.prototype.getStats = function() {
            const e3 = this;
            return this._pc.getStats().then((t4) => Fn(t4, e3.track, false));
          };
        }
        if (!("getStats" in e2.RTCRtpSender.prototype) || !("getStats" in e2.RTCRtpReceiver.prototype)) return;
        const t2 = e2.RTCPeerConnection.prototype.getStats;
        e2.RTCPeerConnection.prototype.getStats = function() {
          if (arguments.length > 0 && arguments[0] instanceof e2.MediaStreamTrack) {
            const e3 = arguments[0];
            let t3, i2, n2;
            return this.getSenders().forEach((i3) => {
              i3.track === e3 && (t3 ? n2 = true : t3 = i3);
            }), this.getReceivers().forEach((t4) => (t4.track === e3 && (i2 ? n2 = true : i2 = t4), t4.track === e3)), n2 || t3 && i2 ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : t3 ? t3.getStats() : i2 ? i2.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
          }
          return t2.apply(this, arguments);
        };
      }
      function qn(e2) {
        e2.RTCPeerConnection.prototype.getLocalStreams = function() {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((e3) => this._shimmedLocalStreams[e3][0]);
        };
        const t2 = e2.RTCPeerConnection.prototype.addTrack;
        e2.RTCPeerConnection.prototype.addTrack = function(e3, i3) {
          if (!i3) return t2.apply(this, arguments);
          this._shimmedLocalStreams = this._shimmedLocalStreams || {};
          const n3 = t2.apply(this, arguments);
          return this._shimmedLocalStreams[i3.id] ? -1 === this._shimmedLocalStreams[i3.id].indexOf(n3) && this._shimmedLocalStreams[i3.id].push(n3) : this._shimmedLocalStreams[i3.id] = [i3, n3], n3;
        };
        const i2 = e2.RTCPeerConnection.prototype.addStream;
        e2.RTCPeerConnection.prototype.addStream = function(e3) {
          this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e3.getTracks().forEach((e4) => {
            if (this.getSenders().find((t4) => t4.track === e4)) throw new DOMException("Track already exists.", "InvalidAccessError");
          });
          const t3 = this.getSenders();
          i2.apply(this, arguments);
          const n3 = this.getSenders().filter((e4) => -1 === t3.indexOf(e4));
          this._shimmedLocalStreams[e3.id] = [e3].concat(n3);
        };
        const n2 = e2.RTCPeerConnection.prototype.removeStream;
        e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e3.id], n2.apply(this, arguments);
        };
        const r2 = e2.RTCPeerConnection.prototype.removeTrack;
        e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e3 && Object.keys(this._shimmedLocalStreams).forEach((t3) => {
            const i3 = this._shimmedLocalStreams[t3].indexOf(e3);
            -1 !== i3 && this._shimmedLocalStreams[t3].splice(i3, 1), 1 === this._shimmedLocalStreams[t3].length && delete this._shimmedLocalStreams[t3];
          }), r2.apply(this, arguments);
        };
      }
      function zn(e2, t2) {
        if (!e2.RTCPeerConnection) return;
        if (e2.RTCPeerConnection.prototype.addTrack && t2.version >= 65) return qn(e2);
        const i2 = e2.RTCPeerConnection.prototype.getLocalStreams;
        e2.RTCPeerConnection.prototype.getLocalStreams = function() {
          const e3 = i2.apply(this);
          return this._reverseStreams = this._reverseStreams || {}, e3.map((e4) => this._reverseStreams[e4.id]);
        };
        const n2 = e2.RTCPeerConnection.prototype.addStream;
        e2.RTCPeerConnection.prototype.addStream = function(t3) {
          if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t3.getTracks().forEach((e3) => {
            if (this.getSenders().find((t4) => t4.track === e3)) throw new DOMException("Track already exists.", "InvalidAccessError");
          }), !this._reverseStreams[t3.id]) {
            const i3 = new e2.MediaStream(t3.getTracks());
            this._streams[t3.id] = i3, this._reverseStreams[i3.id] = t3, t3 = i3;
          }
          n2.apply(this, [t3]);
        };
        const r2 = e2.RTCPeerConnection.prototype.removeStream;
        function s2(e3, t3) {
          let i3 = t3.sdp;
          return Object.keys(e3._reverseStreams || []).forEach((t4) => {
            const n3 = e3._reverseStreams[t4], r3 = e3._streams[n3.id];
            i3 = i3.replace(new RegExp(r3.id, "g"), n3.id);
          }), new RTCSessionDescription({ type: t3.type, sdp: i3 });
        }
        e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, r2.apply(this, [this._streams[e3.id] || e3]), delete this._reverseStreams[this._streams[e3.id] ? this._streams[e3.id].id : e3.id], delete this._streams[e3.id];
        }, e2.RTCPeerConnection.prototype.addTrack = function(t3, i3) {
          if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
          const n3 = [].slice.call(arguments, 1);
          if (1 !== n3.length || !n3[0].getTracks().find((e3) => e3 === t3)) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
          if (this.getSenders().find((e3) => e3.track === t3)) throw new DOMException("Track already exists.", "InvalidAccessError");
          this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
          const r3 = this._streams[i3.id];
          if (r3) r3.addTrack(t3), Promise.resolve().then(() => {
            this.dispatchEvent(new Event("negotiationneeded"));
          });
          else {
            const n4 = new e2.MediaStream([t3]);
            this._streams[i3.id] = n4, this._reverseStreams[n4.id] = i3, this.addStream(n4);
          }
          return this.getSenders().find((e3) => e3.track === t3);
        }, ["createOffer", "createAnswer"].forEach(function(t3) {
          const i3 = e2.RTCPeerConnection.prototype[t3], n3 = { [t3]() {
            const e3 = arguments;
            return arguments.length && "function" == typeof arguments[0] ? i3.apply(this, [(t4) => {
              const i4 = s2(this, t4);
              e3[0].apply(null, [i4]);
            }, (t4) => {
              e3[1] && e3[1].apply(null, t4);
            }, arguments[2]]) : i3.apply(this, arguments).then((e4) => s2(this, e4));
          } };
          e2.RTCPeerConnection.prototype[t3] = n3[t3];
        });
        const o2 = e2.RTCPeerConnection.prototype.setLocalDescription;
        e2.RTCPeerConnection.prototype.setLocalDescription = function() {
          return arguments.length && arguments[0].type ? (arguments[0] = function(e3, t3) {
            let i3 = t3.sdp;
            return Object.keys(e3._reverseStreams || []).forEach((t4) => {
              const n3 = e3._reverseStreams[t4], r3 = e3._streams[n3.id];
              i3 = i3.replace(new RegExp(n3.id, "g"), r3.id);
            }), new RTCSessionDescription({ type: t3.type, sdp: i3 });
          }(this, arguments[0]), o2.apply(this, arguments)) : o2.apply(this, arguments);
        };
        const a2 = Object.getOwnPropertyDescriptor(e2.RTCPeerConnection.prototype, "localDescription");
        Object.defineProperty(e2.RTCPeerConnection.prototype, "localDescription", { get() {
          const e3 = a2.get.apply(this);
          return "" === e3.type ? e3 : s2(this, e3);
        } }), e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
          if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
          if (!e3._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
          if (!(e3._pc === this)) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
          let t3;
          this._streams = this._streams || {}, Object.keys(this._streams).forEach((i3) => {
            this._streams[i3].getTracks().find((t4) => e3.track === t4) && (t3 = this._streams[i3]);
          }), t3 && (1 === t3.getTracks().length ? this.removeStream(this._reverseStreams[t3.id]) : t3.removeTrack(e3.track), this.dispatchEvent(new Event("negotiationneeded")));
        };
      }
      function Jn(e2, t2) {
        !e2.RTCPeerConnection && e2.webkitRTCPeerConnection && (e2.RTCPeerConnection = e2.webkitRTCPeerConnection), e2.RTCPeerConnection && t2.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t3) {
          const i2 = e2.RTCPeerConnection.prototype[t3], n2 = { [t3]() {
            return arguments[0] = new ("addIceCandidate" === t3 ? e2.RTCIceCandidate : e2.RTCSessionDescription)(arguments[0]), i2.apply(this, arguments);
          } };
          e2.RTCPeerConnection.prototype[t3] = n2[t3];
        });
      }
      function Xn(e2, t2) {
        Dn(e2, "negotiationneeded", (e3) => {
          const i2 = e3.target;
          if (!(t2.version < 72 || i2.getConfiguration && "plan-b" === i2.getConfiguration().sdpSemantics) || "stable" === i2.signalingState) return e3;
        });
      }
      var Qn = Object.freeze({ __proto__: null, fixNegotiationNeeded: Xn, shimAddTrackRemoveTrack: zn, shimAddTrackRemoveTrackWithNative: qn, shimGetDisplayMedia: function(e2, t2) {
        e2.navigator.mediaDevices && "getDisplayMedia" in e2.navigator.mediaDevices || e2.navigator.mediaDevices && ("function" == typeof t2 ? e2.navigator.mediaDevices.getDisplayMedia = function(i2) {
          return t2(i2).then((t3) => {
            const n2 = i2.video && i2.video.width, r2 = i2.video && i2.video.height, s2 = i2.video && i2.video.frameRate;
            return i2.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: t3, maxFrameRate: s2 || 3 } }, n2 && (i2.video.mandatory.maxWidth = n2), r2 && (i2.video.mandatory.maxHeight = r2), e2.navigator.mediaDevices.getUserMedia(i2);
          });
        } : console.error("shimGetDisplayMedia: getSourceId argument is not a function"));
      }, shimGetSendersWithDtmf: Hn, shimGetStats: Kn, shimGetUserMedia: jn, shimMediaStream: Gn, shimOnTrack: Wn, shimPeerConnection: Jn, shimSenderReceiverGetStats: Yn });
      function Zn(e2, t2) {
        const i2 = e2 && e2.navigator, n2 = e2 && e2.MediaStreamTrack;
        if (i2.getUserMedia = function(e3, t3, n3) {
          Mn("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), i2.mediaDevices.getUserMedia(e3).then(t3, n3);
        }, !(t2.version > 55 && "autoGainControl" in i2.mediaDevices.getSupportedConstraints())) {
          const e3 = function(e4, t4, i3) {
            t4 in e4 && !(i3 in e4) && (e4[i3] = e4[t4], delete e4[t4]);
          }, t3 = i2.mediaDevices.getUserMedia.bind(i2.mediaDevices);
          if (i2.mediaDevices.getUserMedia = function(i3) {
            return "object" == typeof i3 && "object" == typeof i3.audio && (i3 = JSON.parse(JSON.stringify(i3)), e3(i3.audio, "autoGainControl", "mozAutoGainControl"), e3(i3.audio, "noiseSuppression", "mozNoiseSuppression")), t3(i3);
          }, n2 && n2.prototype.getSettings) {
            const t4 = n2.prototype.getSettings;
            n2.prototype.getSettings = function() {
              const i3 = t4.apply(this, arguments);
              return e3(i3, "mozAutoGainControl", "autoGainControl"), e3(i3, "mozNoiseSuppression", "noiseSuppression"), i3;
            };
          }
          if (n2 && n2.prototype.applyConstraints) {
            const t4 = n2.prototype.applyConstraints;
            n2.prototype.applyConstraints = function(i3) {
              return "audio" === this.kind && "object" == typeof i3 && (i3 = JSON.parse(JSON.stringify(i3)), e3(i3, "autoGainControl", "mozAutoGainControl"), e3(i3, "noiseSuppression", "mozNoiseSuppression")), t4.apply(this, [i3]);
            };
          }
        }
      }
      function $n(e2) {
        "object" == typeof e2 && e2.RTCTrackEvent && "receiver" in e2.RTCTrackEvent.prototype && !("transceiver" in e2.RTCTrackEvent.prototype) && Object.defineProperty(e2.RTCTrackEvent.prototype, "transceiver", { get() {
          return { receiver: this.receiver };
        } });
      }
      function er(e2, t2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection && !e2.mozRTCPeerConnection) return;
        !e2.RTCPeerConnection && e2.mozRTCPeerConnection && (e2.RTCPeerConnection = e2.mozRTCPeerConnection), t2.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t3) {
          const i3 = e2.RTCPeerConnection.prototype[t3], n3 = { [t3]() {
            return arguments[0] = new ("addIceCandidate" === t3 ? e2.RTCIceCandidate : e2.RTCSessionDescription)(arguments[0]), i3.apply(this, arguments);
          } };
          e2.RTCPeerConnection.prototype[t3] = n3[t3];
        });
        const i2 = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, n2 = e2.RTCPeerConnection.prototype.getStats;
        e2.RTCPeerConnection.prototype.getStats = function() {
          const [e3, r2, s2] = arguments;
          return n2.apply(this, [e3 || null]).then((e4) => {
            if (t2.version < 53 && !r2) try {
              e4.forEach((e5) => {
                e5.type = i2[e5.type] || e5.type;
              });
            } catch (t3) {
              if ("TypeError" !== t3.name) throw t3;
              e4.forEach((t4, n3) => {
                e4.set(n3, Object.assign({}, t4, { type: i2[t4.type] || t4.type }));
              });
            }
            return e4;
          }).then(r2, s2);
        };
      }
      function tr(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection || !e2.RTCRtpSender) return;
        if (e2.RTCRtpSender && "getStats" in e2.RTCRtpSender.prototype) return;
        const t2 = e2.RTCPeerConnection.prototype.getSenders;
        t2 && (e2.RTCPeerConnection.prototype.getSenders = function() {
          const e3 = t2.apply(this, []);
          return e3.forEach((e4) => e4._pc = this), e3;
        });
        const i2 = e2.RTCPeerConnection.prototype.addTrack;
        i2 && (e2.RTCPeerConnection.prototype.addTrack = function() {
          const e3 = i2.apply(this, arguments);
          return e3._pc = this, e3;
        }), e2.RTCRtpSender.prototype.getStats = function() {
          return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
        };
      }
      function ir(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection || !e2.RTCRtpSender) return;
        if (e2.RTCRtpSender && "getStats" in e2.RTCRtpReceiver.prototype) return;
        const t2 = e2.RTCPeerConnection.prototype.getReceivers;
        t2 && (e2.RTCPeerConnection.prototype.getReceivers = function() {
          const e3 = t2.apply(this, []);
          return e3.forEach((e4) => e4._pc = this), e3;
        }), Dn(e2, "track", (e3) => (e3.receiver._pc = e3.srcElement, e3)), e2.RTCRtpReceiver.prototype.getStats = function() {
          return this._pc.getStats(this.track);
        };
      }
      function nr(e2) {
        e2.RTCPeerConnection && !("removeStream" in e2.RTCPeerConnection.prototype) && (e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          Mn("removeStream", "removeTrack"), this.getSenders().forEach((t2) => {
            t2.track && e3.getTracks().includes(t2.track) && this.removeTrack(t2);
          });
        });
      }
      function rr(e2) {
        e2.DataChannel && !e2.RTCDataChannel && (e2.RTCDataChannel = e2.DataChannel);
      }
      function sr(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection) return;
        const t2 = e2.RTCPeerConnection.prototype.addTransceiver;
        t2 && (e2.RTCPeerConnection.prototype.addTransceiver = function() {
          this.setParametersPromises = [];
          let e3 = arguments[1] && arguments[1].sendEncodings;
          void 0 === e3 && (e3 = []), e3 = [...e3];
          const i2 = e3.length > 0;
          i2 && e3.forEach((e4) => {
            if ("rid" in e4) {
              if (!/^[a-z0-9]{0,16}$/i.test(e4.rid)) throw new TypeError("Invalid RID value provided.");
            }
            if ("scaleResolutionDownBy" in e4 && !(parseFloat(e4.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0");
            if ("maxFramerate" in e4 && !(parseFloat(e4.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0");
          });
          const n2 = t2.apply(this, arguments);
          if (i2) {
            const { sender: t3 } = n2, i3 = t3.getParameters();
            (!("encodings" in i3) || 1 === i3.encodings.length && 0 === Object.keys(i3.encodings[0]).length) && (i3.encodings = e3, t3.sendEncodings = e3, this.setParametersPromises.push(t3.setParameters(i3).then(() => {
              delete t3.sendEncodings;
            }).catch(() => {
              delete t3.sendEncodings;
            })));
          }
          return n2;
        });
      }
      function or(e2) {
        if ("object" != typeof e2 || !e2.RTCRtpSender) return;
        const t2 = e2.RTCRtpSender.prototype.getParameters;
        t2 && (e2.RTCRtpSender.prototype.getParameters = function() {
          const e3 = t2.apply(this, arguments);
          return "encodings" in e3 || (e3.encodings = [].concat(this.sendEncodings || [{}])), e3;
        });
      }
      function ar(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection) return;
        const t2 = e2.RTCPeerConnection.prototype.createOffer;
        e2.RTCPeerConnection.prototype.createOffer = function() {
          return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t2.apply(this, arguments)).finally(() => {
            this.setParametersPromises = [];
          }) : t2.apply(this, arguments);
        };
      }
      function cr(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection) return;
        const t2 = e2.RTCPeerConnection.prototype.createAnswer;
        e2.RTCPeerConnection.prototype.createAnswer = function() {
          return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t2.apply(this, arguments)).finally(() => {
            this.setParametersPromises = [];
          }) : t2.apply(this, arguments);
        };
      }
      var dr = Object.freeze({ __proto__: null, shimAddTransceiver: sr, shimCreateAnswer: cr, shimCreateOffer: ar, shimGetDisplayMedia: function(e2, t2) {
        e2.navigator.mediaDevices && "getDisplayMedia" in e2.navigator.mediaDevices || e2.navigator.mediaDevices && (e2.navigator.mediaDevices.getDisplayMedia = function(i2) {
          if (!i2 || !i2.video) {
            const e3 = new DOMException("getDisplayMedia without video constraints is undefined");
            return e3.name = "NotFoundError", e3.code = 8, Promise.reject(e3);
          }
          return true === i2.video ? i2.video = { mediaSource: t2 } : i2.video.mediaSource = t2, e2.navigator.mediaDevices.getUserMedia(i2);
        });
      }, shimGetParameters: or, shimGetUserMedia: Zn, shimOnTrack: $n, shimPeerConnection: er, shimRTCDataChannel: rr, shimReceiverGetStats: ir, shimRemoveStream: nr, shimSenderGetStats: tr });
      function lr(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection) {
          if ("getLocalStreams" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.getLocalStreams = function() {
            return this._localStreams || (this._localStreams = []), this._localStreams;
          }), !("addStream" in e2.RTCPeerConnection.prototype)) {
            const t2 = e2.RTCPeerConnection.prototype.addTrack;
            e2.RTCPeerConnection.prototype.addStream = function(e3) {
              this._localStreams || (this._localStreams = []), this._localStreams.includes(e3) || this._localStreams.push(e3), e3.getAudioTracks().forEach((i2) => t2.call(this, i2, e3)), e3.getVideoTracks().forEach((i2) => t2.call(this, i2, e3));
            }, e2.RTCPeerConnection.prototype.addTrack = function(e3, ...i2) {
              return i2 && i2.forEach((e4) => {
                this._localStreams ? this._localStreams.includes(e4) || this._localStreams.push(e4) : this._localStreams = [e4];
              }), t2.apply(this, arguments);
            };
          }
          "removeStream" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.removeStream = function(e3) {
            this._localStreams || (this._localStreams = []);
            const t2 = this._localStreams.indexOf(e3);
            if (-1 === t2) return;
            this._localStreams.splice(t2, 1);
            const i2 = e3.getTracks();
            this.getSenders().forEach((e4) => {
              i2.includes(e4.track) && this.removeTrack(e4);
            });
          });
        }
      }
      function ur(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection && ("getRemoteStreams" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.getRemoteStreams = function() {
          return this._remoteStreams ? this._remoteStreams : [];
        }), !("onaddstream" in e2.RTCPeerConnection.prototype))) {
          Object.defineProperty(e2.RTCPeerConnection.prototype, "onaddstream", { get() {
            return this._onaddstream;
          }, set(e3) {
            this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e3), this.addEventListener("track", this._onaddstreampoly = (e4) => {
              e4.streams.forEach((e5) => {
                if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(e5)) return;
                this._remoteStreams.push(e5);
                const t3 = new Event("addstream");
                t3.stream = e5, this.dispatchEvent(t3);
              });
            });
          } });
          const t2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
          e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
            const e3 = this;
            return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(t3) {
              t3.streams.forEach((t4) => {
                if (e3._remoteStreams || (e3._remoteStreams = []), e3._remoteStreams.indexOf(t4) >= 0) return;
                e3._remoteStreams.push(t4);
                const i2 = new Event("addstream");
                i2.stream = t4, e3.dispatchEvent(i2);
              });
            }), t2.apply(e3, arguments);
          };
        }
      }
      function hr(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection) return;
        const t2 = e2.RTCPeerConnection.prototype, i2 = t2.createOffer, n2 = t2.createAnswer, r2 = t2.setLocalDescription, s2 = t2.setRemoteDescription, o2 = t2.addIceCandidate;
        t2.createOffer = function(e3, t3) {
          const n3 = arguments.length >= 2 ? arguments[2] : arguments[0], r3 = i2.apply(this, [n3]);
          return t3 ? (r3.then(e3, t3), Promise.resolve()) : r3;
        }, t2.createAnswer = function(e3, t3) {
          const i3 = arguments.length >= 2 ? arguments[2] : arguments[0], r3 = n2.apply(this, [i3]);
          return t3 ? (r3.then(e3, t3), Promise.resolve()) : r3;
        };
        let a2 = function(e3, t3, i3) {
          const n3 = r2.apply(this, [e3]);
          return i3 ? (n3.then(t3, i3), Promise.resolve()) : n3;
        };
        t2.setLocalDescription = a2, a2 = function(e3, t3, i3) {
          const n3 = s2.apply(this, [e3]);
          return i3 ? (n3.then(t3, i3), Promise.resolve()) : n3;
        }, t2.setRemoteDescription = a2, a2 = function(e3, t3, i3) {
          const n3 = o2.apply(this, [e3]);
          return i3 ? (n3.then(t3, i3), Promise.resolve()) : n3;
        }, t2.addIceCandidate = a2;
      }
      function pr(e2) {
        const t2 = e2 && e2.navigator;
        if (t2.mediaDevices && t2.mediaDevices.getUserMedia) {
          const e3 = t2.mediaDevices, i2 = e3.getUserMedia.bind(e3);
          t2.mediaDevices.getUserMedia = (e4) => i2(_r(e4));
        }
        !t2.getUserMedia && t2.mediaDevices && t2.mediaDevices.getUserMedia && (t2.getUserMedia = (function(e3, i2, n2) {
          t2.mediaDevices.getUserMedia(e3).then(i2, n2);
        }).bind(t2));
      }
      function _r(e2) {
        return e2 && void 0 !== e2.video ? Object.assign({}, e2, { video: xn(e2.video) }) : e2;
      }
      function Er(e2) {
        if (!e2.RTCPeerConnection) return;
        const t2 = e2.RTCPeerConnection;
        e2.RTCPeerConnection = function(e3, i2) {
          if (e3 && e3.iceServers) {
            const t3 = [];
            for (let i3 = 0; i3 < e3.iceServers.length; i3++) {
              let n2 = e3.iceServers[i3];
              !n2.hasOwnProperty("urls") && n2.hasOwnProperty("url") ? (Mn("RTCIceServer.url", "RTCIceServer.urls"), n2 = JSON.parse(JSON.stringify(n2)), n2.urls = n2.url, delete n2.url, t3.push(n2)) : t3.push(e3.iceServers[i3]);
            }
            e3.iceServers = t3;
          }
          return new t2(e3, i2);
        }, e2.RTCPeerConnection.prototype = t2.prototype, "generateCertificate" in t2 && Object.defineProperty(e2.RTCPeerConnection, "generateCertificate", { get: () => t2.generateCertificate });
      }
      function mr(e2) {
        "object" == typeof e2 && e2.RTCTrackEvent && "receiver" in e2.RTCTrackEvent.prototype && !("transceiver" in e2.RTCTrackEvent.prototype) && Object.defineProperty(e2.RTCTrackEvent.prototype, "transceiver", { get() {
          return { receiver: this.receiver };
        } });
      }
      function fr(e2) {
        const t2 = e2.RTCPeerConnection.prototype.createOffer;
        e2.RTCPeerConnection.prototype.createOffer = function(e3) {
          if (e3) {
            void 0 !== e3.offerToReceiveAudio && (e3.offerToReceiveAudio = !!e3.offerToReceiveAudio);
            const t3 = this.getTransceivers().find((e4) => "audio" === e4.receiver.track.kind);
            false === e3.offerToReceiveAudio && t3 ? "sendrecv" === t3.direction ? t3.setDirection ? t3.setDirection("sendonly") : t3.direction = "sendonly" : "recvonly" === t3.direction && (t3.setDirection ? t3.setDirection("inactive") : t3.direction = "inactive") : true !== e3.offerToReceiveAudio || t3 || this.addTransceiver("audio", { direction: "recvonly" }), void 0 !== e3.offerToReceiveVideo && (e3.offerToReceiveVideo = !!e3.offerToReceiveVideo);
            const i2 = this.getTransceivers().find((e4) => "video" === e4.receiver.track.kind);
            false === e3.offerToReceiveVideo && i2 ? "sendrecv" === i2.direction ? i2.setDirection ? i2.setDirection("sendonly") : i2.direction = "sendonly" : "recvonly" === i2.direction && (i2.setDirection ? i2.setDirection("inactive") : i2.direction = "inactive") : true !== e3.offerToReceiveVideo || i2 || this.addTransceiver("video", { direction: "recvonly" });
          }
          return t2.apply(this, arguments);
        };
      }
      function gr(e2) {
        "object" != typeof e2 || e2.AudioContext || (e2.AudioContext = e2.webkitAudioContext);
      }
      var Tr = Object.freeze({ __proto__: null, shimAudioContext: gr, shimCallbacksAPI: hr, shimConstraints: _r, shimCreateOfferLegacy: fr, shimGetUserMedia: pr, shimLocalStreamsAPI: lr, shimRTCIceServerUrls: Er, shimRemoteStreamsAPI: ur, shimTrackEventTransceiver: mr }), Sr = { exports: {} };
      !function(e2) {
        const t2 = { generateIdentifier: function() {
          return Math.random().toString(36).substring(2, 12);
        } };
        t2.localCName = t2.generateIdentifier(), t2.splitLines = function(e3) {
          return e3.trim().split("\n").map((e4) => e4.trim());
        }, t2.splitSections = function(e3) {
          return e3.split("\nm=").map((e4, t3) => (t3 > 0 ? "m=" + e4 : e4).trim() + "\r\n");
        }, t2.getDescription = function(e3) {
          const i2 = t2.splitSections(e3);
          return i2 && i2[0];
        }, t2.getMediaSections = function(e3) {
          const i2 = t2.splitSections(e3);
          return i2.shift(), i2;
        }, t2.matchPrefix = function(e3, i2) {
          return t2.splitLines(e3).filter((e4) => 0 === e4.indexOf(i2));
        }, t2.parseCandidate = function(e3) {
          let t3;
          t3 = 0 === e3.indexOf("a=candidate:") ? e3.substring(12).split(" ") : e3.substring(10).split(" ");
          const i2 = { foundation: t3[0], component: { 1: "rtp", 2: "rtcp" }[t3[1]] || t3[1], protocol: t3[2].toLowerCase(), priority: parseInt(t3[3], 10), ip: t3[4], address: t3[4], port: parseInt(t3[5], 10), type: t3[7] };
          for (let e4 = 8; e4 < t3.length; e4 += 2) switch (t3[e4]) {
            case "raddr":
              i2.relatedAddress = t3[e4 + 1];
              break;
            case "rport":
              i2.relatedPort = parseInt(t3[e4 + 1], 10);
              break;
            case "tcptype":
              i2.tcpType = t3[e4 + 1];
              break;
            case "ufrag":
              i2.ufrag = t3[e4 + 1], i2.usernameFragment = t3[e4 + 1];
              break;
            default:
              void 0 === i2[t3[e4]] && (i2[t3[e4]] = t3[e4 + 1]);
          }
          return i2;
        }, t2.writeCandidate = function(e3) {
          const t3 = [];
          t3.push(e3.foundation);
          const i2 = e3.component;
          "rtp" === i2 ? t3.push(1) : "rtcp" === i2 ? t3.push(2) : t3.push(i2), t3.push(e3.protocol.toUpperCase()), t3.push(e3.priority), t3.push(e3.address || e3.ip), t3.push(e3.port);
          const n2 = e3.type;
          return t3.push("typ"), t3.push(n2), "host" !== n2 && e3.relatedAddress && e3.relatedPort && (t3.push("raddr"), t3.push(e3.relatedAddress), t3.push("rport"), t3.push(e3.relatedPort)), e3.tcpType && "tcp" === e3.protocol.toLowerCase() && (t3.push("tcptype"), t3.push(e3.tcpType)), (e3.usernameFragment || e3.ufrag) && (t3.push("ufrag"), t3.push(e3.usernameFragment || e3.ufrag)), "candidate:" + t3.join(" ");
        }, t2.parseIceOptions = function(e3) {
          return e3.substring(14).split(" ");
        }, t2.parseRtpMap = function(e3) {
          let t3 = e3.substring(9).split(" ");
          const i2 = { payloadType: parseInt(t3.shift(), 10) };
          return t3 = t3[0].split("/"), i2.name = t3[0], i2.clockRate = parseInt(t3[1], 10), i2.channels = 3 === t3.length ? parseInt(t3[2], 10) : 1, i2.numChannels = i2.channels, i2;
        }, t2.writeRtpMap = function(e3) {
          let t3 = e3.payloadType;
          void 0 !== e3.preferredPayloadType && (t3 = e3.preferredPayloadType);
          const i2 = e3.channels || e3.numChannels || 1;
          return "a=rtpmap:" + t3 + " " + e3.name + "/" + e3.clockRate + (1 !== i2 ? "/" + i2 : "") + "\r\n";
        }, t2.parseExtmap = function(e3) {
          const t3 = e3.substring(9).split(" ");
          return { id: parseInt(t3[0], 10), direction: t3[0].indexOf("/") > 0 ? t3[0].split("/")[1] : "sendrecv", uri: t3[1], attributes: t3.slice(2).join(" ") };
        }, t2.writeExtmap = function(e3) {
          return "a=extmap:" + (e3.id || e3.preferredId) + (e3.direction && "sendrecv" !== e3.direction ? "/" + e3.direction : "") + " " + e3.uri + (e3.attributes ? " " + e3.attributes : "") + "\r\n";
        }, t2.parseFmtp = function(e3) {
          const t3 = {};
          let i2;
          const n2 = e3.substring(e3.indexOf(" ") + 1).split(";");
          for (let e4 = 0; e4 < n2.length; e4++) i2 = n2[e4].trim().split("="), t3[i2[0].trim()] = i2[1];
          return t3;
        }, t2.writeFmtp = function(e3) {
          let t3 = "", i2 = e3.payloadType;
          if (void 0 !== e3.preferredPayloadType && (i2 = e3.preferredPayloadType), e3.parameters && Object.keys(e3.parameters).length) {
            const n2 = [];
            Object.keys(e3.parameters).forEach((t4) => {
              void 0 !== e3.parameters[t4] ? n2.push(t4 + "=" + e3.parameters[t4]) : n2.push(t4);
            }), t3 += "a=fmtp:" + i2 + " " + n2.join(";") + "\r\n";
          }
          return t3;
        }, t2.parseRtcpFb = function(e3) {
          const t3 = e3.substring(e3.indexOf(" ") + 1).split(" ");
          return { type: t3.shift(), parameter: t3.join(" ") };
        }, t2.writeRtcpFb = function(e3) {
          let t3 = "", i2 = e3.payloadType;
          return void 0 !== e3.preferredPayloadType && (i2 = e3.preferredPayloadType), e3.rtcpFeedback && e3.rtcpFeedback.length && e3.rtcpFeedback.forEach((e4) => {
            t3 += "a=rtcp-fb:" + i2 + " " + e4.type + (e4.parameter && e4.parameter.length ? " " + e4.parameter : "") + "\r\n";
          }), t3;
        }, t2.parseSsrcMedia = function(e3) {
          const t3 = e3.indexOf(" "), i2 = { ssrc: parseInt(e3.substring(7, t3), 10) }, n2 = e3.indexOf(":", t3);
          return n2 > -1 ? (i2.attribute = e3.substring(t3 + 1, n2), i2.value = e3.substring(n2 + 1)) : i2.attribute = e3.substring(t3 + 1), i2;
        }, t2.parseSsrcGroup = function(e3) {
          const t3 = e3.substring(13).split(" ");
          return { semantics: t3.shift(), ssrcs: t3.map((e4) => parseInt(e4, 10)) };
        }, t2.getMid = function(e3) {
          const i2 = t2.matchPrefix(e3, "a=mid:")[0];
          if (i2) return i2.substring(6);
        }, t2.parseFingerprint = function(e3) {
          const t3 = e3.substring(14).split(" ");
          return { algorithm: t3[0].toLowerCase(), value: t3[1].toUpperCase() };
        }, t2.getDtlsParameters = function(e3, i2) {
          return { role: "auto", fingerprints: t2.matchPrefix(e3 + i2, "a=fingerprint:").map(t2.parseFingerprint) };
        }, t2.writeDtlsParameters = function(e3, t3) {
          let i2 = "a=setup:" + t3 + "\r\n";
          return e3.fingerprints.forEach((e4) => {
            i2 += "a=fingerprint:" + e4.algorithm + " " + e4.value + "\r\n";
          }), i2;
        }, t2.parseCryptoLine = function(e3) {
          const t3 = e3.substring(9).split(" ");
          return { tag: parseInt(t3[0], 10), cryptoSuite: t3[1], keyParams: t3[2], sessionParams: t3.slice(3) };
        }, t2.writeCryptoLine = function(e3) {
          return "a=crypto:" + e3.tag + " " + e3.cryptoSuite + " " + ("object" == typeof e3.keyParams ? t2.writeCryptoKeyParams(e3.keyParams) : e3.keyParams) + (e3.sessionParams ? " " + e3.sessionParams.join(" ") : "") + "\r\n";
        }, t2.parseCryptoKeyParams = function(e3) {
          if (0 !== e3.indexOf("inline:")) return null;
          const t3 = e3.substring(7).split("|");
          return { keyMethod: "inline", keySalt: t3[0], lifeTime: t3[1], mkiValue: t3[2] ? t3[2].split(":")[0] : void 0, mkiLength: t3[2] ? t3[2].split(":")[1] : void 0 };
        }, t2.writeCryptoKeyParams = function(e3) {
          return e3.keyMethod + ":" + e3.keySalt + (e3.lifeTime ? "|" + e3.lifeTime : "") + (e3.mkiValue && e3.mkiLength ? "|" + e3.mkiValue + ":" + e3.mkiLength : "");
        }, t2.getCryptoParameters = function(e3, i2) {
          return t2.matchPrefix(e3 + i2, "a=crypto:").map(t2.parseCryptoLine);
        }, t2.getIceParameters = function(e3, i2) {
          const n2 = t2.matchPrefix(e3 + i2, "a=ice-ufrag:")[0], r2 = t2.matchPrefix(e3 + i2, "a=ice-pwd:")[0];
          return n2 && r2 ? { usernameFragment: n2.substring(12), password: r2.substring(10) } : null;
        }, t2.writeIceParameters = function(e3) {
          let t3 = "a=ice-ufrag:" + e3.usernameFragment + "\r\na=ice-pwd:" + e3.password + "\r\n";
          return e3.iceLite && (t3 += "a=ice-lite\r\n"), t3;
        }, t2.parseRtpParameters = function(e3) {
          const i2 = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, n2 = t2.splitLines(e3)[0].split(" ");
          i2.profile = n2[2];
          for (let r3 = 3; r3 < n2.length; r3++) {
            const s2 = n2[r3], o2 = t2.matchPrefix(e3, "a=rtpmap:" + s2 + " ")[0];
            if (o2) {
              const n3 = t2.parseRtpMap(o2), r4 = t2.matchPrefix(e3, "a=fmtp:" + s2 + " ");
              switch (n3.parameters = r4.length ? t2.parseFmtp(r4[0]) : {}, n3.rtcpFeedback = t2.matchPrefix(e3, "a=rtcp-fb:" + s2 + " ").map(t2.parseRtcpFb), i2.codecs.push(n3), n3.name.toUpperCase()) {
                case "RED":
                case "ULPFEC":
                  i2.fecMechanisms.push(n3.name.toUpperCase());
              }
            }
          }
          t2.matchPrefix(e3, "a=extmap:").forEach((e4) => {
            i2.headerExtensions.push(t2.parseExtmap(e4));
          });
          const r2 = t2.matchPrefix(e3, "a=rtcp-fb:* ").map(t2.parseRtcpFb);
          return i2.codecs.forEach((e4) => {
            r2.forEach((t3) => {
              e4.rtcpFeedback.find((e5) => e5.type === t3.type && e5.parameter === t3.parameter) || e4.rtcpFeedback.push(t3);
            });
          }), i2;
        }, t2.writeRtpDescription = function(e3, i2) {
          let n2 = "";
          n2 += "m=" + e3 + " ", n2 += i2.codecs.length > 0 ? "9" : "0", n2 += " " + (i2.profile || "UDP/TLS/RTP/SAVPF") + " ", n2 += i2.codecs.map((e4) => void 0 !== e4.preferredPayloadType ? e4.preferredPayloadType : e4.payloadType).join(" ") + "\r\n", n2 += "c=IN IP4 0.0.0.0\r\n", n2 += "a=rtcp:9 IN IP4 0.0.0.0\r\n", i2.codecs.forEach((e4) => {
            n2 += t2.writeRtpMap(e4), n2 += t2.writeFmtp(e4), n2 += t2.writeRtcpFb(e4);
          });
          let r2 = 0;
          return i2.codecs.forEach((e4) => {
            e4.maxptime > r2 && (r2 = e4.maxptime);
          }), r2 > 0 && (n2 += "a=maxptime:" + r2 + "\r\n"), i2.headerExtensions && i2.headerExtensions.forEach((e4) => {
            n2 += t2.writeExtmap(e4);
          }), n2;
        }, t2.parseRtpEncodingParameters = function(e3) {
          const i2 = [], n2 = t2.parseRtpParameters(e3), r2 = -1 !== n2.fecMechanisms.indexOf("RED"), s2 = -1 !== n2.fecMechanisms.indexOf("ULPFEC"), o2 = t2.matchPrefix(e3, "a=ssrc:").map((e4) => t2.parseSsrcMedia(e4)).filter((e4) => "cname" === e4.attribute), a2 = o2.length > 0 && o2[0].ssrc;
          let c2;
          const d2 = t2.matchPrefix(e3, "a=ssrc-group:FID").map((e4) => e4.substring(17).split(" ").map((e5) => parseInt(e5, 10)));
          d2.length > 0 && d2[0].length > 1 && d2[0][0] === a2 && (c2 = d2[0][1]), n2.codecs.forEach((e4) => {
            if ("RTX" === e4.name.toUpperCase() && e4.parameters.apt) {
              let t3 = { ssrc: a2, codecPayloadType: parseInt(e4.parameters.apt, 10) };
              a2 && c2 && (t3.rtx = { ssrc: c2 }), i2.push(t3), r2 && (t3 = JSON.parse(JSON.stringify(t3)), t3.fec = { ssrc: a2, mechanism: s2 ? "red+ulpfec" : "red" }, i2.push(t3));
            }
          }), 0 === i2.length && a2 && i2.push({ ssrc: a2 });
          let l2 = t2.matchPrefix(e3, "b=");
          return l2.length && (l2 = 0 === l2[0].indexOf("b=TIAS:") ? parseInt(l2[0].substring(7), 10) : 0 === l2[0].indexOf("b=AS:") ? 1e3 * parseInt(l2[0].substring(5), 10) * 0.95 - 16e3 : void 0, i2.forEach((e4) => {
            e4.maxBitrate = l2;
          })), i2;
        }, t2.parseRtcpParameters = function(e3) {
          const i2 = {}, n2 = t2.matchPrefix(e3, "a=ssrc:").map((e4) => t2.parseSsrcMedia(e4)).filter((e4) => "cname" === e4.attribute)[0];
          n2 && (i2.cname = n2.value, i2.ssrc = n2.ssrc);
          const r2 = t2.matchPrefix(e3, "a=rtcp-rsize");
          i2.reducedSize = r2.length > 0, i2.compound = 0 === r2.length;
          const s2 = t2.matchPrefix(e3, "a=rtcp-mux");
          return i2.mux = s2.length > 0, i2;
        }, t2.writeRtcpParameters = function(e3) {
          let t3 = "";
          return e3.reducedSize && (t3 += "a=rtcp-rsize\r\n"), e3.mux && (t3 += "a=rtcp-mux\r\n"), void 0 !== e3.ssrc && e3.cname && (t3 += "a=ssrc:" + e3.ssrc + " cname:" + e3.cname + "\r\n"), t3;
        }, t2.parseMsid = function(e3) {
          let i2;
          const n2 = t2.matchPrefix(e3, "a=msid:");
          if (1 === n2.length) return i2 = n2[0].substring(7).split(" "), { stream: i2[0], track: i2[1] };
          const r2 = t2.matchPrefix(e3, "a=ssrc:").map((e4) => t2.parseSsrcMedia(e4)).filter((e4) => "msid" === e4.attribute);
          return r2.length > 0 ? (i2 = r2[0].value.split(" "), { stream: i2[0], track: i2[1] }) : void 0;
        }, t2.parseSctpDescription = function(e3) {
          const i2 = t2.parseMLine(e3), n2 = t2.matchPrefix(e3, "a=max-message-size:");
          let r2;
          n2.length > 0 && (r2 = parseInt(n2[0].substring(19), 10)), isNaN(r2) && (r2 = 65536);
          const s2 = t2.matchPrefix(e3, "a=sctp-port:");
          if (s2.length > 0) return { port: parseInt(s2[0].substring(12), 10), protocol: i2.fmt, maxMessageSize: r2 };
          const o2 = t2.matchPrefix(e3, "a=sctpmap:");
          if (o2.length > 0) {
            const e4 = o2[0].substring(10).split(" ");
            return { port: parseInt(e4[0], 10), protocol: e4[1], maxMessageSize: r2 };
          }
        }, t2.writeSctpDescription = function(e3, t3) {
          let i2 = [];
          return i2 = "DTLS/SCTP" !== e3.protocol ? ["m=" + e3.kind + " 9 " + e3.protocol + " " + t3.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t3.port + "\r\n"] : ["m=" + e3.kind + " 9 " + e3.protocol + " " + t3.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t3.port + " " + t3.protocol + " 65535\r\n"], void 0 !== t3.maxMessageSize && i2.push("a=max-message-size:" + t3.maxMessageSize + "\r\n"), i2.join("");
        }, t2.generateSessionId = function() {
          return Math.random().toString().substr(2, 22);
        }, t2.writeSessionBoilerplate = function(e3, i2, n2) {
          let r2;
          const s2 = void 0 !== i2 ? i2 : 2;
          r2 = e3 || t2.generateSessionId();
          return "v=0\r\no=" + (n2 || "thisisadapterortc") + " " + r2 + " " + s2 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
        }, t2.getDirection = function(e3, i2) {
          const n2 = t2.splitLines(e3);
          for (let e4 = 0; e4 < n2.length; e4++) switch (n2[e4]) {
            case "a=sendrecv":
            case "a=sendonly":
            case "a=recvonly":
            case "a=inactive":
              return n2[e4].substring(2);
          }
          return i2 ? t2.getDirection(i2) : "sendrecv";
        }, t2.getKind = function(e3) {
          return t2.splitLines(e3)[0].split(" ")[0].substring(2);
        }, t2.isRejected = function(e3) {
          return "0" === e3.split(" ", 2)[1];
        }, t2.parseMLine = function(e3) {
          const i2 = t2.splitLines(e3)[0].substring(2).split(" ");
          return { kind: i2[0], port: parseInt(i2[1], 10), protocol: i2[2], fmt: i2.slice(3).join(" ") };
        }, t2.parseOLine = function(e3) {
          const i2 = t2.matchPrefix(e3, "o=")[0].substring(2).split(" ");
          return { username: i2[0], sessionId: i2[1], sessionVersion: parseInt(i2[2], 10), netType: i2[3], addressType: i2[4], address: i2[5] };
        }, t2.isValidSDP = function(e3) {
          if ("string" != typeof e3 || 0 === e3.length) return false;
          const i2 = t2.splitLines(e3);
          for (let e4 = 0; e4 < i2.length; e4++) if (i2[e4].length < 2 || "=" !== i2[e4].charAt(1)) return false;
          return true;
        }, e2.exports = t2;
      }(Sr);
      var Rr = Sr.exports, Cr = i(Rr), Ir = e({ __proto__: null, default: Cr }, [Rr]);
      function vr(e2) {
        if (!e2.RTCIceCandidate || e2.RTCIceCandidate && "foundation" in e2.RTCIceCandidate.prototype) return;
        const t2 = e2.RTCIceCandidate;
        e2.RTCIceCandidate = function(e3) {
          if ("object" == typeof e3 && e3.candidate && 0 === e3.candidate.indexOf("a=") && ((e3 = JSON.parse(JSON.stringify(e3))).candidate = e3.candidate.substr(2)), e3.candidate && e3.candidate.length) {
            const i2 = new t2(e3), n2 = Cr.parseCandidate(e3.candidate), r2 = Object.assign(i2, n2);
            return r2.toJSON = function() {
              return { candidate: r2.candidate, sdpMid: r2.sdpMid, sdpMLineIndex: r2.sdpMLineIndex, usernameFragment: r2.usernameFragment };
            }, r2;
          }
          return new t2(e3);
        }, e2.RTCIceCandidate.prototype = t2.prototype, Dn(e2, "icecandidate", (t3) => (t3.candidate && Object.defineProperty(t3, "candidate", { value: new e2.RTCIceCandidate(t3.candidate), writable: "false" }), t3));
      }
      function yr(e2) {
        !e2.RTCIceCandidate || e2.RTCIceCandidate && "relayProtocol" in e2.RTCIceCandidate.prototype || Dn(e2, "icecandidate", (e3) => {
          if (e3.candidate) {
            const t2 = Cr.parseCandidate(e3.candidate.candidate);
            "relay" === t2.type && (e3.candidate.relayProtocol = { 0: "tls", 1: "tcp", 2: "udp" }[t2.priority >> 24]);
          }
          return e3;
        });
      }
      function Ar(e2, t2) {
        if (!e2.RTCPeerConnection) return;
        "sctp" in e2.RTCPeerConnection.prototype || Object.defineProperty(e2.RTCPeerConnection.prototype, "sctp", { get() {
          return void 0 === this._sctp ? null : this._sctp;
        } });
        const i2 = function(e3) {
          if (!e3 || !e3.sdp) return false;
          const t3 = Cr.splitSections(e3.sdp);
          return t3.shift(), t3.some((e4) => {
            const t4 = Cr.parseMLine(e4);
            return t4 && "application" === t4.kind && -1 !== t4.protocol.indexOf("SCTP");
          });
        }, n2 = function(e3) {
          const t3 = e3.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
          if (null === t3 || t3.length < 2) return -1;
          const i3 = parseInt(t3[1], 10);
          return i3 != i3 ? -1 : i3;
        }, r2 = function(e3) {
          let i3 = 65536;
          return "firefox" === t2.browser && (i3 = t2.version < 57 ? -1 === e3 ? 16384 : 2147483637 : t2.version < 60 ? 57 === t2.version ? 65535 : 65536 : 2147483637), i3;
        }, s2 = function(e3, i3) {
          let n3 = 65536;
          "firefox" === t2.browser && 57 === t2.version && (n3 = 65535);
          const r3 = Cr.matchPrefix(e3.sdp, "a=max-message-size:");
          return r3.length > 0 ? n3 = parseInt(r3[0].substr(19), 10) : "firefox" === t2.browser && -1 !== i3 && (n3 = 2147483637), n3;
        }, o2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
        e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
          if (this._sctp = null, "chrome" === t2.browser && t2.version >= 76) {
            const { sdpSemantics: e3 } = this.getConfiguration();
            "plan-b" === e3 && Object.defineProperty(this, "sctp", { get() {
              return void 0 === this._sctp ? null : this._sctp;
            }, enumerable: true, configurable: true });
          }
          if (i2(arguments[0])) {
            const e3 = n2(arguments[0]), t3 = r2(e3), i3 = s2(arguments[0], e3);
            let o3;
            o3 = 0 === t3 && 0 === i3 ? Number.POSITIVE_INFINITY : 0 === t3 || 0 === i3 ? Math.max(t3, i3) : Math.min(t3, i3);
            const a2 = {};
            Object.defineProperty(a2, "maxMessageSize", { get: () => o3 }), this._sctp = a2;
          }
          return o2.apply(this, arguments);
        };
      }
      function br(e2) {
        if (!e2.RTCPeerConnection || !("createDataChannel" in e2.RTCPeerConnection.prototype)) return;
        function t2(e3, t3) {
          const i3 = e3.send;
          e3.send = function() {
            const n2 = arguments[0], r2 = n2.length || n2.size || n2.byteLength;
            if ("open" === e3.readyState && t3.sctp && r2 > t3.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + t3.sctp.maxMessageSize + " bytes)");
            return i3.apply(e3, arguments);
          };
        }
        const i2 = e2.RTCPeerConnection.prototype.createDataChannel;
        e2.RTCPeerConnection.prototype.createDataChannel = function() {
          const e3 = i2.apply(this, arguments);
          return t2(e3, this), e3;
        }, Dn(e2, "datachannel", (e3) => (t2(e3.channel, e3.target), e3));
      }
      function wr(e2) {
        if (!e2.RTCPeerConnection || "connectionState" in e2.RTCPeerConnection.prototype) return;
        const t2 = e2.RTCPeerConnection.prototype;
        Object.defineProperty(t2, "connectionState", { get() {
          return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState;
        }, enumerable: true, configurable: true }), Object.defineProperty(t2, "onconnectionstatechange", { get() {
          return this._onconnectionstatechange || null;
        }, set(e3) {
          this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e3 && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e3);
        }, enumerable: true, configurable: true }), ["setLocalDescription", "setRemoteDescription"].forEach((e3) => {
          const i2 = t2[e3];
          t2[e3] = function() {
            return this._connectionstatechangepoly || (this._connectionstatechangepoly = (e4) => {
              const t3 = e4.target;
              if (t3._lastConnectionState !== t3.connectionState) {
                t3._lastConnectionState = t3.connectionState;
                const i3 = new Event("connectionstatechange", e4);
                t3.dispatchEvent(i3);
              }
              return e4;
            }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), i2.apply(this, arguments);
          };
        });
      }
      function Or(e2, t2) {
        if (!e2.RTCPeerConnection) return;
        if ("chrome" === t2.browser && t2.version >= 71) return;
        if ("safari" === t2.browser && t2.version >= 605) return;
        const i2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
        e2.RTCPeerConnection.prototype.setRemoteDescription = function(t3) {
          if (t3 && t3.sdp && -1 !== t3.sdp.indexOf("\na=extmap-allow-mixed")) {
            const i3 = t3.sdp.split("\n").filter((e3) => "a=extmap-allow-mixed" !== e3.trim()).join("\n");
            e2.RTCSessionDescription && t3 instanceof e2.RTCSessionDescription ? arguments[0] = new e2.RTCSessionDescription({ type: t3.type, sdp: i3 }) : t3.sdp = i3;
          }
          return i2.apply(this, arguments);
        };
      }
      function Nr(e2, t2) {
        if (!e2.RTCPeerConnection || !e2.RTCPeerConnection.prototype) return;
        const i2 = e2.RTCPeerConnection.prototype.addIceCandidate;
        i2 && 0 !== i2.length && (e2.RTCPeerConnection.prototype.addIceCandidate = function() {
          return arguments[0] ? ("chrome" === t2.browser && t2.version < 78 || "firefox" === t2.browser && t2.version < 68 || "safari" === t2.browser) && arguments[0] && "" === arguments[0].candidate ? Promise.resolve() : i2.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve());
        });
      }
      function Dr(e2, t2) {
        if (!e2.RTCPeerConnection || !e2.RTCPeerConnection.prototype) return;
        const i2 = e2.RTCPeerConnection.prototype.setLocalDescription;
        i2 && 0 !== i2.length && (e2.RTCPeerConnection.prototype.setLocalDescription = function() {
          let e3 = arguments[0] || {};
          if ("object" != typeof e3 || e3.type && e3.sdp) return i2.apply(this, arguments);
          if (e3 = { type: e3.type, sdp: e3.sdp }, !e3.type) switch (this.signalingState) {
            case "stable":
            case "have-local-offer":
            case "have-remote-pranswer":
              e3.type = "offer";
              break;
            default:
              e3.type = "answer";
          }
          if (e3.sdp || "offer" !== e3.type && "answer" !== e3.type) return i2.apply(this, [e3]);
          return ("offer" === e3.type ? this.createOffer : this.createAnswer).apply(this).then((e4) => i2.apply(this, [e4]));
        });
      }
      var Pr = Object.freeze({ __proto__: null, removeExtmapAllowMixed: Or, shimAddIceCandidateNullOrEmpty: Nr, shimConnectionState: wr, shimMaxMessageSize: Ar, shimParameterlessSetLocalDescription: Dr, shimRTCIceCandidate: vr, shimRTCIceCandidateRelayProtocol: yr, shimSendThrowTypeError: br });
      !function({ window: e2 } = {}, t2 = { shimChrome: true, shimFirefox: true, shimSafari: true }) {
        const i2 = kn, n2 = function(e3) {
          const t3 = { browser: null, version: null };
          if (void 0 === e3 || !e3.navigator) return t3.browser = "Not a browser.", t3;
          const { navigator: i3 } = e3;
          if (i3.mozGetUserMedia) t3.browser = "firefox", t3.version = Nn(i3.userAgent, /Firefox\/(\d+)\./, 1);
          else if (i3.webkitGetUserMedia || false === e3.isSecureContext && e3.webkitRTCPeerConnection) t3.browser = "chrome", t3.version = Nn(i3.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
          else {
            if (!e3.RTCPeerConnection || !i3.userAgent.match(/AppleWebKit\/(\d+)\./)) return t3.browser = "Not a supported browser.", t3;
            t3.browser = "safari", t3.version = Nn(i3.userAgent, /AppleWebKit\/(\d+)\./, 1), t3.supportsUnifiedPlan = e3.RTCRtpTransceiver && "currentDirection" in e3.RTCRtpTransceiver.prototype;
          }
          return t3;
        }(e2), r2 = { browserDetails: n2, commonShim: Pr, extractVersion: Nn, disableLog: Pn, disableWarnings: Ln, sdp: Ir };
        switch (n2.browser) {
          case "chrome":
            if (!Qn || !Jn || !t2.shimChrome) return i2("Chrome shim is not included in this adapter release."), r2;
            if (null === n2.version) return i2("Chrome shim can not determine version, not shimming."), r2;
            i2("adapter.js shimming chrome."), r2.browserShim = Qn, Nr(e2, n2), Dr(e2), jn(e2, n2), Gn(e2), Jn(e2, n2), Wn(e2), zn(e2, n2), Hn(e2), Kn(e2), Yn(e2), Xn(e2, n2), vr(e2), yr(e2), wr(e2), Ar(e2, n2), br(e2), Or(e2, n2);
            break;
          case "firefox":
            if (!dr || !er || !t2.shimFirefox) return i2("Firefox shim is not included in this adapter release."), r2;
            i2("adapter.js shimming firefox."), r2.browserShim = dr, Nr(e2, n2), Dr(e2), Zn(e2, n2), er(e2, n2), $n(e2), nr(e2), tr(e2), ir(e2), rr(e2), sr(e2), or(e2), ar(e2), cr(e2), vr(e2), wr(e2), Ar(e2, n2), br(e2);
            break;
          case "safari":
            if (!Tr || !t2.shimSafari) return i2("Safari shim is not included in this adapter release."), r2;
            i2("adapter.js shimming safari."), r2.browserShim = Tr, Nr(e2, n2), Dr(e2), Er(e2), fr(e2), hr(e2), lr(e2), ur(e2), mr(e2), pr(e2), gr(e2), vr(e2), yr(e2), Ar(e2, n2), br(e2), Or(e2, n2);
            break;
          default:
            i2("Unsupported browser!");
        }
      }({ window: "undefined" == typeof window ? void 0 : window });
      var Lr = { exports: {} }, kr = wi, Mr = N, Ur = Qt.f;
      kr({ target: "Object", stat: true, forced: Object.defineProperty !== Ur, sham: !Mr }, { defineProperty: Ur });
      var xr = ie.Object, Vr = Lr.exports = function(e2, t2, i2) {
        return xr.defineProperty(e2, t2, i2);
      };
      xr.defineProperty.sham && (Vr.sham = true);
      var Fr = i(Lr.exports), Br = R, jr = Array.isArray || function(e2) {
        return "Array" == Br(e2);
      }, Gr = TypeError, Wr = Ct, Hr = Qt, Kr = B, Yr = function(e2, t2, i2) {
        var n2 = Wr(t2);
        n2 in e2 ? Hr.f(e2, n2, Kr(0, i2)) : e2[n2] = i2;
      }, qr = w, zr = He, Jr = d(Function.toString);
      qr(zr.inspectSource) || (zr.inspectSource = function(e2) {
        return Jr(e2);
      });
      var Xr = zr.inspectSource, Qr = d, Zr = n, $r = w, es = ln, ts = Xr, is = function() {
      }, ns = [], rs = ae("Reflect", "construct"), ss = /^\s*(?:class|function)\b/, os = Qr(ss.exec), as = !ss.exec(is), cs = function(e2) {
        if (!$r(e2)) return false;
        try {
          return rs(is, ns, e2), true;
        } catch (e3) {
          return false;
        }
      }, ds = function(e2) {
        if (!$r(e2)) return false;
        switch (es(e2)) {
          case "AsyncFunction":
          case "GeneratorFunction":
          case "AsyncGeneratorFunction":
            return false;
        }
        try {
          return as || !!os(ss, ts(e2));
        } catch (e3) {
          return true;
        }
      };
      ds.sham = true;
      var ls = !rs || Zr(function() {
        var e2;
        return cs(cs.call) || !cs(Object) || !cs(function() {
          e2 = true;
        }) || e2;
      }) ? ds : cs, us = jr, hs = ls, ps = te, _s = ht("species"), Es = Array, ms = function(e2) {
        var t2;
        return us(e2) && (t2 = e2.constructor, (hs(t2) && (t2 === Es || us(t2.prototype)) || ps(t2) && null === (t2 = t2[_s])) && (t2 = void 0)), void 0 === t2 ? Es : t2;
      }, fs = function(e2, t2) {
        return new (ms(e2))(0 === t2 ? 0 : t2);
      }, gs = n, Ts = Ee, Ss = ht("species"), Rs = wi, Cs = n, Is = jr, vs = te, ys = Je, As = Bi, bs = function(e2) {
        if (e2 > 9007199254740991) throw Gr("Maximum allowed index exceeded");
        return e2;
      }, ws = Yr, Os = fs, Ns = function(e2) {
        return Ts >= 51 || !gs(function() {
          var t2 = [];
          return (t2.constructor = {})[Ss] = function() {
            return { foo: 1 };
          }, 1 !== t2[e2](Boolean).foo;
        });
      }, Ds = Ee, Ps = ht("isConcatSpreadable"), Ls = Ds >= 51 || !Cs(function() {
        var e2 = [];
        return e2[Ps] = false, e2.concat()[0] !== e2;
      }), ks = function(e2) {
        if (!vs(e2)) return false;
        var t2 = e2[Ps];
        return void 0 !== t2 ? !!t2 : Is(e2);
      };
      Rs({ target: "Array", proto: true, arity: 1, forced: !Ls || !Ns("concat") }, { concat: function(e2) {
        var t2, i2, n2, r2, s2, o2 = ys(this), a2 = Os(o2, 0), c2 = 0;
        for (t2 = -1, n2 = arguments.length; t2 < n2; t2++) if (ks(s2 = -1 === t2 ? o2 : arguments[t2])) for (r2 = As(s2), bs(c2 + r2), i2 = 0; i2 < r2; i2++, c2++) i2 in s2 && ws(a2, c2, s2[i2]);
        else bs(c2 + 1), ws(a2, c2++, s2);
        return a2.length = c2, a2;
      } });
      var Ms = {}, Us = {}, xs = Ze, Vs = Z, Fs = Ki.indexOf, Bs = Us, js = d([].push), Gs = function(e2, t2) {
        var i2, n2 = Vs(e2), r2 = 0, s2 = [];
        for (i2 in n2) !xs(Bs, i2) && xs(n2, i2) && js(s2, i2);
        for (; t2.length > r2; ) xs(n2, i2 = t2[r2++]) && (~Fs(s2, i2) || js(s2, i2));
        return s2;
      }, Ws = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], Hs = Gs, Ks = Ws, Ys = Object.keys || function(e2) {
        return Hs(e2, Ks);
      }, qs = N, zs = Zt, Js = Qt, Xs = ii, Qs = Z, Zs = Ys;
      Ms.f = qs && !zs ? Object.defineProperties : function(e2, t2) {
        Xs(e2);
        for (var i2, n2 = Qs(t2), r2 = Zs(t2), s2 = r2.length, o2 = 0; s2 > o2; ) Js.f(e2, i2 = r2[o2++], n2[i2]);
        return e2;
      };
      var $s, eo = ae("document", "documentElement"), to = nt, io = Ye("keys"), no = function(e2) {
        return io[e2] || (io[e2] = to(e2));
      }, ro = ii, so = Ms, oo = Ws, ao = Us, co = eo, lo = At, uo = "prototype", ho = "script", po = no("IE_PROTO"), _o = function() {
      }, Eo = function(e2) {
        return "<" + ho + ">" + e2 + "</" + ho + ">";
      }, mo = function(e2) {
        e2.write(Eo("")), e2.close();
        var t2 = e2.parentWindow.Object;
        return e2 = null, t2;
      }, fo = function() {
        try {
          $s = new ActiveXObject("htmlfile");
        } catch (e3) {
        }
        var e2, t2, i2;
        fo = "undefined" != typeof document ? document.domain && $s ? mo($s) : (t2 = lo("iframe"), i2 = "java" + ho + ":", t2.style.display = "none", co.appendChild(t2), t2.src = String(i2), (e2 = t2.contentWindow.document).open(), e2.write(Eo("document.F=Object")), e2.close(), e2.F) : mo($s);
        for (var n2 = oo.length; n2--; ) delete fo[uo][oo[n2]];
        return fo();
      };
      ao[po] = true;
      var go = Object.create || function(e2, t2) {
        var i2;
        return null !== e2 ? (_o[uo] = ro(e2), i2 = new _o(), _o[uo] = null, i2[po] = e2) : i2 = fo(), void 0 === t2 ? i2 : so.f(i2, t2);
      }, To = {}, So = Gs, Ro = Ws.concat("length", "prototype");
      To.f = Object.getOwnPropertyNames || function(e2) {
        return So(e2, Ro);
      };
      var Co = {}, Io = Ui, vo = Bi, yo = Yr, Ao = Array, bo = Math.max, wo = function(e2, t2, i2) {
        for (var n2 = vo(e2), r2 = Io(t2, n2), s2 = Io(void 0 === i2 ? n2 : i2, n2), o2 = Ao(bo(s2 - r2, 0)), a2 = 0; r2 < s2; r2++, a2++) yo(o2, a2, e2[r2]);
        return o2.length = a2, o2;
      }, Oo = R, No = Z, Do = To.f, Po = wo, Lo = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
      Co.f = function(e2) {
        return Lo && "Window" == Oo(e2) ? function(e3) {
          try {
            return Do(e3);
          } catch (e4) {
            return Po(Lo);
          }
        }(e2) : Do(No(e2));
      };
      var ko = {};
      ko.f = Object.getOwnPropertySymbols;
      var Mo = mi, Uo = function(e2, t2, i2, n2) {
        return n2 && n2.enumerable ? e2[t2] = i2 : Mo(e2, t2, i2), e2;
      }, xo = Qt, Vo = function(e2, t2, i2) {
        return xo.f(e2, t2, i2);
      }, Fo = {}, Bo = ht;
      Fo.f = Bo;
      var jo, Go, Wo, Ho = ie, Ko = Ze, Yo = Fo, qo = Qt.f, zo = function(e2) {
        var t2 = Ho.Symbol || (Ho.Symbol = {});
        Ko(t2, e2) || qo(t2, e2, { value: Yo.f(e2) });
      }, Jo = L, Xo = ae, Qo = ht, Zo = Uo, $o = function() {
        var e2 = Xo("Symbol"), t2 = e2 && e2.prototype, i2 = t2 && t2.valueOf, n2 = Qo("toPrimitive");
        t2 && !t2[n2] && Zo(t2, n2, function(e3) {
          return Jo(i2, this);
        }, { arity: 1 });
      }, ea = ln, ta = nn ? {}.toString : function() {
        return "[object " + ea(this) + "]";
      }, ia = nn, na = Qt.f, ra = mi, sa = Ze, oa = ta, aa = ht("toStringTag"), ca = function(e2, t2, i2, n2) {
        if (e2) {
          var r2 = i2 ? e2 : e2.prototype;
          sa(r2, aa) || na(r2, aa, { configurable: true, value: t2 }), n2 && !ia && ra(r2, "toString", oa);
        }
      }, da = w, la = h2.WeakMap, ua = da(la) && /native code/.test(String(la)), ha = h2, pa = te, _a = mi, Ea = Ze, ma = He, fa = no, ga = Us, Ta = "Object already initialized", Sa = ha.TypeError, Ra = ha.WeakMap;
      if (ua || ma.state) {
        var Ca = ma.state || (ma.state = new Ra());
        Ca.get = Ca.get, Ca.has = Ca.has, Ca.set = Ca.set, jo = function(e2, t2) {
          if (Ca.has(e2)) throw Sa(Ta);
          return t2.facade = e2, Ca.set(e2, t2), t2;
        }, Go = function(e2) {
          return Ca.get(e2) || {};
        }, Wo = function(e2) {
          return Ca.has(e2);
        };
      } else {
        var Ia = fa("state");
        ga[Ia] = true, jo = function(e2, t2) {
          if (Ea(e2, Ia)) throw Sa(Ta);
          return t2.facade = e2, _a(e2, Ia, t2), t2;
        }, Go = function(e2) {
          return Ea(e2, Ia) ? e2[Ia] : {};
        }, Wo = function(e2) {
          return Ea(e2, Ia);
        };
      }
      var va = { set: jo, get: Go, has: Wo, enforce: function(e2) {
        return Wo(e2) ? Go(e2) : jo(e2, {});
      }, getterFor: function(e2) {
        return function(t2) {
          var i2;
          if (!pa(t2) || (i2 = Go(t2)).type !== e2) throw Sa("Incompatible receiver, " + e2 + " required");
          return i2;
        };
      } }, ya = Xt, Aa = K, ba = Je, wa = Bi, Oa = fs, Na = d([].push), Da = function(e2) {
        var t2 = 1 == e2, i2 = 2 == e2, n2 = 3 == e2, r2 = 4 == e2, s2 = 6 == e2, o2 = 7 == e2, a2 = 5 == e2 || s2;
        return function(c2, d2, l2, u2) {
          for (var h3, p2, _2 = ba(c2), E2 = Aa(_2), m2 = ya(d2, l2), f2 = wa(E2), g2 = 0, T2 = u2 || Oa, S2 = t2 ? T2(c2, f2) : i2 || o2 ? T2(c2, 0) : void 0; f2 > g2; g2++) if ((a2 || g2 in E2) && (p2 = m2(h3 = E2[g2], g2, _2), e2)) if (t2) S2[g2] = p2;
          else if (p2) switch (e2) {
            case 3:
              return true;
            case 5:
              return h3;
            case 6:
              return g2;
            case 2:
              Na(S2, h3);
          }
          else switch (e2) {
            case 4:
              return false;
            case 7:
              Na(S2, h3);
          }
          return s2 ? -1 : n2 || r2 ? r2 : S2;
        };
      }, Pa = { forEach: Da(0), map: Da(1), filter: Da(2), some: Da(3), every: Da(4), find: Da(5), findIndex: Da(6), filterReject: Da(7) }, La = wi, ka = h2, Ma = L, Ua = d, xa = N, Va = Te, Fa = n, Ba = Ze, ja = l, Ga = ii, Wa = Z, Ha = Ct, Ka = pn, Ya = B, qa = go, za = Ys, Ja = To, Xa = Co, Qa = ko, Za = O, $a = Qt, ec = Ms, tc = k, ic = Uo, nc = Vo, rc = Ye, sc = Us, oc = nt, ac = ht, cc = Fo, dc = zo, lc = $o, uc = ca, hc = va, pc = Pa.forEach, _c = no("hidden"), Ec = "Symbol", mc = "prototype", fc = hc.set, gc = hc.getterFor(Ec), Tc = Object[mc], Sc = ka.Symbol, Rc = Sc && Sc[mc], Cc = ka.TypeError, Ic = ka.QObject, vc = Za.f, yc = $a.f, Ac = Xa.f, bc = tc.f, wc = Ua([].push), Oc = rc("symbols"), Nc = rc("op-symbols"), Dc = rc("wks"), Pc = !Ic || !Ic[mc] || !Ic[mc].findChild, Lc = xa && Fa(function() {
        return 7 != qa(yc({}, "a", { get: function() {
          return yc(this, "a", { value: 7 }).a;
        } })).a;
      }) ? function(e2, t2, i2) {
        var n2 = vc(Tc, t2);
        n2 && delete Tc[t2], yc(e2, t2, i2), n2 && e2 !== Tc && yc(Tc, t2, n2);
      } : yc, kc = function(e2, t2) {
        var i2 = Oc[e2] = qa(Rc);
        return fc(i2, { type: Ec, tag: e2, description: t2 }), xa || (i2.description = t2), i2;
      }, Mc = function(e2, t2, i2) {
        e2 === Tc && Mc(Nc, t2, i2), Ga(e2);
        var n2 = Ha(t2);
        return Ga(i2), Ba(Oc, n2) ? (i2.enumerable ? (Ba(e2, _c) && e2[_c][n2] && (e2[_c][n2] = false), i2 = qa(i2, { enumerable: Ya(0, false) })) : (Ba(e2, _c) || yc(e2, _c, Ya(1, {})), e2[_c][n2] = true), Lc(e2, n2, i2)) : yc(e2, n2, i2);
      }, Uc = function(e2, t2) {
        Ga(e2);
        var i2 = Wa(t2), n2 = za(i2).concat(Bc(i2));
        return pc(n2, function(t3) {
          xa && !Ma(xc, i2, t3) || Mc(e2, t3, i2[t3]);
        }), e2;
      }, xc = function(e2) {
        var t2 = Ha(e2), i2 = Ma(bc, this, t2);
        return !(this === Tc && Ba(Oc, t2) && !Ba(Nc, t2)) && (!(i2 || !Ba(this, t2) || !Ba(Oc, t2) || Ba(this, _c) && this[_c][t2]) || i2);
      }, Vc = function(e2, t2) {
        var i2 = Wa(e2), n2 = Ha(t2);
        if (i2 !== Tc || !Ba(Oc, n2) || Ba(Nc, n2)) {
          var r2 = vc(i2, n2);
          return !r2 || !Ba(Oc, n2) || Ba(i2, _c) && i2[_c][n2] || (r2.enumerable = true), r2;
        }
      }, Fc = function(e2) {
        var t2 = Ac(Wa(e2)), i2 = [];
        return pc(t2, function(e3) {
          Ba(Oc, e3) || Ba(sc, e3) || wc(i2, e3);
        }), i2;
      }, Bc = function(e2) {
        var t2 = e2 === Tc, i2 = Ac(t2 ? Nc : Wa(e2)), n2 = [];
        return pc(i2, function(e3) {
          !Ba(Oc, e3) || t2 && !Ba(Tc, e3) || wc(n2, Oc[e3]);
        }), n2;
      };
      Va || (Sc = function() {
        if (ja(Rc, this)) throw Cc("Symbol is not a constructor");
        var e2 = arguments.length && void 0 !== arguments[0] ? Ka(arguments[0]) : void 0, t2 = oc(e2), i2 = function(e3) {
          this === Tc && Ma(i2, Nc, e3), Ba(this, _c) && Ba(this[_c], t2) && (this[_c][t2] = false), Lc(this, t2, Ya(1, e3));
        };
        return xa && Pc && Lc(Tc, t2, { configurable: true, set: i2 }), kc(t2, e2);
      }, ic(Rc = Sc[mc], "toString", function() {
        return gc(this).tag;
      }), ic(Sc, "withoutSetter", function(e2) {
        return kc(oc(e2), e2);
      }), tc.f = xc, $a.f = Mc, ec.f = Uc, Za.f = Vc, Ja.f = Xa.f = Fc, Qa.f = Bc, cc.f = function(e2) {
        return kc(ac(e2), e2);
      }, xa && nc(Rc, "description", { configurable: true, get: function() {
        return gc(this).description;
      } })), La({ global: true, constructor: true, wrap: true, forced: !Va, sham: !Va }, { Symbol: Sc }), pc(za(Dc), function(e2) {
        dc(e2);
      }), La({ target: Ec, stat: true, forced: !Va }, { useSetter: function() {
        Pc = true;
      }, useSimple: function() {
        Pc = false;
      } }), La({ target: "Object", stat: true, forced: !Va, sham: !xa }, { create: function(e2, t2) {
        return void 0 === t2 ? qa(e2) : Uc(qa(e2), t2);
      }, defineProperty: Mc, defineProperties: Uc, getOwnPropertyDescriptor: Vc }), La({ target: "Object", stat: true, forced: !Va }, { getOwnPropertyNames: Fc }), lc(), uc(Sc, Ec), sc[_c] = true;
      var jc = Te && !!Symbol.for && !!Symbol.keyFor, Gc = wi, Wc = ae, Hc = Ze, Kc = pn, Yc = Ye, qc = jc, zc = Yc("string-to-symbol-registry"), Jc = Yc("symbol-to-string-registry");
      Gc({ target: "Symbol", stat: true, forced: !qc }, { for: function(e2) {
        var t2 = Kc(e2);
        if (Hc(zc, t2)) return zc[t2];
        var i2 = Wc("Symbol")(t2);
        return zc[t2] = i2, Jc[i2] = t2, i2;
      } });
      var Xc = wi, Qc = Ze, Zc = ye, $c = be, ed = jc, td = Ye("symbol-to-string-registry");
      Xc({ target: "Symbol", stat: true, forced: !ed }, { keyFor: function(e2) {
        if (!Zc(e2)) throw TypeError($c(e2) + " is not a symbol");
        if (Qc(td, e2)) return td[e2];
      } });
      var id = d([].slice), nd = jr, rd = w, sd = R, od = pn, ad = d([].push), cd = wi, dd = ae, ld = f, ud = L, hd = d, pd = n, _d = w, Ed = ye, md = id, fd = function(e2) {
        if (rd(e2)) return e2;
        if (nd(e2)) {
          for (var t2 = e2.length, i2 = [], n2 = 0; n2 < t2; n2++) {
            var r2 = e2[n2];
            "string" == typeof r2 ? ad(i2, r2) : "number" != typeof r2 && "Number" != sd(r2) && "String" != sd(r2) || ad(i2, od(r2));
          }
          var s2 = i2.length, o2 = true;
          return function(e3, t3) {
            if (o2) return o2 = false, t3;
            if (nd(this)) return t3;
            for (var n3 = 0; n3 < s2; n3++) if (i2[n3] === e3) return t3;
          };
        }
      }, gd = Te, Td = String, Sd = dd("JSON", "stringify"), Rd = hd(/./.exec), Cd = hd("".charAt), Id = hd("".charCodeAt), vd = hd("".replace), yd = hd(1 .toString), Ad = /[\uD800-\uDFFF]/g, bd = /^[\uD800-\uDBFF]$/, wd = /^[\uDC00-\uDFFF]$/, Od = !gd || pd(function() {
        var e2 = dd("Symbol")();
        return "[null]" != Sd([e2]) || "{}" != Sd({ a: e2 }) || "{}" != Sd(Object(e2));
      }), Nd = pd(function() {
        return '"\\udf06\\ud834"' !== Sd("\uDF06\uD834") || '"\\udead"' !== Sd("\uDEAD");
      }), Dd = function(e2, t2) {
        var i2 = md(arguments), n2 = fd(t2);
        if (_d(n2) || void 0 !== e2 && !Ed(e2)) return i2[1] = function(e3, t3) {
          if (_d(n2) && (t3 = ud(n2, this, Td(e3), t3)), !Ed(t3)) return t3;
        }, ld(Sd, null, i2);
      }, Pd = function(e2, t2, i2) {
        var n2 = Cd(i2, t2 - 1), r2 = Cd(i2, t2 + 1);
        return Rd(bd, e2) && !Rd(wd, r2) || Rd(wd, e2) && !Rd(bd, n2) ? "\\u" + yd(Id(e2, 0), 16) : e2;
      };
      Sd && cd({ target: "JSON", stat: true, arity: 3, forced: Od || Nd }, { stringify: function(e2, t2, i2) {
        var n2 = md(arguments), r2 = ld(Od ? Dd : Sd, null, n2);
        return Nd && "string" == typeof r2 ? vd(r2, Ad, Pd) : r2;
      } });
      var Ld = ko, kd = Je;
      wi({ target: "Object", stat: true, forced: !Te || n(function() {
        Ld.f(1);
      }) }, { getOwnPropertySymbols: function(e2) {
        var t2 = Ld.f;
        return t2 ? t2(kd(e2)) : [];
      } }), zo("asyncIterator"), zo("hasInstance"), zo("isConcatSpreadable"), zo("iterator"), zo("match"), zo("matchAll"), zo("replace"), zo("search"), zo("species"), zo("split");
      var Md = $o;
      zo("toPrimitive"), Md();
      var Ud = ae, xd = ca;
      zo("toStringTag"), xd(Ud("Symbol"), "Symbol"), zo("unscopables"), ca(h2.JSON, "JSON", true);
      var Vd, Fd, Bd, jd = ie.Symbol, Gd = {}, Wd = N, Hd = Ze, Kd = Function.prototype, Yd = Wd && Object.getOwnPropertyDescriptor, qd = Hd(Kd, "name"), zd = { EXISTS: qd, PROPER: qd && "something" === (function() {
      }).name, CONFIGURABLE: qd && (!Wd || Wd && Yd(Kd, "name").configurable) }, Jd = !n(function() {
        function e2() {
        }
        return e2.prototype.constructor = null, Object.getPrototypeOf(new e2()) !== e2.prototype;
      }), Xd = Ze, Qd = w, Zd = Je, $d = Jd, el = no("IE_PROTO"), tl = Object, il = tl.prototype, nl = $d ? tl.getPrototypeOf : function(e2) {
        var t2 = Zd(e2);
        if (Xd(t2, el)) return t2[el];
        var i2 = t2.constructor;
        return Qd(i2) && t2 instanceof i2 ? i2.prototype : t2 instanceof tl ? il : null;
      }, rl = n, sl = w, ol = te, al = go, cl = nl, dl = Uo, ll = ht("iterator"), ul = false;
      [].keys && ("next" in (Bd = [].keys()) ? (Fd = cl(cl(Bd))) !== Object.prototype && (Vd = Fd) : ul = true);
      var hl = !ol(Vd) || rl(function() {
        var e2 = {};
        return Vd[ll].call(e2) !== e2;
      });
      sl((Vd = hl ? {} : al(Vd))[ll]) || dl(Vd, ll, function() {
        return this;
      });
      var pl = { IteratorPrototype: Vd, BUGGY_SAFARI_ITERATORS: ul }, _l = pl.IteratorPrototype, El = go, ml = B, fl = ca, gl = Gd, Tl = function() {
        return this;
      }, Sl = function(e2, t2, i2, n2) {
        var r2 = t2 + " Iterator";
        return e2.prototype = El(_l, { next: ml(+!n2, i2) }), fl(e2, r2, false, true), gl[r2] = Tl, e2;
      }, Rl = d, Cl = De, Il = w, vl = String, yl = TypeError, Al = function(e2, t2, i2) {
        try {
          return Rl(Cl(Object.getOwnPropertyDescriptor(e2, t2)[i2]));
        } catch (e3) {
        }
      }, bl = ii, wl = function(e2) {
        if ("object" == typeof e2 || Il(e2)) return e2;
        throw yl("Can't set " + vl(e2) + " as a prototype");
      }, Ol = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var e2, t2 = false, i2 = {};
        try {
          (e2 = Al(Object.prototype, "__proto__", "set"))(i2, []), t2 = i2 instanceof Array;
        } catch (e3) {
        }
        return function(i3, n2) {
          return bl(i3), wl(n2), t2 ? e2(i3, n2) : i3.__proto__ = n2, i3;
        };
      }() : void 0), Nl = wi, Dl = L, Pl = zd, Ll = Sl, kl = nl, Ml = ca, Ul = Uo, xl = Gd, Vl = pl, Fl = Pl.PROPER, Bl = Vl.BUGGY_SAFARI_ITERATORS, jl = ht("iterator"), Gl = "keys", Wl = "values", Hl = "entries", Kl = function() {
        return this;
      }, Yl = function(e2, t2, i2, n2, r2, s2, o2) {
        Ll(i2, t2, n2);
        var a2, c2, d2, l2 = function(e3) {
          if (e3 === r2 && E2) return E2;
          if (!Bl && e3 in p2) return p2[e3];
          switch (e3) {
            case Gl:
            case Wl:
            case Hl:
              return function() {
                return new i2(this, e3);
              };
          }
          return function() {
            return new i2(this);
          };
        }, u2 = t2 + " Iterator", h3 = false, p2 = e2.prototype, _2 = p2[jl] || p2["@@iterator"] || r2 && p2[r2], E2 = !Bl && _2 || l2(r2), m2 = "Array" == t2 && p2.entries || _2;
        if (m2 && (a2 = kl(m2.call(new e2()))) !== Object.prototype && a2.next && (Ml(a2, u2, true, true), xl[u2] = Kl), Fl && r2 == Wl && _2 && _2.name !== Wl && (h3 = true, E2 = function() {
          return Dl(_2, this);
        }), r2) if (c2 = { values: l2(Wl), keys: s2 ? E2 : l2(Gl), entries: l2(Hl) }, o2) for (d2 in c2) (Bl || h3 || !(d2 in p2)) && Ul(p2, d2, c2[d2]);
        else Nl({ target: t2, proto: true, forced: Bl || h3 }, c2);
        return o2 && p2[jl] !== E2 && Ul(p2, jl, E2, { name: r2 }), xl[t2] = E2, c2;
      }, ql = function(e2, t2) {
        return { value: e2, done: t2 };
      }, zl = Z, Jl = Gd, Xl = va;
      Qt.f;
      var Ql = Yl, Zl = ql, $l = "Array Iterator", eu = Xl.set, tu = Xl.getterFor($l);
      Ql(Array, "Array", function(e2, t2) {
        eu(this, { type: $l, target: zl(e2), index: 0, kind: t2 });
      }, function() {
        var e2 = tu(this), t2 = e2.target, i2 = e2.kind, n2 = e2.index++;
        return !t2 || n2 >= t2.length ? (e2.target = void 0, Zl(void 0, true)) : Zl("keys" == i2 ? n2 : "values" == i2 ? t2[n2] : [n2, t2[n2]], false);
      }, "values"), Jl.Arguments = Jl.Array;
      var iu = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, nu = h2, ru = ln, su = mi, ou = Gd, au = ht("toStringTag");
      for (var cu in iu) {
        var du = nu[cu], lu = du && du.prototype;
        lu && ru(lu) !== au && su(lu, au, cu), ou[cu] = ou.Array;
      }
      var uu = jd, hu = ht, pu = Qt.f, _u = hu("metadata"), Eu = Function.prototype;
      void 0 === Eu[_u] && pu(Eu, _u, { value: null }), zo("dispose"), zo("metadata");
      var mu = uu;
      zo("asyncDispose");
      var fu = d, gu = ae("Symbol"), Tu = gu.keyFor, Su = fu(gu.prototype.valueOf), Ru = gu.isRegisteredSymbol || function(e2) {
        try {
          return void 0 !== Tu(Su(e2));
        } catch (e3) {
          return false;
        }
      };
      wi({ target: "Symbol", stat: true }, { isRegisteredSymbol: Ru });
      for (var Cu = Ye, Iu = ae, vu = d, yu = ye, Au = ht, bu = Iu("Symbol"), wu = bu.isWellKnownSymbol, Ou = Iu("Object", "getOwnPropertyNames"), Nu = vu(bu.prototype.valueOf), Du = Cu("wks"), Pu = 0, Lu = Ou(bu), ku = Lu.length; Pu < ku; Pu++) try {
        var Mu = Lu[Pu];
        yu(bu[Mu]) && Au(Mu);
      } catch (e2) {
      }
      var Uu = function(e2) {
        if (wu && wu(e2)) return true;
        try {
          for (var t2 = Nu(e2), i2 = 0, n2 = Ou(Du), r2 = n2.length; i2 < r2; i2++) if (Du[n2[i2]] == t2) return true;
        } catch (e3) {
        }
        return false;
      };
      wi({ target: "Symbol", stat: true, forced: true }, { isWellKnownSymbol: Uu }), zo("matcher"), zo("observable"), wi({ target: "Symbol", stat: true, name: "isRegisteredSymbol" }, { isRegistered: Ru }), wi({ target: "Symbol", stat: true, name: "isWellKnownSymbol", forced: true }, { isWellKnown: Uu }), zo("metadataKey"), zo("patternMatch"), zo("replaceAll");
      var xu = i(mu), Vu = d, Fu = Pi, Bu = pn, ju = J, Gu = Vu("".charAt), Wu = Vu("".charCodeAt), Hu = Vu("".slice), Ku = function(e2) {
        return function(t2, i2) {
          var n2, r2, s2 = Bu(ju(t2)), o2 = Fu(i2), a2 = s2.length;
          return o2 < 0 || o2 >= a2 ? e2 ? "" : void 0 : (n2 = Wu(s2, o2)) < 55296 || n2 > 56319 || o2 + 1 === a2 || (r2 = Wu(s2, o2 + 1)) < 56320 || r2 > 57343 ? e2 ? Gu(s2, o2) : n2 : e2 ? Hu(s2, o2, o2 + 2) : r2 - 56320 + (n2 - 55296 << 10) + 65536;
        };
      }, Yu = { codeAt: Ku(false), charAt: Ku(true) }, qu = Yu.charAt, zu = pn, Ju = va, Xu = Yl, Qu = ql, Zu = "String Iterator", $u = Ju.set, eh = Ju.getterFor(Zu);
      Xu(String, "String", function(e2) {
        $u(this, { type: Zu, string: zu(e2), index: 0 });
      }, function() {
        var e2, t2 = eh(this), i2 = t2.string, n2 = t2.index;
        return n2 >= i2.length ? Qu(void 0, true) : (e2 = qu(i2, n2), t2.index += e2.length, Qu(e2, false));
      });
      var th = i(Fo.f("iterator"));
      function ih(e2) {
        return ih = "function" == typeof xu && "symbol" == typeof th ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && "function" == typeof xu && e3.constructor === xu && e3 !== xu.prototype ? "symbol" : typeof e3;
        }, ih(e2);
      }
      var nh = i(Fo.f("toPrimitive"));
      function rh(e2) {
        var t2 = function(e3, t3) {
          if ("object" !== ih(e3) || null === e3) return e3;
          var i2 = e3[nh];
          if (void 0 !== i2) {
            var n2 = i2.call(e3, t3 || "default");
            if ("object" !== ih(n2)) return n2;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === t3 ? String : Number)(e3);
        }(e2, "string");
        return "symbol" === ih(t2) ? t2 : String(t2);
      }
      function sh(e2, t2, i2) {
        return (t2 = rh(t2)) in e2 ? Fr(e2, t2, { value: i2, enumerable: true, configurable: true, writable: true }) : e2[t2] = i2, e2;
      }
      var oh = zi("Array").keys, ah = ln, ch = Ze, dh = l, lh = oh, uh = Array.prototype, hh = { DOMTokenList: true, NodeList: true }, ph = i(function(e2) {
        var t2 = e2.keys;
        return e2 === uh || dh(uh, e2) && t2 === uh.keys || ch(hh, ah(e2)) ? lh : t2;
      }), _h = be, Eh = TypeError, mh = wo, fh = Math.floor, gh = function(e2, t2) {
        var i2 = e2.length, n2 = fh(i2 / 2);
        return i2 < 8 ? Th(e2, t2) : Sh(e2, gh(mh(e2, 0, n2), t2), gh(mh(e2, n2), t2), t2);
      }, Th = function(e2, t2) {
        for (var i2, n2, r2 = e2.length, s2 = 1; s2 < r2; ) {
          for (n2 = s2, i2 = e2[s2]; n2 && t2(e2[n2 - 1], i2) > 0; ) e2[n2] = e2[--n2];
          n2 !== s2++ && (e2[n2] = i2);
        }
        return e2;
      }, Sh = function(e2, t2, i2, n2) {
        for (var r2 = t2.length, s2 = i2.length, o2 = 0, a2 = 0; o2 < r2 || a2 < s2; ) e2[o2 + a2] = o2 < r2 && a2 < s2 ? n2(t2[o2], i2[a2]) <= 0 ? t2[o2++] : i2[a2++] : o2 < r2 ? t2[o2++] : i2[a2++];
        return e2;
      }, Rh = gh, Ch = n, Ih = function(e2, t2) {
        var i2 = [][e2];
        return !!i2 && Ch(function() {
          i2.call(null, t2 || function() {
            return 1;
          }, 1);
        });
      }, vh = ce.match(/firefox\/(\d+)/i), yh = !!vh && +vh[1], Ah = /MSIE|Trident/.test(ce), bh = ce.match(/AppleWebKit\/(\d+)\./), wh = !!bh && +bh[1], Oh = wi, Nh = d, Dh = De, Ph = Je, Lh = Bi, kh = function(e2, t2) {
        if (!delete e2[t2]) throw Eh("Cannot delete property " + _h(t2) + " of " + _h(e2));
      }, Mh = pn, Uh = n, xh = Rh, Vh = Ih, Fh = yh, Bh = Ah, jh = Ee, Gh = wh, Wh = [], Hh = Nh(Wh.sort), Kh = Nh(Wh.push), Yh = Uh(function() {
        Wh.sort(void 0);
      }), qh = Uh(function() {
        Wh.sort(null);
      }), zh = Vh("sort"), Jh = !Uh(function() {
        if (jh) return jh < 70;
        if (!(Fh && Fh > 3)) {
          if (Bh) return true;
          if (Gh) return Gh < 603;
          var e2, t2, i2, n2, r2 = "";
          for (e2 = 65; e2 < 76; e2++) {
            switch (t2 = String.fromCharCode(e2), e2) {
              case 66:
              case 69:
              case 70:
              case 72:
                i2 = 3;
                break;
              case 68:
              case 71:
                i2 = 4;
                break;
              default:
                i2 = 2;
            }
            for (n2 = 0; n2 < 47; n2++) Wh.push({ k: t2 + n2, v: i2 });
          }
          for (Wh.sort(function(e3, t3) {
            return t3.v - e3.v;
          }), n2 = 0; n2 < Wh.length; n2++) t2 = Wh[n2].k.charAt(0), r2.charAt(r2.length - 1) !== t2 && (r2 += t2);
          return "DGBEFHACIJK" !== r2;
        }
      });
      Oh({ target: "Array", proto: true, forced: Yh || !qh || !zh || !Jh }, { sort: function(e2) {
        void 0 !== e2 && Dh(e2);
        var t2 = Ph(this);
        if (Jh) return void 0 === e2 ? Hh(t2) : Hh(t2, e2);
        var i2, n2, r2 = [], s2 = Lh(t2);
        for (n2 = 0; n2 < s2; n2++) n2 in t2 && Kh(r2, t2[n2]);
        for (xh(r2, /* @__PURE__ */ function(e3) {
          return function(t3, i3) {
            return void 0 === i3 ? -1 : void 0 === t3 ? 1 : void 0 !== e3 ? +e3(t3, i3) || 0 : Mh(t3) > Mh(i3) ? 1 : -1;
          };
        }(e2)), i2 = Lh(r2), n2 = 0; n2 < i2; ) t2[n2] = r2[n2++];
        for (; n2 < s2; ) kh(t2, n2++);
        return t2;
      } });
      var Xh = zi("Array").sort, Qh = l, Zh = Xh, $h = Array.prototype, ep = i(function(e2) {
        var t2 = e2.sort;
        return e2 === $h || Qh($h, e2) && t2 === $h.sort ? Zh : t2;
      }), tp = ae, ip = To, np = ko, rp = ii, sp = d([].concat), op = tp("Reflect", "ownKeys") || function(e2) {
        var t2 = ip.f(rp(e2)), i2 = np.f;
        return i2 ? sp(t2, i2(e2)) : t2;
      }, ap = Ze, cp = op, dp = O, lp = Qt, up = te, hp = mi, pp = Error, _p = d("".replace), Ep = String(pp("zxcasd").stack), mp = /\n\s*at [^:]*:[^\n]*/, fp = mp.test(Ep), gp = B, Tp = !n(function() {
        var e2 = Error("a");
        return !("stack" in e2) || (Object.defineProperty(e2, "stack", gp(1, 7)), 7 !== e2.stack);
      }), Sp = mi, Rp = function(e2, t2) {
        if (fp && "string" == typeof e2 && !pp.prepareStackTrace) for (; t2--; ) e2 = _p(e2, mp, "");
        return e2;
      }, Cp = Tp, Ip = Error.captureStackTrace, vp = Gd, yp = ht("iterator"), Ap = Array.prototype, bp = function(e2) {
        return void 0 !== e2 && (vp.Array === e2 || Ap[yp] === e2);
      }, wp = ln, Op = ke, Np = Y, Dp = Gd, Pp = ht("iterator"), Lp = function(e2) {
        if (!Np(e2)) return Op(e2, Pp) || Op(e2, "@@iterator") || Dp[wp(e2)];
      }, kp = L, Mp = De, Up = ii, xp = be, Vp = Lp, Fp = TypeError, Bp = function(e2, t2) {
        var i2 = arguments.length < 2 ? Vp(e2) : t2;
        if (Mp(i2)) return Up(kp(i2, e2));
        throw Fp(xp(e2) + " is not iterable");
      }, jp = L, Gp = ii, Wp = ke, Hp = function(e2, t2, i2) {
        var n2, r2;
        Gp(e2);
        try {
          if (!(n2 = Wp(e2, "return"))) {
            if ("throw" === t2) throw i2;
            return i2;
          }
          n2 = jp(n2, e2);
        } catch (e3) {
          r2 = true, n2 = e3;
        }
        if ("throw" === t2) throw i2;
        if (r2) throw n2;
        return Gp(n2), i2;
      }, Kp = Xt, Yp = L, qp = ii, zp = be, Jp = bp, Xp = Bi, Qp = l, Zp = Bp, $p = Lp, e_ = Hp, t_ = TypeError, i_ = function(e2, t2) {
        this.stopped = e2, this.result = t2;
      }, n_ = i_.prototype, r_ = function(e2, t2, i2) {
        var n2, r2, s2, o2, a2, c2, d2, l2 = i2 && i2.that, u2 = !(!i2 || !i2.AS_ENTRIES), h3 = !(!i2 || !i2.IS_RECORD), p2 = !(!i2 || !i2.IS_ITERATOR), _2 = !(!i2 || !i2.INTERRUPTED), E2 = Kp(t2, l2), m2 = function(e3) {
          return n2 && e_(n2, "normal", e3), new i_(true, e3);
        }, f2 = function(e3) {
          return u2 ? (qp(e3), _2 ? E2(e3[0], e3[1], m2) : E2(e3[0], e3[1])) : _2 ? E2(e3, m2) : E2(e3);
        };
        if (h3) n2 = e2.iterator;
        else if (p2) n2 = e2;
        else {
          if (!(r2 = $p(e2))) throw t_(zp(e2) + " is not iterable");
          if (Jp(r2)) {
            for (s2 = 0, o2 = Xp(e2); o2 > s2; s2++) if ((a2 = f2(e2[s2])) && Qp(n_, a2)) return a2;
            return new i_(false);
          }
          n2 = Zp(e2, r2);
        }
        for (c2 = h3 ? e2.next : n2.next; !(d2 = Yp(c2, n2)).done; ) {
          try {
            a2 = f2(d2.value);
          } catch (e3) {
            e_(n2, "throw", e3);
          }
          if ("object" == typeof a2 && a2 && Qp(n_, a2)) return a2;
        }
        return new i_(false);
      }, s_ = pn, o_ = wi, a_ = l, c_ = nl, d_ = Ol, l_ = function(e2, t2, i2) {
        for (var n2 = cp(t2), r2 = lp.f, s2 = dp.f, o2 = 0; o2 < n2.length; o2++) {
          var a2 = n2[o2];
          ap(e2, a2) || i2 && ap(i2, a2) || r2(e2, a2, s2(t2, a2));
        }
      }, u_ = go, h_ = mi, p_ = B, __ = function(e2, t2) {
        up(t2) && "cause" in t2 && hp(e2, "cause", t2.cause);
      }, E_ = function(e2, t2, i2, n2) {
        Cp && (Ip ? Ip(e2, t2) : Sp(e2, "stack", Rp(i2, n2)));
      }, m_ = r_, f_ = function(e2, t2) {
        return void 0 === e2 ? arguments.length < 2 ? "" : t2 : s_(e2);
      }, g_ = ht("toStringTag"), T_ = Error, S_ = [].push, R_ = function(e2, t2) {
        var i2, n2 = a_(C_, this);
        d_ ? i2 = d_(T_(), n2 ? c_(this) : C_) : (i2 = n2 ? this : u_(C_), h_(i2, g_, "Error")), void 0 !== t2 && h_(i2, "message", f_(t2)), E_(i2, R_, i2.stack, 1), arguments.length > 2 && __(i2, arguments[2]);
        var r2 = [];
        return m_(e2, S_, { that: r2 }), h_(i2, "errors", r2), i2;
      };
      d_ ? d_(R_, T_) : l_(R_, T_, { name: true });
      var C_ = R_.prototype = u_(T_.prototype, { constructor: p_(1, R_), message: p_(1, ""), name: p_(1, "AggregateError") });
      o_({ global: true, constructor: true, arity: 2 }, { AggregateError: R_ });
      var I_, v_, y_, A_, b_ = "undefined" != typeof process && "process" == R(process), w_ = ae, O_ = Vo, N_ = N, D_ = ht("species"), P_ = l, L_ = TypeError, k_ = function(e2, t2) {
        if (P_(t2, e2)) return e2;
        throw L_("Incorrect invocation");
      }, M_ = ls, U_ = be, x_ = TypeError, V_ = ii, F_ = function(e2) {
        if (M_(e2)) return e2;
        throw x_(U_(e2) + " is not a constructor");
      }, B_ = Y, j_ = ht("species"), G_ = function(e2, t2) {
        var i2, n2 = V_(e2).constructor;
        return void 0 === n2 || B_(i2 = V_(n2)[j_]) ? t2 : F_(i2);
      }, W_ = TypeError, H_ = function(e2, t2) {
        if (e2 < t2) throw W_("Not enough arguments");
        return e2;
      }, K_ = /(?:ipad|iphone|ipod).*applewebkit/i.test(ce), Y_ = h2, q_ = f, z_ = Xt, J_ = w, X_ = Ze, Q_ = n, Z_ = eo, $_ = id, eE = At, tE = H_, iE = K_, nE = b_, rE = Y_.setImmediate, sE = Y_.clearImmediate, oE = Y_.process, aE = Y_.Dispatch, cE = Y_.Function, dE = Y_.MessageChannel, lE = Y_.String, uE = 0, hE = {}, pE = "onreadystatechange";
      Q_(function() {
        I_ = Y_.location;
      });
      var _E = function(e2) {
        if (X_(hE, e2)) {
          var t2 = hE[e2];
          delete hE[e2], t2();
        }
      }, EE = function(e2) {
        return function() {
          _E(e2);
        };
      }, mE = function(e2) {
        _E(e2.data);
      }, fE = function(e2) {
        Y_.postMessage(lE(e2), I_.protocol + "//" + I_.host);
      };
      rE && sE || (rE = function(e2) {
        tE(arguments.length, 1);
        var t2 = J_(e2) ? e2 : cE(e2), i2 = $_(arguments, 1);
        return hE[++uE] = function() {
          q_(t2, void 0, i2);
        }, v_(uE), uE;
      }, sE = function(e2) {
        delete hE[e2];
      }, nE ? v_ = function(e2) {
        oE.nextTick(EE(e2));
      } : aE && aE.now ? v_ = function(e2) {
        aE.now(EE(e2));
      } : dE && !iE ? (A_ = (y_ = new dE()).port2, y_.port1.onmessage = mE, v_ = z_(A_.postMessage, A_)) : Y_.addEventListener && J_(Y_.postMessage) && !Y_.importScripts && I_ && "file:" !== I_.protocol && !Q_(fE) ? (v_ = fE, Y_.addEventListener("message", mE, false)) : v_ = pE in eE("script") ? function(e2) {
        Z_.appendChild(eE("script"))[pE] = function() {
          Z_.removeChild(this), _E(e2);
        };
      } : function(e2) {
        setTimeout(EE(e2), 0);
      });
      var gE = { set: rE, clear: sE }, TE = function() {
        this.head = null, this.tail = null;
      };
      TE.prototype = { add: function(e2) {
        var t2 = { item: e2, next: null }, i2 = this.tail;
        i2 ? i2.next = t2 : this.head = t2, this.tail = t2;
      }, get: function() {
        var e2 = this.head;
        if (e2) return null === (this.head = e2.next) && (this.tail = null), e2.item;
      } };
      var SE, RE, CE, IE, vE, yE = TE, AE = /ipad|iphone|ipod/i.test(ce) && "undefined" != typeof Pebble, bE = /web0s(?!.*chrome)/i.test(ce), wE = h2, OE = Xt, NE = O.f, DE = gE.set, PE = yE, LE = K_, kE = AE, ME = bE, UE = b_, xE = wE.MutationObserver || wE.WebKitMutationObserver, VE = wE.document, FE = wE.process, BE = wE.Promise, jE = NE(wE, "queueMicrotask"), GE = jE && jE.value;
      if (!GE) {
        var WE = new PE(), HE = function() {
          var e2, t2;
          for (UE && (e2 = FE.domain) && e2.exit(); t2 = WE.get(); ) try {
            t2();
          } catch (e3) {
            throw WE.head && SE(), e3;
          }
          e2 && e2.enter();
        };
        LE || UE || ME || !xE || !VE ? !kE && BE && BE.resolve ? ((IE = BE.resolve(void 0)).constructor = BE, vE = OE(IE.then, IE), SE = function() {
          vE(HE);
        }) : UE ? SE = function() {
          FE.nextTick(HE);
        } : (DE = OE(DE, wE), SE = function() {
          DE(HE);
        }) : (RE = true, CE = VE.createTextNode(""), new xE(HE).observe(CE, { characterData: true }), SE = function() {
          CE.data = RE = !RE;
        }), GE = function(e2) {
          WE.head || SE(), WE.add(e2);
        };
      }
      var KE = GE, YE = function(e2) {
        try {
          return { error: false, value: e2() };
        } catch (e3) {
          return { error: true, value: e3 };
        }
      }, qE = h2.Promise, zE = "object" == typeof Deno && Deno && "object" == typeof Deno.version, JE = !zE && !b_ && "object" == typeof window && "object" == typeof document, XE = h2, QE = qE, ZE = w, $E = Yt, em = Xr, tm = ht, im = JE, nm = zE, rm = Ee, sm = QE && QE.prototype, om = tm("species"), am = false, cm = ZE(XE.PromiseRejectionEvent), dm = $E("Promise", function() {
        var e2 = em(QE), t2 = e2 !== String(QE);
        if (!t2 && 66 === rm) return true;
        if (!sm.catch || !sm.finally) return true;
        if (!rm || rm < 51 || !/native code/.test(e2)) {
          var i2 = new QE(function(e3) {
            e3(1);
          }), n2 = function(e3) {
            e3(function() {
            }, function() {
            });
          };
          if ((i2.constructor = {})[om] = n2, !(am = i2.then(function() {
          }) instanceof n2)) return true;
        }
        return !t2 && (im || nm) && !cm;
      }), lm = { CONSTRUCTOR: dm, REJECTION_EVENT: cm, SUBCLASSING: am }, um = {}, hm = De, pm = TypeError, _m = function(e2) {
        var t2, i2;
        this.promise = new e2(function(e3, n2) {
          if (void 0 !== t2 || void 0 !== i2) throw pm("Bad Promise constructor");
          t2 = e3, i2 = n2;
        }), this.resolve = hm(t2), this.reject = hm(i2);
      };
      um.f = function(e2) {
        return new _m(e2);
      };
      var Em, mm, fm = wi, gm = b_, Tm = h2, Sm = L, Rm = Uo, Cm = ca, Im = function(e2) {
        var t2 = w_(e2);
        N_ && t2 && !t2[D_] && O_(t2, D_, { configurable: true, get: function() {
          return this;
        } });
      }, vm = De, ym = w, Am = te, bm = k_, wm = G_, Om = gE.set, Nm = KE, Dm = function(e2, t2) {
        try {
          1 == arguments.length ? console.error(e2) : console.error(e2, t2);
        } catch (e3) {
        }
      }, Pm = YE, Lm = yE, km = va, Mm = qE, Um = lm, xm = um, Vm = "Promise", Fm = Um.CONSTRUCTOR, Bm = Um.REJECTION_EVENT, jm = km.getterFor(Vm), Gm = km.set, Wm = Mm && Mm.prototype, Hm = Mm, Km = Wm, Ym = Tm.TypeError, qm = Tm.document, zm = Tm.process, Jm = xm.f, Xm = Jm, Qm = !!(qm && qm.createEvent && Tm.dispatchEvent), Zm = "unhandledrejection", $m = function(e2) {
        var t2;
        return !(!Am(e2) || !ym(t2 = e2.then)) && t2;
      }, ef = function(e2, t2) {
        var i2, n2, r2, s2 = t2.value, o2 = 1 == t2.state, a2 = o2 ? e2.ok : e2.fail, c2 = e2.resolve, d2 = e2.reject, l2 = e2.domain;
        try {
          a2 ? (o2 || (2 === t2.rejection && of(t2), t2.rejection = 1), true === a2 ? i2 = s2 : (l2 && l2.enter(), i2 = a2(s2), l2 && (l2.exit(), r2 = true)), i2 === e2.promise ? d2(Ym("Promise-chain cycle")) : (n2 = $m(i2)) ? Sm(n2, i2, c2, d2) : c2(i2)) : d2(s2);
        } catch (e3) {
          l2 && !r2 && l2.exit(), d2(e3);
        }
      }, tf = function(e2, t2) {
        e2.notified || (e2.notified = true, Nm(function() {
          for (var i2, n2 = e2.reactions; i2 = n2.get(); ) ef(i2, e2);
          e2.notified = false, t2 && !e2.rejection && rf(e2);
        }));
      }, nf = function(e2, t2, i2) {
        var n2, r2;
        Qm ? ((n2 = qm.createEvent("Event")).promise = t2, n2.reason = i2, n2.initEvent(e2, false, true), Tm.dispatchEvent(n2)) : n2 = { promise: t2, reason: i2 }, !Bm && (r2 = Tm["on" + e2]) ? r2(n2) : e2 === Zm && Dm("Unhandled promise rejection", i2);
      }, rf = function(e2) {
        Sm(Om, Tm, function() {
          var t2, i2 = e2.facade, n2 = e2.value;
          if (sf(e2) && (t2 = Pm(function() {
            gm ? zm.emit("unhandledRejection", n2, i2) : nf(Zm, i2, n2);
          }), e2.rejection = gm || sf(e2) ? 2 : 1, t2.error)) throw t2.value;
        });
      }, sf = function(e2) {
        return 1 !== e2.rejection && !e2.parent;
      }, of = function(e2) {
        Sm(Om, Tm, function() {
          var t2 = e2.facade;
          gm ? zm.emit("rejectionHandled", t2) : nf("rejectionhandled", t2, e2.value);
        });
      }, af = function(e2, t2, i2) {
        return function(n2) {
          e2(t2, n2, i2);
        };
      }, cf = function(e2, t2, i2) {
        e2.done || (e2.done = true, i2 && (e2 = i2), e2.value = t2, e2.state = 2, tf(e2, true));
      }, df = function(e2, t2, i2) {
        if (!e2.done) {
          e2.done = true, i2 && (e2 = i2);
          try {
            if (e2.facade === t2) throw Ym("Promise can't be resolved itself");
            var n2 = $m(t2);
            n2 ? Nm(function() {
              var i3 = { done: false };
              try {
                Sm(n2, t2, af(df, i3, e2), af(cf, i3, e2));
              } catch (t3) {
                cf(i3, t3, e2);
              }
            }) : (e2.value = t2, e2.state = 1, tf(e2, false));
          } catch (t3) {
            cf({ done: false }, t3, e2);
          }
        }
      };
      Fm && (Km = (Hm = function(e2) {
        bm(this, Km), vm(e2), Sm(Em, this);
        var t2 = jm(this);
        try {
          e2(af(df, t2), af(cf, t2));
        } catch (e3) {
          cf(t2, e3);
        }
      }).prototype, (Em = function(e2) {
        Gm(this, { type: Vm, done: false, notified: false, parent: false, reactions: new Lm(), rejection: false, state: 0, value: void 0 });
      }).prototype = Rm(Km, "then", function(e2, t2) {
        var i2 = jm(this), n2 = Jm(wm(this, Hm));
        return i2.parent = true, n2.ok = !ym(e2) || e2, n2.fail = ym(t2) && t2, n2.domain = gm ? zm.domain : void 0, 0 == i2.state ? i2.reactions.add(n2) : Nm(function() {
          ef(n2, i2);
        }), n2.promise;
      }), mm = function() {
        var e2 = new Em(), t2 = jm(e2);
        this.promise = e2, this.resolve = af(df, t2), this.reject = af(cf, t2);
      }, xm.f = Jm = function(e2) {
        return e2 === Hm || void 0 === e2 ? new mm(e2) : Xm(e2);
      }), fm({ global: true, constructor: true, wrap: true, forced: Fm }, { Promise: Hm }), Cm(Hm, Vm, false, true), Im(Vm);
      var lf = ht("iterator"), uf = false;
      try {
        var hf = 0, pf = { next: function() {
          return { done: !!hf++ };
        }, return: function() {
          uf = true;
        } };
        pf[lf] = function() {
          return this;
        }, Array.from(pf, function() {
          throw 2;
        });
      } catch (e2) {
      }
      var _f = qE, Ef = function(e2, t2) {
        if (!t2 && !uf) return false;
        var i2 = false;
        try {
          var n2 = {};
          n2[lf] = function() {
            return { next: function() {
              return { done: i2 = true };
            } };
          }, e2(n2);
        } catch (e3) {
        }
        return i2;
      }, mf = lm.CONSTRUCTOR || !Ef(function(e2) {
        _f.all(e2).then(void 0, function() {
        });
      }), ff = L, gf = De, Tf = um, Sf = YE, Rf = r_;
      wi({ target: "Promise", stat: true, forced: mf }, { all: function(e2) {
        var t2 = this, i2 = Tf.f(t2), n2 = i2.resolve, r2 = i2.reject, s2 = Sf(function() {
          var i3 = gf(t2.resolve), s3 = [], o2 = 0, a2 = 1;
          Rf(e2, function(e3) {
            var c2 = o2++, d2 = false;
            a2++, ff(i3, t2, e3).then(function(e4) {
              d2 || (d2 = true, s3[c2] = e4, --a2 || n2(s3));
            }, r2);
          }), --a2 || n2(s3);
        });
        return s2.error && r2(s2.value), i2.promise;
      } });
      var Cf = wi, If = lm.CONSTRUCTOR;
      qE && qE.prototype, Cf({ target: "Promise", proto: true, forced: If, real: true }, { catch: function(e2) {
        return this.then(void 0, e2);
      } });
      var vf = L, yf = De, Af = um, bf = YE, wf = r_;
      wi({ target: "Promise", stat: true, forced: mf }, { race: function(e2) {
        var t2 = this, i2 = Af.f(t2), n2 = i2.reject, r2 = bf(function() {
          var r3 = yf(t2.resolve);
          wf(e2, function(e3) {
            vf(r3, t2, e3).then(i2.resolve, n2);
          });
        });
        return r2.error && n2(r2.value), i2.promise;
      } });
      var Of = L, Nf = um;
      wi({ target: "Promise", stat: true, forced: lm.CONSTRUCTOR }, { reject: function(e2) {
        var t2 = Nf.f(this);
        return Of(t2.reject, void 0, e2), t2.promise;
      } });
      var Df = ii, Pf = te, Lf = um, kf = function(e2, t2) {
        if (Df(e2), Pf(t2) && t2.constructor === e2) return t2;
        var i2 = Lf.f(e2);
        return (0, i2.resolve)(t2), i2.promise;
      }, Mf = wi, Uf = qE, xf = lm.CONSTRUCTOR, Vf = kf, Ff = ae("Promise"), Bf = !xf;
      Mf({ target: "Promise", stat: true, forced: true }, { resolve: function(e2) {
        return Vf(Bf && this === Ff ? Uf : this, e2);
      } });
      var jf = L, Gf = De, Wf = um, Hf = YE, Kf = r_;
      wi({ target: "Promise", stat: true, forced: mf }, { allSettled: function(e2) {
        var t2 = this, i2 = Wf.f(t2), n2 = i2.resolve, r2 = i2.reject, s2 = Hf(function() {
          var i3 = Gf(t2.resolve), r3 = [], s3 = 0, o2 = 1;
          Kf(e2, function(e3) {
            var a2 = s3++, c2 = false;
            o2++, jf(i3, t2, e3).then(function(e4) {
              c2 || (c2 = true, r3[a2] = { status: "fulfilled", value: e4 }, --o2 || n2(r3));
            }, function(e4) {
              c2 || (c2 = true, r3[a2] = { status: "rejected", reason: e4 }, --o2 || n2(r3));
            });
          }), --o2 || n2(r3);
        });
        return s2.error && r2(s2.value), i2.promise;
      } });
      var Yf = L, qf = De, zf = ae, Jf = um, Xf = YE, Qf = r_, Zf = "No one promise resolved";
      wi({ target: "Promise", stat: true, forced: mf }, { any: function(e2) {
        var t2 = this, i2 = zf("AggregateError"), n2 = Jf.f(t2), r2 = n2.resolve, s2 = n2.reject, o2 = Xf(function() {
          var n3 = qf(t2.resolve), o3 = [], a2 = 0, c2 = 1, d2 = false;
          Qf(e2, function(e3) {
            var l2 = a2++, u2 = false;
            c2++, Yf(n3, t2, e3).then(function(e4) {
              u2 || d2 || (d2 = true, r2(e4));
            }, function(e4) {
              u2 || d2 || (u2 = true, o3[l2] = e4, --c2 || s2(new i2(o3, Zf)));
            });
          }), --c2 || s2(new i2(o3, Zf));
        });
        return o2.error && s2(o2.value), n2.promise;
      } });
      var $f = wi, eg = qE, tg = n, ig = ae, ng = w, rg = G_, sg = kf, og = eg && eg.prototype;
      $f({ target: "Promise", proto: true, real: true, forced: !!eg && tg(function() {
        og.finally.call({ then: function() {
        } }, function() {
        });
      }) }, { finally: function(e2) {
        var t2 = rg(this, ig("Promise")), i2 = ng(e2);
        return this.then(i2 ? function(i3) {
          return sg(t2, e2()).then(function() {
            return i3;
          });
        } : e2, i2 ? function(i3) {
          return sg(t2, e2()).then(function() {
            throw i3;
          });
        } : e2);
      } });
      var ag = ie.Promise, cg = i(ag);
      const dg = () => {
      };
      function lg() {
        const e2 = { promise: void 0, isResolved: false, isRejected: false, isFinished: false, resolve: void 0, reject: void 0, cancel: dg };
        return e2.promise = new cg((t2, i2) => {
          e2.resolve = (i3) => {
            e2.isFinished || (e2.isResolved = true, e2.isFinished = true, t2(i3), e2.value = i3);
          }, e2.reject = (t3) => {
            e2.isFinished || (e2.isRejected = true, e2.isFinished = true, i2(t3));
          };
        }), e2;
      }
      const ug = /* @__PURE__ */ new Map(), hg = /* @__PURE__ */ new Map(), pg = /* @__PURE__ */ new Map();
      var _g, Eg;
      !function(e2) {
        e2.WIN_10 = "Windows 10", e2.WIN_81 = "Windows 8.1", e2.WIN_8 = "Windows 8", e2.WIN_7 = "Windows 7", e2.WIN_VISTA = "Windows Vista", e2.WIN_SERVER_2003 = "Windows Server 2003", e2.WIN_XP = "Windows XP", e2.WIN_2000 = "Windows 2000", e2.ANDROID = "Android", e2.HARMONY_OS = "HarmonyOS", e2.OPEN_BSD = "Open BSD", e2.SUN_OS = "Sun OS", e2.LINUX = "Linux", e2.IOS = "iOS", e2.MAC_OS = "Mac OS", e2.CHROMIUM_OS = "Chromium OS", e2.QNX = "QNX", e2.UNIX = "UNIX", e2.BEOS = "BeOS", e2.OS_2 = "OS/2", e2.SEARCH_BOT = "Search Bot";
      }(_g || (_g = {})), function(e2) {
        e2.CHROME = "Chrome", e2.SAFARI = "Safari", e2.EDGE = "Edge", e2.FIREFOX = "Firefox", e2.OPERA = "OPR", e2.QQ = "QQBrowser", e2.WECHAT = "MicroMessenger";
      }(Eg || (Eg = {}));
      var mg = { exports: {} };
      !function(e2, i2) {
        !function(t2, n2) {
          var r2 = "function", s2 = "undefined", o2 = "object", a2 = "string", c2 = "major", d2 = "model", l2 = "name", u2 = "type", h3 = "vendor", p2 = "version", _2 = "architecture", E2 = "console", m2 = "mobile", f2 = "tablet", g2 = "smarttv", T2 = "wearable", S2 = "embedded", R2 = "Amazon", C2 = "Apple", I2 = "ASUS", v2 = "BlackBerry", y2 = "Browser", A2 = "Chrome", b2 = "Firefox", w2 = "Google", O2 = "Huawei", N2 = "LG", D2 = "Microsoft", P2 = "Motorola", L2 = "Opera", k2 = "Samsung", M2 = "Sharp", U2 = "Sony", x2 = "Xiaomi", V2 = "Zebra", F2 = "Facebook", B2 = "Chromium OS", j2 = "Mac OS", G2 = function(e3) {
            for (var t3 = {}, i3 = 0; i3 < e3.length; i3++) t3[e3[i3].toUpperCase()] = e3[i3];
            return t3;
          }, W2 = function(e3, t3) {
            return typeof e3 === a2 && -1 !== H2(t3).indexOf(H2(e3));
          }, H2 = function(e3) {
            return e3.toLowerCase();
          }, K2 = function(e3, t3) {
            if (typeof e3 === a2) return e3 = e3.replace(/^\s\s*/, ""), typeof t3 === s2 ? e3 : e3.substring(0, 350);
          }, Y2 = function(e3, t3) {
            for (var i3, s3, a3, c3, d3, l3, u3 = 0; u3 < t3.length && !d3; ) {
              var h4 = t3[u3], p3 = t3[u3 + 1];
              for (i3 = s3 = 0; i3 < h4.length && !d3 && h4[i3]; ) if (d3 = h4[i3++].exec(e3)) for (a3 = 0; a3 < p3.length; a3++) l3 = d3[++s3], typeof (c3 = p3[a3]) === o2 && c3.length > 0 ? 2 === c3.length ? typeof c3[1] == r2 ? this[c3[0]] = c3[1].call(this, l3) : this[c3[0]] = c3[1] : 3 === c3.length ? typeof c3[1] !== r2 || c3[1].exec && c3[1].test ? this[c3[0]] = l3 ? l3.replace(c3[1], c3[2]) : n2 : this[c3[0]] = l3 ? c3[1].call(this, l3, c3[2]) : n2 : 4 === c3.length && (this[c3[0]] = l3 ? c3[3].call(this, l3.replace(c3[1], c3[2])) : n2) : this[c3] = l3 || n2;
              u3 += 2;
            }
          }, q2 = function(e3, t3) {
            for (var i3 in t3) if (typeof t3[i3] === o2 && t3[i3].length > 0) {
              for (var r3 = 0; r3 < t3[i3].length; r3++) if (W2(t3[i3][r3], e3)) return "?" === i3 ? n2 : i3;
            } else if (W2(t3[i3], e3)) return "?" === i3 ? n2 : i3;
            return e3;
          }, z2 = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }, J2 = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [p2, [l2, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [p2, [l2, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [l2, p2], [/opios[\/ ]+([\w\.]+)/i], [p2, [l2, L2 + " Mini"]], [/\bopr\/([\w\.]+)/i], [p2, [l2, L2]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(weibo)__([\d\.]+)/i], [l2, p2], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [p2, [l2, "UC" + y2]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i], [p2, [l2, "WeChat(Win) Desktop"]], [/micromessenger\/([\w\.]+)/i], [p2, [l2, "WeChat"]], [/konqueror\/([\w\.]+)/i], [p2, [l2, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [p2, [l2, "IE"]], [/yabrowser\/([\w\.]+)/i], [p2, [l2, "Yandex"]], [/(avast|avg)\/([\w\.]+)/i], [[l2, /(.+)/, "$1 Secure " + y2], p2], [/\bfocus\/([\w\.]+)/i], [p2, [l2, b2 + " Focus"]], [/\bopt\/([\w\.]+)/i], [p2, [l2, L2 + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [p2, [l2, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [p2, [l2, "Dolphin"]], [/coast\/([\w\.]+)/i], [p2, [l2, L2 + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [p2, [l2, "MIUI " + y2]], [/fxios\/([-\w\.]+)/i], [p2, [l2, b2]], [/\bqihu|(qi?ho?o?|360)browser/i], [[l2, "360 " + y2]], [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i], [[l2, /(.+)/, "$1 " + y2], p2], [/(comodo_dragon)\/([\w\.]+)/i], [[l2, /_/g, " "], p2], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i], [l2, p2], [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i, /\[(linkedin)app\]/i], [l2], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[l2, F2], p2], [/(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram)[\/ ]([-\w\.]+)/i], [l2, p2], [/\bgsa\/([\w\.]+) .*safari\//i], [p2, [l2, "GSA"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [p2, [l2, A2 + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[l2, A2 + " WebView"], p2], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [p2, [l2, "Android " + y2]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [l2, p2], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [p2, [l2, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [p2, l2], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [l2, [p2, q2, { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }]], [/(webkit|khtml)\/([\w\.]+)/i], [l2, p2], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[l2, "Netscape"], p2], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [p2, [l2, b2 + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i], [l2, p2], [/(cobalt)\/([\w\.]+)/i], [l2, [p2, /master.|lts./, ""]]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[_2, "amd64"]], [/(ia32(?=;))/i], [[_2, H2]], [/((?:i[346]|x)86)[;\)]/i], [[_2, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[_2, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[_2, "armhf"]], [/windows (ce|mobile); ppc;/i], [[_2, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[_2, /ower/, "", H2]], [/(sun4\w)[;\)]/i], [[_2, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[_2, H2]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [d2, [h3, k2], [u2, f2]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [d2, [h3, k2], [u2, m2]], [/\((ip(?:hone|od)[\w ]*);/i], [d2, [h3, C2], [u2, m2]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [d2, [h3, C2], [u2, f2]], [/(macintosh);/i], [d2, [h3, C2]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [d2, [h3, M2], [u2, m2]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [d2, [h3, O2], [u2, f2]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [d2, [h3, O2], [u2, m2]], [/\b(poco[\w ]+)(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[d2, /_/g, " "], [h3, x2], [u2, m2]], [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[d2, /_/g, " "], [h3, x2], [u2, f2]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [d2, [h3, "OPPO"], [u2, m2]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [d2, [h3, "Vivo"], [u2, m2]], [/\b(rmx[12]\d{3})(?: bui|;|\))/i], [d2, [h3, "Realme"], [u2, m2]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [d2, [h3, P2], [u2, m2]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [d2, [h3, P2], [u2, f2]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [d2, [h3, N2], [u2, f2]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [d2, [h3, N2], [u2, m2]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [d2, [h3, "Lenovo"], [u2, f2]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[d2, /_/g, " "], [h3, "Nokia"], [u2, m2]], [/(pixel c)\b/i], [d2, [h3, w2], [u2, f2]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [d2, [h3, w2], [u2, m2]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [d2, [h3, U2], [u2, m2]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[d2, "Xperia Tablet"], [h3, U2], [u2, f2]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [d2, [h3, "OnePlus"], [u2, m2]], [/(alexa)webm/i, /(kf[a-z]{2}wi)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [d2, [h3, R2], [u2, f2]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[d2, /(.+)/g, "Fire Phone $1"], [h3, R2], [u2, m2]], [/(playbook);[-\w\),; ]+(rim)/i], [d2, h3, [u2, f2]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [d2, [h3, v2], [u2, m2]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [d2, [h3, I2], [u2, f2]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [d2, [h3, I2], [u2, m2]], [/(nexus 9)/i], [d2, [h3, "HTC"], [u2, f2]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [h3, [d2, /_/g, " "], [u2, m2]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [d2, [h3, "Acer"], [u2, f2]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [d2, [h3, "Meizu"], [u2, m2]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [h3, d2, [u2, m2]], [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [h3, d2, [u2, f2]], [/(surface duo)/i], [d2, [h3, D2], [u2, f2]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [d2, [h3, "Fairphone"], [u2, m2]], [/(u304aa)/i], [d2, [h3, "AT&T"], [u2, m2]], [/\bsie-(\w*)/i], [d2, [h3, "Siemens"], [u2, m2]], [/\b(rct\w+) b/i], [d2, [h3, "RCA"], [u2, f2]], [/\b(venue[\d ]{2,7}) b/i], [d2, [h3, "Dell"], [u2, f2]], [/\b(q(?:mv|ta)\w+) b/i], [d2, [h3, "Verizon"], [u2, f2]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [d2, [h3, "Barnes & Noble"], [u2, f2]], [/\b(tm\d{3}\w+) b/i], [d2, [h3, "NuVision"], [u2, f2]], [/\b(k88) b/i], [d2, [h3, "ZTE"], [u2, f2]], [/\b(nx\d{3}j) b/i], [d2, [h3, "ZTE"], [u2, m2]], [/\b(gen\d{3}) b.+49h/i], [d2, [h3, "Swiss"], [u2, m2]], [/\b(zur\d{3}) b/i], [d2, [h3, "Swiss"], [u2, f2]], [/\b((zeki)?tb.*\b) b/i], [d2, [h3, "Zeki"], [u2, f2]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[h3, "Dragon Touch"], d2, [u2, f2]], [/\b(ns-?\w{0,9}) b/i], [d2, [h3, "Insignia"], [u2, f2]], [/\b((nxa|next)-?\w{0,9}) b/i], [d2, [h3, "NextBook"], [u2, f2]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[h3, "Voice"], d2, [u2, m2]], [/\b(lvtel\-)?(v1[12]) b/i], [[h3, "LvTel"], d2, [u2, m2]], [/\b(ph-1) /i], [d2, [h3, "Essential"], [u2, m2]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [d2, [h3, "Envizen"], [u2, f2]], [/\b(trio[-\w\. ]+) b/i], [d2, [h3, "MachSpeed"], [u2, f2]], [/\btu_(1491) b/i], [d2, [h3, "Rotor"], [u2, f2]], [/(shield[\w ]+) b/i], [d2, [h3, "Nvidia"], [u2, f2]], [/(sprint) (\w+)/i], [h3, d2, [u2, m2]], [/(kin\.[onetw]{3})/i], [[d2, /\./g, " "], [h3, D2], [u2, m2]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [d2, [h3, V2], [u2, f2]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [d2, [h3, V2], [u2, m2]], [/smart-tv.+(samsung)/i], [h3, [u2, g2]], [/hbbtv.+maple;(\d+)/i], [[d2, /^/, "SmartTV"], [h3, k2], [u2, g2]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[h3, N2], [u2, g2]], [/(apple) ?tv/i], [h3, [d2, C2 + " TV"], [u2, g2]], [/crkey/i], [[d2, A2 + "cast"], [h3, w2], [u2, g2]], [/droid.+aft(\w)( bui|\))/i], [d2, [h3, R2], [u2, g2]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [d2, [h3, M2], [u2, g2]], [/(bravia[\w ]+)( bui|\))/i], [d2, [h3, U2], [u2, g2]], [/(mitv-\w{5}) bui/i], [d2, [h3, x2], [u2, g2]], [/Hbbtv.*(technisat) (.*);/i], [h3, d2, [u2, g2]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[h3, K2], [d2, K2], [u2, g2]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[u2, g2]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [h3, d2, [u2, E2]], [/droid.+; (shield) bui/i], [d2, [h3, "Nvidia"], [u2, E2]], [/(playstation [345portablevi]+)/i], [d2, [h3, U2], [u2, E2]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [d2, [h3, D2], [u2, E2]], [/((pebble))app/i], [h3, d2, [u2, T2]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [d2, [h3, C2], [u2, T2]], [/droid.+; (glass) \d/i], [d2, [h3, w2], [u2, T2]], [/droid.+; (wt63?0{2,3})\)/i], [d2, [h3, V2], [u2, T2]], [/(quest( 2| pro)?)/i], [d2, [h3, F2], [u2, T2]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [h3, [u2, S2]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i], [d2, [u2, m2]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [d2, [u2, f2]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[u2, f2]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[u2, m2]], [/(android[-\w\. ]{0,9});.+buil/i], [d2, [h3, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [p2, [l2, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [p2, [l2, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i], [l2, p2], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [p2, l2]], os: [[/microsoft (windows) (vista|xp)/i], [l2, p2], [/(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i], [l2, [p2, q2, z2]], [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[l2, "Windows"], [p2, q2, z2]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /cfnetwork\/.+darwin/i], [[p2, /_/g, "."], [l2, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[l2, j2], [p2, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [p2, l2], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [l2, p2], [/\(bb(10);/i], [p2, [l2, v2]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [p2, [l2, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [p2, [l2, b2 + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [p2, [l2, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [p2, [l2, "watchOS"]], [/crkey\/([\d\.]+)/i], [p2, [l2, A2 + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[l2, B2], p2], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [l2, p2], [/(sunos) ?([\w\.\d]*)/i], [[l2, "Solaris"], p2], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i, /(unix) ?([\w\.]*)/i], [l2, p2]] }, X2 = function(e3, i3) {
            if (typeof e3 === o2 && (i3 = e3, e3 = n2), !(this instanceof X2)) return new X2(e3, i3).getResult();
            var E3 = typeof t2 !== s2 && t2.navigator ? t2.navigator : n2, g3 = e3 || (E3 && E3.userAgent ? E3.userAgent : ""), T3 = E3 && E3.userAgentData ? E3.userAgentData : n2, S3 = i3 ? function(e4, t3) {
              var i4 = {};
              for (var n3 in e4) t3[n3] && t3[n3].length % 2 == 0 ? i4[n3] = t3[n3].concat(e4[n3]) : i4[n3] = e4[n3];
              return i4;
            }(J2, i3) : J2;
            return this.getBrowser = function() {
              var e4 = {};
              return e4[l2] = n2, e4[p2] = n2, Y2.call(e4, g3, S3.browser), e4[c2] = function(e5) {
                return typeof e5 === a2 ? e5.replace(/[^\d\.]/g, "").split(".")[0] : n2;
              }(e4[p2]), E3 && E3.brave && typeof E3.brave.isBrave == r2 && (e4[l2] = "Brave"), e4;
            }, this.getCPU = function() {
              var e4 = {};
              return e4[_2] = n2, Y2.call(e4, g3, S3.cpu), e4;
            }, this.getDevice = function() {
              var e4 = {};
              return e4[h3] = n2, e4[d2] = n2, e4[u2] = n2, Y2.call(e4, g3, S3.device), !e4[u2] && T3 && T3.mobile && (e4[u2] = m2), "Macintosh" == e4[d2] && E3 && typeof E3.standalone !== s2 && E3.maxTouchPoints && E3.maxTouchPoints > 2 && (e4[d2] = "iPad", e4[u2] = f2), e4;
            }, this.getEngine = function() {
              var e4 = {};
              return e4[l2] = n2, e4[p2] = n2, Y2.call(e4, g3, S3.engine), e4;
            }, this.getOS = function() {
              var e4 = {};
              return e4[l2] = n2, e4[p2] = n2, Y2.call(e4, g3, S3.os), !e4[l2] && T3 && "Unknown" != T3.platform && (e4[l2] = T3.platform.replace(/chrome os/i, B2).replace(/macos/i, j2)), e4;
            }, this.getResult = function() {
              return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
            }, this.getUA = function() {
              return g3;
            }, this.setUA = function(e4) {
              return g3 = typeof e4 === a2 && e4.length > 350 ? K2(e4, 350) : e4, this;
            }, this.setUA(g3), this;
          };
          X2.VERSION = "0.7.34", X2.BROWSER = G2([l2, p2, c2]), X2.CPU = G2([_2]), X2.DEVICE = G2([d2, h3, u2, E2, m2, g2, f2, T2, S2]), X2.ENGINE = X2.OS = G2([l2, p2]), e2.exports && (i2 = e2.exports = X2), i2.UAParser = X2;
          var Q2 = typeof t2 !== s2 && (t2.jQuery || t2.Zepto);
          if (Q2 && !Q2.ua) {
            var Z2 = new X2();
            Q2.ua = Z2.getResult(), Q2.ua.get = function() {
              return Z2.getUA();
            }, Q2.ua.set = function(e3) {
              Z2.setUA(e3);
              var t3 = Z2.getResult();
              for (var i3 in t3) Q2.ua[i3] = t3[i3];
            };
          }
        }("object" == typeof window ? window : t);
      }(mg, mg.exports);
      const fg = new (i(mg.exports))();
      let gg = fg.getResult(), Tg = null;
      function Sg(e2) {
        if (!Tg) {
          e2 && fg.setUA(e2), gg = fg.getResult();
          const t2 = function(e3) {
            if ("Blink" === e3.engine.name && "WeChat" !== e3.browser.name) return Eg.CHROME;
            switch (e3.browser.name) {
              case "Chrome Headless":
              case "Chrome":
              case "Chromium":
                return Eg.CHROME;
              case "Safari":
              case "Mobile Safari":
                return Eg.SAFARI;
              case "Edge":
                return Eg.EDGE;
              case "Firefox":
                return Eg.FIREFOX;
              case "QQBrowser":
                return Eg.QQ;
              case "Opera":
                return Eg.OPERA;
              case "WeChat":
                return Eg.WECHAT;
              default:
                return e3.browser.name || "";
            }
          }(gg), i2 = function(e3) {
            let t3;
            t3 = "Blink" === e3.engine.name ? e3.engine.version || "" : e3.browser.version || "";
            return t3.split(".")[0];
          }(gg), n2 = function(e3) {
            if ("Windows" === e3.os.name) return e3.os.version ? e3.os.name + " " + e3.os.version : e3.os.name;
            return e3.os.name || "";
          }(gg), r2 = gg.os.version;
          if (!(t2 && i2 && n2 && r2)) return { name: t2, version: i2, os: n2, osVersion: r2 };
          Tg = { name: t2, version: i2, os: n2, osVersion: r2 };
        }
        return Tg;
      }
      function Rg() {
        return Sg().os;
      }
      function Cg() {
        const e2 = Sg();
        return "".concat(e2.os, " ").concat(e2.osVersion);
      }
      function Ig() {
        const e2 = Sg();
        return !!("WebKit" === gg.engine.name && e2.os === _g.MAC_OS && navigator.maxTouchPoints && navigator.maxTouchPoints > 0 && e2.name !== Eg.SAFARI || Og() && e2.name !== Eg.SAFARI);
      }
      function vg() {
        const e2 = Sg();
        if (Ig()) {
          if (e2.os === _g.MAC_OS) return true;
          if (e2.os === _g.IOS) {
            const e3 = gg.os.version && gg.os.version.split(".");
            if (e3 && 14 === Number(e3[0]) && e3[1] && Number(e3[1]) >= 3) return true;
            if (e3 && Number(e3[0]) > 14) return true;
          }
        }
        return false;
      }
      function yg() {
        return "WebKit" === gg.engine.name;
      }
      function Ag() {
        return Sg().name === Eg.CHROME;
      }
      function bg() {
        return Sg().name === Eg.SAFARI;
      }
      function wg() {
        return Sg().name === Eg.FIREFOX;
      }
      function Og() {
        return Sg().os === _g.IOS;
      }
      function Ng(e2) {
        const t2 = Sg();
        return !(t2.name !== Eg.CHROME || !t2.osVersion) && Number(t2.version) >= e2;
      }
      function Dg(e2) {
        const t2 = Sg();
        return !(t2.name !== Eg.EDGE || !t2.osVersion) && Number(t2.version) >= e2;
      }
      function Pg(e2) {
        const t2 = Sg();
        return !(t2.name !== Eg.OPERA || !t2.osVersion) && Number(t2.version) >= e2;
      }
      function Lg() {
        const e2 = Sg();
        return !(e2.name !== Eg.CHROME || !e2.osVersion) && Number(e2.version) <= 90;
      }
      function kg() {
        const e2 = Sg();
        if (e2.os !== _g.IOS || !e2.osVersion) return false;
        const t2 = e2.osVersion.split(".");
        return Number(t2[0]) < 14 || 14 === Number(t2[0]) && Number(t2[1]) <= 6;
      }
      function Mg() {
        const e2 = Sg();
        if (e2.os !== _g.IOS || !e2.osVersion) return false;
        const t2 = e2.osVersion.split(".");
        return 15 === Number(t2[0]);
      }
      function Ug() {
        const e2 = Sg();
        if (e2.os !== _g.IOS || !e2.osVersion) return false;
        const t2 = e2.osVersion.split(".");
        return 16 === Number(t2[0]);
      }
      function xg() {
        const e2 = Sg();
        if (e2.os !== _g.IOS || !e2.osVersion) return false;
        const t2 = e2.osVersion.split(".");
        return 15 === Number(t2[0]) && Number(t2[1]) >= 1;
      }
      function Vg() {
        return bg() && navigator.maxTouchPoints > 0;
      }
      function Fg() {
        return Sg().name === Eg.WECHAT;
      }
      function Bg() {
        return window.navigator.appVersion && null !== window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./) && window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1] <= 35;
      }
      function jg() {
        const e2 = Sg();
        if (e2.name === Eg.EDGE || e2.name === Eg.SAFARI) return false;
        return !!navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]./i);
      }
      function Gg() {
        return Rg() === _g.ANDROID;
      }
      function Wg() {
        const e2 = Sg();
        return Gg() && (e2.name === Eg.CHROME || e2.name === Eg.WECHAT || /chrome|chromium/i.test(navigator.userAgent));
      }
      var Hg;
      !function(e2) {
        e2.UNEXPECTED_ERROR = "UNEXPECTED_ERROR", e2.UNEXPECTED_RESPONSE = "UNEXPECTED_RESPONSE", e2.TIMEOUT = "TIMEOUT", e2.INVALID_PARAMS = "INVALID_PARAMS", e2.NOT_READABLE = "NOT_READABLE", e2.NOT_SUPPORTED = "NOT_SUPPORTED", e2.INVALID_OPERATION = "INVALID_OPERATION", e2.OPERATION_ABORTED = "OPERATION_ABORTED", e2.WEB_SECURITY_RESTRICT = "WEB_SECURITY_RESTRICT", e2.EXCHANGE_SDP_FAILED = "EXCHANGE_SDP_FAILED", e2.ADD_CANDIDATE_FAILED = "ADD_CANDIDATE_FAILED", e2.DATACHANNEL_FAILED = "DATACHANNEL_FAILED", e2.NETWORK_ERROR = "NETWORK_ERROR", e2.NETWORK_TIMEOUT = "NETWORK_TIMEOUT", e2.NETWORK_RESPONSE_ERROR = "NETWORK_RESPONSE_ERROR", e2.API_INVOKE_TIMEOUT = "API_INVOKE_TIMEOUT", e2.ENUMERATE_DEVICES_FAILED = "ENUMERATE_DEVICES_FAILED", e2.DEVICE_NOT_FOUND = "DEVICE_NOT_FOUND", e2.ELECTRON_IS_NULL = "ELECTRON_IS_NULL", e2.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR = "ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR", e2.CHROME_PLUGIN_NO_RESPONSE = "CHROME_PLUGIN_NO_RESPONSE", e2.CHROME_PLUGIN_NOT_INSTALL = "CHROME_PLUGIN_NOT_INSTALL", e2.MEDIA_OPTION_INVALID = "MEDIA_OPTION_INVALID", e2.PERMISSION_DENIED = "PERMISSION_DENIED", e2.CONSTRAINT_NOT_SATISFIED = "CONSTRAINT_NOT_SATISFIED", e2.TRACK_IS_DISABLED = "TRACK_IS_DISABLED", e2.GET_VIDEO_ELEMENT_VISIBLE_ERROR = "GET_VIDEO_ELEMENT_VISIBLE_ERROR", e2.SHARE_AUDIO_NOT_ALLOWED = "SHARE_AUDIO_NOT_ALLOWED", e2.LOW_STREAM_ENCODING_ERROR = "LOW_STREAM_ENCODING_ERROR", e2.SET_ENCODING_PARAMETER_ERROR = "SET_ENCODING_PARAMETER_ERROR", e2.TRACK_STATE_UNREACHABLE = "TRACK_STATE_UNREACHABLE", e2.INVALID_UINT_UID_FROM_STRING_UID = "INVALID_UINT_UID_FROM_STRING_UID", e2.CAN_NOT_GET_PROXY_SERVER = "CAN_NOT_GET_PROXY_SERVER", e2.CAN_NOT_GET_GATEWAY_SERVER = "CAN_NOT_GET_GATEWAY_SERVER", e2.VOID_GATEWAY_ADDRESS = "VOID_GATEWAY_ADDRESS", e2.UID_CONFLICT = "UID_CONFLICT", e2.MULTI_UNILBS_RESPONSE_ERROR = "MULTI_UNILBS_RESPONSE_ERROR", e2.UPDATE_TICKET_FAILED = "UPDATE_TICKET_FAILED", e2.INVALID_LOCAL_TRACK = "INVALID_LOCAL_TRACK", e2.INVALID_TRACK = "INVALID_TRACK", e2.SENDER_NOT_FOUND = "SENDER_NOT_FOUND", e2.CREATE_OFFER_FAILED = "CREATE_OFFER_FAILED", e2.SET_ANSWER_FAILED = "SET_ANSWER_FAILED", e2.ICE_FAILED = "ICE_FAILED", e2.PC_CLOSED = "PC_CLOSED", e2.SENDER_REPLACE_FAILED = "SENDER_REPLACE_FAILED", e2.GET_LOCAL_CAPABILITIES_FAILED = "GET_LOCAL_CAPABILITIES_FAILED", e2.GET_LOCAL_CONNECTION_PARAMS_FAILED = "GET_LOCAL_CONNECTION_PARAMS_FAILED", e2.SUBSCRIBE_FAILED = "SUBSCRIBE_FAILED", e2.UNSUBSCRIBE_FAILED = "UNSUBSCRIBE_FAILED", e2.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST", e2.NO_ICE_CANDIDATE = "NO_ICE_CANDIDATE", e2.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS = "CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS", e2.EXIST_DISABLED_VIDEO_TRACK = "EXIST_DISABLED_VIDEO_TRACK", e2.INVALID_REMOTE_USER = "INVALID_REMOTE_USER", e2.REMOTE_USER_IS_NOT_PUBLISHED = "REMOTE_USER_IS_NOT_PUBLISHED", e2.CUSTOM_REPORT_SEND_FAILED = "CUSTOM_REPORT_SEND_FAILED", e2.CUSTOM_REPORT_FREQUENCY_TOO_HIGH = "CUSTOM_REPORT_FREQUENCY_TOO_HIGH", e2.FETCH_AUDIO_FILE_FAILED = "FETCH_AUDIO_FILE_FAILED", e2.READ_LOCAL_AUDIO_FILE_ERROR = "READ_LOCAL_AUDIO_FILE_ERROR", e2.DECODE_AUDIO_FILE_FAILED = "DECODE_AUDIO_FILE_FAILED", e2.WS_ABORT = "WS_ABORT", e2.WS_DISCONNECT = "WS_DISCONNECT", e2.WS_ERR = "WS_ERR", e2.EXTERNAL_SIGNAL_ABORT = "EXTERNAL_SIGNAL_ABORT", e2.LIVE_STREAMING_TASK_CONFLICT = "LIVE_STREAMING_TASK_CONFLICT", e2.LIVE_STREAMING_INVALID_ARGUMENT = "LIVE_STREAMING_INVALID_ARGUMENT", e2.LIVE_STREAMING_INTERNAL_SERVER_ERROR = "LIVE_STREAMING_INTERNAL_SERVER_ERROR", e2.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED = "LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED", e2.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED = "LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED", e2.LIVE_STREAMING_CDN_ERROR = "LIVE_STREAMING_CDN_ERROR", e2.LIVE_STREAMING_INVALID_RAW_STREAM = "LIVE_STREAMING_INVALID_RAW_STREAM", e2.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT = "LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT", e2.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE = "LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE", e2.LIVE_STREAMING_WARN_FREQUENT_REQUEST = "LIVE_STREAMING_WARN_FREQUENT_REQUEST", e2.WEBGL_INTERNAL_ERROR = "WEBGL_INTERNAL_ERROR", e2.BEAUTY_PROCESSOR_INTERNAL_ERROR = "BEAUTY_PROCESSOR_INTERNAL_ERROR", e2.CROSS_CHANNEL_WAIT_STATUS_ERROR = "CROSS_CHANNEL_WAIT_STATUS_ERROR", e2.CROSS_CHANNEL_FAILED_JOIN_SRC = "CROSS_CHANNEL_FAILED_JOIN_SEC", e2.CROSS_CHANNEL_FAILED_JOIN_DEST = "CROSS_CHANNEL_FAILED_JOIN_DEST", e2.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST = "CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST", e2.CROSS_CHANNEL_SERVER_ERROR_RESPONSE = "CROSS_CHANNEL_SERVER_ERROR_RESPONSE", e2.METADATA_OUT_OF_RANGE = "METADATA_OUT_OF_RANGE", e2.LOCAL_AEC_ERROR = "LOCAL_AEC_ERROR", e2.INVALID_PLUGIN = "INVALID_PLUGIN", e2.DISCONNECT_P2P = "DISCONNECT_P2P", e2.INIT_WEBSOCKET_TIMEOUT = "INIT_WEBSOCKET_TIMEOUT", e2.CONVERTING_IMAGEDATA_TO_BLOB_FAILED = "CONVERTING_IMAGEDATA_TO_BLOB_FAILED", e2.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED = "CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED", e2.INIT_DATACHANNEL_TIMEOUT = "INIT_DATACHANNEL_TIMEOUT", e2.CREATE_DATACHANNEL_ERROR = "CREATE_DATACHANNEL_ERROR", e2.DATACHANNEL_CONNECTION_TIMEOUT = "DATACHANNEL_CONNECTION_TIMEOUT", e2.PROHIBITED_OPERATION = "PROHIBITED_OPERATION", e2.IMAGE_MODERATION_UPLOAD_FAILED = "IMAGE_MODERATION_UPLOAD_FAILED", e2.P2P_MESSAGE_FAILED = "P2P_MESSAGE_FAILED";
      }(Hg || (Hg = {}));
      let Kg = class extends Error {
        constructor(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", i2 = arguments.length > 2 ? arguments[2] : void 0;
          super(t2), sh(this, "code", void 0), sh(this, "message", void 0), sh(this, "data", void 0), sh(this, "name", "AgoraRTCException"), this.code = e2, this.message = "AgoraRTCError ".concat(this.code, ": ").concat(t2), this.data = i2;
        }
        toString() {
          return this.data ? "data: ".concat(JSON.stringify(this.data), "\n").concat(this.stack) : "".concat(this.stack);
        }
        print() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "error", t2 = arguments.length > 1 ? arguments[1] : void 0;
          return "error" === e2 && (t2 || console).error(this.toString()), "warning" === e2 && (t2 || console).warn(this.toString()), this;
        }
        throw(e2) {
          throw this.print("error", e2), this;
        }
      };
      function Yg(e2, t2) {
        if ("boolean" != typeof e2) throw new Kg(Hg.INVALID_PARAMS, "Invalid ".concat(t2, ": The value is of the boolean type."));
      }
      function qg(e2, t2, i2) {
        if (bn(i2).call(i2, e2)) return;
        throw new Kg(Hg.INVALID_PARAMS, "".concat(t2, " can only be set as ").concat(JSON.stringify(i2)));
      }
      function zg(e2, t2) {
        let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e4;
        if (e2 < i2 || e2 > n2 || (!(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]) && !function(e3) {
          return "number" == typeof e3 && e3 % 1 == 0;
        }(e2)) {
          throw new Kg(Hg.INVALID_PARAMS, "invalid ".concat(t2, ": the value range is [").concat(i2, ", ").concat(n2, "]. integer only"));
        }
      }
      function Jg(e2, t2) {
        if ("number" != typeof e2) {
          if (!(e2.min || e2.max || e2.ideal || e2.exact)) {
            throw new Kg(Hg.INVALID_PARAMS, "".concat(t2, " is not a valid ConstrainLong"));
          }
          void 0 !== e2.min && zg(e2.min, "".concat(t2, ".min"), 0, 1 / 0), void 0 !== e2.max && zg(e2.max, "".concat(t2, ".max"), 1, 1 / 0), void 0 !== e2.exact && zg(e2.exact, "".concat(t2, ".exact"), 1, 1 / 0), void 0 !== e2.ideal && zg(e2.ideal, "".concat(t2, ".ideal"), 1, 1 / 0);
        } else zg(e2, t2, 1, 1 / 0);
      }
      function Xg(e2, t2) {
        let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 255, r2 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
        if (null == e2) throw new Kg(Hg.INVALID_PARAMS, "".concat(t2 || "param", " cannot be empty"));
        if (!$g(e2, i2, n2, r2)) throw new Kg(Hg.INVALID_PARAMS, "Invalid ".concat(t2 || "string param", ": Length of the string: [").concat(i2, ",").concat(n2, "].").concat(r2 ? " ASCII characters only." : ""));
      }
      function Qg(e2, t2) {
        if (!Array.isArray(e2)) throw new Kg(Hg.INVALID_PARAMS, "".concat(t2, " should be an array"));
      }
      function Zg(e2) {
        return null == e2;
      }
      function $g(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 255, n2 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
        return "string" == typeof e2 && e2.length <= i2 && e2.length >= t2 && (!n2 || function(e3) {
          if ("string" != typeof e3) return false;
          for (let t3 = 0; t3 < e3.length; t3 += 1) {
            const i3 = e3.charCodeAt(t3);
            if (i3 < 0 || i3 > 255) return false;
          }
          return true;
        }(e2));
      }
      function eT(e2, t2, i2) {
        if ("getBigUint64" in DataView.prototype) return e2.getBigUint64(t2, i2);
        const n2 = e2.getUint32(t2, i2), r2 = e2.getUint32(t2 + 4, i2), s2 = Number(!!i2), o2 = Number(!i2);
        return BigInt(n2 * o2 + r2 * s2) << BigInt(32) | BigInt(n2 * s2 + r2 * o2);
      }
      function tT(e2, t2, i2, n2) {
        if ("setBigUint64" in DataView.prototype) return e2.setBigUint64(t2, i2, n2);
        const r2 = Number(i2 >> BigInt(32)), s2 = Number(i2 & BigInt(4294967295));
        n2 ? (e2.setUint32(t2 + 4, r2, n2), e2.setUint32(t2, s2, n2)) : (e2.setUint32(t2, r2, n2), e2.setUint32(t2 + 4, s2, n2));
      }
      var iT, nT;
      !function(e2) {
        e2.COVERED = "COVERED", e2.POSITION = "POSITION", e2.SIZE = "SIZE", e2.STYLE = "STYLE";
      }(iT || (iT = {})), function(e2) {
        e2.UNMOUNTED = "UNMOUNTED", e2.INVALID_HTML_ELEMENT = "INVALID_HTML_ELEMENT";
      }(nT || (nT = {}));
      const rT = new class {
        constructor() {
          sh(this, "_clientSize", null), sh(this, "getClientWidth", () => document.documentElement ? document.documentElement.clientWidth : document.body.clientWidth), sh(this, "getClientHeight", () => document.documentElement ? document.documentElement.clientHeight : document.body.clientHeight), sh(this, "getStyle", (e2) => window.getComputedStyle(e2, null)), sh(this, "checkCssVisibleProperty", (e2) => {
            var t2;
            let i2 = true;
            const n2 = this.getStyle(e2), { display: r2, visibility: s2, opacity: o2, filter: a2 } = n2;
            if (("none" === r2 || bn(t2 = ["hidden", "collapse"]).call(t2, s2) || Number(o2) < 0.1) && (i2 = false), !i2) return false;
            if (a2) {
              a2.split(" ").filter((e3) => {
                var t3;
                const i3 = e3.split("(")[0];
                return bn(t3 = ["brightness", "blur", "opacity"]).call(t3, i3);
              }).map((e3) => {
                const [t3, i3] = e3.split(/\(|\)/);
                return [t3, Number(i3.match(/^[0-9\.]+/))];
              }).forEach((e3) => {
                const [t3, n3] = e3;
                switch (t3) {
                  case "brightness":
                    (n3 < 0.1 || n3 > 3) && (i2 = false);
                    break;
                  case "blur":
                    n3 > 3 && (i2 = false);
                    break;
                  case "opacity":
                    n3 < 0.1 && (i2 = false);
                }
              });
            }
            return i2;
          }), sh(this, "checkPropertyUpToAllParentNodes", (e2, t2) => {
            let i2 = true, n2 = true;
            const r2 = (e3) => t2(e3);
            let s2 = e2;
            for (; s2 && n2; ) {
              r2(s2) || (i2 = false, n2 = false), s2 = s2.parentElement, s2 || (n2 = false);
            }
            return i2;
          }), sh(this, "checkActualCssVisibleIncludeInherit", (e2) => this.checkPropertyUpToAllParentNodes(e2, this.checkCssVisibleProperty)), sh(this, "getSizeAboutClient", (e2) => {
            const { width: t2, height: i2, left: n2, right: r2, top: s2, bottom: o2 } = e2.getBoundingClientRect(), a2 = this.getClientWidth(), c2 = this.getClientHeight();
            return { width: t2, height: i2, left: n2, right: r2, top: s2, bottom: o2, clientWidth: a2, clientHeight: c2, clientMin: Math.min(a2, c2) };
          }), sh(this, "checkActualSize", () => {
            const { width: e2, height: t2, clientMin: i2 } = this._clientSize;
            return this.checkSizeIsVisible(e2, t2, i2);
          }), sh(this, "elementFromPoint", (e2, t2) => document.elementFromPoint ? document.elementFromPoint(e2, t2) : null), sh(this, "checkCoverForAPoint", (e2, t2, i2) => {
            const n2 = this.elementFromPoint(e2, t2);
            return null !== n2 && n2 !== i2;
          }), sh(this, "getPointPositionList", () => {
            const { width: e2, height: t2, left: i2, top: n2 } = this._clientSize, r2 = e2 / 6, s2 = t2 / 6, o2 = [], a2 = 10 ** 6;
            for (let e3 = 0; e3 < 5; e3++) for (let t3 = 0; t3 < 5; t3++) {
              const c2 = (i2 * a2 + (0 === e3 ? 0.1 : 4 === e3 ? (r2 * e3 * a2 - 1e5) / a2 : r2 * e3) * a2) / a2, d2 = (n2 * a2 + (0 === t3 ? 0.1 : 4 === t3 ? (s2 * t3 * a2 - 1e5) / a2 : s2 * t3) * a2) / a2;
              o2.push({ x: c2, y: d2 });
            }
            return [...o2];
          }), sh(this, "checkElementCover", (e2) => this.getPointPositionList().map((t2) => this.checkCoverForAPoint(t2.x, t2.y, e2)).filter((e3) => !!e3).length > 6), sh(this, "checkSizeIsVisible", (e2, t2, i2) => (e2 > 50 || i2 / e2 <= 10) && (t2 > 50 || i2 / t2 <= 10)), sh(this, "checkSizeOfPartInClient", () => {
            const { left: e2, right: t2, top: i2, bottom: n2, clientHeight: r2, clientWidth: s2, clientMin: o2 } = this._clientSize;
            let a2, c2, d2, l2;
            if (e2 < 0) a2 = 0;
            else {
              if (!(e2 < s2)) return false;
              a2 = e2;
            }
            if (t2 < 0) return false;
            if (c2 = t2 < s2 ? t2 : s2, i2 < 0) d2 = 0;
            else {
              if (!(i2 < r2)) return false;
              d2 = i2;
            }
            if (n2 < 0) return false;
            l2 = n2 < r2 ? n2 : r2;
            const u2 = c2 - a2, h3 = l2 - d2;
            return this.checkSizeIsVisible(u2, h3, o2);
          }), sh(this, "returnHiddenResult", (e2) => (this._clientSize = null, { visible: false, reason: e2 })), sh(this, "checkOneElementVisible", (e2) => {
            if (e2 instanceof HTMLElement) {
              if (this.checkElementIsMountedOnDom(e2)) {
                if (this.checkActualCssVisibleIncludeInherit(e2)) {
                  if (this._clientSize = this.getSizeAboutClient(e2), this.checkElementCover(e2)) return this.returnHiddenResult(iT.COVERED);
                  {
                    const e3 = this.checkActualSize(), t2 = this.checkSizeOfPartInClient();
                    return e3 && !t2 ? this.returnHiddenResult(iT.POSITION) : e3 ? (this._clientSize = null, { visible: true }) : this.returnHiddenResult(iT.SIZE);
                  }
                }
                return this.returnHiddenResult(iT.STYLE);
              }
              return this.returnHiddenResult(nT.UNMOUNTED);
            }
            return this.returnHiddenResult(nT.INVALID_HTML_ELEMENT);
          }), sh(this, "checkElementIsMountedOnDom", (e2) => this.checkPropertyUpToAllParentNodes(e2, (e3) => "HTML" !== e3.nodeName.toUpperCase() ? null !== e3.parentElement : !!document.documentElement));
        }
      }();
      function sT(e2) {
        return new TextEncoder().encode(e2);
      }
      const oT = function(e2, t2) {
        const i2 = new Uint8Array(e2.byteLength + t2.byteLength);
        return i2.set(new Uint8Array(e2), 0), i2.set(new Uint8Array(t2), e2.byteLength), i2;
      };
      const aT = async (e2) => {
        const t2 = function(e3) {
          const t3 = window.atob(e3), i3 = new Uint8Array(new ArrayBuffer(t3.length));
          for (let e4 = 0; e4 < t3.length; e4 += 1) i3[e4] = t3.charCodeAt(e4);
          return i3;
        }("MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCMnXAHkKIGAM+x4N22gCI+Wyu\nSTM9ztkT3uYslTT2PuKmZfPzhH6kVdO7PTjGCOZnAsyb3oTtWat0KcxQ4jxvqQV+\nHvYl3iI1Yd4vl2c3qRMJPLtRDfNxa2Mcxgq7e9aEUibzdd0st+OJAy3tOj/Y0aVy\nxQiYDz3vqa6bP29adwIDAQAB"), i2 = await window.crypto.subtle.importKey("spki", t2, { name: "RSA-OAEP", hash: "SHA-256" }, true, ["encrypt"]), n2 = sT(e2), r2 = await window.crypto.subtle.encrypt({ name: "RSA-OAEP" }, i2, n2);
        return function(e3) {
          let t3 = "";
          for (let i3 = 0; i3 < e3.length; i3 += 1) t3 += String.fromCharCode(e3[i3]);
          return window.btoa(t3);
        }(new Uint8Array(r2));
      }, cT = async (e2) => function(e3, t2) {
        let i2 = "";
        return new Uint8Array(e3).forEach((e4) => {
          i2 += e4.toString(t2).padStart(2, "0");
        }), i2;
      }(await crypto.subtle.digest("SHA-256", sT(e2)), 16);
      class dT {
        constructor() {
          sh(this, "_events", {}), sh(this, "addListener", this.on);
        }
        getListeners(e2) {
          return this._events[e2] ? this._events[e2].map((e3) => e3.listener) : [];
        }
        on(e2, t2) {
          this._events[e2] || (this._events[e2] = []);
          const i2 = this._events[e2];
          -1 === this._indexOfListener(i2, t2) && i2.push({ listener: t2, once: false });
        }
        once(e2, t2) {
          this._events[e2] || (this._events[e2] = []);
          const i2 = this._events[e2];
          -1 === this._indexOfListener(i2, t2) && i2.push({ listener: t2, once: true });
        }
        off(e2, t2) {
          if (!this._events[e2]) return;
          const i2 = this._events[e2], n2 = this._indexOfListener(i2, t2);
          -1 !== n2 && i2.splice(n2, 1), 0 === this._events[e2].length && delete this._events[e2];
        }
        removeAllListeners(e2) {
          e2 ? delete this._events[e2] : this._events = {};
        }
        emit(e2) {
          this._events[e2] || (this._events[e2] = []);
          const t2 = this._events[e2].map((e3) => e3);
          for (var i2 = arguments.length, n2 = new Array(i2 > 1 ? i2 - 1 : 0), r2 = 1; r2 < i2; r2++) n2[r2 - 1] = arguments[r2];
          for (let i3 = 0; i3 < t2.length; i3 += 1) {
            const r3 = t2[i3];
            r3.once && this.off(e2, r3.listener), r3.listener.apply(this, n2 || []);
          }
        }
        safeEmit(e2) {
          for (var t2 = arguments.length, i2 = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++) i2[n2 - 1] = arguments[n2];
          [...this._events[e2] || []].forEach((t3) => {
            t3.once && this.off(e2, t3.listener);
            try {
              t3.listener.apply(this, i2);
            } catch (t4) {
              console.error("safeEmit event:".concat(e2, " error ").concat(null == t4 ? void 0 : t4.toString()));
            }
          });
        }
        _indexOfListener(e2, t2) {
          let i2 = e2.length;
          for (; i2--; ) if (e2[i2].listener === t2) return i2;
          return -1;
        }
      }
      let lT = null;
      function uT() {
        if (lT) return lT;
        if (window.electron) return lT = window.electron;
        if (!window.require) return null;
        try {
          return lT = window.require("electron"), lT;
        } catch (e2) {
          return null;
        }
      }
      var hT, pT, _T, ET, mT, fT, gT, TT;
      function ST(e2) {
        return zg(e2.timeout, "config.timeout", 0, 1e5), zg(e2.timeoutFactor, "config.timeoutFactor", 0, 100, false), zg(e2.maxRetryCount, "config.maxRetryConfig", 0, 1 / 0), zg(e2.maxRetryTimeout, "config.maxRetryTimeout", 0, 1 / 0), true;
      }
      function RT(e2) {
        if (!Array.isArray(e2) || e2.length < 1) return false;
        try {
          e2.forEach((e3) => {
            if (!e3.urls) throw Error();
          });
        } catch (e3) {
          return false;
        }
        return true;
      }
      function CT(e2) {
        return Xg(e2.turnServerURL, "turnServerURL"), Xg(e2.username, "username"), Xg(e2.password, "password"), e2.udpport && zg(e2.udpport, "udpport", 1, 99999, true), e2.forceturn && Yg(e2.forceturn, "forceturn"), e2.security && Yg(e2.security, "security"), e2.tcpport && zg(e2.tcpport, "tcpport", 1, 99999, true), true;
      }
      function IT(e2) {
        return void 0 !== e2.level && qg(e2.level, "level", [1, 2, 3]), void 0 !== e2.delay && zg(e2.delay, "delay", 0, 3e3, true), true;
      }
      function vT(e2, t2) {
        for (var i2 = arguments.length, n2 = new Array(i2 > 2 ? i2 - 2 : 0), r2 = 2; r2 < i2; r2++) n2[r2 - 2] = arguments[r2];
        return 0 === e2.getListeners(t2).length ? cg.reject(new Kg(Hg.UNEXPECTED_ERROR, "can not emit promise")) : new cg((i3, r3) => {
          e2.emit(t2, ...n2, i3, r3);
        });
      }
      function yT(e2, t2) {
        if (0 === e2.getListeners(t2).length) return cg.resolve();
        for (var i2 = arguments.length, n2 = new Array(i2 > 2 ? i2 - 2 : 0), r2 = 2; r2 < i2; r2++) n2[r2 - 2] = arguments[r2];
        return vT(e2, t2, ...n2);
      }
      function AT(e2, t2) {
        if (0 === e2.getListeners(t2).length) return null;
        for (var i2 = arguments.length, n2 = new Array(i2 > 2 ? i2 - 2 : 0), r2 = 2; r2 < i2; r2++) n2[r2 - 2] = arguments[r2];
        return bT(e2, t2, ...n2);
      }
      function bT(e2, t2) {
        let i2 = null, n2 = null;
        for (var r2 = arguments.length, s2 = new Array(r2 > 2 ? r2 - 2 : 0), o2 = 2; o2 < r2; o2++) s2[o2 - 2] = arguments[o2];
        if (e2.emit(t2, ...s2, (e3) => {
          i2 = e3;
        }, (e3) => {
          n2 = e3;
        }), null !== n2) throw n2;
        if (null === i2) throw new Kg(Hg.UNEXPECTED_ERROR, "handler is not sync");
        return i2;
      }
      !function(e2) {
        e2.CREATE_CLIENT = "createClient", e2.CHECK_SYSTEM_REQUIREMENTS = "checkSystemRequirements", e2.SET_AREA = "setArea", e2.CHECK_VIDEO_TRACK_IS_ACTIVE = "checkVideoTrackIsActive", e2.CHECK_AUDIO_TRACK_IS_ACTIVE = "checkAudioTrackIsActive", e2.CREATE_MIC_AUDIO_TRACK = "createMicrophoneAudioTrack", e2.CREATE_CUSTOM_AUDIO_TRACK = "createCustomAudioTrack", e2.CREATE_BUFFER_AUDIO_TRACK = "createBufferSourceAudioTrack", e2.CREATE_CAM_VIDEO_TRACK = "createCameraVideoTrack", e2.CREATE_CUSTOM_VIDEO_TRACK = "createCustomVideoTrack", e2.CREATE_MIC_AND_CAM_TRACKS = "createMicrophoneAndCameraTracks", e2.CREATE_SCREEN_VIDEO_TRACK = "createScreenVideoTrack", e2.SET_ENCRYPTION_CONFIG = "Client.setEncryptionConfig", e2.START_PROXY_SERVER = "Client.startProxyServer", e2.STOP_PROXY_SERVER = "Client.stopProxyServer", e2.SET_PROXY_SERVER = "Client.setProxyServer", e2.SET_TURN_SERVER = "Client.setTurnServer", e2.SET_CLIENT_ROLE = "Client.setClientRole", e2.SET_LOW_STREAM_PARAMETER = "Client.setLowStreamParameter", e2.ENABLE_DUAL_STREAM = "Client.enableDualStream", e2.DISABLE_DUAL_STREAM = "Client.disableDualStream", e2.JOIN = "Client.join", e2.LEAVE = "Client.leave", e2.PUBLISH = "Client.publish", e2.UNPUBLISH = "Client.unpublish", e2.SUBSCRIBE = "Client.subscribe", e2.MASS_SUBSCRIBE = "Client.massSubscribe", e2.MASS_UNSUBSCRIBE = "Client.massUnsubscribe", e2.UNSUBSCRIBE = "Client.unsubscribe", e2.RENEW_TOKEN = "Client.renewToken", e2.SET_REMOTE_VIDEO_STREAM_TYPE = "Client.setRemoteVideoStreamType", e2.SET_STREAM_FALLBACK_OPTION = "Client.setStreamFallbackOption", e2.ENABLE_AUDIO_VOLUME_INDICATOR = "Client.enableAudioVolumeIndicator", e2.SEND_CUSTOM_REPORT_MESSAGE = "Client.sendCustomReportMessage", e2.INSPECT_VIDEO_CONTENT = "Client.inspectVideoContent", e2.STOP_INSPECT_VIDEO_CONTENT = "Client.stopInspectVideoContent", e2.JOIN_FALLBACK_TO_PROXY = "Client._joinFallbackToProxy", e2.DATACHANNEL_FAILBACK = "Client._datachannelFailback", e2.ON_LIVE_STREAM_WARNING = "Client.onLiveStreamWarning", e2.ON_LIVE_STREAM_ERROR = "Client.onLiveStreamingError", e2.START_LIVE_STREAMING = "Client.startLiveStreaming", e2.SET_LIVE_TRANSCODING = "Client.setLiveTranscoding", e2.STOP_LIVE_STREAMING = "Client.stopLiveStreaming", e2.START_CHANNEL_MEDIA_RELAY = "Client.startChannelMediaRelay", e2.UPDATE_CHANNEL_MEDIA_RELAY = "Client.updateChannelMediaRelay", e2.STOP_CHANNEL_MEDIA_RELAY = "Client.stopChannelMediaRelay", e2.REQUEST_CONFIG_DISTRIBUTE = "_config-distribute-request", e2.SET_CONFIG_DISTRIBUTE = "_configDistribute", e2.LOCAL_TRACK_SET_MUTED = "LocalTrack.setMute", e2.LOCAL_AUDIO_TRACK_PLAY = "LocalAudioTrack.play", e2.LOCAL_AUDIO_TRACK_PLAY_IN_ELEMENT = "LocalAudioTrack.playInElement", e2.LOCAL_AUDIO_TRACK_STOP = "LocalAudioTrack.stop", e2.LOCAL_AUDIO_TRACK_SET_VOLUME = "LocalAudioTrack.setVolume", e2.MIC_AUDIO_TRACK_SET_DEVICE = "MicrophoneAudioTrack.setDevice", e2.BUFFER_AUDIO_TRACK_START = "BufferSourceAudioTrack.startProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_STOP = "BufferSourceAudioTrack.stopProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_PAUSE = "BufferSourceAudioTrack.pauseProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_RESUME = "BufferSourceAudioTrack.resumeProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_SEEK = "BufferSourceAudioTrack.seekAudioBuffer", e2.LOCAL_VIDEO_TRACK_PLAY = "LocalVideoTrack.play", e2.LOCAL_VIDEO_TRACK_STOP = "LocalVideoTrack.stop", e2.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE = "LocalVideoTrack.getVideoElementVisibleStatus", e2.LOCAL_VIDEO_TRACK_BEAUTY = "LocalVideoTrack.setBeautyEffect", e2.LOCAL_VIDEO_SEND_SEI_DATA = "LocalVideoTrack.sendSeiData", e2.CAM_VIDEO_TRACK_SET_DEVICE = "CameraVideoTrack.setDevice", e2.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG = "CameraVideoTrack.setEncoderConfiguration", e2.REMOTE_VIDEO_TRACK_PLAY = "RemoteVideoTrack.play", e2.REMOTE_VIDEO_TRACK_STOP = "RemoteVideoTrack.stop", e2.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE = "RemoteVideoTrack.getVideoElementVisibleStatus", e2.REMOTE_AUDIO_TRACK_PLAY = "RemoteAudioTrack.play", e2.REMOTE_AUDIO_TRACK_STOP = "RemoteAudioTrack.stop", e2.REMOTE_AUDIO_SET_VOLUME = "RemoteAudioTrack.setVolume", e2.REMOTE_AUDIO_SET_OUTPUT_DEVICE = "RemoteAudioTrack.setOutputDevice", e2.GET_MEDIA_STREAM_TRACK = "Track.getMediaStreamTrack", e2.STREAM_TYPE_CHANGE = "streamTypeChange", e2.CONNECTION_STATE_CHANGE = "connectionStateChange", e2.LOAD_CONFIG_FROM_LOCALSTORAGE = "loadConfigFromLocalStorage", e2.IMAGE_MODERATION_UPLOAD = "imageModerationUpload";
      }(hT || (hT = {})), function(e2) {
        e2.TRACER = "tracer";
      }(pT || (pT = {})), function(e2) {
        e2[e2.AUDIENCE_LEVEL_LOW_LATENCY = 1] = "AUDIENCE_LEVEL_LOW_LATENCY", e2[e2.AUDIENCE_LEVEL_ULTRA_LOW_LATENCY = 2] = "AUDIENCE_LEVEL_ULTRA_LOW_LATENCY", e2[e2.AUDIENCE_LEVEL_SYNC_LATENCY = 3] = "AUDIENCE_LEVEL_SYNC_LATENCY";
      }(_T || (_T = {})), function(e2) {
        e2.LEAVE = "LEAVE", e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.UID_BANNED = "UID_BANNED", e2.IP_BANNED = "IP_BANNED", e2.CHANNEL_BANNED = "CHANNEL_BANNED", e2.FALLBACK = "FALLBACK", e2.LICENSE_MISSING = "LICENSE_MISSING", e2.LICENSE_EXPIRED = "LICENSE_EXPIRED", e2.LICENSE_MINUTES_EXCEEDED = "LICENSE_MINUTES_EXCEEDED", e2.LICENSE_PERIOD_INVALID = "LICENSE_PERIOD_INVALID", e2.LICENSE_MULTIPLE_SDK_SERVICE = "LICENSE_MULTIPLE_SDK_SERVICE", e2.LICENSE_ILLEGAL = "LICENSE_ILLEGAL", e2.TOKEN_EXPIRE = "TOKEN_EXPIRE";
      }(ET || (ET = {})), function(e2) {
        e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.MEDIA_RECONNECT_START = "media-reconnect-start", e2.MEDIA_RECONNECT_END = "media-reconnect-end", e2.IS_USING_CLOUD_PROXY = "is-using-cloud-proxy", e2.USER_JOINED = "user-joined", e2.USER_LEAVED = "user-left", e2.USER_PUBLISHED = "user-published", e2.USER_UNPUBLISHED = "user-unpublished", e2.USER_INFO_UPDATED = "user-info-updated", e2.CLIENT_BANNED = "client-banned", e2.CHANNEL_MEDIA_RELAY_STATE = "channel-media-relay-state", e2.CHANNEL_MEDIA_RELAY_EVENT = "channel-media-relay-event", e2.VOLUME_INDICATOR = "volume-indicator", e2.CRYPT_ERROR = "crypt-error", e2.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "token-privilege-will-expire", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "token-privilege-did-expire", e2.NETWORK_QUALITY = "network-quality", e2.STREAM_TYPE_CHANGED = "stream-type-changed", e2.STREAM_FALLBACK = "stream-fallback", e2.RECEIVE_METADATA = "receive-metadata", e2.STREAM_MESSAGE = "stream-message", e2.LIVE_STREAMING_ERROR = "live-streaming-error", e2.LIVE_STREAMING_WARNING = "live-streaming-warning", e2.INJECT_STREAM_STATUS = "stream-inject-status", e2.EXCEPTION = "exception", e2.ERROR = "error", e2.P2P_LOST = "p2p_lost", e2.JOIN_FALLBACK_TO_PROXY = "join-fallback-to-proxy", e2.CHANNEL_FALLBACK_TO_WEBSOCKET = "channel-fallback-to-websocket", e2.MEDIA_CONNECTION_TYPE_CHANGE = "media-connection-type-change", e2.PUBLISHED_USER_LIST = "published-user-list", e2.CONTENT_INSPECT_CONNECTION_STATE_CHANGE = "content-inspect-connection-state-change", e2.CONTENT_INSPECT_ERROR = "content-inspect-error", e2.CONTENT_INSPECT_RESULT = "content-inspect-result", e2.IMAGE_MODERATION_CONNECTION_STATE_CHANGE = "image-moderation-connection-state-change";
      }(mT || (mT = {})), function(e2) {
        e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.MULTI_IP = "MULTI_IP", e2.TIMEOUT = "TIMEOUT", e2.OFFLINE = "OFFLINE", e2.LEAVE = "LEAVE", e2.P2P_FAILED = "P2P_FAILED", e2.FALLBACK = "FALLBACK";
      }(fT || (fT = {})), function(e2) {
        e2.ONLINE = "ONLINE", e2.OFFLINE = "OFFLINE";
      }(gT || (gT = {})), function(e2) {
        e2.NETWORK_STATE_CHANGE = "NETWORK_STATE_CHANGE", e2.ONLINE = "ONLINE", e2.OFFLINE = "OFFLINE";
      }(TT || (TT = {}));
      const wT = new class extends dT {
        set networkState(e2) {
          this.emit(TT.NETWORK_STATE_CHANGE, e2, this._networkState), e2 === gT.ONLINE ? this.emit(TT.ONLINE) : e2 === gT.OFFLINE && (this.onlineWaiter = new cg((e3) => {
            this.once(TT.ONLINE, () => {
              this.onlineWaiter = void 0, e3(gT.ONLINE);
            });
          }), this.emit(TT.OFFLINE)), this._networkState = e2;
        }
        get networkState() {
          return this._networkState;
        }
        get isOnline() {
          return this._networkState === gT.ONLINE;
        }
        constructor() {
          super(), sh(this, "_moduleName", "network-indicator"), sh(this, "_networkState", gT.ONLINE), sh(this, "onlineWaiter", void 0), window.addEventListener("online", () => {
            this.networkState = gT.ONLINE;
          }), window.addEventListener("offline", () => {
            this.networkState = gT.OFFLINE;
          });
        }
      }();
      var OT = De, NT = Je, DT = K, PT = Bi, LT = TypeError, kT = function(e2) {
        return function(t2, i2, n2, r2) {
          OT(i2);
          var s2 = NT(t2), o2 = DT(s2), a2 = PT(s2), c2 = e2 ? a2 - 1 : 0, d2 = e2 ? -1 : 1;
          if (n2 < 2) for (; ; ) {
            if (c2 in o2) {
              r2 = o2[c2], c2 += d2;
              break;
            }
            if (c2 += d2, e2 ? c2 < 0 : a2 <= c2) throw LT("Reduce of empty array with no initial value");
          }
          for (; e2 ? c2 >= 0 : a2 > c2; c2 += d2) c2 in o2 && (r2 = i2(r2, o2[c2], c2, s2));
          return r2;
        };
      }, MT = { left: kT(false), right: kT(true) }.left;
      wi({ target: "Array", proto: true, forced: !b_ && Ee > 79 && Ee < 83 || !Ih("reduce") }, { reduce: function(e2) {
        var t2 = arguments.length;
        return MT(this, e2, t2, t2 > 1 ? arguments[1] : void 0);
      } });
      var UT = zi("Array").reduce, xT = l, VT = UT, FT = Array.prototype, BT = i(function(e2) {
        var t2 = e2.reduce;
        return e2 === FT || xT(FT, e2) && t2 === FT.reduce ? VT : t2;
      });
      function jT(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function GT(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? jT(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : jT(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      function WT(e2, t2) {
        const i2 = e2.indexOf(t2);
        -1 !== i2 && e2.splice(i2, 1);
      }
      function HT(e2) {
        const t2 = [];
        return e2.forEach((e3) => {
          -1 === t2.indexOf(e3) && t2.push(e3);
        }), t2;
      }
      function KT(e2) {
        void 0 !== cg ? cg.resolve().then(e2) : setTimeout(e2, 0);
      }
      function YT(e2) {
        return JSON.parse(JSON.stringify(e2));
      }
      function qT(e2) {
        try {
          return YT(e2);
        } catch (t2) {
          return e2;
        }
      }
      const zT = {};
      function JT(e2, t2) {
        zT[t2] || (zT[t2] = true, e2());
      }
      function XT(e2) {
        const t2 = window.atob(e2), i2 = new Uint8Array(new ArrayBuffer(t2.length));
        for (let e3 = 0; e3 < t2.length; e3 += 1) i2[e3] = t2.charCodeAt(e3);
        return i2;
      }
      function QT(e2) {
        let t2 = "";
        for (let i2 = 0; i2 < e2.length; i2 += 1) t2 += String.fromCharCode(e2[i2]);
        return window.btoa(t2);
      }
      function ZT() {
        for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
        const n2 = BT(t2).call(t2, (e3, t3) => e3 + t3.length, 0), r2 = new Uint8Array(new ArrayBuffer(n2));
        let s2 = 0;
        return t2.forEach((e3) => {
          r2.set(e3, s2), s2 += e3.length;
        }), r2;
      }
      function $T(e2) {
        return window.TextEncoder ? new TextEncoder().encode(e2).length : e2.length;
      }
      function eS(e2) {
        let t2 = 0;
        return /DingTalk/i.test(navigator.userAgent) && e2.realFormData && (e2 = e2.realFormData), e2.forEach((e3) => {
          t2 += "string" == typeof e3 ? $T(e3) : e3.size;
        }), t2 + 138;
      }
      function tS(e2) {
        const t2 = new Kg(Hg.TIMEOUT, "timeout");
        return new cg((i2, n2) => {
          window.setTimeout(() => n2(t2), e2);
        });
      }
      function iS(e2) {
        return new cg((t2) => {
          window.setTimeout(t2, e2);
        });
      }
      function nS() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 7, t2 = arguments.length > 1 ? arguments[1] : void 0;
        const i2 = Math.random().toString(16).substr(2, e2).toLowerCase();
        return i2.length === e2 ? "".concat(t2).concat(i2) : "".concat(t2).concat(i2) + nS(e2 - i2.length, "");
      }
      function rS() {
        return nS(32, "").toUpperCase();
      }
      const sS = () => {
      };
      const oS = new class {
        constructor() {
          sh(this, "fnMap", /* @__PURE__ */ new Map());
        }
        throttleByKey(e2, t2, i2, n2) {
          for (var r2 = arguments.length, s2 = new Array(r2 > 4 ? r2 - 4 : 0), o2 = 4; o2 < r2; o2++) s2[o2 - 4] = arguments[o2];
          if (this.fnMap.has(t2)) {
            const r3 = this.fnMap.get(t2);
            if (r3.threshold !== i2) {
              r3.fn(...r3.args), clearTimeout(r3.timer);
              const o3 = window.setTimeout(() => {
                const e3 = this.fnMap.get(t2);
                e3 && e3.fn(...e3.args), this.fnMap.delete(t2);
              }, i2);
              this.fnMap.set(t2, { fn: e2, threshold: i2, timer: o3, args: s2, skipFn: n2 });
            } else r3.skipFn && r3.skipFn(...r3.args), this.fnMap.set(t2, GT(GT({}, r3), {}, { fn: e2, args: s2, skipFn: n2 }));
          } else {
            const r3 = window.setTimeout(() => {
              const e3 = this.fnMap.get(t2);
              e3 && e3.fn(...e3.args), this.fnMap.delete(t2);
            }, i2);
            this.fnMap.set(t2, { fn: e2, threshold: i2, timer: r3, args: s2, skipFn: n2 });
          }
        }
      }(), aS = oS.throttleByKey.bind(oS);
      function cS(e2) {
        return "object" == typeof e2 && null !== e2 && !(e2 instanceof RegExp);
      }
      function dS(e2, t2) {
        if (!cS(e2) || !cS(t2)) return t2;
        if (Array.isArray(e2) && !Array.isArray(t2) || !Array.isArray(e2) && Array.isArray(t2)) return t2;
        if (Array.isArray(t2) && Array.isArray(e2)) {
          const i2 = [...e2];
          for (let n2 = 0; n2 < t2.length; n2++) i2[n2] = dS(e2[n2], t2[n2]);
          return i2;
        }
        {
          const i2 = GT({}, e2);
          for (const n2 in t2) Object.prototype.hasOwnProperty.call(t2, n2) && (Object.prototype.hasOwnProperty.call(e2, n2) ? i2[n2] = dS(e2[n2], t2[n2]) : i2[n2] = t2[n2]);
          return i2;
        }
      }
      function lS(e2, t2) {
        let i2 = [0];
        if (t2 && (i2 = new Array(t2).fill(0)), 0 === e2) return i2;
        let n2 = 0;
        for (; e2 > 0 && (i2[n2] = 255 & e2, e2 >>= 8, n2++, !t2 || n2 !== t2); ) ;
        return i2;
      }
      let uS = 1, hS = console;
      class pS {
        static setLogger(e2) {
          hS = e2;
        }
        constructor(e2) {
          sh(this, "lockingPromise", cg.resolve()), sh(this, "locks", 0), sh(this, "name", ""), sh(this, "lockId", void 0), this.lockId = uS++, e2 && (this.name = e2), hS.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is created."));
        }
        get isLocked() {
          return this.locks > 0;
        }
        lock(e2) {
          let t2;
          this.locks += 1, hS.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is locked, current queue ").concat(this.locks, ". ").concat("string" == typeof e2 ? e2 : ""));
          const i2 = new cg((i3) => {
            t2 = () => {
              this.locks -= 1, hS.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is not locked, current queue ").concat(this.locks, ". ").concat("string" == typeof e2 ? e2 : "")), i3();
            };
          }), n2 = this.lockingPromise.then(() => t2);
          return this.lockingPromise = this.lockingPromise.then(() => i2), n2;
        }
      }
      function _S(e2, t2) {
        return function(i2, n2, r2) {
          const s2 = r2.value;
          if ("function" != typeof s2) throw new Error("Cannot use mutex on object property.");
          return r2.value = async function() {
            const i3 = this[t2];
            if (!i3) throw new Error("mutex property key ".concat(t2, " doesn't exist on ").concat(e2));
            const r3 = await i3.lock("From ".concat(e2, ".").concat(n2));
            try {
              for (var o2 = arguments.length, a2 = new Array(o2), c2 = 0; c2 < o2; c2++) a2[c2] = arguments[c2];
              return await s2.apply(this, a2);
            } finally {
              r3();
            }
          }, r2;
        };
      }
      const ES = { timeout: 500, timeoutFactor: 1.5, maxRetryCount: 1 / 0, maxRetryTimeout: 1e4 };
      function mS(e2, t2) {
        const i2 = Math.floor(t2.timeout * Math.pow(t2.timeoutFactor, e2));
        return Math.min(t2.maxRetryTimeout, i2);
      }
      function fS(e2, t2, i2, n2) {
        const r2 = Object.assign({}, ES, n2);
        let s2 = r2.timeout;
        const o2 = async () => {
          await function(e3) {
            return new cg((t3) => {
              window.setTimeout(t3, e3);
            });
          }(s2), s2 *= r2.timeoutFactor, s2 = Math.min(r2.maxRetryTimeout, s2);
        };
        let a2 = false;
        const c2 = new cg(async (n3, s3) => {
          t2 = t2 || (() => false), i2 = i2 || (() => true);
          for (let c3 = 0; c3 < r2.maxRetryCount; c3 += 1) {
            if (a2) return s3(new Kg(Hg.OPERATION_ABORTED));
            try {
              const i3 = await e2();
              if (!t2(i3, c3)) return n3(i3);
              if (c3 + 1 === r2.maxRetryCount) return n3(i3);
              await o2();
            } catch (e3) {
              if (!i2(e3, c3)) return s3(e3);
              if (c3 + 1 === r2.maxRetryCount) return s3(e3);
              await o2();
            }
          }
        });
        return c2.cancel = () => a2 = true, c2;
      }
      let gS = class {
        constructor(e2) {
          sh(this, "input", []), sh(this, "size", void 0), this.size = e2;
        }
        add(e2) {
          this.input.push(e2), this.input.length > this.size && this.input.splice(0, 1);
        }
        mean() {
          var e2;
          return 0 === this.input.length ? 0 : BT(e2 = this.input).call(e2, (e3, t2) => e3 + t2) / this.input.length;
        }
      };
      function TS(e2, t2) {
        return function() {
          return e2.apply(t2, arguments);
        };
      }
      const { toString: SS } = Object.prototype, { getPrototypeOf: RS } = Object, CS = (IS = /* @__PURE__ */ Object.create(null), (e2) => {
        const t2 = SS.call(e2);
        return IS[t2] || (IS[t2] = t2.slice(8, -1).toLowerCase());
      });
      var IS;
      const vS = (e2) => (e2 = e2.toLowerCase(), (t2) => CS(t2) === e2), yS = (e2) => (t2) => typeof t2 === e2, { isArray: AS } = Array, bS = yS("undefined");
      const wS = vS("ArrayBuffer");
      const OS = yS("string"), NS = yS("function"), DS = yS("number"), PS = (e2) => null !== e2 && "object" == typeof e2, LS = (e2) => {
        if ("object" !== CS(e2)) return false;
        const t2 = RS(e2);
        return !(null !== t2 && t2 !== Object.prototype && null !== Object.getPrototypeOf(t2) || Symbol.toStringTag in e2 || Symbol.iterator in e2);
      }, kS = vS("Date"), MS = vS("File"), US = vS("Blob"), xS = vS("FileList"), VS = vS("URLSearchParams");
      function FS(e2, t2, { allOwnKeys: i2 = false } = {}) {
        if (null == e2) return;
        let n2, r2;
        if ("object" != typeof e2 && (e2 = [e2]), AS(e2)) for (n2 = 0, r2 = e2.length; n2 < r2; n2++) t2.call(null, e2[n2], n2, e2);
        else {
          const r3 = i2 ? Object.getOwnPropertyNames(e2) : Object.keys(e2), s2 = r3.length;
          let o2;
          for (n2 = 0; n2 < s2; n2++) o2 = r3[n2], t2.call(null, e2[o2], o2, e2);
        }
      }
      function BS(e2, t2) {
        t2 = t2.toLowerCase();
        const i2 = Object.keys(e2);
        let n2, r2 = i2.length;
        for (; r2-- > 0; ) if (n2 = i2[r2], t2 === n2.toLowerCase()) return n2;
        return null;
      }
      const jS = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global, GS = (e2) => !bS(e2) && e2 !== jS;
      const WS = (HS = "undefined" != typeof Uint8Array && RS(Uint8Array), (e2) => HS && e2 instanceof HS);
      var HS;
      const KS = vS("HTMLFormElement"), YS = (({ hasOwnProperty: e2 }) => (t2, i2) => e2.call(t2, i2))(Object.prototype), qS = vS("RegExp"), zS = (e2, t2) => {
        const i2 = Object.getOwnPropertyDescriptors(e2), n2 = {};
        FS(i2, (i3, r2) => {
          let s2;
          false !== (s2 = t2(i3, r2, e2)) && (n2[r2] = s2 || i3);
        }), Object.defineProperties(e2, n2);
      }, JS = "abcdefghijklmnopqrstuvwxyz", XS = "0123456789", QS = { DIGIT: XS, ALPHA: JS, ALPHA_DIGIT: JS + JS.toUpperCase() + XS };
      const ZS = vS("AsyncFunction");
      var $S = { isArray: AS, isArrayBuffer: wS, isBuffer: function(e2) {
        return null !== e2 && !bS(e2) && null !== e2.constructor && !bS(e2.constructor) && NS(e2.constructor.isBuffer) && e2.constructor.isBuffer(e2);
      }, isFormData: (e2) => {
        let t2;
        return e2 && ("function" == typeof FormData && e2 instanceof FormData || NS(e2.append) && ("formdata" === (t2 = CS(e2)) || "object" === t2 && NS(e2.toString) && "[object FormData]" === e2.toString()));
      }, isArrayBufferView: function(e2) {
        let t2;
        return t2 = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e2) : e2 && e2.buffer && wS(e2.buffer), t2;
      }, isString: OS, isNumber: DS, isBoolean: (e2) => true === e2 || false === e2, isObject: PS, isPlainObject: LS, isUndefined: bS, isDate: kS, isFile: MS, isBlob: US, isRegExp: qS, isFunction: NS, isStream: (e2) => PS(e2) && NS(e2.pipe), isURLSearchParams: VS, isTypedArray: WS, isFileList: xS, forEach: FS, merge: function e2() {
        const { caseless: t2 } = GS(this) && this || {}, i2 = {}, n2 = (n3, r2) => {
          const s2 = t2 && BS(i2, r2) || r2;
          LS(i2[s2]) && LS(n3) ? i2[s2] = e2(i2[s2], n3) : LS(n3) ? i2[s2] = e2({}, n3) : AS(n3) ? i2[s2] = n3.slice() : i2[s2] = n3;
        };
        for (let e3 = 0, t3 = arguments.length; e3 < t3; e3++) arguments[e3] && FS(arguments[e3], n2);
        return i2;
      }, extend: (e2, t2, i2, { allOwnKeys: n2 } = {}) => (FS(t2, (t3, n3) => {
        i2 && NS(t3) ? e2[n3] = TS(t3, i2) : e2[n3] = t3;
      }, { allOwnKeys: n2 }), e2), trim: (e2) => e2.trim ? e2.trim() : e2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), stripBOM: (e2) => (65279 === e2.charCodeAt(0) && (e2 = e2.slice(1)), e2), inherits: (e2, t2, i2, n2) => {
        e2.prototype = Object.create(t2.prototype, n2), e2.prototype.constructor = e2, Object.defineProperty(e2, "super", { value: t2.prototype }), i2 && Object.assign(e2.prototype, i2);
      }, toFlatObject: (e2, t2, i2, n2) => {
        let r2, s2, o2;
        const a2 = {};
        if (t2 = t2 || {}, null == e2) return t2;
        do {
          for (r2 = Object.getOwnPropertyNames(e2), s2 = r2.length; s2-- > 0; ) o2 = r2[s2], n2 && !n2(o2, e2, t2) || a2[o2] || (t2[o2] = e2[o2], a2[o2] = true);
          e2 = false !== i2 && RS(e2);
        } while (e2 && (!i2 || i2(e2, t2)) && e2 !== Object.prototype);
        return t2;
      }, kindOf: CS, kindOfTest: vS, endsWith: (e2, t2, i2) => {
        e2 = String(e2), (void 0 === i2 || i2 > e2.length) && (i2 = e2.length), i2 -= t2.length;
        const n2 = e2.indexOf(t2, i2);
        return -1 !== n2 && n2 === i2;
      }, toArray: (e2) => {
        if (!e2) return null;
        if (AS(e2)) return e2;
        let t2 = e2.length;
        if (!DS(t2)) return null;
        const i2 = new Array(t2);
        for (; t2-- > 0; ) i2[t2] = e2[t2];
        return i2;
      }, forEachEntry: (e2, t2) => {
        const i2 = (e2 && e2[Symbol.iterator]).call(e2);
        let n2;
        for (; (n2 = i2.next()) && !n2.done; ) {
          const i3 = n2.value;
          t2.call(e2, i3[0], i3[1]);
        }
      }, matchAll: (e2, t2) => {
        let i2;
        const n2 = [];
        for (; null !== (i2 = e2.exec(t2)); ) n2.push(i2);
        return n2;
      }, isHTMLForm: KS, hasOwnProperty: YS, hasOwnProp: YS, reduceDescriptors: zS, freezeMethods: (e2) => {
        zS(e2, (t2, i2) => {
          if (NS(e2) && -1 !== ["arguments", "caller", "callee"].indexOf(i2)) return false;
          const n2 = e2[i2];
          NS(n2) && (t2.enumerable = false, "writable" in t2 ? t2.writable = false : t2.set || (t2.set = () => {
            throw Error("Can not rewrite read-only method '" + i2 + "'");
          }));
        });
      }, toObjectSet: (e2, t2) => {
        const i2 = {}, n2 = (e3) => {
          e3.forEach((e4) => {
            i2[e4] = true;
          });
        };
        return AS(e2) ? n2(e2) : n2(String(e2).split(t2)), i2;
      }, toCamelCase: (e2) => e2.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(e3, t2, i2) {
        return t2.toUpperCase() + i2;
      }), noop: () => {
      }, toFiniteNumber: (e2, t2) => (e2 = +e2, Number.isFinite(e2) ? e2 : t2), findKey: BS, global: jS, isContextDefined: GS, ALPHABET: QS, generateString: (e2 = 16, t2 = QS.ALPHA_DIGIT) => {
        let i2 = "";
        const { length: n2 } = t2;
        for (; e2--; ) i2 += t2[Math.random() * n2 | 0];
        return i2;
      }, isSpecCompliantForm: function(e2) {
        return !!(e2 && NS(e2.append) && "FormData" === e2[Symbol.toStringTag] && e2[Symbol.iterator]);
      }, toJSONObject: (e2) => {
        const t2 = new Array(10), i2 = (e3, n2) => {
          if (PS(e3)) {
            if (t2.indexOf(e3) >= 0) return;
            if (!("toJSON" in e3)) {
              t2[n2] = e3;
              const r2 = AS(e3) ? [] : {};
              return FS(e3, (e4, t3) => {
                const s2 = i2(e4, n2 + 1);
                !bS(s2) && (r2[t3] = s2);
              }), t2[n2] = void 0, r2;
            }
          }
          return e3;
        };
        return i2(e2, 0);
      }, isAsyncFn: ZS, isThenable: (e2) => e2 && (PS(e2) || NS(e2)) && NS(e2.then) && NS(e2.catch) };
      function eR(e2, t2, i2, n2, r2) {
        Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e2, this.name = "AxiosError", t2 && (this.code = t2), i2 && (this.config = i2), n2 && (this.request = n2), r2 && (this.response = r2);
      }
      $S.inherits(eR, Error, { toJSON: function() {
        return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: $S.toJSONObject(this.config), code: this.code, status: this.response && this.response.status ? this.response.status : null };
      } });
      const tR = eR.prototype, iR = {};
      ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((e2) => {
        iR[e2] = { value: e2 };
      }), Object.defineProperties(eR, iR), Object.defineProperty(tR, "isAxiosError", { value: true }), eR.from = (e2, t2, i2, n2, r2, s2) => {
        const o2 = Object.create(tR);
        return $S.toFlatObject(e2, o2, function(e3) {
          return e3 !== Error.prototype;
        }, (e3) => "isAxiosError" !== e3), eR.call(o2, e2.message, t2, i2, n2, r2), o2.cause = e2, o2.name = e2.name, s2 && Object.assign(o2, s2), o2;
      };
      function nR(e2) {
        return $S.isPlainObject(e2) || $S.isArray(e2);
      }
      function rR(e2) {
        return $S.endsWith(e2, "[]") ? e2.slice(0, -2) : e2;
      }
      function sR(e2, t2, i2) {
        return e2 ? e2.concat(t2).map(function(e3, t3) {
          return e3 = rR(e3), !i2 && t3 ? "[" + e3 + "]" : e3;
        }).join(i2 ? "." : "") : t2;
      }
      const oR = $S.toFlatObject($S, {}, null, function(e2) {
        return /^is[A-Z]/.test(e2);
      });
      function aR(e2, t2, i2) {
        if (!$S.isObject(e2)) throw new TypeError("target must be an object");
        t2 = t2 || new FormData();
        const n2 = (i2 = $S.toFlatObject(i2, { metaTokens: true, dots: false, indexes: false }, false, function(e3, t3) {
          return !$S.isUndefined(t3[e3]);
        })).metaTokens, r2 = i2.visitor || d2, s2 = i2.dots, o2 = i2.indexes, a2 = (i2.Blob || "undefined" != typeof Blob && Blob) && $S.isSpecCompliantForm(t2);
        if (!$S.isFunction(r2)) throw new TypeError("visitor must be a function");
        function c2(e3) {
          if (null === e3) return "";
          if ($S.isDate(e3)) return e3.toISOString();
          if (!a2 && $S.isBlob(e3)) throw new eR("Blob is not supported. Use a Buffer instead.");
          return $S.isArrayBuffer(e3) || $S.isTypedArray(e3) ? a2 && "function" == typeof Blob ? new Blob([e3]) : Buffer.from(e3) : e3;
        }
        function d2(e3, i3, r3) {
          let a3 = e3;
          if (e3 && !r3 && "object" == typeof e3) {
            if ($S.endsWith(i3, "{}")) i3 = n2 ? i3 : i3.slice(0, -2), e3 = JSON.stringify(e3);
            else if ($S.isArray(e3) && function(e4) {
              return $S.isArray(e4) && !e4.some(nR);
            }(e3) || ($S.isFileList(e3) || $S.endsWith(i3, "[]")) && (a3 = $S.toArray(e3))) return i3 = rR(i3), a3.forEach(function(e4, n3) {
              !$S.isUndefined(e4) && null !== e4 && t2.append(true === o2 ? sR([i3], n3, s2) : null === o2 ? i3 : i3 + "[]", c2(e4));
            }), false;
          }
          return !!nR(e3) || (t2.append(sR(r3, i3, s2), c2(e3)), false);
        }
        const l2 = [], u2 = Object.assign(oR, { defaultVisitor: d2, convertValue: c2, isVisitable: nR });
        if (!$S.isObject(e2)) throw new TypeError("data must be an object");
        return function e3(i3, n3) {
          if (!$S.isUndefined(i3)) {
            if (-1 !== l2.indexOf(i3)) throw Error("Circular reference detected in " + n3.join("."));
            l2.push(i3), $S.forEach(i3, function(i4, s3) {
              true === (!($S.isUndefined(i4) || null === i4) && r2.call(t2, i4, $S.isString(s3) ? s3.trim() : s3, n3, u2)) && e3(i4, n3 ? n3.concat(s3) : [s3]);
            }), l2.pop();
          }
        }(e2), t2;
      }
      function cR(e2) {
        const t2 = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" };
        return encodeURIComponent(e2).replace(/[!'()~]|%20|%00/g, function(e3) {
          return t2[e3];
        });
      }
      function dR(e2, t2) {
        this._pairs = [], e2 && aR(e2, this, t2);
      }
      const lR = dR.prototype;
      function uR(e2) {
        return encodeURIComponent(e2).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      function hR(e2, t2, i2) {
        if (!t2) return e2;
        const n2 = i2 && i2.encode || uR, r2 = i2 && i2.serialize;
        let s2;
        if (s2 = r2 ? r2(t2, i2) : $S.isURLSearchParams(t2) ? t2.toString() : new dR(t2, i2).toString(n2), s2) {
          const t3 = e2.indexOf("#");
          -1 !== t3 && (e2 = e2.slice(0, t3)), e2 += (-1 === e2.indexOf("?") ? "?" : "&") + s2;
        }
        return e2;
      }
      lR.append = function(e2, t2) {
        this._pairs.push([e2, t2]);
      }, lR.toString = function(e2) {
        const t2 = e2 ? function(t3) {
          return e2.call(this, t3, cR);
        } : cR;
        return this._pairs.map(function(e3) {
          return t2(e3[0]) + "=" + t2(e3[1]);
        }, "").join("&");
      };
      var pR = class {
        constructor() {
          this.handlers = [];
        }
        use(e2, t2, i2) {
          return this.handlers.push({ fulfilled: e2, rejected: t2, synchronous: !!i2 && i2.synchronous, runWhen: i2 ? i2.runWhen : null }), this.handlers.length - 1;
        }
        eject(e2) {
          this.handlers[e2] && (this.handlers[e2] = null);
        }
        clear() {
          this.handlers && (this.handlers = []);
        }
        forEach(e2) {
          $S.forEach(this.handlers, function(t2) {
            null !== t2 && e2(t2);
          });
        }
      }, _R = { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false }, ER = { isBrowser: true, classes: { URLSearchParams: "undefined" != typeof URLSearchParams ? URLSearchParams : dR, FormData: "undefined" != typeof FormData ? FormData : null, Blob: "undefined" != typeof Blob ? Blob : null }, protocols: ["http", "https", "file", "blob", "url", "data"] };
      const mR = "undefined" != typeof window && "undefined" != typeof document, fR = (gR = "undefined" != typeof navigator && navigator.product, mR && ["ReactNative", "NativeScript", "NS"].indexOf(gR) < 0);
      var gR;
      const TR = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts;
      var SR = { ...Object.freeze({ __proto__: null, hasBrowserEnv: mR, hasStandardBrowserEnv: fR, hasStandardBrowserWebWorkerEnv: TR }), ...ER };
      function RR(e2) {
        function t2(e3, i2, n2, r2) {
          let s2 = e3[r2++];
          if ("__proto__" === s2) return true;
          const o2 = Number.isFinite(+s2), a2 = r2 >= e3.length;
          if (s2 = !s2 && $S.isArray(n2) ? n2.length : s2, a2) return $S.hasOwnProp(n2, s2) ? n2[s2] = [n2[s2], i2] : n2[s2] = i2, !o2;
          n2[s2] && $S.isObject(n2[s2]) || (n2[s2] = []);
          return t2(e3, i2, n2[s2], r2) && $S.isArray(n2[s2]) && (n2[s2] = function(e4) {
            const t3 = {}, i3 = Object.keys(e4);
            let n3;
            const r3 = i3.length;
            let s3;
            for (n3 = 0; n3 < r3; n3++) s3 = i3[n3], t3[s3] = e4[s3];
            return t3;
          }(n2[s2])), !o2;
        }
        if ($S.isFormData(e2) && $S.isFunction(e2.entries)) {
          const i2 = {};
          return $S.forEachEntry(e2, (e3, n2) => {
            t2(function(e4) {
              return $S.matchAll(/\w+|\[(\w*)]/g, e4).map((e5) => "[]" === e5[0] ? "" : e5[1] || e5[0]);
            }(e3), n2, i2, 0);
          }), i2;
        }
        return null;
      }
      const CR = { transitional: _R, adapter: ["xhr", "http"], transformRequest: [function(e2, t2) {
        const i2 = t2.getContentType() || "", n2 = i2.indexOf("application/json") > -1, r2 = $S.isObject(e2);
        r2 && $S.isHTMLForm(e2) && (e2 = new FormData(e2));
        if ($S.isFormData(e2)) return n2 ? JSON.stringify(RR(e2)) : e2;
        if ($S.isArrayBuffer(e2) || $S.isBuffer(e2) || $S.isStream(e2) || $S.isFile(e2) || $S.isBlob(e2)) return e2;
        if ($S.isArrayBufferView(e2)) return e2.buffer;
        if ($S.isURLSearchParams(e2)) return t2.setContentType("application/x-www-form-urlencoded;charset=utf-8", false), e2.toString();
        let s2;
        if (r2) {
          if (i2.indexOf("application/x-www-form-urlencoded") > -1) return function(e3, t3) {
            return aR(e3, new SR.classes.URLSearchParams(), Object.assign({ visitor: function(e4, t4, i3, n3) {
              return SR.isNode && $S.isBuffer(e4) ? (this.append(t4, e4.toString("base64")), false) : n3.defaultVisitor.apply(this, arguments);
            } }, t3));
          }(e2, this.formSerializer).toString();
          if ((s2 = $S.isFileList(e2)) || i2.indexOf("multipart/form-data") > -1) {
            const t3 = this.env && this.env.FormData;
            return aR(s2 ? { "files[]": e2 } : e2, t3 && new t3(), this.formSerializer);
          }
        }
        return r2 || n2 ? (t2.setContentType("application/json", false), function(e3, t3, i3) {
          if ($S.isString(e3)) try {
            return (t3 || JSON.parse)(e3), $S.trim(e3);
          } catch (e4) {
            if ("SyntaxError" !== e4.name) throw e4;
          }
          return (i3 || JSON.stringify)(e3);
        }(e2)) : e2;
      }], transformResponse: [function(e2) {
        const t2 = this.transitional || CR.transitional, i2 = t2 && t2.forcedJSONParsing, n2 = "json" === this.responseType;
        if (e2 && $S.isString(e2) && (i2 && !this.responseType || n2)) {
          const i3 = !(t2 && t2.silentJSONParsing) && n2;
          try {
            return JSON.parse(e2);
          } catch (e3) {
            if (i3) {
              if ("SyntaxError" === e3.name) throw eR.from(e3, eR.ERR_BAD_RESPONSE, this, null, this.response);
              throw e3;
            }
          }
        }
        return e2;
      }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: SR.classes.FormData, Blob: SR.classes.Blob }, validateStatus: function(e2) {
        return e2 >= 200 && e2 < 300;
      }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } };
      $S.forEach(["delete", "get", "head", "post", "put", "patch"], (e2) => {
        CR.headers[e2] = {};
      });
      var IR = CR;
      const vR = $S.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
      const yR = Symbol("internals");
      function AR(e2) {
        return e2 && String(e2).trim().toLowerCase();
      }
      function bR(e2) {
        return false === e2 || null == e2 ? e2 : $S.isArray(e2) ? e2.map(bR) : String(e2);
      }
      function wR(e2, t2, i2, n2, r2) {
        return $S.isFunction(n2) ? n2.call(this, t2, i2) : (r2 && (t2 = i2), $S.isString(t2) ? $S.isString(n2) ? -1 !== t2.indexOf(n2) : $S.isRegExp(n2) ? n2.test(t2) : void 0 : void 0);
      }
      class OR {
        constructor(e2) {
          e2 && this.set(e2);
        }
        set(e2, t2, i2) {
          const n2 = this;
          function r2(e3, t3, i3) {
            const r3 = AR(t3);
            if (!r3) throw new Error("header name must be a non-empty string");
            const s3 = $S.findKey(n2, r3);
            (!s3 || void 0 === n2[s3] || true === i3 || void 0 === i3 && false !== n2[s3]) && (n2[s3 || t3] = bR(e3));
          }
          const s2 = (e3, t3) => $S.forEach(e3, (e4, i3) => r2(e4, i3, t3));
          return $S.isPlainObject(e2) || e2 instanceof this.constructor ? s2(e2, t2) : $S.isString(e2) && (e2 = e2.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e2.trim()) ? s2(((e3) => {
            const t3 = {};
            let i3, n3, r3;
            return e3 && e3.split("\n").forEach(function(e4) {
              r3 = e4.indexOf(":"), i3 = e4.substring(0, r3).trim().toLowerCase(), n3 = e4.substring(r3 + 1).trim(), !i3 || t3[i3] && vR[i3] || ("set-cookie" === i3 ? t3[i3] ? t3[i3].push(n3) : t3[i3] = [n3] : t3[i3] = t3[i3] ? t3[i3] + ", " + n3 : n3);
            }), t3;
          })(e2), t2) : null != e2 && r2(t2, e2, i2), this;
        }
        get(e2, t2) {
          if (e2 = AR(e2)) {
            const i2 = $S.findKey(this, e2);
            if (i2) {
              const e3 = this[i2];
              if (!t2) return e3;
              if (true === t2) return function(e4) {
                const t3 = /* @__PURE__ */ Object.create(null), i3 = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                let n2;
                for (; n2 = i3.exec(e4); ) t3[n2[1]] = n2[2];
                return t3;
              }(e3);
              if ($S.isFunction(t2)) return t2.call(this, e3, i2);
              if ($S.isRegExp(t2)) return t2.exec(e3);
              throw new TypeError("parser must be boolean|regexp|function");
            }
          }
        }
        has(e2, t2) {
          if (e2 = AR(e2)) {
            const i2 = $S.findKey(this, e2);
            return !(!i2 || void 0 === this[i2] || t2 && !wR(0, this[i2], i2, t2));
          }
          return false;
        }
        delete(e2, t2) {
          const i2 = this;
          let n2 = false;
          function r2(e3) {
            if (e3 = AR(e3)) {
              const r3 = $S.findKey(i2, e3);
              !r3 || t2 && !wR(0, i2[r3], r3, t2) || (delete i2[r3], n2 = true);
            }
          }
          return $S.isArray(e2) ? e2.forEach(r2) : r2(e2), n2;
        }
        clear(e2) {
          const t2 = Object.keys(this);
          let i2 = t2.length, n2 = false;
          for (; i2--; ) {
            const r2 = t2[i2];
            e2 && !wR(0, this[r2], r2, e2, true) || (delete this[r2], n2 = true);
          }
          return n2;
        }
        normalize(e2) {
          const t2 = this, i2 = {};
          return $S.forEach(this, (n2, r2) => {
            const s2 = $S.findKey(i2, r2);
            if (s2) return t2[s2] = bR(n2), void delete t2[r2];
            const o2 = e2 ? function(e3) {
              return e3.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e4, t3, i3) => t3.toUpperCase() + i3);
            }(r2) : String(r2).trim();
            o2 !== r2 && delete t2[r2], t2[o2] = bR(n2), i2[o2] = true;
          }), this;
        }
        concat(...e2) {
          return this.constructor.concat(this, ...e2);
        }
        toJSON(e2) {
          const t2 = /* @__PURE__ */ Object.create(null);
          return $S.forEach(this, (i2, n2) => {
            null != i2 && false !== i2 && (t2[n2] = e2 && $S.isArray(i2) ? i2.join(", ") : i2);
          }), t2;
        }
        [Symbol.iterator]() {
          return Object.entries(this.toJSON())[Symbol.iterator]();
        }
        toString() {
          return Object.entries(this.toJSON()).map(([e2, t2]) => e2 + ": " + t2).join("\n");
        }
        get [Symbol.toStringTag]() {
          return "AxiosHeaders";
        }
        static from(e2) {
          return e2 instanceof this ? e2 : new this(e2);
        }
        static concat(e2, ...t2) {
          const i2 = new this(e2);
          return t2.forEach((e3) => i2.set(e3)), i2;
        }
        static accessor(e2) {
          const t2 = (this[yR] = this[yR] = { accessors: {} }).accessors, i2 = this.prototype;
          function n2(e3) {
            const n3 = AR(e3);
            t2[n3] || (!function(e4, t3) {
              const i3 = $S.toCamelCase(" " + t3);
              ["get", "set", "has"].forEach((n4) => {
                Object.defineProperty(e4, n4 + i3, { value: function(e5, i4, r2) {
                  return this[n4].call(this, t3, e5, i4, r2);
                }, configurable: true });
              });
            }(i2, e3), t2[n3] = true);
          }
          return $S.isArray(e2) ? e2.forEach(n2) : n2(e2), this;
        }
      }
      OR.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), $S.reduceDescriptors(OR.prototype, ({ value: e2 }, t2) => {
        let i2 = t2[0].toUpperCase() + t2.slice(1);
        return { get: () => e2, set(e3) {
          this[i2] = e3;
        } };
      }), $S.freezeMethods(OR);
      var NR = OR;
      function DR(e2, t2) {
        const i2 = this || IR, n2 = t2 || i2, r2 = NR.from(n2.headers);
        let s2 = n2.data;
        return $S.forEach(e2, function(e3) {
          s2 = e3.call(i2, s2, r2.normalize(), t2 ? t2.status : void 0);
        }), r2.normalize(), s2;
      }
      function PR(e2) {
        return !(!e2 || !e2.__CANCEL__);
      }
      function LR(e2, t2, i2) {
        eR.call(this, null == e2 ? "canceled" : e2, eR.ERR_CANCELED, t2, i2), this.name = "CanceledError";
      }
      $S.inherits(LR, eR, { __CANCEL__: true });
      var kR = SR.hasStandardBrowserEnv ? { write(e2, t2, i2, n2, r2, s2) {
        const o2 = [e2 + "=" + encodeURIComponent(t2)];
        $S.isNumber(i2) && o2.push("expires=" + new Date(i2).toGMTString()), $S.isString(n2) && o2.push("path=" + n2), $S.isString(r2) && o2.push("domain=" + r2), true === s2 && o2.push("secure"), document.cookie = o2.join("; ");
      }, read(e2) {
        const t2 = document.cookie.match(new RegExp("(^|;\\s*)(" + e2 + ")=([^;]*)"));
        return t2 ? decodeURIComponent(t2[3]) : null;
      }, remove(e2) {
        this.write(e2, "", Date.now() - 864e5);
      } } : { write() {
      }, read: () => null, remove() {
      } };
      function MR(e2, t2) {
        return e2 && !function(e3) {
          return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e3);
        }(t2) ? function(e3, t3) {
          return t3 ? e3.replace(/\/?\/$/, "") + "/" + t3.replace(/^\/+/, "") : e3;
        }(e2, t2) : t2;
      }
      var UR = SR.hasStandardBrowserEnv ? function() {
        const e2 = /(msie|trident)/i.test(navigator.userAgent), t2 = document.createElement("a");
        let i2;
        function n2(i3) {
          let n3 = i3;
          return e2 && (t2.setAttribute("href", n3), n3 = t2.href), t2.setAttribute("href", n3), { href: t2.href, protocol: t2.protocol ? t2.protocol.replace(/:$/, "") : "", host: t2.host, search: t2.search ? t2.search.replace(/^\?/, "") : "", hash: t2.hash ? t2.hash.replace(/^#/, "") : "", hostname: t2.hostname, port: t2.port, pathname: "/" === t2.pathname.charAt(0) ? t2.pathname : "/" + t2.pathname };
        }
        return i2 = n2(window.location.href), function(e3) {
          const t3 = $S.isString(e3) ? n2(e3) : e3;
          return t3.protocol === i2.protocol && t3.host === i2.host;
        };
      }() : function() {
        return true;
      };
      function xR(e2, t2) {
        let i2 = 0;
        const n2 = function(e3, t3) {
          e3 = e3 || 10;
          const i3 = new Array(e3), n3 = new Array(e3);
          let r2, s2 = 0, o2 = 0;
          return t3 = void 0 !== t3 ? t3 : 1e3, function(a2) {
            const c2 = Date.now(), d2 = n3[o2];
            r2 || (r2 = c2), i3[s2] = a2, n3[s2] = c2;
            let l2 = o2, u2 = 0;
            for (; l2 !== s2; ) u2 += i3[l2++], l2 %= e3;
            if (s2 = (s2 + 1) % e3, s2 === o2 && (o2 = (o2 + 1) % e3), c2 - r2 < t3) return;
            const h3 = d2 && c2 - d2;
            return h3 ? Math.round(1e3 * u2 / h3) : void 0;
          };
        }(50, 250);
        return (r2) => {
          const s2 = r2.loaded, o2 = r2.lengthComputable ? r2.total : void 0, a2 = s2 - i2, c2 = n2(a2);
          i2 = s2;
          const d2 = { loaded: s2, total: o2, progress: o2 ? s2 / o2 : void 0, bytes: a2, rate: c2 || void 0, estimated: c2 && o2 && s2 <= o2 ? (o2 - s2) / c2 : void 0, event: r2 };
          d2[t2 ? "download" : "upload"] = true, e2(d2);
        };
      }
      var VR = "undefined" != typeof XMLHttpRequest && function(e2) {
        return new Promise(function(t2, i2) {
          let n2 = e2.data;
          const r2 = NR.from(e2.headers).normalize();
          let s2, o2, { responseType: a2, withXSRFToken: c2 } = e2;
          function d2() {
            e2.cancelToken && e2.cancelToken.unsubscribe(s2), e2.signal && e2.signal.removeEventListener("abort", s2);
          }
          if ($S.isFormData(n2)) {
            if (SR.hasStandardBrowserEnv || SR.hasStandardBrowserWebWorkerEnv) r2.setContentType(false);
            else if (false !== (o2 = r2.getContentType())) {
              const [e3, ...t3] = o2 ? o2.split(";").map((e4) => e4.trim()).filter(Boolean) : [];
              r2.setContentType([e3 || "multipart/form-data", ...t3].join("; "));
            }
          }
          let l2 = new XMLHttpRequest();
          if (e2.auth) {
            const t3 = e2.auth.username || "", i3 = e2.auth.password ? unescape(encodeURIComponent(e2.auth.password)) : "";
            r2.set("Authorization", "Basic " + btoa(t3 + ":" + i3));
          }
          const u2 = MR(e2.baseURL, e2.url);
          function h3() {
            if (!l2) return;
            const n3 = NR.from("getAllResponseHeaders" in l2 && l2.getAllResponseHeaders());
            !function(e3, t3, i3) {
              const n4 = i3.config.validateStatus;
              i3.status && n4 && !n4(i3.status) ? t3(new eR("Request failed with status code " + i3.status, [eR.ERR_BAD_REQUEST, eR.ERR_BAD_RESPONSE][Math.floor(i3.status / 100) - 4], i3.config, i3.request, i3)) : e3(i3);
            }(function(e3) {
              t2(e3), d2();
            }, function(e3) {
              i2(e3), d2();
            }, { data: a2 && "text" !== a2 && "json" !== a2 ? l2.response : l2.responseText, status: l2.status, statusText: l2.statusText, headers: n3, config: e2, request: l2 }), l2 = null;
          }
          if (l2.open(e2.method.toUpperCase(), hR(u2, e2.params, e2.paramsSerializer), true), l2.timeout = e2.timeout, "onloadend" in l2 ? l2.onloadend = h3 : l2.onreadystatechange = function() {
            l2 && 4 === l2.readyState && (0 !== l2.status || l2.responseURL && 0 === l2.responseURL.indexOf("file:")) && setTimeout(h3);
          }, l2.onabort = function() {
            l2 && (i2(new eR("Request aborted", eR.ECONNABORTED, e2, l2)), l2 = null);
          }, l2.onerror = function() {
            i2(new eR("Network Error", eR.ERR_NETWORK, e2, l2)), l2 = null;
          }, l2.ontimeout = function() {
            let t3 = e2.timeout ? "timeout of " + e2.timeout + "ms exceeded" : "timeout exceeded";
            const n3 = e2.transitional || _R;
            e2.timeoutErrorMessage && (t3 = e2.timeoutErrorMessage), i2(new eR(t3, n3.clarifyTimeoutError ? eR.ETIMEDOUT : eR.ECONNABORTED, e2, l2)), l2 = null;
          }, SR.hasStandardBrowserEnv && (c2 && $S.isFunction(c2) && (c2 = c2(e2)), c2 || false !== c2 && UR(u2))) {
            const t3 = e2.xsrfHeaderName && e2.xsrfCookieName && kR.read(e2.xsrfCookieName);
            t3 && r2.set(e2.xsrfHeaderName, t3);
          }
          void 0 === n2 && r2.setContentType(null), "setRequestHeader" in l2 && $S.forEach(r2.toJSON(), function(e3, t3) {
            l2.setRequestHeader(t3, e3);
          }), $S.isUndefined(e2.withCredentials) || (l2.withCredentials = !!e2.withCredentials), a2 && "json" !== a2 && (l2.responseType = e2.responseType), "function" == typeof e2.onDownloadProgress && l2.addEventListener("progress", xR(e2.onDownloadProgress, true)), "function" == typeof e2.onUploadProgress && l2.upload && l2.upload.addEventListener("progress", xR(e2.onUploadProgress)), (e2.cancelToken || e2.signal) && (s2 = (t3) => {
            l2 && (i2(!t3 || t3.type ? new LR(null, e2, l2) : t3), l2.abort(), l2 = null);
          }, e2.cancelToken && e2.cancelToken.subscribe(s2), e2.signal && (e2.signal.aborted ? s2() : e2.signal.addEventListener("abort", s2)));
          const p2 = function(e3) {
            const t3 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e3);
            return t3 && t3[1] || "";
          }(u2);
          p2 && -1 === SR.protocols.indexOf(p2) ? i2(new eR("Unsupported protocol " + p2 + ":", eR.ERR_BAD_REQUEST, e2)) : l2.send(n2 || null);
        });
      };
      const FR = { http: null, xhr: VR };
      $S.forEach(FR, (e2, t2) => {
        if (e2) {
          try {
            Object.defineProperty(e2, "name", { value: t2 });
          } catch (e3) {
          }
          Object.defineProperty(e2, "adapterName", { value: t2 });
        }
      });
      const BR = (e2) => `- ${e2}`, jR = (e2) => $S.isFunction(e2) || null === e2 || false === e2;
      var GR = { getAdapter: (e2) => {
        e2 = $S.isArray(e2) ? e2 : [e2];
        const { length: t2 } = e2;
        let i2, n2;
        const r2 = {};
        for (let s2 = 0; s2 < t2; s2++) {
          let t3;
          if (i2 = e2[s2], n2 = i2, !jR(i2) && (n2 = FR[(t3 = String(i2)).toLowerCase()], void 0 === n2)) throw new eR(`Unknown adapter '${t3}'`);
          if (n2) break;
          r2[t3 || "#" + s2] = n2;
        }
        if (!n2) {
          const e3 = Object.entries(r2).map(([e4, t3]) => `adapter ${e4} ` + (false === t3 ? "is not supported by the environment" : "is not available in the build"));
          throw new eR("There is no suitable adapter to dispatch the request " + (t2 ? e3.length > 1 ? "since :\n" + e3.map(BR).join("\n") : " " + BR(e3[0]) : "as no adapter specified"), "ERR_NOT_SUPPORT");
        }
        return n2;
      }, adapters: FR };
      function WR(e2) {
        if (e2.cancelToken && e2.cancelToken.throwIfRequested(), e2.signal && e2.signal.aborted) throw new LR(null, e2);
      }
      function HR(e2) {
        WR(e2), e2.headers = NR.from(e2.headers), e2.data = DR.call(e2, e2.transformRequest), -1 !== ["post", "put", "patch"].indexOf(e2.method) && e2.headers.setContentType("application/x-www-form-urlencoded", false);
        return GR.getAdapter(e2.adapter || IR.adapter)(e2).then(function(t2) {
          return WR(e2), t2.data = DR.call(e2, e2.transformResponse, t2), t2.headers = NR.from(t2.headers), t2;
        }, function(t2) {
          return PR(t2) || (WR(e2), t2 && t2.response && (t2.response.data = DR.call(e2, e2.transformResponse, t2.response), t2.response.headers = NR.from(t2.response.headers))), Promise.reject(t2);
        });
      }
      const KR = (e2) => e2 instanceof NR ? e2.toJSON() : e2;
      function YR(e2, t2) {
        t2 = t2 || {};
        const i2 = {};
        function n2(e3, t3, i3) {
          return $S.isPlainObject(e3) && $S.isPlainObject(t3) ? $S.merge.call({ caseless: i3 }, e3, t3) : $S.isPlainObject(t3) ? $S.merge({}, t3) : $S.isArray(t3) ? t3.slice() : t3;
        }
        function r2(e3, t3, i3) {
          return $S.isUndefined(t3) ? $S.isUndefined(e3) ? void 0 : n2(void 0, e3, i3) : n2(e3, t3, i3);
        }
        function s2(e3, t3) {
          if (!$S.isUndefined(t3)) return n2(void 0, t3);
        }
        function o2(e3, t3) {
          return $S.isUndefined(t3) ? $S.isUndefined(e3) ? void 0 : n2(void 0, e3) : n2(void 0, t3);
        }
        function a2(i3, r3, s3) {
          return s3 in t2 ? n2(i3, r3) : s3 in e2 ? n2(void 0, i3) : void 0;
        }
        const c2 = { url: s2, method: s2, data: s2, baseURL: o2, transformRequest: o2, transformResponse: o2, paramsSerializer: o2, timeout: o2, timeoutMessage: o2, withCredentials: o2, withXSRFToken: o2, adapter: o2, responseType: o2, xsrfCookieName: o2, xsrfHeaderName: o2, onUploadProgress: o2, onDownloadProgress: o2, decompress: o2, maxContentLength: o2, maxBodyLength: o2, beforeRedirect: o2, transport: o2, httpAgent: o2, httpsAgent: o2, cancelToken: o2, socketPath: o2, responseEncoding: o2, validateStatus: a2, headers: (e3, t3) => r2(KR(e3), KR(t3), true) };
        return $S.forEach(Object.keys(Object.assign({}, e2, t2)), function(n3) {
          const s3 = c2[n3] || r2, o3 = s3(e2[n3], t2[n3], n3);
          $S.isUndefined(o3) && s3 !== a2 || (i2[n3] = o3);
        }), i2;
      }
      const qR = "1.6.7", zR = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach((e2, t2) => {
        zR[e2] = function(i2) {
          return typeof i2 === e2 || "a" + (t2 < 1 ? "n " : " ") + e2;
        };
      });
      const JR = {};
      zR.transitional = function(e2, t2, i2) {
        function n2(e3, t3) {
          return "[Axios v" + qR + "] Transitional option '" + e3 + "'" + t3 + (i2 ? ". " + i2 : "");
        }
        return (i3, r2, s2) => {
          if (false === e2) throw new eR(n2(r2, " has been removed" + (t2 ? " in " + t2 : "")), eR.ERR_DEPRECATED);
          return t2 && !JR[r2] && (JR[r2] = true, console.warn(n2(r2, " has been deprecated since v" + t2 + " and will be removed in the near future"))), !e2 || e2(i3, r2, s2);
        };
      };
      var XR = { assertOptions: function(e2, t2, i2) {
        if ("object" != typeof e2) throw new eR("options must be an object", eR.ERR_BAD_OPTION_VALUE);
        const n2 = Object.keys(e2);
        let r2 = n2.length;
        for (; r2-- > 0; ) {
          const s2 = n2[r2], o2 = t2[s2];
          if (o2) {
            const t3 = e2[s2], i3 = void 0 === t3 || o2(t3, s2, e2);
            if (true !== i3) throw new eR("option " + s2 + " must be " + i3, eR.ERR_BAD_OPTION_VALUE);
          } else if (true !== i2) throw new eR("Unknown option " + s2, eR.ERR_BAD_OPTION);
        }
      }, validators: zR };
      const QR = XR.validators;
      let ZR = class {
        constructor(e2) {
          this.defaults = e2, this.interceptors = { request: new pR(), response: new pR() };
        }
        async request(e2, t2) {
          try {
            return await this._request(e2, t2);
          } catch (e3) {
            if (e3 instanceof Error) {
              let t3;
              Error.captureStackTrace ? Error.captureStackTrace(t3 = {}) : t3 = new Error();
              const i2 = t3.stack ? t3.stack.replace(/^.+\n/, "") : "";
              e3.stack ? i2 && !String(e3.stack).endsWith(i2.replace(/^.+\n.+\n/, "")) && (e3.stack += "\n" + i2) : e3.stack = i2;
            }
            throw e3;
          }
        }
        _request(e2, t2) {
          "string" == typeof e2 ? (t2 = t2 || {}).url = e2 : t2 = e2 || {}, t2 = YR(this.defaults, t2);
          const { transitional: i2, paramsSerializer: n2, headers: r2 } = t2;
          void 0 !== i2 && XR.assertOptions(i2, { silentJSONParsing: QR.transitional(QR.boolean), forcedJSONParsing: QR.transitional(QR.boolean), clarifyTimeoutError: QR.transitional(QR.boolean) }, false), null != n2 && ($S.isFunction(n2) ? t2.paramsSerializer = { serialize: n2 } : XR.assertOptions(n2, { encode: QR.function, serialize: QR.function }, true)), t2.method = (t2.method || this.defaults.method || "get").toLowerCase();
          let s2 = r2 && $S.merge(r2.common, r2[t2.method]);
          r2 && $S.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (e3) => {
            delete r2[e3];
          }), t2.headers = NR.concat(s2, r2);
          const o2 = [];
          let a2 = true;
          this.interceptors.request.forEach(function(e3) {
            "function" == typeof e3.runWhen && false === e3.runWhen(t2) || (a2 = a2 && e3.synchronous, o2.unshift(e3.fulfilled, e3.rejected));
          });
          const c2 = [];
          let d2;
          this.interceptors.response.forEach(function(e3) {
            c2.push(e3.fulfilled, e3.rejected);
          });
          let l2, u2 = 0;
          if (!a2) {
            const e3 = [HR.bind(this), void 0];
            for (e3.unshift.apply(e3, o2), e3.push.apply(e3, c2), l2 = e3.length, d2 = Promise.resolve(t2); u2 < l2; ) d2 = d2.then(e3[u2++], e3[u2++]);
            return d2;
          }
          l2 = o2.length;
          let h3 = t2;
          for (u2 = 0; u2 < l2; ) {
            const e3 = o2[u2++], t3 = o2[u2++];
            try {
              h3 = e3(h3);
            } catch (e4) {
              t3.call(this, e4);
              break;
            }
          }
          try {
            d2 = HR.call(this, h3);
          } catch (e3) {
            return Promise.reject(e3);
          }
          for (u2 = 0, l2 = c2.length; u2 < l2; ) d2 = d2.then(c2[u2++], c2[u2++]);
          return d2;
        }
        getUri(e2) {
          return hR(MR((e2 = YR(this.defaults, e2)).baseURL, e2.url), e2.params, e2.paramsSerializer);
        }
      };
      $S.forEach(["delete", "get", "head", "options"], function(e2) {
        ZR.prototype[e2] = function(t2, i2) {
          return this.request(YR(i2 || {}, { method: e2, url: t2, data: (i2 || {}).data }));
        };
      }), $S.forEach(["post", "put", "patch"], function(e2) {
        function t2(t3) {
          return function(i2, n2, r2) {
            return this.request(YR(r2 || {}, { method: e2, headers: t3 ? { "Content-Type": "multipart/form-data" } : {}, url: i2, data: n2 }));
          };
        }
        ZR.prototype[e2] = t2(), ZR.prototype[e2 + "Form"] = t2(true);
      });
      var $R = ZR;
      class eC {
        constructor(e2) {
          if ("function" != typeof e2) throw new TypeError("executor must be a function.");
          let t2;
          this.promise = new Promise(function(e3) {
            t2 = e3;
          });
          const i2 = this;
          this.promise.then((e3) => {
            if (!i2._listeners) return;
            let t3 = i2._listeners.length;
            for (; t3-- > 0; ) i2._listeners[t3](e3);
            i2._listeners = null;
          }), this.promise.then = (e3) => {
            let t3;
            const n2 = new Promise((e4) => {
              i2.subscribe(e4), t3 = e4;
            }).then(e3);
            return n2.cancel = function() {
              i2.unsubscribe(t3);
            }, n2;
          }, e2(function(e3, n2, r2) {
            i2.reason || (i2.reason = new LR(e3, n2, r2), t2(i2.reason));
          });
        }
        throwIfRequested() {
          if (this.reason) throw this.reason;
        }
        subscribe(e2) {
          this.reason ? e2(this.reason) : this._listeners ? this._listeners.push(e2) : this._listeners = [e2];
        }
        unsubscribe(e2) {
          if (!this._listeners) return;
          const t2 = this._listeners.indexOf(e2);
          -1 !== t2 && this._listeners.splice(t2, 1);
        }
        static source() {
          let e2;
          return { token: new eC(function(t2) {
            e2 = t2;
          }), cancel: e2 };
        }
      }
      var tC = eC;
      const iC = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 };
      Object.entries(iC).forEach(([e2, t2]) => {
        iC[t2] = e2;
      });
      var nC = iC;
      const rC = function e2(t2) {
        const i2 = new $R(t2), n2 = TS($R.prototype.request, i2);
        return $S.extend(n2, $R.prototype, i2, { allOwnKeys: true }), $S.extend(n2, i2, null, { allOwnKeys: true }), n2.create = function(i3) {
          return e2(YR(t2, i3));
        }, n2;
      }(IR);
      rC.Axios = $R, rC.CanceledError = LR, rC.CancelToken = tC, rC.isCancel = PR, rC.VERSION = qR, rC.toFormData = aR, rC.AxiosError = eR, rC.Cancel = rC.CanceledError, rC.all = function(e2) {
        return Promise.all(e2);
      }, rC.spread = function(e2) {
        return function(t2) {
          return e2.apply(null, t2);
        };
      }, rC.isAxiosError = function(e2) {
        return $S.isObject(e2) && true === e2.isAxiosError;
      }, rC.mergeConfig = YR, rC.AxiosHeaders = NR, rC.formToJSON = (e2) => RR($S.isHTMLForm(e2) ? new FormData(e2) : e2), rC.getAdapter = GR.getAdapter, rC.HttpStatusCode = nC, rC.default = rC;
      var sC = rC;
      function oC(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function aC(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? oC(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : oC(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      let cC, dC = 0, lC = 0;
      function uC(e2, t2, i2, n2) {
        return new cg((r2, s2) => {
          t2.responseType = t2.responseType || "json", t2.data && !i2 ? (t2.data = JSON.stringify(t2.data), dC += $T(t2.data)) : i2 && (t2.data.size ? dC += t2.data.size : t2.data instanceof FormData ? dC += eS(t2.data) : dC += $T(JSON.stringify(t2.data))), t2.headers = t2.headers || {}, t2.headers["Content-Type"] = t2.headers["Content-Type"] || "application/json", t2.method = "POST", t2.url = e2, sC.request(t2).then((e3) => {
            "string" == typeof e3.data ? lC += $T(e3.data) : e3.data instanceof ArrayBuffer || e3.data instanceof Uint8Array ? lC += e3.data.byteLength : lC += $T(JSON.stringify(e3.data)), n2 && r2({ data: e3.data, headers: e3.headers }), r2(e3.data);
          }).catch((e3) => {
            sC.isCancel(e3) ? s2(new Kg(Hg.OPERATION_ABORTED, "cancel token canceled")) : "ECONNABORTED" === e3.code ? s2(new Kg(Hg.NETWORK_TIMEOUT, e3.message)) : e3.response ? s2(new Kg(Hg.NETWORK_RESPONSE_ERROR, e3.response.status)) : s2(new Kg(Hg.NETWORK_ERROR, e3.message));
          });
        });
      }
      async function hC(e2, t2) {
        const i2 = new Blob([t2.data], { type: "buffer" });
        return await uC(e2, aC(aC({}, t2), {}, { data: i2, headers: { "Content-Type": "application/octet-stream" } }), true);
      }
      const pC = () => "HTTPS" === (cC || cC || (cC = (window.location.protocol.split(":")[0] || "").toUpperCase(), cC)), _C = () => void 0 !== window.isSecureContext;
      const EC = function(e2) {
        if (e2.match(/[0-9]+\.[0-9]+\.[0-9]+$/)) return e2;
        const t2 = e2.match(/([0-9]+\.[0-9]+\.[0-9]+)\-alpha\.([0-9]+)/);
        if (t2 && t2[1] && t2[2]) {
          const e3 = t2[1], i3 = t2[2];
          return "".concat(e3, ".").concat(i3);
        }
        const i2 = e2.match(/([0-9]+\.[0-9]+\.[0-9]+)\-special\.([0-9]+)/);
        if (i2 && i2[1] && i2[2]) {
          const e3 = i2[1], t3 = i2[2];
          return "".concat(e3, ".").concat(100 * (Number(t3) + 1));
        }
        return "4.0.0.999";
      }("4.20.2"), mC = function() {
        try {
          return true === JSON.parse("true");
        } catch (e2) {
          return true;
        }
      }();
      var fC;
      !function(e2) {
        e2.Default = "default", e2.Auto = "auto", e2.Relay = "relay", e2.SdRtn = "sd-rtn";
      }(fC || (fC = {}));
      const gC = "v4.20.2-0-g8ae7fdad(3/20/2024, 4:48:46 PM)", TC = { PROCESS_ID: "", ENCRYPT_AES: true, AREAS: ["CHINA", "GLOBAL"], WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io", "webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io", "webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-web-2.ap.sd-rtn.com", "cds-ap-web-3.agora.io", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-web-2.ap.sd-rtn.com", "sua-ap-web-3.agora.io", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-web-2.ap.sd-rtn.com", "uap-ap-web-3.agora.io", "uap-web-4.ap.sd-rtn.com"], LOG_UPLOAD_SERVER: "logservice.agora.io", EVENT_REPORT_DOMAIN: "statscollector-1.agora.io", EVENT_REPORT_BACKUP_DOMAIN: "web-2.statscollector.sd-rtn.com", ENABLE_EVENT_REPORT: true, GATEWAY_ADDRESS: [], GATEWAY_WSS_ADDRESS: "", LIVE_STREAMING_ADDRESS: "", HTTP_CONNECT_TIMEOUT: 5e3, SIGNAL_REQUEST_TIMEOUT: 1e4, REPORT_STATS: true, UPLOAD_LOG: false, NOT_REPORT_EVENT: [], SUBSCRIBE_TWCC: false, PUBLISH_TWCC: false, PING_PONG_TIME_OUT: 10, WEBSOCKET_TIMEOUT_MIN: 1e4, EVENT_REPORT_SEND_INTERVAL: 3e3, CONFIG_DISTRIBUTE_INTERVAL: 3e5, ENABLE_CONFIG_DISTRIBUTE: true, CANDIDATE_TIMEOUT: 5e3, SHOW_REPORT_INVOKER_LOG: false, JOIN_EXTEND: "", PUB_EXTEND: "", SUB_EXTEND: "", FORCE_TURN: false, TURN_ENABLE_TCP: true, TURN_ENABLE_UDP: true, MAX_UPLOAD_CACHE: 50, UPLOAD_CACHE_INTERVAL: 2e3, AJAX_REQUEST_CONCURRENT: 3, REPORT_APP_SCENARIO: void 0, GATEWAY_DOMAINS: ["edge.agora.io", "edge.sd-rtn.com"], CONNECT_GATEWAY_WITHOUT_DOMAIN: false, WORKER_DOMAIN: "edge.agora.io", TURN_DOMAIN: "edge.agora.io", EVENT_REPORT_RETRY: true, CHROME_FORCE_PLAN_B: false, AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL: 400, AUDIO_SOURCE_AVG_VOLUME_DURATION: 3e3, AUDIO_VOLUME_INDICATION_INTERVAL: 2e3, VOLUME_VOICE_WEIGHT: 10, GET_VOLUME_OF_MUTED_AUDIO_TRACK: false, STATS_UPDATE_INTERVAL: 250, NORMAL_EVENT_QUEUE_CAPACITY: 100, CUSTOM_REPORT: true, CUSTOM_REPORT_LIMIT: 20, PROXY_SERVER_TYPE2: "webnginx-proxy.agora.io", PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com", "webrtc-cloud-proxy.agora.io"], CUSTOM_PUB_ANSWER_MODIFIER: null, CUSTOM_SUB_ANSWER_MODIFIER: null, CUSTOM_PUB_OFFER_MODIFIER: null, CUSTOM_SUB_OFFER_MODIFIER: null, DSCP_TYPE: "high", REMOVE_NEW_CODECS: true, FRAGEMENT_LENGTH: 3, WEBSOCKET_COMPRESS: false, SIMULCAST: false, PRELOAD_MEDIA_COUNT: 0, USE_PUB_RTX: false, USE_SUB_RTX: false, CHECK_VIDEO_VISIBLE_INTERVAL: 3e4, CHECK_LOCAL_STATS_INTERVAL: 100, PROFILE_SWITCH_INTERVAL: 2e3, UNSUPPORTED_VIDEO_CODEC: [], ENUMERATE_DEVICES_INTERVAL: false, ENUMERATE_DEVICES_INTERVAL_TIME: 1e4, USE_NEW_TOKEN: false, CLOSE_AFB_FOR_LOCAL_AP: true, JOIN_MAX_CONCURRENCY: 6, JOIN_WITH_FALLBACK_SIGNAL_PROXY: true, JOIN_WITH_FALLBACK_MEDIA_PROXY: true, JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE: false, JOIN_GATEWAY_TRY_443PORT_DURATION: 2e3, JOIN_GATEWAY_USE_443PORT_ONLY: false, JOIN_GATEWAY_USE_DUAL_DOMAIN: true, JOIN_GATEWAY_FALLBACK_PORT: 443, USE_TURN_SERVER_OF_GATEWAY: false, H264_PROFILE_LEVEL_ID: "", USE_NEW_LOG: false, LOG_VERSION: 3, MEDIA_DEVICE_CONSTRAINTS: null, ENCRYPT_PROXY_USERNAME_AND_PSW: true, SDP_LOGGING: false, CSP_DETECTED_HOSTNAME_LIST: ["agora.io", "sd-rtn.com"], REMOTE_AUDIO_TRACK_USES_WEB_AUDIO: false, LOCAL_AUDIO_TRACK_USES_WEB_AUDIO: false, BITRATE_ADAPTER_TYPE: "STANDARD_BITRATE", AI_DENOISER_PARAMETERS: { excludedLinks: [] }, ADJUST_3A_FROM_PLUGINS: true, RAISE_H264_BASELINE_PRIORITY: true, FILTER_SEND_H264_BASELINE: false, ENABLE_PUBLISHED_USER_LIST: true, MAX_SUBSCRIPTION: 50, X_GOOGLE_START_BITRATE: void 0, NEW_REPORT_SERVER: false, NEW_REPORT_SERVER_DOMAINS: ["data-reporting.agora.io", "data-reporting.agora.io"], VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT: 3e5, VIDEO_INSPECT_INTERVAL_MINIMUM: 1e3, VIDEO_INSPECT_QUALITY_RATIO: 0.9, VIDEO_INSPECT_WORKER_MANAGER_HOST: "edge.agora.io", VIDEO_INSPECT_WORKER_MANAGER_PORT: "", VIDEO_INSPECT_WORKER_PORT: "", SHOW_VIDEO_INSPECT_WORKER_MESSAGE: false, STATS_COLLECTOR_PORT: 443, FORCE_TURN_TCP: false, SUBSCRIBE_AUDIO_FILTER_TOPN: void 0, ENABLE_PUBLISH_AUDIO_FILTER: void 0, DISABLE_FEC: void 0, WEBAUDIO_INIT_OPTIONS: void 0, FILTER_VIDEO_FEC: true, FILTER_AUDIO_FEC: false, CHROME_DUAL_STREAM_USE_ENCODING: true, DISABLE_DUAL_STREAM_USE_ENCODING: false, EXTENSION_USAGE_UPLOAD_INTERVAL: 1e4, ICE_RESTART: true, ICE_RESTART_INTERVAL: 1e4, NEW_ICE_RESTART: false, ENABLE_USER_LICENSE_CHECK: true, SIGNAL_CHANNEL: 0, TRANSMITTER_INITIAL_RTT: 30, TRANSMITTER_INITIAL_RTO: 30, TRANSMITTER_MAX_BATCH_ACK_COUNT: 2, TRANSMITTER_MAX_RTO: 500, DATACHANNEL_COMPRESS: false, FINGERPRINT: null, DC_JOIN_WITH_FAILBACK: 5e3, ENABLE_VIDEO_FRAME_CALLBACK: true, VIDEO_FREEZE_DURATION: 500, SPATIALIZER_PARAMETERS: {}, UPLOAD_LOG_INTERVAL: 3e3, UPLOAD_LOG_REQUEST_RETRY_INTERVAL: 2e3, UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL: 2e4, UPLOAD_LOG_TRY_INTERVAL_WHILE_OFF: 5e3, UPLOAD_LOG_RETRY_INTERVAL_V1: 1e4, UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1: 200, UPLOAD_LOG_LENGTH_EACH_TIME: 10, APP_TYPE: 0, DISABLE_WEBAUDIO: false, CHANNEL_MEDIA_RELAY_SERVERS: void 0, KEEP_LAST_FRAME: true, FORWARD_P2P_CREATION: true, SYNC_GROUP: true, BLOCK_LOCAL_CLIENT: false, AP_AREA: true, SVC: [], ENABLE_ENCODED_TRANSFORM: false, ENABLE_VIDEO_SEI: false, IMAGE_MODERATION_WORKER_HOST: "edge.agora.io", IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT: 3e5, IMAGE_MODERATION_INTERVAL_MINIMUM: 1e3, SHOW_IMAGE_MODERATION_WORKER_MESSAGE: false, IMAGE_MODERATION_QUALITY_RATIO: 0.9, IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL: 5e3, SHOW_GLOBAL_CLIENT_LIST: false, ENABLE_DATASTREAM_2: false, DATASTREAM_MAX_RETRANSMITS: 10, ENABLE_USER_AUTO_REBALANCE_CHECK: true, ENABLE_INSTANT_VIDEO: false, ENABLE_NTP_REPORT: false, USE_XR: false, TCP_CANDIDATE_ONLY: false, EXTERNAL_SIGNAL_REQUEST_TIMEOUT: 3e3, SHOW_P2P_LOG: false, MAX_P2P_TIMEOUT: 3e4, P2P_TOKEN_INTERVAL: 1e3, SHOW_DATASTREAM2_LOG: false, RESTRICTION_SET_PLAYBACK_DEVICE: true, USE_PURE_ENCRYPTION_MASTER_KEY: false, ACCOUNT_REGISTER_RETRY_TIMEOUT: 1, ACCOUNT_REGISTER_RETRY_RATIO: 2, ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX: 6e4, ACCOUNT_REGISTER_RETRY_COUNT_MAX: 1e5, AUDIO_CONTEXT: null, WEBCS_BACKUP_CONNECT_TIMEOUT: 6e3, PLAYER_STATE_DEFER: 2e3, SIGNAL_REQUEST_WATCH_INTERVAL: 1e3, FILEPATH_LENMAX: 255, DUALSTREAM_OPERATION_CHECK: true, MEDIA_ELEMENT_EXISTS_DEPTH: 3, SHIM_CANDIDATE: false, LEAVE_MSG_TIMEOUT: 2e3, STATS_FILTER: { transportId: true, googTrackId: true }, FILTER_VIDEO_CODEC: [], PLUGIN_INFO: [] };
      function SC(e2, t2, i2) {
        var n2, r2;
        bn(n2 = Object.keys(TC)).call(n2, e2) && (!i2 && bn(r2 = Object.keys(CC)).call(r2, e2) || (TC[e2] = t2, "ENABLE_VIDEO_SEI" === e2 && true === t2 && (TC.ENABLE_ENCODED_TRANSFORM = true)));
      }
      function RC(e2) {
        return TC[e2];
      }
      const CC = {};
      function IC(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function vC(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? IC(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : IC(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      var yC;
      !function(e2) {
        e2.SET_SESSION_ID = "SET_SESSION_ID", e2.SET_P2P_ID = "SET_P2P_id", e2.SET_DC_ID = "SET_DC_id", e2.SET_UID = "SET_UID", e2.SET_INT_UID = "SET_INT_UID", e2.SET_PUB_ID = "SET_PUB_ID", e2.SET_CLOUD_PROXY_SERVER_MODE = "SET_CLOUD_PROXY_SERVER_MODE", e2.KEY_METRIC_CLIENT_CREATED = "KEY_METRIC_CLIENT_CREATED", e2.KEY_METRIC_JOIN_START = "KEY_METRIC_JOIN_START", e2.AVOID_JOIN_START = "AVOID_JOIN_START", e2.KEY_METRIC_JOIN_END = "KEY_METRIC_JOIN_END", e2.KEY_METRIC_REQUEST_AP_START = "KEY_METRIC_REQUEST_AP_START", e2.KEY_METRIC_REQUEST_AP_END = "KEY_METRIC_REQUEST_AP_END", e2.KEY_METRIC_JOIN_GATEWAY_START = "KEY_METRIC_JOIN_GATEWAY_START", e2.KEY_METRIC_JOIN_GATEWAY_END = "KEY_METRIC_JOIN_GATEWAY_END", e2.KEY_METRIC_PEER_CONNECTION_START = "KEY_METRIC_PEER_CONNECTION_START", e2.KEY_METRIC_PEER_CONNECTION_END = "KEY_METRIC_PEER_CONNECTION_END", e2.KEY_METRIC_DESCRIPTION_START = "KEY_METRIC_DESCRIPTION_START", e2.KEY_METRIC_ICE_CONNECTION_END = "KEY_METRIC_ICE_CONNECTION_END", e2.KEY_METRIC_SIGNAL_CHANNEL_OPEN = "KEY_METRIC_SIGNAL_CHANNEL_OPEN", e2.KEY_METRIC_PUBLISH = "KEY_METRIC_PUBLISH", e2.KEY_METRIC_SUBSCRIBE = "KEY_METRIC_SUBSCRIBE", e2.RECORD_JOIN_CHANNEL_SERVICE = "RECORD_JOIN_CHANNEL_SERVICE", e2.RESET_JOIN_CHANNEL_SERVICE_RECORDS = "RESET_JOIN_CHANNEL_SERVICE_RECORDS", e2.RESET_KEY_METRICS = "RESET_KEY_METRICS", e2.SET_USE_DATACHANNEL = "SET_USE_DATACHANNEL", e2.SET_USE_P2P = "SET_USE_P2P", e2.SET_TRANSPORT_TYPE = "SET_TRANSPORT_TYPE";
      }(yC || (yC = {}));
      class AC {
        constructor(e2, t2, i2, n2) {
          sh(this, "state", void 0), this.state = { codec: e2, audioCodec: t2, mode: i2, clientId: n2, sessionId: null, p2pId: 0, dcId: 0, pubId: 0, subId: 0, avoidJoinStart: 0, keyMetrics: { publish: [], subscribe: [] }, joinChannelServiceRecords: [], cloudProxyServerMode: "disabled", useDataChannel: false, useP2P: false, p2pTransport: fC.Default };
        }
        dispatch(e2) {
          this.state = function(e3, t2) {
            switch (t2.type) {
              case yC.SET_SESSION_ID:
                return vC(vC({}, e3), {}, { sessionId: t2.sessionId });
              case yC.SET_P2P_ID:
                return vC(vC({}, e3), {}, { p2pId: t2.p2pId });
              case yC.SET_UID:
                return vC(vC({}, e3), {}, { uid: t2.uid });
              case yC.SET_INT_UID:
                return vC(vC({}, e3), {}, { intUid: t2.intUid });
              case yC.SET_PUB_ID:
                return vC(vC({}, e3), {}, { pubId: t2.pubId });
              case yC.KEY_METRIC_CLIENT_CREATED:
                return vC(vC({}, e3), {}, { keyMetrics: vC(vC({}, e3.keyMetrics), {}, { clientCreated: t2.metric }) });
              case yC.KEY_METRIC_JOIN_START:
                return vC(vC({}, e3), {}, { keyMetrics: vC(vC({}, e3.keyMetrics), {}, { joinStart: t2.metric }) });
              case yC.AVOID_JOIN_START:
                return vC(vC({}, e3), {}, { avoidJoinStart: t2.avoidJoinStart });
              case yC.KEY_METRIC_JOIN_END:
                return vC(vC({}, e3), {}, { keyMetrics: vC(vC({}, e3.keyMetrics), {}, { joinEnd: t2.metric }) });
              case yC.KEY_METRIC_REQUEST_AP_START:
                return vC(vC({}, e3), {}, { keyMetrics: vC(vC({}, e3.keyMetrics), {}, { requestAPStart: t2.metric }) });
              case yC.KEY_METRIC_REQUEST_AP_END:
                return vC(vC({}, e3), {}, { keyMetrics: vC(vC({}, e3.keyMetrics), {}, { requestAPEnd: t2.metric }) });
              case yC.KEY_METRIC_JOIN_GATEWAY_START:
                return vC(vC({}, e3), {}, { keyMetrics: vC(vC({}, e3.keyMetrics), {}, { joinGatewayStart: t2.metric }) });
              case yC.KEY_METRIC_JOIN_GATEWAY_END:
                return vC(vC({}, e3), {}, { keyMetrics: vC(vC({}, e3.keyMetrics), {}, { joinGatewayEnd: t2.metric }) });
              case yC.KEY_METRIC_PEER_CONNECTION_START:
                return vC(vC({}, e3), {}, { keyMetrics: vC(vC({}, e3.keyMetrics), {}, { peerConnectionStart: t2.metric }) });
              case yC.KEY_METRIC_PEER_CONNECTION_END:
                return vC(vC({}, e3), {}, { keyMetrics: vC(vC({}, e3.keyMetrics), {}, { peerConnectionEnd: t2.metric }) });
              case yC.KEY_METRIC_DESCRIPTION_START:
                return vC(vC({}, e3), {}, { keyMetrics: vC(vC({}, e3.keyMetrics), {}, { descriptionStart: t2.metric }) });
              case yC.KEY_METRIC_SIGNAL_CHANNEL_OPEN:
                return vC(vC({}, e3), {}, { keyMetrics: vC(vC({}, e3.keyMetrics), {}, { signalChannelOpen: t2.metric }) });
              case yC.KEY_METRIC_ICE_CONNECTION_END:
                return vC(vC({}, e3), {}, { keyMetrics: vC(vC({}, e3.keyMetrics), {}, { iceConnectionEnd: t2.metric }) });
              case yC.KEY_METRIC_PUBLISH: {
                const i2 = e3.keyMetrics.publish, n2 = i2.findIndex((e4) => e4.trackId === t2.metric.trackId);
                return -1 !== n2 ? (i2[n2] = vC(vC({}, i2[n2]), t2.metric), vC(vC({}, e3), {}, { keyMetrics: vC(vC({}, e3.keyMetrics), {}, { publish: [...i2] }) })) : vC(vC({}, e3), {}, { keyMetrics: vC(vC({}, e3.keyMetrics), {}, { publish: [...e3.keyMetrics.publish, t2.metric] }) });
              }
              case yC.KEY_METRIC_SUBSCRIBE: {
                const i2 = e3.keyMetrics.subscribe, n2 = i2.findIndex((e4) => e4.userId === t2.metric.userId && e4.type === t2.metric.type);
                return -1 !== n2 ? (i2[n2] = vC(vC({}, i2[n2]), t2.metric), vC(vC({}, e3), {}, { keyMetrics: vC(vC({}, e3.keyMetrics), {}, { subscribe: [...i2] }) })) : vC(vC({}, e3), {}, { keyMetrics: vC(vC({}, e3.keyMetrics), {}, { subscribe: [...e3.keyMetrics.subscribe, t2.metric] }) });
              }
              case yC.SET_CLOUD_PROXY_SERVER_MODE:
                return e3.cloudProxyServerMode = t2.mode, e3;
              case yC.RECORD_JOIN_CHANNEL_SERVICE:
                return "number" != typeof t2.index ? e3.joinChannelServiceRecords = [...e3.joinChannelServiceRecords, t2.record] : (e3.joinChannelServiceRecords[t2.index] = vC(vC({}, e3.joinChannelServiceRecords[t2.index]), t2.record), e3.joinChannelServiceRecords = [...e3.joinChannelServiceRecords]), e3;
              case yC.RESET_JOIN_CHANNEL_SERVICE_RECORDS:
                return e3.joinChannelServiceRecords = [], e3;
              case yC.RESET_KEY_METRICS:
                return e3.keyMetrics = { publish: [], subscribe: [] }, e3;
              case yC.SET_USE_DATACHANNEL:
                return vC(vC({}, e3), {}, { useDataChannel: t2.val });
              case yC.SET_USE_P2P:
                return vC(vC({}, e3), {}, { useP2P: t2.val });
              case yC.SET_TRANSPORT_TYPE:
                return vC(vC({}, e3), {}, { p2pTransport: t2.val });
              default:
                return e3;
            }
          }(this.state, e2);
        }
        set sessionId(e2) {
          this.dispatch({ type: yC.SET_SESSION_ID, sessionId: e2 });
        }
        get sessionId() {
          return this.state.sessionId;
        }
        set codec(e2) {
          this.state.codec = e2;
        }
        get codec() {
          return this.state.codec;
        }
        get mode() {
          return this.state.mode;
        }
        get audioCodec() {
          return this.state.audioCodec;
        }
        get clientId() {
          return this.state.clientId;
        }
        set p2pId(e2) {
          this.dispatch({ type: yC.SET_P2P_ID, p2pId: e2 });
        }
        get p2pId() {
          return this.state.p2pId;
        }
        set dcId(e2) {
          this.dispatch({ type: yC.SET_DC_ID, dcId: e2 });
        }
        get dcId() {
          return this.state.dcId;
        }
        set uid(e2) {
          this.dispatch({ type: yC.SET_UID, uid: e2 });
        }
        get uid() {
          return this.state.uid;
        }
        set intUid(e2) {
          this.dispatch({ type: yC.SET_INT_UID, intUid: e2 });
        }
        get intUid() {
          return this.state.intUid;
        }
        set pubId(e2) {
          this.dispatch({ type: yC.SET_PUB_ID, pubId: e2 });
        }
        get pubId() {
          return this.state.pubId;
        }
        set cloudProxyServerMode(e2) {
          this.dispatch({ type: yC.SET_CLOUD_PROXY_SERVER_MODE, mode: e2 });
        }
        get cloudProxyServerMode() {
          return this.state.cloudProxyServerMode;
        }
        set useDataChannel(e2) {
          this.dispatch({ type: yC.SET_USE_DATACHANNEL, val: e2 });
        }
        get useDataChannel() {
          return this.state.useDataChannel;
        }
        set useP2P(e2) {
          this.dispatch({ type: yC.SET_USE_P2P, val: e2 });
        }
        get useP2P() {
          return this.state.useP2P;
        }
        set p2pTransport(e2) {
          this.dispatch({ type: yC.SET_TRANSPORT_TYPE, val: e2 });
        }
        get p2pTransport() {
          return this.state.p2pTransport;
        }
        clientCreated() {
          this.dispatch({ type: yC.KEY_METRIC_CLIENT_CREATED, metric: Date.now() });
        }
        joinStart() {
          this.dispatch({ type: yC.KEY_METRIC_JOIN_START, metric: Date.now() });
        }
        joinEnd() {
          this.dispatch({ type: yC.KEY_METRIC_JOIN_END, metric: Date.now() });
        }
        requestAPStart() {
          this.dispatch({ type: yC.KEY_METRIC_REQUEST_AP_START, metric: Date.now() });
        }
        requestAPEnd() {
          this.dispatch({ type: yC.KEY_METRIC_REQUEST_AP_END, metric: Date.now() });
        }
        joinGatewayStart() {
          this.dispatch({ type: yC.KEY_METRIC_JOIN_GATEWAY_START, metric: Date.now() });
        }
        joinGatewayEnd() {
          this.dispatch({ type: yC.KEY_METRIC_JOIN_GATEWAY_END, metric: Date.now() });
        }
        peerConnectionStart() {
          this.dispatch({ type: yC.KEY_METRIC_PEER_CONNECTION_START, metric: Date.now() });
        }
        peerConnectionEnd() {
          this.dispatch({ type: yC.KEY_METRIC_PEER_CONNECTION_END, metric: Date.now() });
        }
        descriptionStart() {
          this.dispatch({ type: yC.KEY_METRIC_DESCRIPTION_START, metric: Date.now() });
        }
        signalChannelOpen() {
          this.dispatch({ type: yC.KEY_METRIC_SIGNAL_CHANNEL_OPEN, metric: Date.now() });
        }
        iceConnectionEnd() {
          this.dispatch({ type: yC.KEY_METRIC_ICE_CONNECTION_END, metric: Date.now() });
        }
        publish(e2, t2, i2, n2) {
          this.dispatch({ type: yC.KEY_METRIC_PUBLISH, metric: vC(vC({ trackId: e2, type: t2 }, i2 && { publishStart: i2 }), n2 && { publishEnd: n2 }) });
        }
        subscribe(e2, t2, i2, n2, r2, s2, o2) {
          this.dispatch({ type: yC.KEY_METRIC_SUBSCRIBE, metric: vC(vC(vC(vC(vC({ userId: e2, type: t2 }, i2 && { subscribeStart: i2 }), n2 && { subscribeEnd: n2 }), r2 && { firstFrame: r2 }), s2 && { streamAdded: s2 }), o2 && { firstDecoded: o2 }) });
        }
        massSubscribe(e2, t2, i2, n2) {
          e2.forEach((e3) => {
            this.dispatch({ type: yC.KEY_METRIC_SUBSCRIBE, metric: vC(vC(vC({ userId: e3.userId, type: e3.type }, t2 && { subscribeStart: t2 }), i2 && { subscribeEnd: i2 }), n2 && { firstFrame: n2 }) });
          });
        }
        get keyMetrics() {
          return this.state.keyMetrics;
        }
        recordJoinChannelService(e2, t2) {
          "gateway" === e2.service && Array.isArray(e2.urls) && (e2.urls = e2.urls.map((e3) => e3.replace(/(\d+)-\d+-\d+-(\d+)/, "$1-*-*-$2")));
          try {
            return "number" != typeof t2 ? (this.dispatch({ type: yC.RECORD_JOIN_CHANNEL_SERVICE, record: vC(vC({}, e2), {}, { sessionId: this.sessionId, cloudProxyMode: this.cloudProxyServerMode, uid: this.uid }) }), this.state.joinChannelServiceRecords.length - 1) : (t2 < 0 || t2 >= this.state.joinChannelServiceRecords.length || this.dispatch({ type: yC.RECORD_JOIN_CHANNEL_SERVICE, record: e2, index: t2 }), t2);
          } catch (e3) {
            return 0;
          }
        }
        resetJoinChannelServiceRecords() {
          this.dispatch({ type: yC.RESET_JOIN_CHANNEL_SERVICE_RECORDS });
        }
        resetKeyMetrics() {
          this.dispatch({ type: yC.RESET_KEY_METRICS });
        }
        get joinChannelServiceRecords() {
          try {
            return this.state.joinChannelServiceRecords;
          } catch (e2) {
            return [];
          }
        }
        get avoidJoinStart() {
          return this.state.avoidJoinStart;
        }
        set avoidJoinStart(e2) {
          this.dispatch({ type: yC.AVOID_JOIN_START, avoidJoinStart: e2 });
        }
      }
      var bC, wC;
      !function(e2) {
        e2.h264 = "h264", e2.h265 = "h265", e2.vp8 = "vp8", e2.vp9 = "vp9", e2.av1 = "av1";
      }(bC || (bC = {})), function(e2) {
        e2.opus = "opus", e2.pcma = "pcma", e2.pcmu = "pcmu", e2.g722 = "g722";
      }(wC || (wC = {}));
      const OC = 128, NC = 96, DC = 1e3, PC = 10;
      let LC = 0;
      const kC = new class extends dT {
        reportLogUploadError(e2) {
          this.emit("REPORT_LOG_UPLOAD", e2);
        }
      }();
      class MC {
        constructor(e2) {
          sh(this, "logger", void 0), sh(this, "prefixLists", []), this.logger = e2;
        }
        debug() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          this.logger.debug(...this.prefixLists, ...t2);
        }
        info() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          this.logger.info(...this.prefixLists, ...t2);
        }
        warning() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          this.logger.warning(...this.prefixLists, ...t2);
        }
        error() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          this.logger.error(...this.prefixLists, ...t2);
        }
        prefix(e2) {
          return this.prefixLists.push(e2), this;
        }
        popPrefix() {
          return this.prefixLists.pop(), this;
        }
      }
      function UC() {
        const e2 = /* @__PURE__ */ new Date();
        return e2.toTimeString().split(" ")[0] + ":" + e2.getMilliseconds();
      }
      function xC() {
        const e2 = /* @__PURE__ */ new Date(), t2 = /((\d+:){2}\d+)/.exec((/* @__PURE__ */ new Date()).toUTCString());
        return t2 ? (null == t2 ? void 0 : t2[0]) + ":" + e2.getUTCMilliseconds() : e2.toTimeString().split(" ")[0] + ":" + e2.getMilliseconds();
      }
      const VC = { DEBUG: 0, INFO: 1, WARNING: 2, ERROR: 3, NONE: 4 }, FC = Date.now(), BC = (e2) => {
        for (const t2 in VC) if (Object.prototype.hasOwnProperty.call(VC, t2) && VC[t2] === e2) return t2;
        return "DEFAULT";
      };
      const jC = new class {
        constructor() {
          sh(this, "proxyServerURL", void 0), sh(this, "logLevel", VC.DEBUG), sh(this, "uploadState", "collecting"), sh(this, "uploadLogWaitingList", []), sh(this, "uploadLogUploadingList", []), sh(this, "uploadErrorCount", 0), sh(this, "currentLogID", 0), sh(this, "url", void 0), sh(this, "extLog", (e2, t2) => {
            this.appendLogToWaitingList(e2, ...t2);
          });
        }
        debug() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          const n2 = [VC.DEBUG].concat(t2);
          this.log.apply(this, n2);
        }
        info() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          const n2 = [VC.INFO].concat(t2);
          this.log.apply(this, n2);
        }
        warning() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          const n2 = [VC.WARNING].concat(t2);
          this.log.apply(this, n2);
        }
        warn() {
          this.warning(...arguments);
        }
        error() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          const n2 = [VC.ERROR].concat(t2);
          this.log.apply(this, n2);
        }
        upload() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          const n2 = [VC.DEBUG].concat(t2);
          this.uploadLog.apply(this, n2);
        }
        setLogLevel(e2) {
          e2 = Math.min(Math.max(0, e2), 4), this.logLevel = e2;
        }
        enableLogUpload() {
          SC("UPLOAD_LOG", true);
        }
        disableLogUpload() {
          SC("UPLOAD_LOG", false), this.uploadLogUploadingList = [], this.uploadLogWaitingList = [];
        }
        setProxyServer(e2) {
          this.proxyServerURL = e2;
        }
        prefix(e2) {
          return new MC(this).prefix(e2);
        }
        log() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          if (Date.now() - FC < 100) return void setTimeout(() => {
            this.log(...t2);
          }, Date.now() - FC);
          const n2 = Math.max(0, Math.min(4, t2[0]));
          if (t2[0] = UC() + " Agora-SDK [".concat(BC(n2), "]:"), this.appendLogToWaitingList(n2, ...t2), n2 < this.logLevel) return;
          const r2 = UC() + " %cAgora-SDK [".concat(BC(n2), "]:");
          let s2 = [];
          if (!RC("USE_NEW_LOG")) switch (n2) {
            case VC.DEBUG:
              s2 = [r2, "color: #64B5F6;"].concat(t2.slice(1)), console.log.apply(console, s2);
              break;
            case VC.INFO:
              s2 = [r2, "color: #1E88E5; font-weight: bold;"].concat(t2.slice(1)), console.log.apply(console, s2);
              break;
            case VC.WARNING:
              s2 = [r2, "color: #FB8C00; font-weight: bold;"].concat(t2.slice(1)), console.warn.apply(console, s2);
              break;
            case VC.ERROR:
              s2 = [r2, "color: #B00020; font-weight: bold;"].concat(t2.slice(1)), console.error.apply(console, s2);
          }
        }
        uploadLog() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          if (Date.now() - FC < 100) return void setTimeout(() => {
            this.uploadLog(...t2);
          }, Date.now() - FC);
          const n2 = Math.max(0, Math.min(4, t2[0]));
          t2[0] = UC() + " Agora-SDK [".concat(BC(n2), "]:"), this.appendLogToWaitingList(n2, ...t2);
        }
        appendLogToWaitingList(e2) {
          if (!RC("UPLOAD_LOG")) return;
          for (var t2 = arguments.length, i2 = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++) i2[n2 - 1] = arguments[n2];
          Array.isArray(i2[0]) ? i2[0][0] = xC() + " Agora-SDK [".concat(BC(e2), "]:") : i2[0] = xC() + " Agora-SDK [".concat(BC(e2), "]:");
          let r2 = "";
          i2.forEach((e3) => {
            "object" == typeof e3 && (e3 = JSON.stringify(e3)), r2 += "".concat(e3, " ");
          }), this.uploadLogWaitingList.push({ payload_str: r2, log_level: e2, log_item_id: this.currentLogID++ }), "uploading" === this.uploadState && 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();
        }
        startUpload() {
          this.uploadState = "uploading", 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();
        }
        async uploadLogs() {
          const e2 = this.uploadLogUploadingList, t2 = { sdk_version: EC, process_id: RC("PROCESS_ID"), payload: JSON.stringify(e2) };
          return fS(async () => {
            const e3 = await sC.post(this.url || (this.proxyServerURL ? "https://".concat(this.proxyServerURL, "/ls/?h=").concat(RC("LOG_UPLOAD_SERVER"), "&p=443&d=upload/v1") : "https://".concat(RC("LOG_UPLOAD_SERVER"), "/upload/v1")), t2, { responseType: "text" });
            if ("OK" !== e3.data) {
              const t3 = new Error("unexpected upload log response");
              throw t3.response = e3, t3;
            }
          }, () => (this.uploadLogUploadingList = [], false), (e3) => (e3.response ? kC.reportLogUploadError({ status: e3.response.status, data: e3.response.data, headers: e3.response.headers, message: e3.message }) : e3.request ? kC.reportLogUploadError({ status: e3.request.status, message: e3.message }) : kC.reportLogUploadError({ status: -1, message: e3.message }), true), { timeout: RC("UPLOAD_LOG_REQUEST_RETRY_INTERVAL"), maxRetryTimeout: RC("UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL") });
        }
        uploadLogInterval() {
          0 === this.uploadLogUploadingList.length && 0 === this.uploadLogWaitingList.length || (0 === this.uploadLogUploadingList.length && (this.uploadLogUploadingList = this.uploadLogWaitingList.splice(0, RC("UPLOAD_LOG_LENGTH_EACH_TIME"))), this.uploadLogs().then(() => {
            this.uploadErrorCount = 0, this.uploadLogWaitingList.length > 0 && window.setTimeout(() => this.uploadLogInterval(), RC("UPLOAD_LOG_INTERVAL"));
          }).catch((e2) => {
            this.uploadErrorCount += 1, this.uploadErrorCount < 2 ? window.setTimeout(() => this.uploadLogInterval(), RC("UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1")) : window.setTimeout(() => this.uploadLogInterval(), RC("UPLOAD_LOG_RETRY_INTERVAL_V1"));
          }));
        }
      }();
      var GC, WC;
      function HC(e2) {
        return Xg(e2.reportId, "params.reportId", 0, 100, false), Xg(e2.category, "params.category", 0, 100, false), Xg(e2.event, "params.event", 0, 100, false), Xg(e2.label, "params.label", 0, 100, false), zg(e2.value, "params.value", Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, false), true;
      }
      !function(e2) {
        e2.FREE = "free", e2.UPLOADING = "uploading";
      }(GC || (GC = {})), function(e2) {
        e2[e2.MISC = 0] = "MISC", e2[e2.INTERNAL_EVENT = 1] = "INTERNAL_EVENT", e2[e2.PUBLIC_EVENT = 2] = "PUBLIC_EVENT", e2[e2.WEB_EVENT = 3] = "WEB_EVENT", e2[e2.INTERNAL_API = 4] = "INTERNAL_API", e2[e2.WEB_API = 5] = "WEB_API", e2[e2.PUBLIC_API = 6] = "PUBLIC_API";
      }(WC || (WC = {}));
      const KC = { sid: "", lts: 0, success: null, cname: null, uid: null, peer: null, cid: null, elapse: null, extend: null, vid: 0 };
      var YC, qC, zC, JC;
      function XC(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function QC(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? XC(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : XC(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      !function(e2) {
        e2.PUBLISH = "publish", e2.SUBSCRIBE = "subscribe", e2.WS_COMPRESSOR_INIT = "ws_compressor_init", e2.SESSION_INIT = "session_init", e2.JOIN_CHOOSE_SERVER = "join_choose_server", e2.REQ_USER_ACCOUNT = "req_user_account", e2.JOIN_GATEWAY = "join_gateway", e2.REJOIN_GATEWAY = "rejoin_gateway", e2.STREAM_SWITCH = "stream_switch", e2.REQUEST_PROXY_WORKER_MANAGER = "request_proxy_worker_manager", e2.REQUEST_PROXY_APPCENTER = "request_proxy_appcenter", e2.FIRST_VIDEO_RECEIVED = "first_video_received", e2.FIRST_AUDIO_RECEIVED = "first_audio_received", e2.FIRST_VIDEO_DECODE = "first_video_decode", e2.FIRST_AUDIO_DECODE = "first_audio_decode", e2.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e2.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e2.ON_UPDATE_STREAM = "on_update_stream", e2.ON_REMOVE_STREAM = "on_remove_stream", e2.USER_ANALYTICS = "req_user_analytics", e2.PC_STATS = "pc_stats", e2.UPDATE_REMOTE_RTPCAPABILITIES = "update_remote_rtpCapabilities";
      }(YC || (YC = {})), function(e2) {
        e2.SESSION = "io.agora.pb.Wrtc.Session", e2.JOIN_CHOOSE_SERVER = "io.agora.pb.Wrtc.JoinChooseServer", e2.REQ_USER_ACCOUNT = "io.agora.pb.Wrtc.ReqUserAccount", e2.JOIN_GATEWAY = "io.agora.pb.Wrtc.JoinGateway", e2.RE_JOIN_GATEWAY = "io.agora.pb.Wrtc.ReJoinGateway", e2.PUBLISH = "io.agora.pb.Wrtc.Publish", e2.SUBSCRIBE = "io.agora.pb.Wrtc.Subscribe", e2.WS_COMPRESSOR_INIT = "io.agora.pb.Wrtc.WsCompressorInit", e2.STREAM_SWITCH = "io.agora.pb.Wrtc.StreamSwitch", e2.AUDIO_SENDING_STOPPED = "io.agora.pb.Wrtc.AudioSendingStopped", e2.VIDEO_SENDING_STOPPED = "io.agora.pb.Wrtc.VideoSendingStopped", e2.REQUEST_PROXY_APPCENTER = "io.agora.pb.Wrtc.RequestProxyAppCenter", e2.REQUEST_PROXY_WORKER_MANAGER = "io.agora.pb.Wrtc.RequestProxyWorkerManager", e2.API_INVOKE = "io.agora.pb.Wrtc.ApiInvoke", e2.FIRST_VIDEO_RECEIVED = "io.agora.pb.Wrtc.FirstVideoReceived", e2.FIRST_AUDIO_RECEIVED = "io.agora.pb.Wrtc.FirstAudioReceived", e2.FIRST_VIDEO_DECODE = "io.agora.pb.Wrtc.FirstVideoDecode", e2.FIRST_AUDIO_DECODE = "io.agora.pb.Wrtc.FirstAudioDecode", e2.ON_ADD_AUDIO_STREAM = "io.agora.pb.Wrtc.OnAddAudioStream", e2.ON_ADD_VIDEO_STREAM = "io.agora.pb.Wrtc.OnAddVideoStream", e2.ON_UPDATE_STREAM = "io.agora.pb.Wrtc.OnUpdateStream", e2.ON_REMOVE_STREAM = "io.agora.pb.Wrtc.OnRemoveStream", e2.JOIN_CHANNEL_TIMEOUT = "io.agora.pb.Wrtc.JoinChannelTimeout", e2.PEER_PUBLISH_STATUS = "io.agora.pb.Wrtc.PeerPublishStatus", e2.WORKER_EVENT = "io.agora.pb.Wrtc.WorkerEvent", e2.AP_WORKER_EVENT = "io.agora.pb.Wrtc.APWorkerEvent", e2.JOIN_WEB_PROXY_AP = "io.agora.pb.Wrtc.JoinWebProxyAP", e2.WEBSOCKET_QUIT = "io.agora.pb.Wrtc.WebSocketQuit", e2.USER_ANALYTICS = "io.agora.pb.Wrtc.UserAnalytics", e2.AUTOPLAY_FAILED = "io.agora.pb.Wrtc.AutoplayFailed", e2.PC_STATS = "io.agora.pb.Wrtc.PCStats", e2.UPDATE_REMOTE_RTPCAPABILITIES = "io.agora.pb.Wrtc.UpdateRemoteRTPCapabilities";
      }(qC || (qC = {})), function(e2) {
        e2[e2.WORKER_EVENT = 156] = "WORKER_EVENT", e2[e2.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT";
      }(zC || (zC = {})), function(e2) {
        e2[e2.SESSION = 26] = "SESSION", e2[e2.JOIN_CHOOSE_SERVER = 27] = "JOIN_CHOOSE_SERVER", e2[e2.REQ_USER_ACCOUNT = 196] = "REQ_USER_ACCOUNT", e2[e2.JOIN_GATEWAY = 28] = "JOIN_GATEWAY", e2[e2.PUBLISH = 30] = "PUBLISH", e2[e2.SUBSCRIBE = 29] = "SUBSCRIBE", e2[e2.WS_COMPRESSOR_INIT = 9430] = "WS_COMPRESSOR_INIT", e2[e2.STREAM_SWITCH = 32] = "STREAM_SWITCH", e2[e2.AUDIO_SENDING_STOPPED = 33] = "AUDIO_SENDING_STOPPED", e2[e2.VIDEO_SENDING_STOPPED = 34] = "VIDEO_SENDING_STOPPED", e2[e2.REQUEST_PROXY_APPCENTER = 35] = "REQUEST_PROXY_APPCENTER", e2[e2.REQUEST_PROXY_WORKER_MANAGER = 36] = "REQUEST_PROXY_WORKER_MANAGER", e2[e2.API_INVOKE = 41] = "API_INVOKE", e2[e2.FIRST_VIDEO_RECEIVED = 348] = "FIRST_VIDEO_RECEIVED", e2[e2.FIRST_AUDIO_RECEIVED = 349] = "FIRST_AUDIO_RECEIVED", e2[e2.FIRST_VIDEO_DECODE = 350] = "FIRST_VIDEO_DECODE", e2[e2.FIRST_AUDIO_DECODE = 351] = "FIRST_AUDIO_DECODE", e2[e2.ON_ADD_AUDIO_STREAM = 352] = "ON_ADD_AUDIO_STREAM", e2[e2.ON_ADD_VIDEO_STREAM = 353] = "ON_ADD_VIDEO_STREAM", e2[e2.ON_UPDATE_STREAM = 356] = "ON_UPDATE_STREAM", e2[e2.ON_REMOVE_STREAM = 355] = "ON_REMOVE_STREAM", e2[e2.JOIN_CHANNEL_TIMEOUT = 407] = "JOIN_CHANNEL_TIMEOUT", e2[e2.PEER_PUBLISH_STATUS = 408] = "PEER_PUBLISH_STATUS", e2[e2.WORKER_EVENT = 156] = "WORKER_EVENT", e2[e2.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT", e2[e2.JOIN_WEB_PROXY_AP = 700] = "JOIN_WEB_PROXY_AP", e2[e2.WEBSOCKET_QUIT = 671] = "WEBSOCKET_QUIT", e2[e2.USER_ANALYTICS = 1e4] = "USER_ANALYTICS", e2[e2.AUTOPLAY_FAILED = 9178] = "AUTOPLAY_FAILED";
      }(JC || (JC = {}));
      class ZC {
        constructor() {
          sh(this, "baseInfoMap", /* @__PURE__ */ new Map()), sh(this, "proxyServer", void 0), sh(this, "eventUploadTimer", void 0), sh(this, "setSessionIdTimer", void 0), sh(this, "url", void 0), sh(this, "backupUrl", void 0), sh(this, "_appId", void 0), sh(this, "keyEventUploadPendingItems", []), sh(this, "normalEventUploadPendingItems", []), sh(this, "apiInvokeUploadPendingItems", []), sh(this, "apiInvokeCount", 0), sh(this, "ltsList", []), sh(this, "lastSendNormalEventTime", Date.now()), sh(this, "customReportCounterTimer", void 0), sh(this, "customReportCount", 0), sh(this, "extApiInvoke", async (e2) => {
            for (const t2 of e2) {
              const e3 = QC(QC({}, t2), {}, { sid: null, invokeId: ++this.apiInvokeCount, tag: pT.TRACER });
              this.sendApiInvoke(e3);
            }
          }), this.eventUploadTimer = window.setInterval(this.doSend.bind(this), RC("EVENT_REPORT_SEND_INTERVAL")), this.setSessionIdTimer = window.setInterval(this.appendSessionId.bind(this), RC("EVENT_REPORT_SEND_INTERVAL"));
        }
        getBaseInfoBySessionId(e2) {
          return this.baseInfoMap.get(e2);
        }
        adjustSessionStartTime(e2) {
          if (!this.baseInfoMap.has(e2) && !this.baseInfoMap.get(e2)) return void jC.error("adjust session ".concat(e2, " start time, sid is not exist or info is undefined"));
          const t2 = this.baseInfoMap.get(e2), i2 = Date.now(), n2 = t2.startTime;
          t2.startTime = i2, jC.debug("rewrite session ".concat(e2, " startTime: ").concat(i2, " , ").concat(i2 - n2, "ms")), this.baseInfoMap.set(e2, t2);
        }
        setAppId(e2) {
          this._appId = e2;
        }
        reportApiInvoke(e2, t2, i2) {
          t2.timeout = t2.timeout || 6e4, t2.reportResult = void 0 === t2.reportResult || t2.reportResult;
          const n2 = Date.now();
          this.apiInvokeCount += 1;
          const r2 = this.apiInvokeCount, s2 = () => ({ tag: t2.tag, invokeId: r2, sid: e2, name: t2.name, apiInvokeTime: n2, options: t2.options, states: t2.states || null }), o2 = !!RC("SHOW_REPORT_INVOKER_LOG");
          o2 && jC.info("".concat(t2.name, " start"), t2.options);
          let a2 = false;
          iS(t2.timeout).then(() => {
            a2 || (this.sendApiInvoke(QC(QC({}, s2()), {}, { error: Hg.API_INVOKE_TIMEOUT, success: false })), jC.debug("".concat(t2.name, " timeout")));
          });
          const c2 = new Kg(Hg.UNEXPECTED_ERROR, "".concat(t2.name, ": this api invoke is end"));
          return { onSuccess: (e3) => {
            const n3 = () => {
              if (a2) throw c2;
              return a2 = true, this.sendApiInvoke(QC(QC({}, s2()), {}, { success: true }, t2.reportResult && { result: e3 })), o2 && jC.info("".concat(t2.name, " onSuccess")), e3;
            };
            return i2 ? aS(n3, t2.name + "Success", i2, () => a2 = true) : n3();
          }, onError: (e3) => {
            const n3 = () => {
              if (a2) throw e3;
              a2 = true, this.sendApiInvoke(QC(QC({}, s2()), {}, { success: false, error: e3 })), o2 && jC.info("".concat(t2.name, " onFailure"), e3.toString());
            };
            return i2 ? aS(n3, t2.name + "Error", i2, () => a2 = true) : n3();
          } };
        }
        sessionInit(e2, t2) {
          if (this.baseInfoMap.has(e2)) return;
          const i2 = Date.now(), n2 = this.createBaseInfo(e2, i2);
          n2.cname = t2.cname;
          const r2 = Object.assign({}, { willUploadConsoleLog: RC("UPLOAD_LOG"), maxTouchPoints: navigator.maxTouchPoints, areaVersion: mC ? "global" : "oversea", areas: RC("AREAS") && RC("AREAS").join(",") }, t2.extend), { stringUid: s2, channelProfile: o2, channelMode: a2, isABTestSuccess: c2, lsid: d2, clientRole: l2 } = t2, u2 = Date.now(), h3 = QC(QC({}, n2), {}, { eventType: YC.SESSION_INIT, appid: t2.appid, browser: navigator.userAgent, build: gC, lts: u2, elapse: u2 - i2, extend: JSON.stringify(r2), mode: t2.mode, process: RC("PROCESS_ID"), appType: RC("APP_TYPE"), success: true, version: EC, stringUid: s2, channelProfile: o2, channelMode: a2, isABTestSuccess: c2, lsid: d2, clientType: 20, clientRole: l2, serviceId: RC("PROCESS_ID"), extensionID: RC("PLUGIN_INFO").join(",") || "" });
          this.send({ type: qC.SESSION, data: h3 }, true);
        }
        joinChooseServer(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), s2 = QC(QC({}, n2), {}, { eventType: YC.JOIN_CHOOSE_SERVER, lts: r2, eventElapse: r2 - t2.lts, chooseServerAddr: t2.csAddr, errorCode: t2.ec, elapse: r2 - i2.startTime, success: t2.succ, chooseServerAddrList: JSON.stringify(t2.serverList), uid: t2.uid ? parseInt(t2.uid) : null, cid: t2.cid ? parseInt(t2.cid) : null, chooseServerIp: t2.csIp || "", opid: t2.opid, unilbsServerIds: t2.unilbsServerIds, extend: t2.extend || void 0, isHttp3: t2.isHttp3 });
          this.send({ type: qC.JOIN_CHOOSE_SERVER, data: s2 }, true);
        }
        reqUserAccount(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), s2 = QC(QC({}, n2), {}, { eventType: YC.REQ_USER_ACCOUNT, lts: r2, success: t2.success, serverAddress: t2.serverAddr, stringUid: t2.stringUid, uid: t2.uid, errorCode: t2.errorCode, elapse: r2 - i2.startTime, eventElapse: r2 - t2.lts, extend: JSON.stringify(t2.extend) });
          this.send({ type: qC.REQ_USER_ACCOUNT, data: s2 }, true);
        }
        joinGateway(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info;
          t2.vid && (n2.vid = t2.vid), n2.uid = t2.uid, n2.cid = t2.cid;
          const r2 = Date.now(), { firstSuccess: s2, avoidJoinStartTime: o2, isProxy: a2, addr: c2 } = t2, d2 = r2 - (s2 && o2 ? o2 : i2.startTime), l2 = QC(QC({}, n2), {}, { eventType: YC.JOIN_GATEWAY, lts: r2, gatewayAddr: t2.addr, success: t2.succ, errorCode: t2.ec, elapse: d2, eventElapse: r2 - t2.lts, firstSuccess: s2, signalChannel: t2.signalChannel }), u2 = l2.success ? 1 : 0;
          if (t2.succ && (i2.lastJoinSuccessTime = r2), s2) this.send({ type: qC.JOIN_GATEWAY, data: l2 }, true);
          else {
            let e3;
            if (c2) if (a2) {
              const t4 = c2.match(/h=(\d{1,3}-){3}\d{1,3}/g), i3 = c2.match(/p=[0-9]{1,6}/g);
              e3 = { isSuccess: u2, gatewayIp: t4 && t4.length ? t4[0].split("=")[1].replace(/-/g, ".") : "", port: i3 && i3.length ? i3[0].split("=")[1] : "", isProxy: a2 ? 1 : 0 };
            } else {
              const t4 = c2.match(/wss:\/\/(\d{1,3}-){3}\d{1,3}/g), i3 = c2.match(/(:|p=)[0-9]{1,6}/g);
              e3 = { isSuccess: u2, gatewayIp: t4 && t4.length ? t4[0].split("//")[1].replace(/-/g, ".") : "", port: i3 && i3.length ? i3[0].split(/:|p=/g)[1] : "", isProxy: a2 ? 1 : 0 };
            }
            else e3 = { isSuccess: u2, gatewayIp: "", port: "", isProxy: a2 ? 1 : 0 };
            delete l2.success, delete l2.eventType, delete l2.firstSuccess, l2.vid = Number(l2.vid);
            const t3 = Object.assign({}, l2, e3, { eventType: YC.REJOIN_GATEWAY });
            this.send({ type: qC.RE_JOIN_GATEWAY, data: t3 }, true);
          }
        }
        joinChannelTimeout(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = Date.now(), r2 = QC(QC({}, i2.info), {}, { lts: n2, timeout: t2, elapse: n2 - i2.startTime });
          this.send({ type: qC.JOIN_CHANNEL_TIMEOUT, data: r2 }, true);
        }
        publish(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), s2 = QC(QC({}, n2), {}, { eventType: YC.PUBLISH, lts: r2, eventElapse: t2.eventElapse, elapse: r2 - i2.startTime, success: t2.succ, errorCode: t2.ec, videoName: t2.videoName, audioName: t2.audioName, screenName: t2.screenName, screenshare: t2.screenshare, audio: t2.audio, video: t2.video, p2pid: t2.p2pid, publishRequestid: t2.publishRequestid });
          this.send({ type: qC.PUBLISH, data: s2 }, true);
        }
        subscribe(e2, t2, i2) {
          const n2 = this.baseInfoMap.get(e2);
          if (!n2) return;
          const r2 = n2.info, s2 = Date.now(), o2 = QC(QC({}, r2), {}, { eventType: YC.SUBSCRIBE, lts: s2, eventElapse: t2.eventElapse, elapse: s2 - n2.startTime, success: t2.succ, errorCode: t2.ec, video: t2.video, audio: t2.audio, subscribeRequestid: t2.subscribeRequestid, p2pid: t2.p2pid }, i2 && { extend: JSON.stringify({ isMassSubscribe: true }) });
          "string" == typeof t2.peerid ? o2.peerSuid = t2.peerid : o2.peer = t2.peerid, this.send({ type: qC.SUBSCRIBE, data: o2 }, true);
        }
        wsCompressorInit(e2) {
          var t2;
          const i2 = [...ph(t2 = this.baseInfoMap).call(t2)], n2 = i2.length ? i2[0] : "UnableToGetSid", r2 = this.baseInfoMap.get(n2);
          if (!r2) return;
          const s2 = r2.info, o2 = Date.now(), a2 = QC(QC({}, s2), {}, { eventType: YC.WS_COMPRESSOR_INIT, lts: o2, eventElapse: e2.eventElapse, elapse: o2 - r2.startTime, status: e2.status ? 1 : 2 });
          this.send({ type: qC.WS_COMPRESSOR_INIT, data: a2 }, true);
        }
        firstRemoteVideoDecode(e2, t2, i2, n2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2) return;
          const s2 = r2.info, o2 = Date.now(), a2 = QC(QC(QC({}, s2), n2), {}, { elapse: o2 - r2.startTime, eventType: t2, lts: o2, firstDecodeFrame: Math.max(o2 - r2.startTime, 0), apEnd: Math.max(n2.apEnd - r2.startTime, 0), apStart: Math.max(n2.apStart - r2.startTime, 0), joinGwEnd: Math.max(n2.joinGwEnd - r2.startTime, 0), joinGwStart: Math.max(n2.joinGwStart - r2.startTime, 0), pcEnd: Math.max(n2.pcEnd - r2.startTime, 0), pcStart: Math.max(n2.pcStart - r2.startTime, 0), subscriberEnd: Math.max(n2.subscriberEnd - r2.startTime, 0), subscriberStart: Math.max(n2.subscriberStart - r2.startTime, 0), videoAddNotify: Math.max(n2.videoAddNotify - r2.startTime, 0) });
          this.send({ type: i2, data: a2 }, true);
        }
        firstRemoteFrame(e2, t2, i2, n2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2) return;
          const s2 = r2.info, o2 = Date.now(), a2 = QC(QC(QC({}, s2), n2), {}, { elapse: o2 - r2.startTime, eventType: t2, lts: o2 });
          this.send({ type: i2, data: a2 }, true);
        }
        pcStats(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), s2 = QC(QC(QC({}, n2), t2), {}, { vid: void 0 === n2.vid ? 0 : Number(n2.vid), elapse: r2 - i2.startTime, eventType: YC.PC_STATS, lts: r2 });
          this.send({ type: qC.PC_STATS, data: s2 }, true);
        }
        updateRemoteRTPCapabilities(e2, t2) {
          if (e2) {
            const i2 = this.baseInfoMap.get(e2);
            if (!i2) return;
            const n2 = i2.info, r2 = Date.now(), s2 = QC(QC(QC({}, n2), t2), {}, { vid: void 0 === n2.vid ? 0 : Number(n2.vid), eventType: YC.UPDATE_REMOTE_RTPCAPABILITIES, lts: r2 });
            this.send({ type: qC.UPDATE_REMOTE_RTPCAPABILITIES, data: s2 }, true);
          }
        }
        onGatewayStream(e2, t2, i2, n2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2) return;
          const s2 = r2.info, o2 = Date.now(), a2 = QC(QC(QC({}, s2), n2), {}, { eventType: t2, lts: o2 });
          this.send({ type: i2, data: a2 }, true);
        }
        streamSwitch(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), s2 = QC(QC({}, n2), {}, { eventType: YC.STREAM_SWITCH, lts: r2, isDual: t2.isdual, elapse: r2 - i2.startTime, success: t2.succ });
          this.send({ type: qC.STREAM_SWITCH, data: s2 }, true);
        }
        requestProxyAppCenter(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), s2 = QC(QC({}, n2), {}, { eventType: YC.REQUEST_PROXY_APPCENTER, lts: r2, eventElapse: r2 - t2.lts, elapse: r2 - i2.startTime, APAddr: t2.APAddr, workerManagerList: t2.workerManagerList, response: t2.response, errorCode: t2.ec, success: t2.succ });
          this.send({ type: qC.REQUEST_PROXY_APPCENTER, data: s2 }, true);
        }
        requestProxyWorkerManager(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), s2 = QC(QC({}, n2), {}, { eventType: YC.REQUEST_PROXY_WORKER_MANAGER, lts: r2, eventElapse: r2 - t2.lts, elapse: r2 - i2.startTime, workerManagerAddr: t2.workerManagerAddr, response: t2.response, errorCode: t2.ec, success: t2.succ });
          this.send({ type: qC.REQUEST_PROXY_WORKER_MANAGER, data: s2 }, true);
        }
        setProxyServer(e2) {
          this.proxyServer = e2, e2 ? jC.debug("reportProxyServerurl: ".concat(e2)) : jC.debug("disable reportProxyServerurl: ".concat(e2));
        }
        peerPublishStatus(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), s2 = QC(QC({}, n2), {}, { subscribeElapse: t2.subscribeElapse, peer: t2.peer, peerPublishDuration: Math.max(t2.audioPublishDuration, t2.videoPublishDuration), audiotag: t2.audioPublishDuration > 0 ? 1 : -1, videotag: t2.videoPublishDuration > 0 ? 1 : -1, lts: r2, elapse: r2 - i2.startTime, joinChannelSuccessElapse: r2 - (i2.lastJoinSuccessTime || r2), peerPublishDurationVideo: t2.videoPublishDuration, peerPublishDurationAudio: t2.audioPublishDuration });
          this.send({ type: qC.PEER_PUBLISH_STATUS, data: s2 }, true);
        }
        workerEvent(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), s2 = function(e3, t3, i3) {
            const n3 = e3[t3];
            if (!n3 || "string" != typeof n3) return [e3];
            e3[t3] = "";
            const r3 = $T(JSON.stringify(e3));
            let s3 = 0;
            const o2 = [];
            let a2 = 0;
            for (let c2 = 0; c2 < n3.length; c2++) a2 += n3.charCodeAt(c2) <= 127 ? 1 : 3, a2 <= i3 - r3 || (o2[o2.length] = GT(GT({}, e3), {}, { [t3]: n3.substring(s3, c2) }), s3 = c2, a2 = n3.charCodeAt(c2) <= 127 ? 1 : 3);
            return s3 !== n3.length - 1 && (o2[o2.length] = GT(GT({}, e3), {}, { [t3]: n3.substring(s3) })), o2;
          }(QC(QC(QC({}, n2), t2), {}, { elapse: r2 - i2.startTime, lts: r2, productType: "WebRTC" }), "payload", 1300);
          s2.forEach((e3) => this.send({ type: qC.WORKER_EVENT, data: e3 }, true));
        }
        apworkerEvent(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), s2 = QC(QC(QC({}, n2), t2), {}, { elapse: r2 - i2.startTime, lts: r2 });
          this.send({ type: qC.AP_WORKER_EVENT, data: s2 }, true);
        }
        joinWebProxyAP(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), s2 = QC(QC(QC({}, n2), t2), {}, { elapse: r2 - i2.startTime, lts: r2, extend: t2.extend || void 0 });
          this.send({ type: qC.JOIN_WEB_PROXY_AP, data: s2 }, true);
        }
        WebSocketQuit(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), s2 = QC(QC(QC({}, n2), t2), {}, { elapse: r2 - i2.startTime, lts: r2 });
          this.send({ type: qC.WEBSOCKET_QUIT, data: s2 }, true);
        }
        async sendCustomReportMessage(e2, t2) {
          if (this.customReportCount += t2.length, this.customReportCount > RC("CUSTOM_REPORT_LIMIT")) throw new Kg(Hg.CUSTOM_REPORT_FREQUENCY_TOO_HIGH);
          this.customReportCounterTimer || (this.customReportCounterTimer = window.setInterval(() => {
            this.customReportCount = 0;
          }, 5e3));
          const i2 = Date.now(), n2 = t2.map((t3) => ({ type: qC.USER_ANALYTICS, data: QC(QC({ sid: e2 }, t3), {}, { lts: i2 }) }));
          try {
            RC("NEW_REPORT_SERVER") ? await this.postDataToStatsCollector2(n2) : await this.postDataToStatsCollector(n2);
          } catch (e3) {
            throw jC.error("send custom report message failed", e3.toString()), new Kg(Hg.CUSTOM_REPORT_SEND_FAILED, e3.message);
          }
        }
        sendApiInvoke(e2) {
          const t2 = RC("NOT_REPORT_EVENT");
          if (e2.tag && bn(t2) && bn(t2).call(t2, e2.tag)) return false;
          if (null === e2.sid) return this.apiInvokeUploadPendingItems.push(e2), false;
          const i2 = this.baseInfoMap.get(e2.sid);
          if (!i2) return this.apiInvokeUploadPendingItems.push(e2), false;
          const { cname: n2, uid: r2, cid: s2 } = i2.info;
          let o2;
          if (e2.lts = e2.lts || Date.now(), e2.error) if (e2.error instanceof Kg) {
            const { code: t3, message: i3 } = e2.error;
            o2 = t3 || (i3 || e2.error.toString());
          } else o2 = e2.error.toString();
          const a2 = { invokeId: e2.invokeId, sid: e2.sid, cname: n2, cid: s2, uid: r2, lts: e2.lts, success: e2.success, elapse: e2.lts - i2.startTime, execElapse: e2.lts - e2.apiInvokeTime, apiName: e2.name, options: e2.options ? JSON.stringify(e2.options) : void 0, execStates: e2.states ? JSON.stringify(e2.states) : void 0, execResult: e2.result ? JSON.stringify(e2.result) : void 0, errorCode: e2.error ? o2 : void 0, errorMsg: e2.error ? JSON.stringify(e2.error) : void 0 };
          return this.send({ type: qC.API_INVOKE, data: a2 }, false), true;
        }
        appendSessionId() {
          ZC.__CLIENT_LIST__.forEach((e2) => {
            if (e2._sessionId) {
              const t2 = this.apiInvokeUploadPendingItems.length;
              for (let i2 = 0; i2 < t2; i2++) {
                const t3 = this.apiInvokeUploadPendingItems.shift();
                t3 && (t3.sid = e2._sessionId, this.sendApiInvoke(Object.assign({}, t3)));
              }
            }
          });
        }
        send(e2, t2) {
          if (t2) return this.keyEventUploadPendingItems.push(e2), void this.sendItems(this.keyEventUploadPendingItems, true);
          this.normalEventUploadPendingItems.push(e2), this.normalEventUploadPendingItems.length > RC("NORMAL_EVENT_QUEUE_CAPACITY") && this.normalEventUploadPendingItems.splice(0, 1), this.normalEventUploadPendingItems.length >= 10 && this.sendItems(this.normalEventUploadPendingItems, false);
        }
        doSend() {
          this.keyEventUploadPendingItems.length > 0 && this.sendItems(this.keyEventUploadPendingItems, true), this.normalEventUploadPendingItems.length > 0 && Date.now() - this.lastSendNormalEventTime >= 5e3 && this.sendItems(this.normalEventUploadPendingItems, false);
        }
        sendItems(e2, t2) {
          const i2 = [], n2 = [];
          for (; e2.length; ) {
            const t3 = e2.shift();
            i2.length < 20 ? i2.push(t3) : n2.push(t3);
          }
          e2.push(...n2);
          for (const e3 of [...i2]) {
            var r2;
            if (-1 !== this.ltsList.indexOf(e3.data.lts)) e3.data.lts = this.ltsList[this.ltsList.length - 1] + 1, this.ltsList.push(e3.data.lts);
            else this.ltsList.push(e3.data.lts), ep(r2 = this.ltsList).call(r2, (e4, t3) => e4 - t3);
          }
          t2 || (this.lastSendNormalEventTime = Date.now());
          return RC("ENABLE_EVENT_REPORT") ? (i2.length && (RC("NEW_REPORT_SERVER") ? this.postDataToStatsCollector2(i2) : this.postDataToStatsCollector(i2)).catch(/* @__PURE__ */ ((e3) => (i3) => {
            RC("EVENT_REPORT_RETRY") && (t2 ? this.keyEventUploadPendingItems = this.keyEventUploadPendingItems.concat(e3) : (this.normalEventUploadPendingItems = this.normalEventUploadPendingItems.concat(e3), this.normalEventUploadPendingItems.length > RC("NORMAL_EVENT_QUEUE_CAPACITY") && (this.normalEventUploadPendingItems.splice(0, this.normalEventUploadPendingItems.length - RC("NORMAL_EVENT_QUEUE_CAPACITY")), jC.warning("report: drop normal events"))));
          })(i2)), e2) : e2;
        }
        async postDataToStatsCollector2(e2) {
          wT.networkState === gT.OFFLINE && await cg.race([wT.onlineWaiter, iS(2 * ES.maxRetryTimeout)]);
          const t2 = (e3) => {
            let t3 = new Uint8Array();
            return e3.forEach((e4) => {
              const i3 = sT(JSON.stringify(e4.data)), n3 = new ArrayBuffer(5), r2 = ((e5) => {
                let t4 = 0;
                return Object.entries(qC).forEach((i4) => {
                  let [n4, r3] = i4;
                  r3 === e5.type && (t4 = EventNameToID[n4]);
                }), t4;
              })(e4), s2 = new DataView(n3);
              s2.setUint16(0, i3.byteLength, true), s2.setUint8(2, 255 & r2), s2.setUint8(3, r2 >>> 8 & 255), s2.setUint8(4, r2 >>> 16 & 255), t3 = oT(t3, new Uint8Array(n3)), t3 = oT(t3, i3);
            }), t3;
          }, i2 = "event";
          let n2 = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(RC("NEW_REPORT_SERVER_DOMAINS")[0], "&p=443&d=").concat(i2) : "https://".concat(RC("NEW_REPORT_SERVER_DOMAINS")[0], "/").concat(i2);
          for (let r2 = 0; r2 < 2; r2 += 1) {
            1 === r2 && (n2 = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(RC("NEW_REPORT_SERVER_DOMAINS")[1], "&p=443&d=").concat(i2) : "https://".concat(RC("NEW_REPORT_SERVER_DOMAINS")[1], "/").concat(i2));
            try {
              await uC(n2, { timeout: 1e4, data: t2(e2), headers: QC(QC({ biz: "webrtc", sendts: Math.round(Date.now() / 1e3), debug: "false" }, this._appId && { appid: this._appId }), {}, { "Content-Type": "application/octet-stream" }) }, true);
            } catch (e3) {
              if (1 === r2) throw e3;
              continue;
            }
            return;
          }
        }
        async postDataToStatsCollector(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          const i2 = { msgType: "EventMessages", sentTs: Math.round(Date.now() / 1e3), payloads: e2.map((e3) => JSON.stringify(e3)), vid: ((e3) => {
            const t3 = e3 && e3.data.sid && this.baseInfoMap.get(e3.data.sid);
            return t3 && t3.info.vid && +t3.info.vid || 0;
          })(e2[0]) };
          wT.networkState === gT.OFFLINE && await cg.race([wT.onlineWaiter, iS(2 * ES.maxRetryTimeout)]);
          const n2 = t2 ? "/events/proto-raws" : "/events/messages";
          let r2 = this.url || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(RC("EVENT_REPORT_DOMAIN"), "&p=").concat(RC("STATS_COLLECTOR_PORT"), "&d=").concat(n2) : "https://".concat(RC("EVENT_REPORT_DOMAIN"), ":").concat(RC("STATS_COLLECTOR_PORT")).concat(n2));
          for (let e3 = 0; e3 < 2; e3 += 1) {
            1 === e3 && (r2 = this.backupUrl || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(RC("EVENT_REPORT_BACKUP_DOMAIN"), "&p=").concat(RC("STATS_COLLECTOR_PORT"), "&d=").concat(n2) : "https://".concat(RC("EVENT_REPORT_BACKUP_DOMAIN"), ":").concat(RC("STATS_COLLECTOR_PORT")).concat(n2)));
            try {
              t2 ? await hC(r2, { timeout: 1e4, data: i2 }) : await uC(r2, { timeout: 1e4, data: i2 });
            } catch (t3) {
              if (1 === e3) throw t3;
              continue;
            }
            return;
          }
        }
        createBaseInfo(e2, t2) {
          const i2 = Object.assign({}, KC);
          return i2.sid = e2, this.baseInfoMap.set(e2, { info: i2, startTime: t2 }), i2;
        }
        reportResourceTiming(e2, t2) {
          const i2 = performance.getEntriesByName(e2), n2 = i2[i2.length - 1];
          n2 && this.reportApiInvoke(t2, { name: "Client.resourceTiming", options: n2, tag: pT.TRACER }).onSuccess();
        }
      }
      function $C() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        return function(t2, i2, n2) {
          const r2 = n2.value;
          if ("function" == typeof r2) {
            const s2 = e2.className || t2.__className__ || ("AgoraRTCClient" === t2.constructor.name ? "Client" : t2.constructor.name);
            n2.value = function() {
              for (var t3 = arguments.length, n3 = new Array(t3), o2 = 0; o2 < t3; o2++) n3[o2] = arguments[o2];
              let a2 = n3;
              if (e2.argsMap) try {
                a2 = e2.argsMap(this, ...n3);
              } catch (e3) {
                jC.warning(e3), a2 = [];
              }
              try {
                JSON.stringify(a2);
              } catch (e3) {
                jC.warning("arguments for method ".concat(s2, ".").concat(String(i2), " not serializable for apiInvoke.")), a2 = [];
              }
              const c2 = (e2.report || eI).reportApiInvoke(this._sessionId || null, { name: "".concat(s2, ".").concat(String(i2)), options: a2, tag: pT.TRACER, reportResult: e2.reportResult }, e2.throttleTime);
              try {
                const t4 = r2.apply(this, n3);
                return t4 instanceof cg ? t4.then((t5) => (c2.onSuccess(e2.reportResult && t5), t5)).catch((e3) => {
                  throw c2.onError(e3), e3;
                }) : (c2.onSuccess(e2.reportResult && t4), t4);
              } catch (e3) {
                throw c2.onError(e3), e3;
              }
            };
          }
          return n2;
        };
      }
      sh(ZC, "__CLIENT_LIST__", []);
      const eI = new ZC();
      kC.on("REPORT_LOG_UPLOAD", (e2) => {
        e2.networkState = wT.networkState, eI.reportApiInvoke(null, { name: "logUploadError", options: e2, tag: pT.TRACER });
      });
      const tI = ["CHINA", "GLOBAL"], iI = function() {
        const e2 = "us".concat("erna", "me"), t2 = "pa".concat("sswo", "rd"), i2 = ["t", "s", "t"];
        i2.splice(1, 0, "e");
        const n2 = i2.join(""), r2 = [];
        for (let e3 = 0; e3 < 6; e3++) r2.push("1");
        const s2 = r2.join(""), o2 = {};
        return o2[e2] = n2, o2[t2] = s2, Object.assign(o2, { turnServerURL: "", tcpport: 3433, udpport: 3478, forceturn: false });
      }();
      window.DEFAULT_TURN_CONFIG = iI, mC || (TC.WEBCS_DOMAIN = ["ap-web-1-oversea.agora.io", "ap-web-1-north-america.agora.io"], TC.WEBCS_DOMAIN_BACKUP_LIST = ["ap-web-2-oversea.agora.io", "ap-web-2-north-america.agora.io"], TC.PROXY_CS = ["proxy-ap-web-oversea.agora.io", "proxy-ap-web-america.agora.io"], TC.CDS_AP = ["cds-ap-web-oversea.agora.io", "cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], TC.ACCOUNT_REGISTER = ["sua-ap-web-oversea.agora.io", "sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], TC.UAP_AP = ["uap-ap-web-oversea.agora.io", "uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], TC.LOG_UPLOAD_SERVER = "logservice-oversea.agora.io", TC.EVENT_REPORT_DOMAIN = "statscollector-1-oversea.agora.io", TC.EVENT_REPORT_BACKUP_DOMAIN = "statscollector-2-oversea.agora.io", TC.PROXY_SERVER_TYPE3 = "webrtc-cloud-proxy.agora.io", TC.AREAS = ["NORTH_AMERICA", "OVERSEA"]);
      const nI = [[0, 1, 2, 3, 4, 5, 5], [0, 2, 2, 3, 4, 5, 5], [0, 3, 3, 3, 4, 5, 5], [0, 4, 4, 4, 4, 5, 5], [0, 5, 5, 5, 5, 5, 5]], rI = [];
      function sI(e2, t2) {
        return !!t2 && rI.some((i2) => i2.uid === e2 && i2.channelName === t2);
      }
      ZC.__CLIENT_LIST__ = rI;
      var oI, aI, cI, dI, lI, uI, hI, pI, _I, EI, mI, fI, gI, TI, SI, RI, CI, II = zi("Array").values, vI = ln, yI = Ze, AI = l, bI = II, wI = Array.prototype, OI = { DOMTokenList: true, NodeList: true }, NI = i(function(e2) {
        var t2 = e2.values;
        return e2 === wI || AI(wI, e2) && t2 === wI.values || yI(OI, vI(e2)) ? bI : t2;
      });
      function DI(e2, t2, i2, n2) {
        var r2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e2, t2, i2, n2);
        else for (var a2 = e2.length - 1; a2 >= 0; a2--) (r2 = e2[a2]) && (o2 = (s2 < 3 ? r2(o2) : s2 > 3 ? r2(t2, i2, o2) : r2(t2, i2)) || o2);
        return s2 > 3 && o2 && Object.defineProperty(t2, i2, o2), o2;
      }
      function PI(e2, t2) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e2, t2);
      }
      !function(e2) {
        e2.L1T1 = "L1T1", e2.L1T2 = "L1T2", e2.L1T3 = "L1T3", e2.L2T1_KEY = "L2T1_KEY", e2.L2T2_KEY = "L2T2_KEY", e2.L2T3_KEY = "L2T3_KEY", e2.L3T1_KEY = "L3T1_KEY", e2.L3T2_KEY = "L3T2_KEY", e2.L3T3_KEY = "L3T3_KEY";
      }(oI || (oI = {})), function(e2) {
        e2.CERTIFICATE = "certificate", e2.CODEC = "codec", e2.CANDIDATE_PAIR = "candidate-pair", e2.LOCAL_CANDIDATE = "local-candidate", e2.REMOTE_CANDIDATE = "remote-candidate", e2.INBOUND = "inbound-rtp", e2.TRACK = "track", e2.OUTBOUND = "outbound-rtp", e2.PC = "peer-connection", e2.REMOTE_INBOUND = "remote-inbound-rtp", e2.REMOTE_OUTBOUND = "remote-outbound-rtp", e2.TRANSPORT = "transport", e2.CSRC = "csrc", e2.DATA_CHANNEL = "data-channel", e2.STREAM = "stream", e2.SENDER = "sender", e2.RECEIVER = "receiver";
      }(aI || (aI = {})), function(e2) {
        e2[e2.ACCESS_POINT = 101] = "ACCESS_POINT", e2[e2.UNILBS = 201] = "UNILBS", e2[e2.STRING_UID_ALLOCATOR = 901] = "STRING_UID_ALLOCATOR";
      }(cI || (cI = {})), function(e2) {
        e2[e2.IIIEGAL_APPID = 1] = "IIIEGAL_APPID", e2[e2.IIIEGAL_UID = 2] = "IIIEGAL_UID", e2[e2.INTERNAL_ERROR = 3] = "INTERNAL_ERROR";
      }(dI || (dI = {})), function(e2) {
        e2[e2.INVALID_VENDOR_KEY = 5] = "INVALID_VENDOR_KEY", e2[e2.INVALID_CHANNEL_NAME = 7] = "INVALID_CHANNEL_NAME", e2[e2.INTERNAL_ERROR = 8] = "INTERNAL_ERROR", e2[e2.NO_AUTHORIZED = 9] = "NO_AUTHORIZED", e2[e2.DYNAMIC_KEY_TIMEOUT = 10] = "DYNAMIC_KEY_TIMEOUT", e2[e2.NO_ACTIVE_STATUS = 11] = "NO_ACTIVE_STATUS", e2[e2.DYNAMIC_KEY_EXPIRED = 13] = "DYNAMIC_KEY_EXPIRED", e2[e2.STATIC_USE_DYNAMIC_KEY = 14] = "STATIC_USE_DYNAMIC_KEY", e2[e2.DYNAMIC_USE_STATIC_KEY = 15] = "DYNAMIC_USE_STATIC_KEY", e2[e2.USER_OVERLOAD = 16] = "USER_OVERLOAD", e2[e2.FORBIDDEN_REGION = 18] = "FORBIDDEN_REGION", e2[e2.CANNOT_MEET_AREA_DEMAND = 19] = "CANNOT_MEET_AREA_DEMAND";
      }(lI || (lI = {})), function(e2) {
        e2[e2.NO_FLAG_SET = 100] = "NO_FLAG_SET", e2[e2.FLAG_SET_BUT_EMPTY = 101] = "FLAG_SET_BUT_EMPTY", e2[e2.INVALID_FALG_SET = 102] = "INVALID_FALG_SET", e2[e2.FLAG_SET_BUT_NO_RE = 103] = "FLAG_SET_BUT_NO_RE", e2[e2.INVALID_SERVICE_ID = 104] = "INVALID_SERVICE_ID", e2[e2.NO_SERVICE_AVAILABLE = 200] = "NO_SERVICE_AVAILABLE", e2[e2.NO_SERVICE_AVAILABLE_P2P = 201] = "NO_SERVICE_AVAILABLE_P2P", e2[e2.NO_SERVICE_AVAILABLE_VOICE = 202] = "NO_SERVICE_AVAILABLE_VOICE", e2[e2.NO_SERVICE_AVAILABLE_WEBRTC = 203] = "NO_SERVICE_AVAILABLE_WEBRTC", e2[e2.NO_SERVICE_AVAILABLE_CDS = 204] = "NO_SERVICE_AVAILABLE_CDS", e2[e2.NO_SERVICE_AVAILABLE_CDN = 205] = "NO_SERVICE_AVAILABLE_CDN", e2[e2.NO_SERVICE_AVAILABLE_TDS = 206] = "NO_SERVICE_AVAILABLE_TDS", e2[e2.NO_SERVICE_AVAILABLE_REPORT = 207] = "NO_SERVICE_AVAILABLE_REPORT", e2[e2.NO_SERVICE_AVAILABLE_APP_CENTER = 208] = "NO_SERVICE_AVAILABLE_APP_CENTER", e2[e2.NO_SERVICE_AVAILABLE_ENV0 = 209] = "NO_SERVICE_AVAILABLE_ENV0", e2[e2.NO_SERVICE_AVAILABLE_VOET = 210] = "NO_SERVICE_AVAILABLE_VOET", e2[e2.NO_SERVICE_AVAILABLE_STRING_UID = 211] = "NO_SERVICE_AVAILABLE_STRING_UID", e2[e2.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS = 212] = "NO_SERVICE_AVAILABLE_WEBRTC_UNILBS", e2[e2.NO_SERVICE_AVAILABLE_UNILBS_FLV = 213] = "NO_SERVICE_AVAILABLE_UNILBS_FLV";
      }(uI || (uI = {})), function(e2) {
        e2[e2.K_TIMESTAMP_EXPIRED = 2] = "K_TIMESTAMP_EXPIRED", e2[e2.K_CHANNEL_PERMISSION_INVALID = 3] = "K_CHANNEL_PERMISSION_INVALID", e2[e2.K_CERTIFICATE_INVALID = 4] = "K_CERTIFICATE_INVALID", e2[e2.K_CHANNEL_NAME_EMPTY = 5] = "K_CHANNEL_NAME_EMPTY", e2[e2.K_CHANNEL_NOT_FOUND = 6] = "K_CHANNEL_NOT_FOUND", e2[e2.K_TICKET_INVALID = 7] = "K_TICKET_INVALID", e2[e2.K_CHANNEL_CONFLICTED = 8] = "K_CHANNEL_CONFLICTED", e2[e2.K_SERVICE_NOT_READY = 9] = "K_SERVICE_NOT_READY", e2[e2.K_SERVICE_TOO_HEAVY = 10] = "K_SERVICE_TOO_HEAVY", e2[e2.K_UID_BANNED = 14] = "K_UID_BANNED", e2[e2.K_IP_BANNED = 15] = "K_IP_BANNED", e2[e2.K_CHANNEL_BANNED = 16] = "K_CHANNEL_BANNED", e2[e2.K_AUTO_REBALANCE = 28] = "K_AUTO_REBALANCE", e2[e2.WARN_NO_AVAILABLE_CHANNEL = 103] = "WARN_NO_AVAILABLE_CHANNEL", e2[e2.WARN_LOOKUP_CHANNEL_TIMEOUT = 104] = "WARN_LOOKUP_CHANNEL_TIMEOUT", e2[e2.WARN_LOOKUP_CHANNEL_REJECTED = 105] = "WARN_LOOKUP_CHANNEL_REJECTED", e2[e2.WARN_OPEN_CHANNEL_TIMEOUT = 106] = "WARN_OPEN_CHANNEL_TIMEOUT", e2[e2.WARN_OPEN_CHANNEL_REJECTED = 107] = "WARN_OPEN_CHANNEL_REJECTED", e2[e2.WARN_REQUEST_DEFERRED = 108] = "WARN_REQUEST_DEFERRED", e2[e2.ERR_DYNAMIC_KEY_TIMEOUT = 109] = "ERR_DYNAMIC_KEY_TIMEOUT", e2[e2.ERR_NO_AUTHORIZED = 110] = "ERR_NO_AUTHORIZED", e2[e2.ERR_VOM_SERVICE_UNAVAILABLE = 111] = "ERR_VOM_SERVICE_UNAVAILABLE", e2[e2.ERR_NO_CHANNEL_AVAILABLE_CODE = 112] = "ERR_NO_CHANNEL_AVAILABLE_CODE", e2[e2.ERR_MASTER_VOCS_UNAVAILABLE = 114] = "ERR_MASTER_VOCS_UNAVAILABLE", e2[e2.ERR_INTERNAL_ERROR = 115] = "ERR_INTERNAL_ERROR", e2[e2.ERR_NO_ACTIVE_STATUS = 116] = "ERR_NO_ACTIVE_STATUS", e2[e2.ERR_INVALID_UID = 117] = "ERR_INVALID_UID", e2[e2.ERR_DYNAMIC_KEY_EXPIRED = 118] = "ERR_DYNAMIC_KEY_EXPIRED", e2[e2.ERR_STATIC_USE_DYANMIC_KE = 119] = "ERR_STATIC_USE_DYANMIC_KE", e2[e2.ERR_DYNAMIC_USE_STATIC_KE = 120] = "ERR_DYNAMIC_USE_STATIC_KE", e2[e2.ERR_NO_VOCS_AVAILABLE = 2e3] = "ERR_NO_VOCS_AVAILABLE", e2[e2.ERR_NO_VOS_AVAILABLE = 2001] = "ERR_NO_VOS_AVAILABLE", e2[e2.ERR_JOIN_CHANNEL_TIMEOUT = 2002] = "ERR_JOIN_CHANNEL_TIMEOUT", e2[e2.ERR_REPEAT_JOIN_CHANNEL = 2003] = "ERR_REPEAT_JOIN_CHANNEL", e2[e2.ERR_JOIN_BY_MULTI_IP = 2004] = "ERR_JOIN_BY_MULTI_IP", e2[e2.ERR_NOT_JOINED = 2011] = "ERR_NOT_JOINED", e2[e2.ERR_REPEAT_JOIN_REQUEST = 2012] = "ERR_REPEAT_JOIN_REQUEST", e2[e2.ERR_INVALID_VENDOR_KEY = 2013] = "ERR_INVALID_VENDOR_KEY", e2[e2.ERR_INVALID_CHANNEL_NAME = 2014] = "ERR_INVALID_CHANNEL_NAME", e2[e2.ERR_INVALID_STRINGUID = 2015] = "ERR_INVALID_STRINGUID", e2[e2.ERR_TOO_MANY_USERS = 2016] = "ERR_TOO_MANY_USERS", e2[e2.ERR_SET_CLIENT_ROLE_TIMEOUT = 2017] = "ERR_SET_CLIENT_ROLE_TIMEOUT", e2[e2.ERR_SET_CLIENT_ROLE_NO_PERMISSION = 2018] = "ERR_SET_CLIENT_ROLE_NO_PERMISSION", e2[e2.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE = 2019] = "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", e2[e2.ERR_PUBLISH_REQUEST_INVALID = 2020] = "ERR_PUBLISH_REQUEST_INVALID", e2[e2.ERR_SUBSCRIBE_REQUEST_INVALID = 2021] = "ERR_SUBSCRIBE_REQUEST_INVALID", e2[e2.ERR_NOT_SUPPORTED_MESSAGE = 2022] = "ERR_NOT_SUPPORTED_MESSAGE", e2[e2.ERR_ILLEAGAL_PLUGIN = 2023] = "ERR_ILLEAGAL_PLUGIN", e2[e2.ERR_REJOIN_TOKEN_INVALID = 2024] = "ERR_REJOIN_TOKEN_INVALID", e2[e2.ERR_REJOIN_USER_NOT_JOINED = 2025] = "ERR_REJOIN_USER_NOT_JOINED", e2[e2.ERR_INVALID_OPTIONAL_INFO = 2027] = "ERR_INVALID_OPTIONAL_INFO", e2[e2.ILLEGAL_AES_PASSWORD = 2028] = "ILLEGAL_AES_PASSWORD", e2[e2.ILLEGAL_CLIENT_ROLE_LEVEL = 2029] = "ILLEGAL_CLIENT_ROLE_LEVEL", e2[e2.ERR_TOO_MANY_BROADCASTERS = 2031] = "ERR_TOO_MANY_BROADCASTERS", e2[e2.ERR_TOO_MANY_SUBSCRIBERS = 2032] = "ERR_TOO_MANY_SUBSCRIBERS", e2[e2.ERR_LICENSE_MISSING = 32769] = "ERR_LICENSE_MISSING", e2[e2.ERR_LICENSE_EXPIRED = 32771] = "ERR_LICENSE_EXPIRED", e2[e2.ERR_LICENSE_MINUTES_EXCEEDED = 32773] = "ERR_LICENSE_MINUTES_EXCEEDED", e2[e2.ERR_LICENSE_PERIOD_INVALID = 32774] = "ERR_LICENSE_PERIOD_INVALID", e2[e2.ERR_LICENSE_MULTIPLE_SDK_SERVICE = 32778] = "ERR_LICENSE_MULTIPLE_SDK_SERVICE", e2[e2.ERR_LICENSE_ILLEGAL = 32783] = "ERR_LICENSE_ILLEGAL", e2[e2.ERR_TEST_RECOVER = 9e3] = "ERR_TEST_RECOVER", e2[e2.ERR_TEST_TRYNEXT = 9001] = "ERR_TEST_TRYNEXT", e2[e2.ERR_TEST_RETRY = 9002] = "ERR_TEST_RETRY";
      }(hI || (hI = {})), function(e2) {
        e2.CONNECTING = "connecting", e2.CONNECTED = "connected", e2.RECONNECTING = "reconnecting", e2.CLOSED = "closed";
      }(pI || (pI = {})), function(e2) {
        e2.WS_CONNECTED = "ws_connected", e2.WS_RECONNECTING = "ws_reconnecting", e2.WS_CLOSED = "ws_closed", e2.WS_RECONNECT_WAITTING_FINISH = "ws_reconnect_waitting_finish", e2.WS_RECONNECT_CREATE_CONNECTION = "ws_reconnect_create_connection", e2.ON_BINARY_DATA = "on_binary_data", e2.REQUEST_RECOVER = "request_recover", e2.REQUEST_JOIN_INFO = "request_join_info", e2.REQUEST_REJOIN_INFO = "req_rejoin_info", e2.IS_P2P_DISCONNECTED = "is_p2p_dis", e2.DISCONNECT_P2P = "dis_p2p", e2.ABORT_P2P_EXECUTION = "abort_p2p_execution", e2.NEED_RENEW_SESSION = "need-sid", e2.REPORT_JOIN_GATEWAY = "report_join_gateway", e2.REQUEST_TIMEOUT = "request_timeout", e2.REQUEST_SUCCESS = "request_success", e2.JOIN_RESPONSE = "join_response", e2.DATACHANNEL_PRECONNECT = "datachannel_preconnect", e2.DATACHANNEL_CONNECTING = "datachannel_connecting", e2.DATACHANNEL_FAILBACK = "datachannel_failback", e2.P2P_CONNECTION = "p2p_connection", e2.P2P_REMOTE_CANDIDATE_UPDATE = "p2p_remote_candidate_update", e2.P2P_SUBSCRIBE = "p2p_subscribe", e2.P2P_UNSUBSCRIBE = "p2p_unsubscribe", e2.P2P_EXCHANGE_SDP = "p2p_exchange_sdp", e2.P2P_ON_ADD_VIDEO_STREAM = "p2p_on_add_video_stream", e2.P2P_ON_ADD_AUDIO_STREAM = "p2p_on_add_audio_stream";
      }(_I || (_I = {})), function(e2) {
        e2.PING = "ping", e2.PING_BACK = "ping_back", e2.JOIN = "join_v3", e2.REJOIN = "rejoin_v3", e2.LEAVE = "leave", e2.SET_CLIENT_ROLE = "set_client_role", e2.PUBLISH = "publish", e2.PUBLISH_DATASTREAM = "publish_datastream", e2.UNPUBLISH = "unpublish", e2.UNPUBLISH_DATASTREAM = "unpublish_datastream", e2.SUBSCRIBE = "subscribe", e2.PRE_SUBSCRIBE = "pre_subscribe", e2.SUBSCRIBE_DATASTREAM = "subscribe_datastream", e2.SUBSCRIBE_STREAMS = "subscribe_streams", e2.UNSUBSCRIBE = "unsubscribe", e2.UNSUBSCRIBE_DATASTREAM = "unsubscribe_datastream", e2.UNSUBSCRIBE_STREAMS = "unsubscribe_streams", e2.SUBSCRIBE_CHANGE = "subscribe_change", e2.TRAFFIC_STATS = "traffic_stats", e2.RENEW_TOKEN = "renew_token", e2.SWITCH_VIDEO_STREAM = "switch_video_stream", e2.DEFAULT_VIDEO_STREAM = "default_video_stream", e2.SET_FALLBACK_OPTION = "set_fallback_option", e2.GATEWAY_INFO = "gateway_info", e2.CONTROL = "control", e2.SEND_METADATA = "send_metadata", e2.DATA_STREAM = "data_stream", e2.PICK_SVC_LAYER = "pick_svc_layer", e2.RESTART_ICE = "restart_ice", e2.CONNECT_PC = "connect_pc", e2.SET_VIDEO_PROFILE = "set_video_profile", e2.SET_PARAMETER = "set_parameter", e2.SET_RTM2_FLAG = "set_rtm2_flag";
      }(EI || (EI = {})), function(e2) {
        e2.WRTC_STATS = "wrtc_stats", e2.WS_INFLATE_DATA_LENGTH = "ws_inflate_data_length", e2.DENOISER_STATS = "denoiser_stats", e2.EXTENSION_USAGE_STATS = "extension_usage_stats";
      }(mI || (mI = {})), function(e2) {
        e2.ON_USER_ONLINE = "on_user_online", e2.ON_USER_OFFLINE = "on_user_offline", e2.ON_STREAM_FALLBACK_UPDATE = "on_stream_fallback_update", e2.ON_PUBLISH_STREAM = "on_publish_stream", e2.ON_UPLINK_STATS = "on_uplink_stats", e2.ON_P2P_LOST = "on_p2p_lost", e2.ON_REMOVE_STREAM = "on_remove_stream", e2.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e2.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e2.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "on_token_privilege_will_expire", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "on_token_privilege_did_expire", e2.ON_USER_BANNED = "on_user_banned", e2.ON_USER_LICENSE_BANNED = "on_user_license_banned", e2.ON_NOTIFICATION = "on_notification", e2.ON_CRYPT_ERROR = "on_crypt_error", e2.MUTE_AUDIO = "mute_audio", e2.MUTE_VIDEO = "mute_video", e2.UNMUTE_AUDIO = "unmute_audio", e2.UNMUTE_VIDEO = "unmute_video", e2.ON_P2P_OK = "on_p2p_ok", e2.RECEIVE_METADATA = "receive_metadata", e2.ON_DATA_STREAM = "on_data_stream", e2.ON_RTP_CAPABILITY_CHANGE = "on_rtp_capability_change", e2.ON_REMOTE_DATASTREAM_UPDATE = "on_remote_datastream_update", e2.ON_REMOTE_FULL_DATASTREAM_INFO = "on_remote_full_datastream_info", e2.ENABLE_LOCAL_VIDEO = "enable_local_video", e2.DISABLE_LOCAL_VIDEO = "disable_local_video", e2.ENABLE_LOCAL_AUDIO = "enable_local_audio", e2.DISABLE_LOCAL_AUDIO = "disable_local_audio", e2.ON_PUBLISHED_USER_LIST = "on_published_user_list";
      }(fI || (fI = {})), function(e2) {
        e2.CONNECTION_STATE_CHANGE = "CONNECTION_STATE_CHANGE", e2.NEED_ANSWER = "NEED_ANSWER", e2.NEED_RENEGOTIATE = "NEED_RENEGOTIATE", e2.P2P_LOST = "P2P_LOST", e2.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST", e2.NEED_UNPUB = "NEED_UNPUB", e2.NEED_UNSUB = "NEED_UNSUB", e2.NEED_UPLOAD = "NEED_UPLOAD", e2.NEED_CONTROL = "NEED_CONTROL", e2.START_RECONNECT = "START_RECONNECT", e2.END_RECONNECT = "END_RECONNECT", e2.NEED_SIGNAL_RTT = "NEED_SIGNAL_RTT";
      }(gI || (gI = {})), function(e2) {
        e2.SEND_ONLY = "SEND_ONLY", e2.RECEIVE_ONLY = "RECEIVE_ONLY";
      }(TI || (TI = {})), function(e2) {
        e2.CONNECTED = "websocket:connected", e2.RECONNECTING = "websocket:reconnecting", e2.WILL_RECONNECT = "websocket:will_reconnect", e2.CLOSED = "websocket:closed", e2.FAILED = "websocket:failed", e2.ON_MESSAGE = "websocket:on_message", e2.REQUEST_NEW_URLS = "websocket:request_new_urls", e2.RECONNECT_WAITTING_FINISH = "websocket:reconnect_waitting_finish", e2.RECONNECT_CREATE_CONNECTION = "websocket:reconnect_create_connection", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "websocket:on_token_privilege_did_expire";
      }(SI || (SI = {}));
      class LI extends Kg {
        constructor(e2) {
          super(e2, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", arguments.length > 2 ? arguments[2] : void 0), sh(this, "name", "AgoraRTCException");
        }
        print() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "error";
          return super.print(e2, jC);
        }
        throw() {
          super.throw(jC);
        }
      }
      function kI(e2) {
        if ("string" != typeof e2 || !/^[a-zA-Z0-9 \!\#\$\%\&\(\)\+\-\:\;\<\=\.\>\?\@\[\]\^\_\{\}\|\~\,]{1,64}$/.test(e2)) throw jC.error("Invalid Channel Name ".concat(e2)), new LI(Hg.INVALID_PARAMS, "The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,");
      }
      function MI(e2) {
        if (!(t2 = e2, "number" == typeof t2 && Math.floor(t2) === t2 && 0 <= t2 && t2 <= 4294967295 || $g(e2, 1, 255))) throw new LI(Hg.INVALID_PARAMS, "[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]");
        var t2;
        "string" == typeof e2 && jC.warn("You input a string as the user ID, to ensure better end-user experience, Agora highly suggests not using a string as the user ID.");
      }
      !function(e2) {
        e2.TRANSCODE = "mix_streaming", e2.RAW = "raw_streaming", e2.INJECT = "inject_streaming";
      }(RI || (RI = {})), function(e2) {
        e2[e2.INJECT_STREAM_STATUS_START_SUCCESS = 0] = "INJECT_STREAM_STATUS_START_SUCCESS", e2[e2.INJECT_STREAM_STATUS_START_ALREADY_EXISTS = 1] = "INJECT_STREAM_STATUS_START_ALREADY_EXISTS", e2[e2.INJECT_STREAM_STATUS_START_UNAUTHORIZED = 2] = "INJECT_STREAM_STATUS_START_UNAUTHORIZED", e2[e2.INJECT_STREAM_STATUS_START_TIMEOUT = 3] = "INJECT_STREAM_STATUS_START_TIMEOUT", e2[e2.INJECT_STREAM_STATUS_START_FAILED = 4] = "INJECT_STREAM_STATUS_START_FAILED", e2[e2.INJECT_STREAM_STATUS_STOP_SUCCESS = 5] = "INJECT_STREAM_STATUS_STOP_SUCCESS", e2[e2.INJECT_STREAM_STATUS_STOP_NOT_FOUND = 6] = "INJECT_STREAM_STATUS_STOP_NOT_FOUND", e2[e2.INJECT_STREAM_STATUS_STOP_UNAUTHORIZED = 7] = "INJECT_STREAM_STATUS_STOP_UNAUTHORIZED", e2[e2.INJECT_STREAM_STATUS_STOP_TIMEOUT = 8] = "INJECT_STREAM_STATUS_STOP_TIMEOUT", e2[e2.INJECT_STREAM_STATUS_STOP_FAILED = 9] = "INJECT_STREAM_STATUS_STOP_FAILED", e2[e2.INJECT_STREAM_STATUS_BROKEN = 10] = "INJECT_STREAM_STATUS_BROKEN";
      }(CI || (CI = {}));
      const UI = { alpha: 1, height: 640, width: 360, x: 0, y: 0, zOrder: 0, audioChannel: 0 }, xI = { x: 0, y: 0, width: 160, height: 160, zOrder: 255, alpha: 1 };
      function VI(e2, t2) {
        Xg(e2.url, "".concat(t2, ".url"), 1, 1e3, false), Zg(e2.x) || zg(e2.x, "".concat(t2, ".x"), 0, 1e4), Zg(e2.y) || zg(e2.y, "".concat(t2, ".y"), 0, 1e4), Zg(e2.width) || zg(e2.width, "".concat(t2, ".width"), 0, 1e4), Zg(e2.height) || zg(e2.height, "".concat(t2, ".height"), 0, 1e4), Zg(e2.zOrder) || zg(e2.zOrder, "".concat(t2, ".zOrder"), 0, 255), Zg(e2.alpha) || zg(e2.alpha, "".concat(t2, ".alpha"), 0, 1, false);
      }
      const FI = { audioBitrate: 48, audioChannels: 1, audioSampleRate: 48e3, backgroundColor: 0, height: 360, lowLatency: false, videoBitrate: 400, videoCodecProfile: 100, videoCodecType: 1, videoFrameRate: 15, videoGop: 30, width: 640, images: [], userConfigs: [], userConfigExtraInfo: "" }, BI = { audioBitrate: 48, audioChannels: 2, audioVolume: 100, audioSampleRate: 48e3, height: 0, width: 0, videoBitrate: 400, videoFramerate: 15, videoGop: 30 };
      var jI, GI, WI, HI, KI, YI, qI, zI, JI, XI, QI, ZI, $I, ev;
      function tv(e2) {
        if (!e2.channelName) throw new LI(Hg.INVALID_PARAMS, "invalid channelName in info");
        if ("number" != typeof e2.uid) throw new LI(Hg.INVALID_PARAMS, "invalid uid in info, uid must be a number");
        return e2.token && Xg(e2.token, "info.token", 1, 2047), MI(e2.uid), kI(e2.channelName), true;
      }
      !function(e2) {
        e2.WARNING = "@live_uap-warning", e2.ERROR = "@line_uap-error", e2.PUBLISH_STREAM_STATUS = "@live_uap-publish-status", e2.INJECT_STREAM_STATUS = "@live_uap-inject-status", e2.WORKER_STATUS = "@live_uap-worker-status", e2.REQUEST_NEW_ADDRESS = "@live_uap-request-address";
      }(jI || (jI = {})), function(e2) {
        e2.REQUEST_WORKER_MANAGER_LIST = "@live_req_worker_manager";
      }(GI || (GI = {})), function(e2) {
        e2[e2.LIVE_STREAM_RESPONSE_SUCCEED = 200] = "LIVE_STREAM_RESPONSE_SUCCEED", e2[e2.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM = 454] = "LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM", e2[e2.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR = 450] = "LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_BAD_STREAM = 451] = "LIVE_STREAM_RESPONSE_BAD_STREAM", e2[e2.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR = 400] = "LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST = 404] = "LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST", e2[e2.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED = 456] = "LIVE_STREAM_RESPONSE_NOT_AUTHORIZED", e2[e2.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE = 457] = "LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE", e2[e2.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN = 429] = "LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN", e2[e2.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH = 452] = "LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH", e2[e2.LIVE_STREAM_RESPONSE_NOT_SUPPORTED = 453] = "LIVE_STREAM_RESPONSE_NOT_SUPPORTED", e2[e2.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM = 455] = "LIVE_STREAM_RESPONSE_MAX_STREAM_NUM", e2[e2.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR = 500] = "LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_WORKER_LOST = 501] = "LIVE_STREAM_RESPONSE_WORKER_LOST", e2[e2.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT = 502] = "LIVE_STREAM_RESPONSE_RESOURCE_LIMIT", e2[e2.LIVE_STREAM_RESPONSE_WORKER_QUIT = 503] = "LIVE_STREAM_RESPONSE_WORKER_QUIT", e2[e2.ERROR_FAIL_SEND_MESSAGE = 504] = "ERROR_FAIL_SEND_MESSAGE", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE = 30] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT = 31] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH = 32] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH", e2[e2.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN = 33] = "PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN";
      }(WI || (WI = {})), function(e2) {
        e2.CONNECT_FAILED = "connect failed", e2.CONNECT_TIMEOUT = "connect timeout", e2.WS_DISCONNECTED = "websocket disconnected", e2.REQUEST_TIMEOUT = "request timeout", e2.REQUEST_FAILED = "request failed", e2.WAIT_STATUS_TIMEOUT = "wait status timeout", e2.WAIT_STATUS_ERROR = "wait status error", e2.BAD_STATE = "bad state", e2.WS_ABORT = "ws abort", e2.AP_REQUEST_TIMEOUT = "AP request timeout", e2.AP_JSON_PARSE_ERROR = "AP json parse error", e2.AP_REQUEST_ERROR = "AP request error", e2.AP_REQUEST_ABORT = "AP request abort";
      }(HI || (HI = {})), function(e2) {
        e2[e2.SetSdkProfile = 0] = "SetSdkProfile", e2[e2.SetSourceChannel = 1] = "SetSourceChannel", e2[e2.SetSourceUserId = 2] = "SetSourceUserId", e2[e2.SetDestChannel = 3] = "SetDestChannel", e2[e2.StartPacketTransfer = 4] = "StartPacketTransfer", e2[e2.StopPacketTransfer = 5] = "StopPacketTransfer", e2[e2.UpdateDestChannel = 6] = "UpdateDestChannel", e2[e2.Reconnect = 7] = "Reconnect", e2[e2.SetVideoProfile = 8] = "SetVideoProfile";
      }(KI || (KI = {})), function(e2) {
        e2.NETWORK_DISCONNECTED = "NETWORK_DISCONNECTED", e2.NETWORK_CONNECTED = "NETWORK_CONNECTED", e2.PACKET_JOINED_SRC_CHANNEL = "PACKET_JOINED_SRC_CHANNEL", e2.PACKET_JOINED_DEST_CHANNEL = "PACKET_JOINED_DEST_CHANNEL", e2.PACKET_SENT_TO_DEST_CHANNEL = "PACKET_SENT_TO_DEST_CHANNEL", e2.PACKET_RECEIVED_VIDEO_FROM_SRC = "PACKET_RECEIVED_VIDEO_FROM_SRC", e2.PACKET_RECEIVED_AUDIO_FROM_SRC = "PACKET_RECEIVED_AUDIO_FROM_SRC", e2.PACKET_UPDATE_DEST_CHANNEL = "PACKET_UPDATE_DEST_CHANNEL", e2.PACKET_UPDATE_DEST_CHANNEL_REFUSED = "PACKET_UPDATE_DEST_CHANNEL_REFUSED", e2.PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE = "PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE";
      }(YI || (YI = {})), function(e2) {
        e2.RELAY_STATE_IDLE = "RELAY_STATE_IDLE", e2.RELAY_STATE_CONNECTING = "RELAY_STATE_CONNECTING", e2.RELAY_STATE_RUNNING = "RELAY_STATE_RUNNING", e2.RELAY_STATE_FAILURE = "RELAY_STATE_FAILURE";
      }(qI || (qI = {})), function(e2) {
        e2.RELAY_OK = "RELAY_OK", e2.SERVER_CONNECTION_LOST = "SERVER_CONNECTION_LOST", e2.SRC_TOKEN_EXPIRED = "SRC_TOKEN_EXPIRED", e2.DEST_TOKEN_EXPIRED = "DEST_TOKEN_EXPIRED";
      }(zI || (zI = {})), function(e2) {
        e2.High = "high", e2.Low = "low", e2.Audio = "audio", e2.Screen = "screen", e2.ScreenLow = "screen_low";
      }(JI || (JI = {})), function(e2) {
        e2.DISCONNECT = "disconnect", e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.NETWORK_QUALITY = "network-quality", e2.STREAM_TYPE_CHANGE = "stream-type-change", e2.IS_P2P_DISCONNECTED = "is-p2p-dis", e2.DISCONNECT_P2P = "dis-p2p", e2.REQUEST_NEW_GATEWAY_LIST = "req-gate-url", e2.NEED_RENEW_SESSION = "need-sid", e2.REQUEST_P2P_CONNECTION_PARAMS = "request-p2p-connection-params", e2.JOIN_RESPONSE = "join-response", e2.REQUEST_DC_CONNECTION_PARAMS = "request-dc-connection-params", e2.RESET_CONNECTION_EVENTS = "reset-connection-events", e2.DATACHANNEL_PRECONNECT = "datachannel_preconnect", e2.DATACHANNEL_FAILBACK = "datachannel_failback", e2.RESET_SIGNAL = "reset-signal";
      }(XI || (XI = {})), function(e2) {
        e2.P2P_DISCONNECTED = "P2P_DISCONNECTED", e2.A_ROUND_WS_FAILED = "A_ROUND_WS_FAILED", e2.TIMEOUT = "TIMEOUT", e2.UNKNOWN_REASON = "UNKNOWN_REASON";
      }(QI || (QI = {})), function(e2) {
        e2[e2.Nothing = 0] = "Nothing", e2[e2.Audio = 1] = "Audio", e2[e2.LwoVideo = 2] = "LwoVideo", e2[e2.Video = 4] = "Video", e2[e2.Data = 8] = "Data", e2[e2.DataStream0 = 256] = "DataStream0", e2[e2.DataStream1 = 512] = "DataStream1", e2[e2.DataStream2 = 1024] = "DataStream2", e2[e2.DataStream3 = 2048] = "DataStream3", e2[e2.DataStream4 = 4096] = "DataStream4", e2[e2.DataStream5 = 8192] = "DataStream5", e2[e2.DataStream6 = 16384] = "DataStream6", e2[e2.DataStream7 = 32768] = "DataStream7";
      }(ZI || (ZI = {})), function(e2) {
        e2[e2.websocket = 0] = "websocket", e2[e2.datachannel = 1] = "datachannel";
      }($I || ($I = {})), function(e2) {
        e2.CHINA = "CHINA", e2.ASIA = "ASIA", e2.NORTH_AMERICA = "NORTH_AMERICA", e2.EUROPE = "EUROPE", e2.JAPAN = "JAPAN", e2.INDIA = "INDIA", e2.KOREA = "KOREA", e2.HKMC = "HKMC", e2.US = "US", e2.OCEANIA = "OCEANIA", e2.SOUTH_AMERICA = "SOUTH_AMERICA", e2.AFRICA = "AFRICA", e2.OVERSEA = "OVERSEA", e2.GLOBAL = "GLOBAL", e2.EXTENSIONS = "EXTENSIONS";
      }(ev || (ev = {}));
      const iv = [ev.AFRICA, ev.ASIA, ev.CHINA, ev.EUROPE, ev.GLOBAL, ev.INDIA, ev.JAPAN, ev.NORTH_AMERICA, ev.OCEANIA, ev.OVERSEA, ev.SOUTH_AMERICA];
      var nv;
      !function(e2) {
        e2.CHINA = "CN", e2.ASIA = "AS", e2.NORTH_AMERICA = "NA", e2.EUROPE = "EU", e2.JAPAN = "JP", e2.INDIA = "IN", e2.KOREA = "KR", e2.HKMC = "HK", e2.US = "US", e2.OCEANIA = "OC", e2.SOUTH_AMERICA = "SA", e2.AFRICA = "AF", e2.OVERSEA = "OVERSEA", e2.GLOBAL = "GLOBAL", e2.EXTENSIONS = "GLOBAL";
      }(nv || (nv = {}));
      const rv = { CHINA: {}, ASIA: { CODE: nv.ASIA, WEBCS_DOMAIN: ["ap-web-1-asia.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-asia.agora.io"], PROXY_CS: ["proxy-ap-web-asia.agora.io"], CDS_AP: ["cds-ap-web-asia.agora.io", "cds-ap-web-asia2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-asia.agora.io", "sua-ap-web-asia2.agora.io"], UAP_AP: ["uap-ap-web-asia.agora.io", "uap-ap-web-asia2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-asia.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-asia.agora.io"], LOG_UPLOAD_SERVER: ["logservice-asia.agora.io"], PROXY_SERVER_TYPE3: ["southeast-asia.webrtc-cloud-proxy.sd-rtn.com"] }, NORTH_AMERICA: { CODE: nv.NORTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-north-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-north-america.agora.io"], PROXY_CS: ["proxy-ap-web-america.agora.io"], CDS_AP: ["cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], UAP_AP: ["uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-north-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-north-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-north-america.agora.io"], PROXY_SERVER_TYPE3: ["east-usa.webrtc-cloud-proxy.sd-rtn.com"] }, EUROPE: { CODE: nv.EUROPE, WEBCS_DOMAIN: ["ap-web-1-europe.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-europe.agora.io"], PROXY_CS: ["proxy-ap-web-europe.agora.io"], CDS_AP: ["cds-ap-web-europe.agora.io", "cds-ap-web-europe2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-europe.agora.io", "sua-ap-web-europe.agora.io"], UAP_AP: ["uap-ap-web-europe.agora.io", "uap-ap-web-europe2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-europe.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-europe.agora.io"], LOG_UPLOAD_SERVER: ["logservice-europe.agora.io"], PROXY_SERVER_TYPE3: ["europe.webrtc-cloud-proxy.sd-rtn.com"] }, JAPAN: { CODE: nv.JAPAN, WEBCS_DOMAIN: ["ap-web-1-japan.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-japan.agora.io"], PROXY_CS: ["proxy-ap-web-japan.agora.io"], CDS_AP: ["cds-ap-web-japan.agora.io", "cds-ap-web-japan2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-japan.agora.io", "sua-ap-web-japan2.agora.io"], UAP_AP: ["uap-ap-web-japan.agora.io", "uap-ap-web-japan2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-japan.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-japan.agora.io"], LOG_UPLOAD_SERVER: ["logservice-japan.agora.io"], PROXY_SERVER_TYPE3: ["japan.webrtc-cloud-proxy.sd-rtn.com"] }, INDIA: { CODE: nv.INDIA, WEBCS_DOMAIN: ["ap-web-1-india.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-india.agora.io"], PROXY_CS: ["proxy-ap-web-india.agora.io"], CDS_AP: ["cds-ap-web-india.agora.io", "cds-ap-web-india2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-india.agora.io", "sua-ap-web-india2.agora.io"], UAP_AP: ["uap-ap-web-india.agora.io", "uap-ap-web-india2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-india.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-india.agora.io"], LOG_UPLOAD_SERVER: ["logservice-india.agora.io"], PROXY_SERVER_TYPE3: ["india.webrtc-cloud-proxy.sd-rtn.com"] }, KOREA: { CODE: nv.KOREA, WEBCS_DOMAIN: ["ap-web-1-korea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-korea.agora.io"], PROXY_CS: ["proxy-ap-web-korea.agora.io"], CDS_AP: ["cds-ap-web-korea.agora.io", "cds-ap-web-korea2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-korea.agora.io", "sua-ap-web-korea2.agora.io"], UAP_AP: ["uap-ap-web-korea.agora.io", "uap-ap-web-korea2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-korea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-korea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-korea.agora.io"], PROXY_SERVER_TYPE3: ["korea.webrtc-cloud-proxy.sd-rtn.com"] }, HKMC: { CODE: nv.HKMC, WEBCS_DOMAIN: ["ap-web-1-hkmc.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-hkmc.agora.io"], PROXY_CS: ["proxy-ap-web-hkmc.agora.io"], CDS_AP: ["cds-ap-web-hkmc.agora.io", "cds-ap-web-hkmc2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-hkmc.agora.io", "sua-ap-web-hkmc2.agora.io"], UAP_AP: ["uap-ap-web-hkmc.agora.io", "uap-ap-web-hkmc2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-hkmc.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-hkmc.agora.io"], LOG_UPLOAD_SERVER: ["logservice-hkmc.agora.io"], PROXY_SERVER_TYPE3: ["hkmc.webrtc-cloud-proxy.sd-rtn.com"] }, US: { CODE: nv.US, WEBCS_DOMAIN: ["ap-web-1-us.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-us.agora.io"], PROXY_CS: ["proxy-ap-web-us.agora.io"], CDS_AP: ["cds-ap-web-us.agora.io", "cds-ap-web-us2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-us.agora.io", "sua-ap-web-us2.agora.io"], UAP_AP: ["uap-ap-web-us.agora.io", "uap-ap-web-us2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-us.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-us.agora.io"], LOG_UPLOAD_SERVER: ["logservice-us.agora.io"], PROXY_SERVER_TYPE3: ["us.webrtc-cloud-proxy.sd-rtn.com"] }, OVERSEA: { CODE: nv.OVERSEA, WEBCS_DOMAIN: ["ap-web-1-oversea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oversea.agora.io"], PROXY_CS: ["proxy-ap-web-oversea.agora.io"], CDS_AP: ["cds-ap-web-oversea.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oversea.agora.io"], UAP_AP: ["uap-ap-web-oversea.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oversea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oversea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oversea.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.agora.io"] }, GLOBAL: { CODE: nv.GLOBAL, WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-ap-web-3.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-ap-web-3.agora.io"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-ap-web-3.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2.agora.io"], LOG_UPLOAD_SERVER: ["logservice.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com"] }, OCEANIA: { CODE: nv.OCEANIA, WEBCS_DOMAIN: ["ap-web-1-oceania.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oceania.agora.io"], PROXY_CS: ["proxy-ap-web-oceania.agora.io"], CDS_AP: ["cds-ap-web-oceania.agora.io", "cds-ap-web-oceania2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oceania.agora.io", "sua-ap-web-oceania2.agora.io"], UAP_AP: ["uap-ap-web-oceania.agora.io", "uap-ap-web-oceania2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oceania.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oceania.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oceania.agora.io"], PROXY_SERVER_TYPE3: ["oceania.webrtc-cloud-proxy.sd-rtn.com"] }, SOUTH_AMERICA: { CODE: nv.SOUTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-south-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-south-america.agora.io"], PROXY_CS: ["proxy-ap-web-south-america.agora.io"], CDS_AP: ["cds-ap-web-south-america.agora.io", "cds-ap-web-south-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-south-america.agora.io", "sua-ap-web-south-america2.agora.io"], UAP_AP: ["uap-ap-web-south-america.agora.io", "uap-ap-web-south-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-south-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-south-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-america.agora.io"], PROXY_SERVER_TYPE3: ["south-america.webrtc-cloud-proxy.sd-rtn.com"] }, AFRICA: { CODE: nv.AFRICA, WEBCS_DOMAIN: ["ap-web-1-africa.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-africa.agora.io"], PROXY_CS: ["proxy-ap-web-africa.agora.io"], CDS_AP: ["cds-ap-web-africa.agora.io", "cds-ap-web-africa2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-africa.agora.io", "sua-ap-web-africa2.agora.io"], UAP_AP: ["uap-ap-web-africa.agora.io", "uap-ap-web-africa2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-africa.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-africa.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-africa.agora.io"], PROXY_SERVER_TYPE3: ["africa.webrtc-cloud-proxy.sd-rtn.com"] }, EXTENSIONS: {} };
      var sv, ov, av, cv, dv, lv, uv, hv, pv, _v, Ev, mv, fv, gv, Tv, Sv, Rv, Cv, Iv, vv, yv, Av, bv, wv;
      mC && (rv.CHINA = { CODE: nv.CHINA, WEBCS_DOMAIN: ["webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["proxy-web.ap.sd-rtn.com"], CDS_AP: ["cds-web-2.ap.sd-rtn.com", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-web-2.ap.sd-rtn.com", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-web-2.ap.sd-rtn.com", "uap-web-4.ap.sd-rtn.com"], EVENT_REPORT_DOMAIN: ["web-3.statscollector.sd-rtn.com"], EVENT_REPORT_BACKUP_DOMAIN: ["web-4.statscollector.sd-rtn.com"], LOG_UPLOAD_SERVER: ["logservice-china.agora.io"], PROXY_SERVER_TYPE3: ["east-cn.webrtc-cloud-proxy.sd-rtn.com"] }), function(e2) {
        e2.UPDATE_BITRATE_LIMIT = "update_bitrate_limit";
      }(sv || (sv = {}));
      class Ov extends dT {
        constructor(e2, t2) {
          super(), sh(this, "onICEConnectionStateChange", void 0), sh(this, "onConnectionStateChange", void 0), sh(this, "onDTLSTransportStateChange", void 0), sh(this, "onDTLSTransportError", void 0), sh(this, "onICETransportStateChange", void 0), sh(this, "onFirstAudioReceived", void 0), sh(this, "onFirstVideoReceived", void 0), sh(this, "onFirstAudioDecoded", void 0), sh(this, "onFirstVideoDecoded", void 0), sh(this, "onFirstVideoDecodedTimeout", void 0), sh(this, "onSelectedLocalCandidateChanged", void 0), sh(this, "onSelectedRemoteCandidateChanged", void 0);
        }
      }
      class Nv extends Ov {
        constructor(e2, t2) {
          super(e2, t2);
        }
      }
      !function(e2) {
        e2.SEND = "sendonly", e2.RECV = "recvonly", e2.SENDRECV = "sendrecv", e2.INACTIVE = "inactive";
      }(ov || (ov = {})), function(e2) {
        e2.VIDEO = "video", e2.AUDIO = "audio";
      }(av || (av = {})), function(e2) {
        e2[e2.UDP = 0] = "UDP", e2[e2.TCP = 1] = "TCP", e2[e2.RELAY = 2] = "RELAY";
      }(cv || (cv = {})), function(e2) {
        e2[e2.FIRST_CONNECTION = 0] = "FIRST_CONNECTION", e2[e2.TCP_RESTART = 1] = "TCP_RESTART", e2[e2.RELAY_RESTART = 2] = "RELAY_RESTART", e2[e2.OLD_FIRST_CONNECTION = 10] = "OLD_FIRST_CONNECTION", e2[e2.OLD_RESTART = 11] = "OLD_RESTART", e2[e2.DISCONNECTED_OR_FAILED = 20] = "DISCONNECTED_OR_FAILED";
      }(dv || (dv = {})), function(e2) {
        e2.LocalVideoTrack = "videoTrack", e2.LocalAudioTrack = "audioTrack", e2.LocalVideoLowTrack = "videoLowTrack";
      }(lv || (lv = {})), function(e2) {
        e2.New = "new", e2.Connected = "connected", e2.Reconnecting = "reconnecting", e2.Disconnected = "disconnected";
      }(uv || (uv = {})), function(e2) {
        e2.StateChange = "stateChange", e2.IceConnectionStateChange = "iceConnectionStateChange", e2.RequestMuteLocal = "requestMuteLocal", e2.RequestUnmuteLocal = "requestUnmuteLocal", e2.RequestRePublish = "requestRePublish", e2.RequestRePublishDataChannel = "requestRePublishDataChannel", e2.RequestReSubscribe = "requestReSubscribe", e2.RequestUploadStats = "requestUploadStats", e2.RequestUpload = "requestUpload", e2.MediaReconnectStart = "MediaReconnectStart", e2.MediaReconnectEnd = "MediaReconnectEnd", e2.NeedSignalRTT = "NeedSignalRTT", e2.RequestRestartICE = "RequestRestartIce", e2.PeerConnectionStateChange = "PeerConnectionStateChange", e2.RequestReconnect = "RequestReconnect", e2.RequestReconnectPC = "RequestReconnectPC", e2.RequestUnpublishForReconnectPC = "RequestUnpublishForReconnectPC", e2.P2PLost = "P2PLost", e2.UpdateVideoEncoder = "UpdateVideoEncoder", e2.ConnectionTypeChange = "ConnectionTypeChange", e2.RequestLowStreamParameter = "RequestLowStreamParameter", e2.QueryClientConnectionState = "QueryClientConnectionState", e2.LocalCandidate = "LocalCandidate", e2.RequestP2PMuteLocal = "requestP2PMuteLocal", e2.RequestP2PUnPublish = "RequestP2PUnPublish", e2.RequestP2PUnmuteRemote = "RequestP2PUnmuteRemote", e2.RequestP2PMuteRemote = "RequestP2PMuteRemote", e2.RequestP2PRestartICE = "RequestP2PRestartICE";
      }(hv || (hv = {})), function(e2) {
        e2.MUTE_LOCAL_VIDEO = "mute_local_video", e2.MUTE_LOCAL_AUDIO = "mute_local_audio", e2.UNMUTE_LOCAL_VIDEO = "unmute_local_video", e2.UNMUTE_LOCAL_AUDIO = "unmute_local_audio", e2.MUTE_REMOTE_VIDEO = "mute_remote_video", e2.MUTE_REMOTE_AUDIO = "mute_remote_audio", e2.UNMUTE_REMOTE_VIDEO = "unmute_remote_video", e2.UNMUTE_REMOTE_AUDIO = "unmute_remote_audio";
      }(pv || (pv = {})), function(e2) {
        e2.CONNECTING = "CONNECTING", e2.RECONNECTING = "RECONNECTING", e2.CONNECTED = "CONNECTED", e2.CLOSED = "CLOSED";
      }(_v || (_v = {})), function(e2) {
        e2[e2.CONNECT_AP = 0] = "CONNECT_AP", e2[e2.AP_CONNECTED = 1] = "AP_CONNECTED", e2[e2.CONNECT_WORKER_MANAGER = 2] = "CONNECT_WORKER_MANAGER", e2[e2.WORKER_MANAGER_CONNECTED = 3] = "WORKER_MANAGER_CONNECTED", e2[e2.GET_WORKER_MANAGER_RESPONSE = 4] = "GET_WORKER_MANAGER_RESPONSE", e2[e2.CONNECT_WORKER = 5] = "CONNECT_WORKER", e2[e2.WORKER_CONNECTED = 6] = "WORKER_CONNECTED", e2[e2.CLOSED = 7] = "CLOSED";
      }(Ev || (Ev = {})), function(e2) {
        e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.STATE_CHANGE = "state-change", e2.INSPECT_RESULT = "inspect-result", e2.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track", e2.REQUEST_NEW_WORKER_URL = "request-new-worker-url";
      }(mv || (mv = {})), function(e2) {
        e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.MULTI_IP = "MULTI_IP", e2.TIMEOUT = "TIMEOUT", e2.OFFLINE = "OFFLINE", e2.LEAVE = "LEAVE", e2.P2P_FAILED = "P2P_FAILED", e2.FALLBACK = "FALLBACK";
      }(fv || (fv = {})), function(e2) {
        e2.CONNECTED = "transmitter:connected", e2.RECONNECTING = "transmitter:reconnecting", e2.WILL_RECONNECT = "transmitter:will_reconnect", e2.CLOSED = "transmitter:closed", e2.FAILED = "transmitter:failed", e2.ON_MESSAGE = "transmitter:on_message", e2.REQUEST_NEW_URLS = "transmitter:request_new_urls", e2.RECONNECT_WAITTING_FINISH = "transmitter:reconnect_waitting_finish", e2.RECONNECT_CREATE_CONNECTION = "transmitter:reconnect_create_connection", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "transmitter:on_token_privilege_did_expire", e2.TO_CONNECT_DATACHANNEL = "transmitter:to_connect_datachannel", e2.FAILBACK = "transmitter:failback";
      }(gv || (gv = {})), function(e2) {
        e2.CAMERA_CHANGED = "camera-changed", e2.MICROPHONE_CHANGED = "microphone-changed", e2.PLAYBACK_DEVICE_CHANGED = "playback-device-changed", e2.AUDIO_AUTOPLAY_FAILED = "audio-autoplay-failed", e2.AUTOPLAY_FAILED = "autoplay-failed", e2.AUDIO_CONTEXT_STATE_CHANGED = "audio-context-state-changed", e2.SECURITY_POLICY_VIOLATION = "security-policy-violation";
      }(Tv || (Tv = {})), function(e2) {
        e2[e2.APP_TYPE_INVALID_VALUE = -1] = "APP_TYPE_INVALID_VALUE", e2[e2.APP_TYPE_NATIVE = 0] = "APP_TYPE_NATIVE", e2[e2.APP_TYPE_NATIVE_COCOS = 1] = "APP_TYPE_NATIVE_COCOS", e2[e2.APP_TYPE_NATIVE_UNITY = 2] = "APP_TYPE_NATIVE_UNITY", e2[e2.APP_TYPE_NATIVE_ELECTRON = 3] = "APP_TYPE_NATIVE_ELECTRON", e2[e2.APP_TYPE_NATIVE_FLUTTER = 4] = "APP_TYPE_NATIVE_FLUTTER", e2[e2.APP_TYPE_NATIVE_UNREAL = 5] = "APP_TYPE_NATIVE_UNREAL", e2[e2.APP_TYPE_NATIVE_XAMARIN = 6] = "APP_TYPE_NATIVE_XAMARIN", e2[e2.APP_TYPE_NATIVE_API_CLOUD = 7] = "APP_TYPE_NATIVE_API_CLOUD", e2[e2.APP_TYPE_NATIVE_REACT_NATIVE = 8] = "APP_TYPE_NATIVE_REACT_NATIVE", e2[e2.APP_TYPE_NATIVE_PYTHON = 9] = "APP_TYPE_NATIVE_PYTHON", e2[e2.APP_TYPE_NATIVE_COCOS_CREATOR = 10] = "APP_TYPE_NATIVE_COCOS_CREATOR", e2[e2.APP_TYPE_NATIVE_RUST = 11] = "APP_TYPE_NATIVE_RUST", e2[e2.APP_TYPE_NATIVE_C_SHARP = 12] = "APP_TYPE_NATIVE_C_SHARP", e2[e2.APP_TYPE_NATIVE_CEF = 13] = "APP_TYPE_NATIVE_CEF", e2[e2.APP_TYPE_NATIVE_UNI_APP = 14] = "APP_TYPE_NATIVE_UNI_APP", e2[e2.APP_TYPE_WEBRTC = 1e3] = "APP_TYPE_WEBRTC", e2[e2.APP_TYPE_WEBRTC_REACT = 1001] = "APP_TYPE_WEBRTC_REACT", e2[e2.APP_TYPE_WEBRTC_VUE = 1002] = "APP_TYPE_WEBRTC_VUE", e2[e2.APP_TYPE_WEBRTC_ANGULAR = 1003] = "APP_TYPE_WEBRTC_ANGULAR";
      }(Sv || (Sv = {})), function(e2) {
        e2.CONNECTING = "CONNECTING", e2.RECONNECTING = "RECONNECTING", e2.CONNECTED = "CONNECTED", e2.CLOSED = "CLOSED";
      }(Rv || (Rv = {})), function(e2) {
        e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.STATE_CHANGE = "state-change", e2.INSPECT_RESULT = "inspect-result", e2.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track", e2.REQUEST_NEW_WORKER_URL = "request-new-worker-url";
      }(Cv || (Cv = {})), function(e2) {
        e2[e2.CONNECT_AP = 0] = "CONNECT_AP", e2[e2.AP_CONNECTED = 1] = "AP_CONNECTED", e2[e2.CONNECT_WORKER_MANAGER = 2] = "CONNECT_WORKER_MANAGER", e2[e2.WORKER_MANAGER_CONNECTED = 3] = "WORKER_MANAGER_CONNECTED", e2[e2.GET_WORKER_MANAGER_RESPONSE = 4] = "GET_WORKER_MANAGER_RESPONSE", e2[e2.CONNECT_WORKER = 5] = "CONNECT_WORKER", e2[e2.WORKER_CONNECTED = 6] = "WORKER_CONNECTED", e2[e2.CLOSED = 7] = "CLOSED";
      }(Iv || (Iv = {})), function(e2) {
        e2.CALL = "call", e2.CANDIDATE = "candidate", e2.PUBLISH = "publish", e2.UNPUBLISH = "unpublish", e2.CONTROL = "control", e2.RESTART_ICE = "restart_ice", e2.ACK = "ack", e2.RESPONSE = "response", e2.JOIN = "join", e2.CHECK = "check";
      }(vv || (vv = {})), function(e2) {
        e2.ABORT = "abort";
      }(yv || (yv = {})), function(e2) {
        e2.MUTE_LOCAL_AUDIO = "mute_local_audio", e2.MUTE_LOCAL_VIDEO = "mute_local_video", e2.UNMUTE_LOCAL_AUDIO = "unmute_local_audio", e2.UNMUTE_LOCAL_VIDEO = "unmute_local_video";
      }(Av || (Av = {})), function(e2) {
        e2[e2.SUCCESS = 1] = "SUCCESS", e2[e2.FAILED = 0] = "FAILED";
      }(bv || (bv = {})), function(e2) {
        e2.P2P_TOKEN_TIMEOUT = "p2p_token_timeout", e2.P2P_TOKEN_CHANGED = "p2p_token_changed";
      }(wv || (wv = {}));
      const Dv = { [cI.ACCESS_POINT]: { [uI.NO_FLAG_SET]: { desc: "flag is zero", retry: false }, [uI.FLAG_SET_BUT_EMPTY]: { desc: "flag is empty", retry: false }, [uI.INVALID_FALG_SET]: { desc: "invalid flag", retry: false }, [uI.FLAG_SET_BUT_NO_RE]: { desc: "flag set unilbs but no request", retry: false }, [uI.INVALID_SERVICE_ID]: { desc: "invalid service id", retry: false }, [uI.NO_SERVICE_AVAILABLE]: { desc: "no service available", retry: true }, [uI.NO_SERVICE_AVAILABLE_P2P]: { desc: "no unilbs p2p service available", retry: true }, [uI.NO_SERVICE_AVAILABLE_VOICE]: { desc: "no unilbs voice service available", retry: true }, [uI.NO_SERVICE_AVAILABLE_WEBRTC]: { desc: "no unilbs webrtc service available", retry: true }, [uI.NO_SERVICE_AVAILABLE_CDS]: { desc: "no cds service available", retry: true }, [uI.NO_SERVICE_AVAILABLE_CDN]: { desc: "no cdn dispatcher service available", retry: true }, [uI.NO_SERVICE_AVAILABLE_TDS]: { desc: "no tds service available", retry: true }, [uI.NO_SERVICE_AVAILABLE_REPORT]: { desc: "no unilbs report service available", retry: true }, [uI.NO_SERVICE_AVAILABLE_APP_CENTER]: { desc: "no app center service available", retry: true }, [uI.NO_SERVICE_AVAILABLE_ENV0]: { desc: "no unilbs sig env0 service available", retry: true }, [uI.NO_SERVICE_AVAILABLE_VOET]: { desc: "no unilbs voet service available", retry: true }, [uI.NO_SERVICE_AVAILABLE_STRING_UID]: { desc: "no string uid service available", retry: true }, [uI.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS]: { desc: "no webrtc unilbs service available", retry: true } }, [cI.UNILBS]: { [lI.INVALID_VENDOR_KEY]: { desc: "invalid vendor key, can not find appid", retry: false }, [lI.INVALID_CHANNEL_NAME]: { desc: "invalid channel name", retry: false }, [lI.INTERNAL_ERROR]: { desc: "unilbs internal error", retry: false }, [lI.NO_AUTHORIZED]: { desc: "invalid token, authorized failed", retry: false }, [lI.DYNAMIC_KEY_TIMEOUT]: { desc: "dynamic key or token timeout", retry: false }, [lI.NO_ACTIVE_STATUS]: { desc: "no active status", retry: false }, [lI.DYNAMIC_KEY_EXPIRED]: { desc: "dynamic key expired", retry: false }, [lI.STATIC_USE_DYNAMIC_KEY]: { desc: "static use dynamic key", retry: false }, [lI.DYNAMIC_USE_STATIC_KEY]: { desc: "dynamic use static key", retry: false }, [lI.USER_OVERLOAD]: { desc: "amount of users over load", retry: false }, [lI.FORBIDDEN_REGION]: { desc: "the request is forbidden in this area", retry: false }, [lI.CANNOT_MEET_AREA_DEMAND]: { desc: "unable to allocate services in this area", retry: false } }, [cI.STRING_UID_ALLOCATOR]: { [dI.IIIEGAL_APPID]: { desc: "invalid appid", retry: false }, [dI.IIIEGAL_UID]: { desc: "invalid string uid", retry: false }, [dI.INTERNAL_ERROR]: { desc: "string uid allocator internal error", retry: true } } };
      function Pv(e2) {
        const t2 = Dv[Math.floor(e2 / 1e4)];
        if (!t2) return { desc: "unkonw error", retry: false };
        const i2 = t2[e2 % 1e4];
        if (!i2) {
          if (Math.floor(e2 / 1e4) === cI.ACCESS_POINT) {
            const t3 = e2 % 1e4;
            if ("1" === t3.toString()[0]) return { desc: e2.toString(), retry: false };
            if ("2" === t3.toString()[0]) return { desc: e2.toString(), retry: true };
          }
          return { desc: "unkonw error", retry: false };
        }
        return i2;
      }
      const Lv = { [hI.K_TIMESTAMP_EXPIRED]: { desc: "K_TIMESTAMP_EXPIRED", action: "failed" }, [hI.K_CHANNEL_PERMISSION_INVALID]: { desc: "K_CHANNEL_PERMISSION_INVALID", action: "failed" }, [hI.K_CERTIFICATE_INVALID]: { desc: "K_CERTIFICATE_INVALID", action: "failed" }, [hI.K_CHANNEL_NAME_EMPTY]: { desc: "K_CHANNEL_NAME_EMPTY", action: "failed" }, [hI.K_CHANNEL_NOT_FOUND]: { desc: "K_CHANNEL_NOT_FOUND", action: "failed" }, [hI.K_TICKET_INVALID]: { desc: "K_TICKET_INVALID", action: "failed" }, [hI.K_CHANNEL_CONFLICTED]: { desc: "K_CHANNEL_CONFLICTED", action: "failed" }, [hI.K_SERVICE_NOT_READY]: { desc: "K_SERVICE_NOT_READY", action: "tryNext" }, [hI.K_SERVICE_TOO_HEAVY]: { desc: "K_SERVICE_TOO_HEAVY", action: "tryNext" }, [hI.K_UID_BANNED]: { desc: "K_UID_BANNED", action: "failed" }, [hI.K_IP_BANNED]: { desc: "K_IP_BANNED", action: "failed" }, [hI.K_AUTO_REBALANCE]: { desc: "k_AUTO_REBALANCE", action: "recover" }, [hI.ERR_INVALID_VENDOR_KEY]: { desc: "ERR_INVALID_VENDOR_KEY", action: "failed" }, [hI.ERR_INVALID_CHANNEL_NAME]: { desc: "ERR_INVALID_CHANNEL_NAME", action: "failed" }, [hI.WARN_NO_AVAILABLE_CHANNEL]: { desc: "WARN_NO_AVAILABLE_CHANNEL", action: "failed" }, [hI.WARN_LOOKUP_CHANNEL_TIMEOUT]: { desc: "WARN_LOOKUP_CHANNEL_TIMEOUT", action: "tryNext" }, [hI.WARN_LOOKUP_CHANNEL_REJECTED]: { desc: "WARN_LOOKUP_CHANNEL_REJECTED", action: "failed" }, [hI.WARN_OPEN_CHANNEL_TIMEOUT]: { desc: "WARN_OPEN_CHANNEL_TIMEOUT", action: "tryNext" }, [hI.WARN_OPEN_CHANNEL_REJECTED]: { desc: "WARN_OPEN_CHANNEL_REJECTED", action: "failed" }, [hI.WARN_REQUEST_DEFERRED]: { desc: "WARN_REQUEST_DEFERRED", action: "failed" }, [hI.ERR_DYNAMIC_KEY_TIMEOUT]: { desc: "ERR_DYNAMIC_KEY_TIMEOUT", action: "failed" }, [hI.ERR_NO_AUTHORIZED]: { desc: "ERR_NO_AUTHORIZED", action: "failed" }, [hI.ERR_VOM_SERVICE_UNAVAILABLE]: { desc: "ERR_VOM_SERVICE_UNAVAILABLE", action: "tryNext" }, [hI.ERR_NO_CHANNEL_AVAILABLE_CODE]: { desc: "ERR_NO_CHANNEL_AVAILABLE_CODE", action: "failed" }, [hI.ERR_MASTER_VOCS_UNAVAILABLE]: { desc: "ERR_MASTER_VOCS_UNAVAILABLE", action: "tryNext" }, [hI.ERR_INTERNAL_ERROR]: { desc: "ERR_INTERNAL_ERROR", action: "tryNext" }, [hI.ERR_NO_ACTIVE_STATUS]: { desc: "ERR_NO_ACTIVE_STATUS", action: "failed" }, [hI.ERR_INVALID_UID]: { desc: "ERR_INVALID_UID", action: "failed" }, [hI.ERR_DYNAMIC_KEY_EXPIRED]: { desc: "ERR_DYNAMIC_KEY_EXPIRED", action: "failed" }, [hI.ERR_STATIC_USE_DYANMIC_KE]: { desc: "ERR_STATIC_USE_DYANMIC_KE", action: "failed" }, [hI.ERR_DYNAMIC_USE_STATIC_KE]: { desc: "ERR_DYNAMIC_USE_STATIC_KE", action: "failed" }, [hI.ERR_NO_VOCS_AVAILABLE]: { desc: "ERR_NO_VOCS_AVAILABLE", action: "tryNext" }, [hI.ERR_NO_VOS_AVAILABLE]: { desc: "ERR_NO_VOS_AVAILABLE", action: "tryNext" }, [hI.ERR_JOIN_CHANNEL_TIMEOUT]: { desc: "ERR_JOIN_CHANNEL_TIMEOUT", action: "tryNext" }, [hI.ERR_JOIN_BY_MULTI_IP]: { desc: "ERR_JOIN_BY_MULTI_IP", action: "recover" }, [hI.ERR_NOT_JOINED]: { desc: "ERR_NOT_JOINED", action: "failed" }, [hI.ERR_REPEAT_JOIN_REQUEST]: { desc: "ERR_REPEAT_JOIN_REQUEST", action: "quit" }, [hI.ERR_REPEAT_JOIN_CHANNEL]: { desc: "ERR_REPEAT_JOIN_CHANNEL", action: "quit" }, [hI.ERR_INVALID_STRINGUID]: { desc: "ERR_INVALID_STRINGUID", action: "failed" }, [hI.ERR_TOO_MANY_USERS]: { desc: "ERR_TOO_MANY_USERS", action: "tryNext" }, [hI.ERR_SET_CLIENT_ROLE_TIMEOUT]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [hI.ERR_SET_CLIENT_ROLE_NO_PERMISSION]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [hI.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE]: { desc: "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", action: "success" }, [hI.ERR_PUBLISH_REQUEST_INVALID]: { desc: "ERR_PUBLISH_REQUEST_INVALID", action: "failed" }, [hI.ERR_SUBSCRIBE_REQUEST_INVALID]: { desc: "ERR_SUBSCRIBE_REQUEST_INVALID", action: "failed" }, [hI.ERR_NOT_SUPPORTED_MESSAGE]: { desc: "ERR_NOT_SUPPORTED_MESSAGE", action: "failed" }, [hI.ERR_ILLEAGAL_PLUGIN]: { desc: "ERR_ILLEAGAL_PLUGIN", action: "failed" }, [hI.ILLEGAL_CLIENT_ROLE_LEVEL]: { desc: "ILLEGAL_CLIENT_ROLE_LEVEL", action: "failed" }, [hI.ERR_REJOIN_TOKEN_INVALID]: { desc: "ERR_REJOIN_TOKEN_INVALID", action: "failed" }, [hI.ERR_REJOIN_USER_NOT_JOINED]: { desc: "ERR_REJOIN_NOT_JOINED", action: "failed" }, [hI.ERR_INVALID_OPTIONAL_INFO]: { desc: "ERR_INVALID_OPTIONAL_INFO", action: "quit" }, [hI.ERR_TEST_RECOVER]: { desc: "ERR_TEST_RECOVER", action: "recover" }, [hI.ERR_TEST_TRYNEXT]: { desc: "ERR_TEST_TRYNEXT", action: "recover" }, [hI.ERR_TEST_RETRY]: { desc: "ERR_TEST_RETRY", action: "recover" }, [hI.ILLEGAL_AES_PASSWORD]: { desc: "ERR_TEST_RETRY", action: "failed" }, [hI.ERR_TOO_MANY_BROADCASTERS]: { desc: "ERR_TOO_MANY_BROADCASTERS", action: "failed" }, [hI.ERR_TOO_MANY_SUBSCRIBERS]: { desc: "ERR_TOO_MANY_SUBSCRIBERS", action: "failed" }, [hI.ERR_LICENSE_ILLEGAL]: { desc: "ERR_LICENSE_ILLEGAL", action: "quit" }, [hI.ERR_LICENSE_MISSING]: { desc: "ERR_LICENSE_MISSING", action: "quit" }, [hI.ERR_LICENSE_EXPIRED]: { desc: "ERR_LICENSE_EXPIRED", action: "quit" }, [hI.ERR_LICENSE_MINUTES_EXCEEDED]: { desc: "ERR_LICENSE_MINUTES_EXCEEDED", action: "quit" }, [hI.ERR_LICENSE_PERIOD_INVALID]: { desc: "ERR_LICENSE_PERIOD_INVALID", action: "quit" }, [hI.ERR_LICENSE_MULTIPLE_SDK_SERVICE]: { desc: "ERR_LICENSE_MULTIPLE_SDK_SERVICE", action: "quit" } };
      function kv(e2) {
        const t2 = Lv[e2];
        return t2 || { desc: "UNKNOW_ERROR_".concat(e2), action: "failed" };
      }
      function Mv(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function Uv(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Mv(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : Mv(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      function xv(e2) {
        return e2.every((e3) => e3.readyState === WebSocket.CLOSED || e3.readyState === WebSocket.CLOSING);
      }
      function Vv(e2, t2) {
        if ("string" == typeof e2) return e2;
        const { proxy: i2, host: n2, port: r2 } = e2;
        if (t2) {
          const e3 = RC("JOIN_GATEWAY_FALLBACK_PORT") || 443;
          return 443 === e3 ? "wss://".concat(n2, "/ws/?p=").concat(Number(r2) + 150) : "wss://".concat(n2, ":").concat(e3, "/ws/?p=").concat(Number(r2) + 150);
        }
        return i2 ? "wss://".concat(i2, "/ws/?h=").concat(n2, "&p=").concat(r2) : "wss://".concat(n2, ":").concat(r2);
      }
      const Fv = /wss:\/\/(.+)\/ws\/\?h=(.+)&p=([0-9]+)\/?/, Bv = /wss:\/\/(.+)\/ws\/\?p=([0-9]+)\/?/, jv = /wss:\/\/(.+):([0-9]+)\/?/, Gv = /wss:\/\/(.[^\/]+)\/?/;
      let Wv = 0;
      class Hv {
        constructor(e2, t2) {
          sh(this, "id", 0), sh(this, "store", void 0), sh(this, "recordIndex", void 0), sh(this, "websockets", []), sh(this, "try443PortDuration", 2e3), sh(this, "forceCloseWSDuration", 5e3), sh(this, "try443PortTimeout", null), sh(this, "forceCloseTimeout", null), sh(this, "isTry443PortFailed", false), sh(this, "isNormalPortFailed", false), sh(this, "useDoubleDomain", false), sh(this, "useProxy", false), sh(this, "startTime", Date.now()), this.id = ++Wv, this.try443PortDuration = RC("JOIN_GATEWAY_TRY_443PORT_DURATION") || 2e3, this.forceCloseWSDuration = e2 || 5e3, this.store = t2;
        }
        closeAllWebsockets() {
          this.websockets.forEach((e2) => {
            e2.onopen = null, e2.onclose = null, e2.onmessage = null, e2.close();
          }), this.websockets.length = 0;
        }
        clearTimeout() {
          this.forceCloseTimeout && clearTimeout(this.forceCloseTimeout), this.try443PortTimeout && clearTimeout(this.try443PortTimeout);
        }
        logger() {
          var e2;
          const t2 = Date.now() - this.startTime;
          for (var i2 = arguments.length, n2 = new Array(i2), r2 = 0; r2 < i2; r2++) n2[r2] = arguments[r2];
          jC.debug("[choose-best-ws ".concat(null === (e2 = this.store) || void 0 === e2 ? void 0 : e2.clientId, " ").concat(this.id, "] ").concat(t2, "ms:"), ...n2);
        }
        createWebSocket(e2, t2, i2) {
          this.logger("createWebSocket:", e2, { isTry443Port: t2, hasTimeoutDetection: i2 });
          const n2 = RC("GATEWAY_DOMAINS"), r2 = Date.now(), s2 = [], o2 = n2.find((t3) => {
            var i3;
            return bn(i3 = e2.host).call(i3, t3);
          });
          o2 || (this.useDoubleDomain = false);
          const a2 = [];
          if (this.useDoubleDomain) n2.forEach((i3) => {
            a2.push(Vv(Uv(Uv({}, e2), {}, { host: e2.host.replace(o2, i3) }), t2));
          });
          else {
            const i3 = Uv({}, e2);
            if (t2 && o2) {
              const e3 = n2.find((e4) => e4 !== o2);
              e3 && (i3.host = i3.host.replace(o2, e3));
            }
            a2.push(Vv(i3, t2));
          }
          try {
            a2.forEach((e3) => {
              const t3 = new WebSocket(e3);
              t3.binaryType = "arraybuffer", s2.push(t3), this.logger("ws is connecting:", t3.url);
            });
          } catch (n3) {
            if (this.logger("ws create failed"), s2.forEach((e3) => e3.close()), s2.length = 0, this.useDoubleDomain) return this.useDoubleDomain = false, this.createWebSocket(e2, t2, i2);
            if (!t2 && 443 !== Number(e2.port)) return this.createWebSocket(e2, true, i2);
            throw new LI(Hg.WS_ERR, "init websocket failed! Error: ".concat(n3.toString()));
          }
          const c2 = lg();
          this.store && this.store.recordJoinChannelService({ urls: s2.map((e3) => e3.url), service: "gateway" }, this.recordIndex), s2.forEach((e3) => {
            e3.onopen = () => {
              this.logger("onopen: ws ".concat(e3.url, " open cost ").concat(Date.now() - r2, "ms")), this.websockets.forEach((t3) => {
                t3 !== e3 && (t3.onopen = null, t3.onclose = null, t3.onmessage = null, t3.close(), this.logger("close backup websocket: ".concat(t3.url)));
              }), this.websockets.length = 0, c2.resolve(e3);
            }, e3.onclose = (i3) => {
              this.logger("onclose: ws ".concat(e3.url, " closed cost ").concat(Date.now() - r2, "ms state: ").concat(e3.readyState)), t2 ? this.isTry443PortFailed = xv(s2) : this.isNormalPortFailed = xv(s2), this.logger("443: ".concat(this.useProxy ? "not try" : this.isTry443PortFailed ? "failed" : "trying", " 47xx: ").concat(this.isNormalPortFailed ? "failed" : "trying")), (t2 && this.isTry443PortFailed || !t2 && (this.isTry443PortFailed || this.useProxy) && this.isNormalPortFailed) && (this.logger("onclose: all websocket is closed, ".concat(i3.reason)), c2.reject({ code: i3.code, reason: QI.A_ROUND_WS_FAILED }));
            }, e3.onmessage = (t3) => this.logger("".concat(e3.url, " onmessage: ").concat(t3.data));
          }), this.websockets.push(...s2);
          return i2 || (() => {
            const i3 = () => {
              this.logger("5s timeout close un-opens, isWebsocket created: ", c2.isResolved), this.websockets.forEach((e3) => e3.readyState !== WebSocket.OPEN && e3.close());
            };
            if (t2 || this.useProxy) return this.logger("add 5s timeout at ".concat(t2 ? "try-443" : "proxy", " condition")), this.forceCloseTimeout = window.setTimeout(i3, this.forceCloseWSDuration);
            this.try443PortTimeout = window.setTimeout(() => {
              if (this.logger("2s timeout, isWebsocket created: ", c2.isResolved), c2.isResolved) return i3();
              Sg().os === _g.MAC_OS && wg() && i3(), this.createWebSocket(e2, true, true).then((e3) => c2.resolve(e3)).catch((e3) => {
                this.isNormalPortFailed && c2.reject(e3), this.logger("try 443 port to create ws failed");
              }), this.forceCloseTimeout = window.setTimeout(i3, this.forceCloseWSDuration);
            }, this.try443PortDuration);
          })(), c2.promise;
        }
        chooseBestWebsocket(e2, t2, i2, n2) {
          return this.useDoubleDomain = !!t2, "string" == typeof e2 && (e2 = function(e3) {
            let t3, i3, n3;
            return [, t3, i3, n3] = e3.match(Fv) || [], t3 || ([, i3, n3] = e3.match(Bv) || []), i3 && n3 || ([, i3, n3] = e3.match(jv) || []), i3 && n3 || ([, i3] = e3.match(Gv) || []), i3 || jC.warning("un-destructible url: ", e3), { proxy: t3, host: i3, port: n3 || "443" };
          }(e2)), this.recordIndex = n2, this.useProxy = !!e2.proxy, i2 && this.useProxy && (jC.warn("cannot use 443 only when use proxy"), i2 = false), this.createWebSocket(e2, !!i2, false).finally(() => this.clearTimeout());
        }
      }
      function Kv(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      class Yv extends dT {
        get url() {
          return this.websocket && this.websocket.url || null;
        }
        get reconnectMode() {
          return this._reconnectMode;
        }
        set reconnectMode(e2) {
          var t2;
          bn(t2 = ["tryNext", "recover"]).call(t2, e2) && this.resetReconnectCount(e2), this._reconnectMode = e2;
        }
        get state() {
          return this._state;
        }
        set state(e2) {
          e2 !== this._state && (this._state = e2, "reconnecting" === this._state ? this.emit(SI.RECONNECTING, this.reconnectReason) : "connected" === this._state ? this.emit(SI.CONNECTED) : "closed" === this._state ? this.emit(SI.CLOSED) : "failed" === this._state && this.emit(SI.FAILED));
        }
        resetReconnectCount(e2) {
          jC.debug("websocket reset reconnect count, reason: " + e2), this.reconnectCount = 0;
        }
        constructor(e2, t2) {
          let i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], r2 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], s2 = arguments.length > 5 ? arguments[5] : void 0;
          super(), sh(this, "connectionID", 0), sh(this, "currentURLIndex", 0), sh(this, "urls", []), sh(this, "_reconnectMode", "tryNext"), sh(this, "reconnectReason", void 0), sh(this, "_initMutex", new pS("websocket")), sh(this, "name", void 0), sh(this, "_state", "closed"), sh(this, "reconnectInterrupter", void 0), sh(this, "websocket", void 0), sh(this, "retryConfig", void 0), sh(this, "reconnectCount", 0), sh(this, "forceCloseTimeout", 5e3), sh(this, "onlineReconnectListener", void 0), sh(this, "useCompress", void 0), sh(this, "tryDoubleDomain", false), sh(this, "use443PortOnly", false), sh(this, "wsInflateLength", 0), sh(this, "wsDeflateLength", 0), sh(this, "closeEstablishingWs", () => {
          }), sh(this, "store", void 0), sh(this, "joinGatewayRecordIndex", void 0), this.store = s2, this.name = e2, this.retryConfig = function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var i3 = null != arguments[t3] ? arguments[t3] : {};
              t3 % 2 ? Kv(Object(i3), true).forEach(function(t4) {
                sh(e3, t4, i3[t4]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : Kv(Object(i3)).forEach(function(t4) {
                Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
              });
            }
            return e3;
          }({}, t2), this.useCompress = i2, this.tryDoubleDomain = n2, this.use443PortOnly = r2;
          const { timeout: o2, timeoutFactor: a2 } = t2, c2 = Math.max(300, Math.floor(3 * o2 / 5)), d2 = Math.max(1.2, Math.floor(8 * a2) / 10);
          gT.ONLINE && (this.retryConfig.timeout = c2, this.retryConfig.timeoutFactor = d2), wT.on(TT.NETWORK_STATE_CHANGE, (e3, t3) => {
            e3 !== t3 && (this.resetReconnectCount("network state change: ".concat(t3, " -> ").concat(e3)), e3 === gT.ONLINE ? (this.retryConfig.timeout = c2, this.retryConfig.timeoutFactor = d2) : (this.retryConfig.timeout = o2, this.retryConfig.timeoutFactor = a2));
          });
        }
        getConnection() {
          return this.websocket || void 0;
        }
        async init(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
          const i2 = await this._initMutex.lock();
          this.forceCloseTimeout = t2, this.urls = e2, this.state = "connecting";
          try {
            const e3 = lg(), t3 = this.urls[this.currentURLIndex];
            this.createWebSocketConnection(t3).then(e3.resolve).catch(e3.reject), this.once(SI.CLOSED, () => {
              e3.reject(new Kg(Hg.WS_DISCONNECT));
            }), this.once(SI.CONNECTED, e3.resolve), await e3.promise;
          } catch (e3) {
          } finally {
            i2();
          }
        }
        close(e2, t2) {
          if (this.currentURLIndex = 0, this.resetReconnectCount("close"), this.reconnectInterrupter && this.reconnectInterrupter(), this.websocket) {
            this.websocket.onclose = null, this.websocket.onopen = null, this.websocket.onmessage = null;
            const e3 = this.websocket;
            t2 ? setTimeout(() => e3.close(), 500) : e3.close(), this.websocket = void 0;
          }
          this.state = e2 ? "failed" : "closed", this.closeEstablishingWs && this.closeEstablishingWs();
        }
        reconnect(e2, t2) {
          if (!this.websocket) return void jC.warning("[".concat(this.name, "] can not reconnect, no websocket"));
          void 0 !== e2 && (this.reconnectMode = e2), jC.debug("[".concat(this.name, "] reconnect is triggered initiative")), "number" == typeof this.joinGatewayRecordIndex && this.store && this.store.recordJoinChannelService({ status: "error", errors: [new Error(t2)] }, this.joinGatewayRecordIndex);
          const i2 = this.websocket.onclose;
          this.websocket.onclose = null, this.websocket.close(), i2 && i2.bind(this.websocket)({ code: 9999, reason: t2 });
        }
        sendMessage(e2) {
          let t2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) throw new Kg(Hg.WS_ABORT, "websocket is not ready");
          try {
            t2 || (e2 = JSON.stringify(e2)), this.websocket.send(e2);
          } catch (e3) {
            throw new Kg(Hg.WS_ERR, "send websocket message error" + e3.toString());
          }
        }
        setWsInflateData(e2) {
          this.wsDeflateLength = this.wsDeflateLength + e2.originLength, this.wsInflateLength = this.wsInflateLength + e2.compressedLength;
        }
        getWsInflateData() {
          const e2 = this.wsInflateLength, t2 = this.wsDeflateLength;
          return this.clearWsInflateData(), { wsInflateLength: e2, wsDeflateLength: t2 };
        }
        clearWsInflateData() {
          this.wsInflateLength = 0, this.wsDeflateLength = 0;
        }
        async createWebSocketConnection(e2) {
          var t2;
          const i2 = lg();
          this.connectionID += 1, this.joinGatewayRecordIndex = void 0;
          const n2 = (e3) => {
            var t3;
            null === (t3 = this.store) || void 0 === t3 || t3.signalChannelOpen(), jC.debug("[".concat(this.name, "] websocket opened:"), e3), this.reconnectMode = "retry", this.state = "connected", this.resetReconnectCount("opened"), i2.resolve();
          }, r2 = async (e3) => {
            var t3;
            if (jC.debug("[".concat(this.name, "] websocket close ").concat(null === (t3 = this.websocket) || void 0 === t3 ? void 0 : t3.url, ", code: ").concat(e3.code, ", reason: ").concat(e3.reason, ", current mode: ").concat(this.reconnectMode)), this.reconnectCount >= this.retryConfig.maxRetryCount) i2.reject(new Kg(Hg.WS_DISCONNECT, "websocket close: ".concat(e3.code))), this.close();
            else {
              "connected" === this.state && (this.reconnectReason = e3.reason, this.state = "reconnecting");
              const t4 = AT(this, SI.WILL_RECONNECT, this.reconnectMode, e3.reason) || this.reconnectMode, n3 = await this.reconnectWithAction(t4);
              if ("closed" === this.state) return void jC.debug("[".concat(this.connectionID, "] ws is closed, no need to reconnect"));
              if (!n3) return i2.reject(new Kg(Hg.WS_DISCONNECT, "websocket reconnect failed: ".concat(e3.code))), this.close(true);
              i2.resolve();
            }
          }, s2 = (e3) => {
            this.emit(SI.ON_MESSAGE, e3);
          }, o2 = (e3) => {
            jC.warn("[".concat(this.connectionID, "] ws open error ").concat(e3));
          };
          this.websocket && (this.websocket.onclose = null, this.websocket.close()), RC("GATEWAY_WSS_ADDRESS") && this.name.startsWith("gateway") && (e2 = RC("GATEWAY_WSS_ADDRESS")), jC.debug("[".concat(this.name, "] start connect, url:"), e2);
          const a2 = null === (t2 = this.store) || void 0 === t2 ? void 0 : t2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "gateway" });
          try {
            var c2;
            const t3 = await this.chooseBestWebsocketConnection(e2);
            this.websocket = t3, n2 && n2(this.websocket.url), this.websocket.onclose = r2, this.websocket.onmessage = s2, this.websocket.onerror = o2, null === (c2 = this.store) || void 0 === c2 || c2.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a2), this.joinGatewayRecordIndex = a2;
          } catch (e3) {
            const t3 = "closed" === this.state, n3 = e3 instanceof Kg, s3 = n3 && e3.code === Hg.WS_ABORT, o3 = n3 && e3.code === Hg.WS_ERR, c3 = n3 ? e3.message : e3 && (e3.reason || e3.toString());
            jC.warning("[choose-best-ws] chooseBestWebsocket error: ".concat(c3)), this.store && this.store.recordJoinChannelService({ endTs: Date.now(), status: s3 ? "aborted" : "error", errors: [e3] }, a2), t3 || o3 ? (i2.reject(t3 ? new Kg(Hg.WS_DISCONNECT, "websocket is closed: ".concat(c3)) : new Kg(Hg.WS_ERR, "init websocket failed: ".concat(c3))), o3 && jC.error("[".concat(this.name, "] init websocket failed: ").concat(c3))) : r2 && r2(e3);
          }
          return i2.promise;
        }
        async reconnectWithAction(e2) {
          let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (this.reconnectCount >= this.retryConfig.maxRetryCount) return false;
          if (0 === this.urls.length) return false;
          if ("closed" === this.state) return false;
          jC.warning("[choose-best-ws] action: =>", e2), this.onlineReconnectListener || wT.isOnline || !wT.onlineWaiter || (this.onlineReconnectListener = wT.onlineWaiter.then(() => {
            this.onlineReconnectListener = void 0;
          }));
          let i2 = true;
          if (this.reconnectInterrupter = () => i2 = false, t2) {
            const t3 = mS(this.reconnectCount, this.retryConfig);
            jC.debug("[".concat(this.name, "] wait ").concat(t3, "ms to reconnect websocket, mode: ").concat(e2)), await cg.race([iS(t3), this.onlineReconnectListener || new cg(() => {
            })]);
          }
          if ("closed" === this._state || !i2) return false;
          this.reconnectCount += 1;
          const n2 = async (e3, t3) => {
            this.emit(SI.RECONNECT_CREATE_CONNECTION, t3), await this.createWebSocketConnection(e3);
          };
          try {
            if ("retry" === e2) this.emit(SI.RECONNECT_WAITTING_FINISH, e2), await n2(this.urls[this.currentURLIndex], e2);
            else if ("tryNext" === e2) {
              if (this.currentURLIndex += 1, this.currentURLIndex >= this.urls.length) return this.reconnectWithAction("recover", false);
              jC.debug("[".concat(this.name, "] websocket url length: ").concat(this.urls.length, " current index: ").concat(this.currentURLIndex)), this.emit(SI.RECONNECT_WAITTING_FINISH, e2), await n2(this.urls[this.currentURLIndex], e2);
            } else "recover" === e2 && (jC.debug("[".concat(this.name, "] request new urls")), this.resetReconnectCount("recover mode"), this.emit(SI.RECONNECT_WAITTING_FINISH, e2), this.urls = await vT(this, SI.REQUEST_NEW_URLS), this.currentURLIndex = 0, await n2(this.urls[this.currentURLIndex], e2));
          } catch (i3) {
            var r2;
            jC.error("[".concat(this.name, "] reconnect failed ").concat(i3 && i3.toString()));
            const n3 = null == i3 || null === (r2 = i3.data) || void 0 === r2 ? void 0 : r2.desc;
            return Array.isArray(n3) && bn(n3).call(n3, "dynamic key expired") ? (this.emit(SI.ON_TOKEN_PRIVILEGE_DID_EXPIRE), false) : this.reconnectWithAction(e2, t2);
          }
          return true;
        }
      }
      class qv extends Yv {
        constructor(e2, t2) {
          super(e2, t2, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 && void 0 !== arguments[3] && arguments[3], arguments.length > 4 && void 0 !== arguments[4] && arguments[4], arguments.length > 5 ? arguments[5] : void 0);
        }
        async chooseBestWebsocketConnection(e2, t2) {
          const i2 = lg(), n2 = function(e3, t3) {
            return new Hv(e3, t3);
          }(this.forceCloseTimeout, this.store);
          this.closeEstablishingWs = () => {
            jC.debug("[choose-best-ws] close establishing websockets"), n2.closeAllWebsockets(), i2.reject(new Kg(Hg.WS_ABORT, "choose best websocket aborted"));
          };
          const r2 = RC("GATEWAY_DOMAINS");
          return jC.debug("[choose-best-ws] currentDomain: ", e2, ", domains: ", r2, "total: ".concat(this.urls.length), "current: ".concat(this.currentURLIndex + 1)), n2.chooseBestWebsocket(e2, this.tryDoubleDomain, this.use443PortOnly, t2).then(i2.resolve).catch(i2.reject), i2.promise.finally(() => {
            this.closeEstablishingWs = void 0;
          });
        }
      }
      class zv extends Yv {
        constructor(e2, t2) {
          super(e2, t2, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 && void 0 !== arguments[3] && arguments[3], arguments.length > 4 && void 0 !== arguments[4] && arguments[4], arguments.length > 5 ? arguments[5] : void 0);
        }
        async chooseBestWebsocketConnection(e2, t2) {
          return new cg((i2, n2) => {
            let r2 = false;
            const s2 = [];
            this.closeEstablishingWs = () => {
              jC.debug("[choose-best-ws] close establishing websockets"), s2.forEach((e3) => {
                e3.onclose = null, e3.onopen = null, e3.onmessage = null, e3.close();
              }), n2(new Kg(Hg.WS_ABORT, "choose best websocket aborted"));
            };
            const o2 = RC("GATEWAY_DOMAINS");
            let a2;
            const c2 = e2.indexOf("?h="), d2 = o2.find((t3) => -1 !== c2 ? bn(e2).call(e2, t3, c2) : bn(e2).call(e2, t3));
            jC.debug("[choose-best-ws] currentDomain: ", d2, ", domains: ", o2);
            let l2 = !this.tryDoubleDomain || !d2;
            if (!l2 && d2) {
              var u2;
              const h4 = Date.now();
              try {
                o2.forEach((t3) => {
                  const i3 = -1 === c2 ? e2.replace(d2, t3) : e2.substr(0, c2) + e2.substr(c2).replace(d2, t3), n3 = new WebSocket(i3);
                  n3.binaryType = "arraybuffer", s2.push(n3), jC.debug("[choose-best-ws] ws is connecting:", n3.url);
                });
              } catch (e3) {
                for (jC.debug("[choose-best-ws] ws create failed, fallback to single url"), s2.forEach((e4) => e4.close()); s2.length; ) s2.pop();
                l2 = true;
              }
              null === (u2 = this.store) || void 0 === u2 || u2.recordJoinChannelService({ urls: s2.map((e3) => e3.url), service: "gateway" }, t2), s2.forEach((e3) => {
                e3.onopen = () => {
                  if (r2) return;
                  const t3 = Date.now() - h4;
                  jC.debug("[choose-best-ws] ws open cost ".concat(t3, "ms")), s2.filter((t4) => t4 !== e3).forEach((e4) => {
                    jC.debug("[choose-best-ws]close backup websocket: ".concat(e4.url)), e4.close();
                  }), r2 = true, i2(e3);
                }, e3.onclose = (e4) => {
                  if (a2 = e4, r2) return;
                  s2.find((e5) => !(e5.readyState === WebSocket.CLOSED || e5.readyState === WebSocket.CLOSING)) || (jC.debug("[choose-best-ws] all websocket is closed"), r2 = true, n2(a2));
                }, e3.onmessage = (t3) => {
                  jC.debug("[choose-best-ws]".concat(e3.url, " onmessage: ").concat(t3.data));
                };
              }), iS(this.forceCloseTimeout).then(() => {
                s2.forEach((e3) => {
                  e3.readyState !== WebSocket.OPEN && e3.close();
                });
              });
            }
            if (l2) {
              var h3;
              let r3;
              jC.debug("[choose-best-ws] use single url: ", e2), null === (h3 = this.store) || void 0 === h3 || h3.recordJoinChannelService({ urls: [e2], service: "gateway" }, t2);
              try {
                r3 = new WebSocket(e2), s2.push(r3), r3.binaryType = "arraybuffer";
              } catch (e3) {
                const t3 = new Kg(Hg.WS_ERR, "init websocket failed! Error: ".concat(e3.toString()));
                return jC.error("[".concat(this.name, "]").concat(t3)), void n2(t3);
              }
              r3.onopen = () => {
                i2(r3);
              }, r3.onclose = (e3) => {
                n2(e3);
              }, r3.onmessage = (e3) => {
                jC.debug("[choose-best-ws]".concat(r3.url, " onmessage: ").concat(e3.data));
              }, iS(this.forceCloseTimeout).then(() => {
                r3 && r3.readyState !== WebSocket.OPEN && r3.close();
              });
            }
          }).then((e3) => (this.closeEstablishingWs = void 0, e3)).catch((e3) => {
            throw this.closeEstablishingWs = void 0, e3;
          });
        }
      }
      class Jv extends dT {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          e2 !== this._connectionState && (this._connectionState = e2, e2 === pI.CONNECTED ? this.emit(_I.WS_CONNECTED) : e2 === pI.RECONNECTING ? this.emit(_I.WS_RECONNECTING, this._websocketReconnectReason) : e2 === pI.CLOSED && this.emit(_I.WS_CLOSED, this._disconnectedReason));
        }
        get currentURLIndex() {
          return this.websocket.currentURLIndex;
        }
        get url() {
          return this.websocket && this.websocket.url || null;
        }
        get rtt() {
          return this.rttRolling.mean();
        }
        constructor(e2, t2) {
          super(), sh(this, "_disconnectedReason", void 0), sh(this, "_websocketReconnectReason", void 0), sh(this, "_connectionState", pI.CLOSED), sh(this, "reconnectToken", void 0), sh(this, "websocket", void 0), sh(this, "openConnectionTime", void 0), sh(this, "clientId", void 0), sh(this, "lastMsgTime", Date.now()), sh(this, "uploadCache", []), sh(this, "uploadCacheInterval", void 0), sh(this, "rttRolling", new gS(5)), sh(this, "pingpongTimer", void 0), sh(this, "wsInflateDataTimer", void 0), sh(this, "pingpongTimeoutCount", 0), sh(this, "joinResponse", void 0), sh(this, "multiIpOption", void 0), sh(this, "initError", void 0), sh(this, "spec", void 0), sh(this, "store", void 0), sh(this, "onWebsocketMessage", (e3) => {
            if (e3.data instanceof ArrayBuffer) return void this.emit(_I.ON_BINARY_DATA, e3.data);
            const t3 = JSON.parse(e3.data);
            if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t3, "_id")) {
              const e4 = "res-@".concat(t3._id);
              this.emit(e4, t3._result, t3._message);
            } else if (Object.prototype.hasOwnProperty.call(t3, "_type")) {
              if (this.emit(t3._type, t3._message), t3._type === fI.ON_NOTIFICATION && this.handleNotification(t3._message), t3._type === fI.ON_USER_BANNED) switch (t3._message.error_code) {
                case 14:
                  this.close(ET.UID_BANNED);
                  break;
                case 15:
                  this.close(ET.IP_BANNED);
                  break;
                case 16:
                  this.close(ET.CHANNEL_BANNED);
              }
              if (t3._type === fI.ON_USER_LICENSE_BANNED) switch (t3._message.error_code) {
                case hI.ERR_LICENSE_MISSING:
                  this.close(ET.LICENSE_MISSING);
                  break;
                case hI.ERR_LICENSE_EXPIRED:
                  this.close(ET.LICENSE_EXPIRED);
                  break;
                case hI.ERR_LICENSE_MINUTES_EXCEEDED:
                  this.close(ET.LICENSE_MINUTES_EXCEEDED);
                  break;
                case hI.ERR_LICENSE_PERIOD_INVALID:
                  this.close(ET.LICENSE_PERIOD_INVALID);
                  break;
                case hI.ERR_LICENSE_MULTIPLE_SDK_SERVICE:
                  this.close(ET.LICENSE_MULTIPLE_SDK_SERVICE);
                  break;
                case hI.ERR_LICENSE_ILLEGAL:
                  this.close(ET.LICENSE_ILLEGAL);
                  break;
                default:
                  this.close();
              }
            }
          }), this.clientId = e2.clientId, this.spec = e2, this.store = t2, this.websocket = new qv("gateway-".concat(this.clientId), this.spec.retryConfig, true, RC("JOIN_GATEWAY_USE_DUAL_DOMAIN"), RC("JOIN_GATEWAY_USE_443PORT_ONLY"), t2), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
            this.connectionState === pI.CONNECTED && this.reconnect("retry", fT.OFFLINE);
          });
        }
        async request(e2, t2, i2, n2) {
          const r2 = nS(6, ""), s2 = { _id: r2, _type: e2, _message: t2 }, o2 = this.websocket.connectionID, a2 = () => new cg((t3, i3) => {
            if (this.connectionState === pI.CONNECTED) return t3();
            const n3 = () => {
              this.off(_I.WS_CLOSED, r3), t3();
            }, r3 = () => {
              this.off(_I.WS_CONNECTED, n3), i3(new LI(Hg.WS_ABORT));
            };
            this.once(_I.WS_CONNECTED, n3), this.once(_I.WS_CLOSED, r3), e2 !== EI.PUBLISH && e2 !== EI.PUBLISH_DATASTREAM && e2 !== EI.SUBSCRIBE && e2 !== EI.SUBSCRIBE_DATASTREAM && e2 !== EI.UNSUBSCRIBE && e2 !== EI.UNSUBSCRIBE_DATASTREAM && e2 !== EI.UNPUBLISH && e2 !== EI.UNPUBLISH_DATASTREAM && e2 !== EI.CONTROL && e2 !== EI.RESTART_ICE || this.once(_I.DISCONNECT_P2P, () => {
              i3(new LI(Hg.DISCONNECT_P2P));
            }), e2 !== EI.PUBLISH && e2 !== EI.RESTART_ICE || this.once(_I.ABORT_P2P_EXECUTION, () => {
              i3(new LI(Hg.DISCONNECT_P2P));
            });
          });
          if (this.connectionState !== pI.CONNECTING && this.connectionState !== pI.RECONNECTING || e2 === EI.JOIN || e2 === EI.REJOIN || await a2(), this.websocket.sendMessage(s2, true), n2) return;
          const c2 = new cg((i3, n3) => {
            let s3 = false;
            const a3 = (n4, r3) => {
              s3 = true, i3({ isSuccess: "success" === n4, message: r3 || {} }), this.off(_I.WS_CLOSED, c3), this.off(_I.WS_RECONNECTING, c3), this.emit(_I.REQUEST_SUCCESS, e2, t2);
            };
            this.once("res-@".concat(r2), a3);
            const c3 = () => {
              n3(new LI(Hg.WS_ABORT, "type: ".concat(e2))), this.off(_I.WS_CLOSED, c3), this.off(_I.WS_RECONNECTING, c3), this.off("res-@".concat(r2), a3);
            };
            this.once(_I.WS_CLOSED, c3), this.once(_I.WS_RECONNECTING, c3), iS(RC("SIGNAL_REQUEST_TIMEOUT")).then(() => {
              this.websocket.connectionID !== o2 || s3 || (jC.warning("[".concat(this.clientId, "] ws request timeout, type: ").concat(e2)), this.emit(_I.REQUEST_TIMEOUT, e2, t2));
            });
          });
          let d2 = null;
          try {
            d2 = await c2;
          } catch (n3) {
            if (this.connectionState === pI.CLOSED || e2 === EI.LEAVE) throw new LI(Hg.WS_ABORT);
            return !this.spec.forceWaitGatewayResponse || i2 ? n3.throw() : e2 === EI.JOIN || e2 === EI.REJOIN ? null : (await a2(), await this.request(e2, t2));
          }
          if (d2.isSuccess) return d2.message;
          const l2 = Number(d2.message.error_code || d2.message.code), u2 = kv(l2), h3 = new LI(Hg.UNEXPECTED_RESPONSE, "".concat(u2.desc, ": ").concat(d2.message.error_str), { code: l2, data: d2.message });
          return "success" === u2.action ? d2.message : (jC.warning("[".concat(this.clientId, "] [").concat(this.websocket.connectionID, "] unexpected response from type ").concat(e2, ", error_code: ").concat(l2, ", message: ").concat(u2.desc, ", action: ").concat(u2.action)), l2 === hI.ERR_TOO_MANY_BROADCASTERS ? e2 === EI.JOIN || e2 === EI.REJOIN ? (this.initError = h3, this.close(), h3.throw()) : h3.throw() : "failed" === u2.action ? h3.throw() : "quit" === u2.action ? (this.initError = h3, this.close(), h3.throw()) : (l2 === hI.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d2.message.option, jC.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", fT.MULTI_IP)) : this.reconnect(u2.action, fT.SERVER_ERROR), e2 === EI.JOIN || e2 === EI.REJOIN ? null : await this.request(e2, t2)));
        }
        waitMessage(e2, t2) {
          return new cg((i2) => {
            const n2 = (r2) => {
              (!t2 || t2(r2)) && (this.off(e2, n2), i2(r2));
            };
            this.on(e2, n2);
          });
        }
        uploadWRTCStats(e2) {
          if (!this.store.sessionId) return void jC.warn("[".concat(this.clientId, "] no session id when upload wrtc stats"));
          const t2 = { lts: Date.now(), sid: this.store.sessionId, uid: this.store.intUid, stats: e2 };
          this.upload(mI.WRTC_STATS, t2);
        }
        upload(e2, t2) {
          const i2 = { _type: e2, _message: t2 };
          try {
            this.websocket.sendMessage(i2);
          } catch (e3) {
            const t3 = RC("MAX_UPLOAD_CACHE") || 50;
            this.uploadCache.push(i2), this.uploadCache.length > t3 && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
              if (this.connectionState !== pI.CONNECTED) return;
              const e4 = this.uploadCache.splice(0, 1)[0];
              0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e4._type, e4._message);
            }, RC("UPLOAD_CACHE_INTERVAL") || 2e3));
          }
        }
        send(e2, t2) {
          const i2 = { _type: e2, _message: t2 };
          this.websocket.sendMessage(i2);
        }
        init(e2, t2) {
          return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new cg((t3, i2) => {
            this.once(_I.WS_CONNECTED, () => t3(this.joinResponse)), this.once(_I.WS_CLOSED, () => i2(this.initError || new LI(Hg.WS_ABORT))), this.connectionState = pI.CONNECTING, this.websocket.init(e2).catch(i2), this.wsInflateDataTimer && window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = window.setInterval(() => {
              this.handleWsInflateData();
            }, 2e4);
          });
        }
        close(e2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.wsInflateDataTimer && (this.handleWsInflateData(), window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e2 || ET.LEAVE, this.connectionState = pI.CLOSED, jC.debug("[".concat(this.clientId, "] ") + "will close websocket in signal"), this.websocket.close(), e2 === ET.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new qv("gateway-".concat(this.clientId), this.spec.retryConfig, true, RC("JOIN_GATEWAY_USE_DUAL_DOMAIN"), RC("JOIN_GATEWAY_USE_443PORT_ONLY"), this.store), this.handleWebsocketEvents());
        }
        async join() {
          if (!this.joinResponse) {
            this.emit(_I.ABORT_P2P_EXECUTION);
            const e2 = await vT(this, _I.REQUEST_JOIN_INFO), t2 = await this.request(EI.JOIN, e2);
            if (!t2) return this.emit(_I.REPORT_JOIN_GATEWAY, QI.TIMEOUT, this.url || ""), false;
            this.joinResponse = t2, this.emit(_I.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
          }
          return this.connectionState = pI.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true;
        }
        async rejoin() {
          if (!this.reconnectToken) throw new LI(Hg.UNEXPECTED_ERROR, "can not rejoin, no rejoin token");
          const e2 = bT(this, _I.REQUEST_REJOIN_INFO);
          e2.token = this.reconnectToken;
          const t2 = await this.request(EI.REJOIN, e2);
          return !!t2 && (this.connectionState = pI.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t2.peers && t2.peers.forEach((e3) => {
            this.emit(fI.ON_USER_ONLINE, { uid: e3.uid }), e3.audio && this.emit(fI.ON_ADD_AUDIO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, audio: true, ssrcId: e3.audio_ssrc }), e3.video && this.emit(fI.ON_ADD_VIDEO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, video: true, ssrcId: e3.video_ssrc }), e3.audio_mute ? this.emit(fI.MUTE_AUDIO, { uid: e3.uid }) : this.emit(fI.UNMUTE_AUDIO, { uid: e3.uid }), e3.video_mute ? this.emit(fI.MUTE_VIDEO, { uid: e3.uid }) : this.emit(fI.UNMUTE_VIDEO, { uid: e3.uid }), e3.audio_enable_local ? this.emit(fI.ENABLE_LOCAL_AUDIO, { uid: e3.uid }) : this.emit(fI.DISABLE_LOCAL_AUDIO, { uid: e3.uid }), e3.video_enable_local ? this.emit(fI.ENABLE_LOCAL_VIDEO, { uid: e3.uid }) : this.emit(fI.DISABLE_LOCAL_VIDEO, { uid: e3.uid }), e3.audio || e3.video || this.emit(fI.ON_REMOVE_STREAM, { uid: e3.uid, uint_id: e3.uint_id });
          }), true);
        }
        reconnect(e2, t2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e2, t2);
        }
        handleNotification(e2) {
          jC.debug("[".concat(this.clientId, "] receive notification: "), e2);
          const t2 = kv(e2.code);
          if ("success" !== t2.action) {
            if ("failed" !== t2.action) return "quit" === t2.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t2.desc && this.close(ET.UID_BANNED), void this.close()) : void this.reconnect(t2.action, fT.SERVER_ERROR);
            jC.error("[".concat(this.clientId, "] ignore error: "), t2.desc);
          }
        }
        handlePingPong() {
          if (!this.websocket || "connected" !== this.websocket.state) return;
          this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
          const e2 = RC("PING_PONG_TIME_OUT"), t2 = Date.now();
          this.pingpongTimeoutCount >= e2 && (jC.warning("[".concat(this.clientId, "] PING-PONG Timeout. Last Socket Message: ").concat(t2 - this.lastMsgTime, "ms")), t2 - this.lastMsgTime > RC("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", fT.TIMEOUT) : this.request(EI.PING, void 0, true).then(() => {
            this.pingpongTimeoutCount = 0;
            const e3 = Date.now() - t2;
            this.rttRolling.add(e3), RC("REPORT_STATS") && this.send(EI.PING_BACK, { pingpongElapse: e3 });
          }).catch((e3) => {
          });
        }
        handleWsInflateData() {
          const { wsInflateLength: e2, wsDeflateLength: t2 } = this.websocket.getWsInflateData();
          0 !== e2 && 0 !== t2 && this.upload(mI.WS_INFLATE_DATA_LENGTH, { ws_deflate_length: t2, ws_inflate_length: e2 });
        }
        handleWebsocketEvents() {
          this.websocket.on(SI.RECONNECT_WAITTING_FINISH, (e2) => {
            this.emit(_I.WS_RECONNECT_WAITTING_FINISH, e2);
          }), this.websocket.on(SI.RECONNECT_CREATE_CONNECTION, (e2) => {
            this.emit(_I.WS_RECONNECT_CREATE_CONNECTION, e2);
          }), this.websocket.on(SI.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(SI.CLOSED, () => {
            this.connectionState = pI.CLOSED;
          }), this.websocket.on(SI.FAILED, () => {
            this._disconnectedReason = ET.NETWORK_ERROR, this.connectionState = pI.CLOSED;
          }), this.websocket.on(SI.RECONNECTING, (e2) => {
            this._websocketReconnectReason = e2, this.joinResponse = void 0, this.connectionState === pI.CONNECTED ? this.connectionState = pI.RECONNECTING : this.connectionState = pI.CONNECTING;
          }), this.websocket.on(SI.WILL_RECONNECT, (e2, t2, i2) => {
            const n2 = bT(this, _I.IS_P2P_DISCONNECTED), r2 = n2 || "retry" !== e2;
            n2 && "retry" === e2 && (jC.debug("".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), e2 = "tryNext", t2 = QI.P2P_DISCONNECTED), r2 && (jC.debug("".concat(this.clientId, " will renewSession, reconnect mode: ").concat(e2)), this.emit(_I.REPORT_JOIN_GATEWAY, t2 || QI.UNKNOWN_REASON, this.url || ""), this.reconnectToken = void 0, this.emit(_I.NEED_RENEW_SESSION), this.emit(_I.DISCONNECT_P2P)), i2(e2);
          }), this.websocket.on(SI.CONNECTED, () => {
            this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch((e2) => {
              jC.warning("[".concat(this.clientId, "] rejoin failed ").concat(e2)), this.reconnect("tryNext", fT.SERVER_ERROR);
            }) : this.join().catch((e2) => {
              if (this.emit(_I.REPORT_JOIN_GATEWAY, e2.message || e2.code || QI.UNKNOWN_REASON, this.url || ""), e2 instanceof LI && e2.code === Hg.UNEXPECTED_RESPONSE && e2.data.code === hI.ERR_NO_AUTHORIZED) return jC.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), void this.reconnect("recover", fT.SERVER_ERROR);
              jC.error("[".concat(this.clientId, "] join gateway request failed"), e2.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", fT.SERVER_ERROR) : (this.initError = e2, this.close());
            });
          }), this.websocket.on(SI.REQUEST_NEW_URLS, (e2, t2) => {
            vT(this, _I.REQUEST_RECOVER, this.multiIpOption).then(e2).catch(t2);
          }), this.websocket.on(SI.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
            this.emit(fI.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
          });
        }
      }
      var Xv = "	\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\uFEFF", Qv = J, Zv = pn, $v = Xv, ey = d("".replace), ty = RegExp("^[" + $v + "]+"), iy = RegExp("(^|[^" + $v + "])[" + $v + "]+$"), ny = function(e2) {
        return function(t2) {
          var i2 = Zv(Qv(t2));
          return 1 & e2 && (i2 = ey(i2, ty, "")), 2 & e2 && (i2 = ey(i2, iy, "$1")), i2;
        };
      }, ry = { start: ny(1), end: ny(2), trim: ny(3) }, sy = zd.PROPER, oy = n, ay = Xv, cy = ry.trim;
      wi({ target: "String", proto: true, forced: function(e2) {
        return oy(function() {
          return !!ay[e2]() || "âÂá " !== "âÂá "[e2]() || sy && ay[e2].name !== e2;
        });
      }("trim") }, { trim: function() {
        return cy(this);
      } });
      var dy, ly, uy = zi("String").trim, hy = l, py = uy, _y = String.prototype, Ey = i(function(e2) {
        var t2 = e2.trim;
        return "string" == typeof e2 || e2 === _y || hy(_y, e2) && t2 === _y.trim ? py : t2;
      });
      function my(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function fy(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? my(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : my(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      function gy(e2) {
        return e2.match(/^[\.\:\d]+$/) ? "".concat(e2.replace(/[^\d]/g, "-"), ".").concat(RC("TURN_DOMAIN")) : (jC.info("Unidentified as ip: ".concat(e2, ", use as host")), e2);
      }
      function Ty(e2, t2) {
        e2.addresses || (e2.addresses = []);
        const i2 = function(e3, t3) {
          if (RC("CONNECT_GATEWAY_WITHOUT_DOMAIN")) return e3.map((e4) => {
            let { ip: t4, port: i4 } = e4;
            return { address: "".concat(t4, ":").concat(i4) };
          });
          const i3 = RC("GATEWAY_DOMAINS");
          let n3 = i3[1] && bn(t3).call(t3, i3[1]) ? 1 : 0;
          return e3.map((e4) => {
            let { domain_prefix: t4, port: r3, ip: s2 } = e4;
            if (t4) return { address: "".concat(t4, ".").concat(i3[n3++ % i3.length], ":").concat(r3) };
            const o2 = /^[\.\:\d]+$/.test(s2), a2 = o2 ? "".concat(s2.replace(/[^\d]/g, "-"), ".").concat(i3[n3++ % i3.length], ":").concat(r3) : "".concat(s2, ":").concat(r3);
            return o2 || jC.info("Unidentified as ip: ".concat(s2, ", use as host")), { ip: s2, port: r3, address: a2 };
          });
        }(e2.addresses, t2), n2 = Array.isArray(e2.detail) && e2.detail[18];
        if (n2 && "string" == typeof n2) {
          const e3 = n2.split(";");
          for (let t3 = 0; t3 < e3.length; t3++) {
            var r2;
            const n3 = Ey(r2 = e3[t3]).call(r2);
            i2[t3] && n3 && (i2[t3].ip6 = n3);
          }
        }
        return { gatewayAddrs: i2, uid: e2.uid, cid: e2.cid, cert: e2.cert, vid: e2.detail && e2.detail[8], uni_lbs_ip: e2.detail && e2.detail[1], res: e2, csIp: e2.detail && e2.detail[502] };
      }
      function Sy(e2) {
        return "number" == typeof e2 ? e2 : e2.exact || e2.ideal || e2.max || e2.min || 0;
      }
      function Ry(e2) {
        const t2 = e2._encoderConfig;
        if (!t2) return {};
        const i2 = { resolution: t2.width && t2.height ? "".concat(Sy(t2.width), "x").concat(Sy(t2.height)) : void 0, maxVideoBW: t2.bitrateMax, minVideoBW: t2.bitrateMin };
        return "number" == typeof t2.frameRate ? (i2.maxFrameRate = t2.frameRate, i2.minFrameRate = t2.frameRate) : t2.frameRate && (i2.maxFrameRate = t2.frameRate.max || t2.frameRate.ideal || t2.frameRate.exact || t2.frameRate.min, i2.minFrameRate = t2.frameRate.min || t2.frameRate.ideal || t2.frameRate.exact || t2.frameRate.max), i2;
      }
      function Cy(e2) {
        return e2 >= 0 && e2 < 0.17 ? 1 : e2 >= 0.17 && e2 < 0.36 ? 2 : e2 >= 0.36 && e2 < 0.59 ? 3 : e2 >= 0.59 && e2 <= 1 ? 4 : e2 > 1 ? 5 : 0;
      }
      function Iy(e2, t2) {
        let i2, n2, r2;
        switch (t2) {
          case dy.CHOOSE_SERVER:
            n2 = 4096, r2 = "choose server";
            break;
          case dy.CLOUD_PROXY:
            n2 = 1048576, r2 = "proxy";
            break;
          case dy.CLOUD_PROXY_5:
            n2 = 4194304, r2 = "proxy5";
            break;
          case dy.CLOUD_PROXY_FALLBACK:
            n2 = 4194310, r2 = "proxy fallback";
            break;
          default:
            throw new LI(Hg.UNEXPECTED_ERROR, "multi unlibs response transformer get unknown service id", { csIp: e2.detail && e2.detail[502], retry: false });
        }
        if (e2.response_body.forEach((t3) => {
          t3.buffer && t3.buffer.flag === n2 && (i2 = { code: t3.buffer.code, addresses: (t3.buffer.edges_services || []).map((e3) => fy(fy({}, e3), {}, { ticket: t3.buffer.cert })), server_ts: e2.enter_ts, uid: t3.buffer.uid, cid: t3.buffer.cid, cname: t3.buffer.cname, detail: fy(fy({}, t3.buffer.detail), e2.detail), flag: t3.buffer.flag, opid: e2.opid, cert: t3.buffer.cert });
        }), !i2) throw new LI(Hg.MULTI_UNILBS_RESPONSE_ERROR, "cannot parse response ".concat(r2, " from multi unilbs response"), { csIp: e2.detail && e2.detail[502] });
        return i2;
      }
      async function vy(e2, t2) {
        return await cg.all(e2.addresses.map(async (e3) => ({ address: gy(e3.ip), tcpport: e3.port, udpport: e3.port, username: t2 && RC("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? t2.toString() : iI.username, password: t2 && RC("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? await cT(t2.toString()) : iI.password })));
      }
      function yy(e2, t2) {
        const i2 = t2._videoHeight || t2.getMediaStreamTrack(true).getSettings().height;
        return i2 ? Math.max(i2 / Sy(e2.height), 1) : (jC.warning("can't get ori-track's height, default scale down 4 times for low stream"), 4);
      }
      function Ay(e2) {
        let { candidateType: t2, relayProtocol: i2, type: n2, address: r2, port: s2, protocol: o2 } = e2;
        return "local-candidate" === n2 ? { candidateType: t2, relayProtocol: i2, protocol: o2 } : { candidateType: t2, relayProtocol: i2, address: r2, port: s2, protocol: o2 };
      }
      function by(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      !function(e2) {
        e2[e2.CHOOSE_SERVER = 11] = "CHOOSE_SERVER", e2[e2.CLOUD_PROXY = 18] = "CLOUD_PROXY", e2[e2.CLOUD_PROXY_5 = 20] = "CLOUD_PROXY_5", e2[e2.CLOUD_PROXY_FALLBACK = 26] = "CLOUD_PROXY_FALLBACK";
      }(dy || (dy = {}));
      class wy extends dT {
        get url() {
          return this._url ? this._url : null;
        }
        get reconnectMode() {
          return this._reconnectMode;
        }
        set reconnectMode(e2) {
          var t2;
          bn(t2 = ["tryNext", "recover"]).call(t2, e2) && this.resetReconnectCount(e2), this._reconnectMode = e2;
        }
        get state() {
          return this._state;
        }
        set state(e2) {
          e2 !== this._state && (this._state = e2, "reconnecting" === this._state ? this.emit(gv.RECONNECTING, this.reconnectReason) : "connected" === this._state ? this.emit(gv.CONNECTED) : "closed" === this._state ? this.emit(gv.CLOSED) : "failed" === this._state && this.emit(gv.FAILED));
        }
        constructor(e2, t2, i2, n2) {
          super(), sh(this, "connectionID", 0), sh(this, "currentURLIndex", 0), sh(this, "reconnectReason", void 0), sh(this, "_reconnectMode", "tryNext"), sh(this, "_name", void 0), sh(this, "_state", "closed"), sh(this, "_retryConfig", void 0), sh(this, "_reconnectCount", 0), sh(this, "_forceCloseTimeout", 5e3), sh(this, "_onlineReconnectListener", void 0), sh(this, "_closeEstablishingTransmitter", () => {
          }), sh(this, "_store", void 0), sh(this, "_joinChannelServiceRecordIndex", void 0), sh(this, "_useCompress", void 0), sh(this, "_inflateLength", 0), sh(this, "_deflateLength", 0), this._store = n2, this._name = e2, this._retryConfig = function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var i3 = null != arguments[t3] ? arguments[t3] : {};
              t3 % 2 ? by(Object(i3), true).forEach(function(t4) {
                sh(e3, t4, i3[t4]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : by(Object(i3)).forEach(function(t4) {
                Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
              });
            }
            return e3;
          }({}, t2), this._useCompress = i2;
        }
        resetReconnectCount(e2) {
          jC.debug("".concat(this._name, " reset reconnect count, reason: ").concat(e2)), this._reconnectCount = 0;
        }
        close(e2, t2) {
          if (this.currentURLIndex = 0, this.resetReconnectCount("close"), this._reconnectInterrupter && this._reconnectInterrupter(), this._transmitter) {
            this._transmitter.onclose = null, this._transmitter.onopen = null, this._transmitter.onmessage = null;
            const e3 = this._transmitter;
            t2 ? setTimeout(() => e3.close(), 500) : e3.close(), this._transmitter = void 0;
          }
          this.state = e2 ? "failed" : "closed", this._closeEstablishingTransmitter && this._closeEstablishingTransmitter();
        }
        reconnect(e2, t2) {
          if (!this._transmitter) return void jC.warning("[".concat(this._name, "] can not reconnect, no websocket"));
          var i2;
          (void 0 !== e2 && (this.reconnectMode = e2), jC.debug("[".concat(this._name, "] reconnect is triggered initiative")), "number" == typeof this._joinChannelServiceRecordIndex) && (null === (i2 = this._store) || void 0 === i2 || i2.recordJoinChannelService({ status: "error", errors: [new Error(t2)] }, this._joinChannelServiceRecordIndex));
          const n2 = this._transmitter.onclose;
          this._transmitter.onclose = null, this._transmitter.close(), n2 && n2.bind(this._transmitter)({ code: 9999, reason: t2 });
        }
        getInflateData() {
          const e2 = this._inflateLength, t2 = this._deflateLength;
          return this.clearInflateData(), { inflateLength: e2, deflateLength: t2 };
        }
        setInflateData(e2) {
          this._deflateLength = this._deflateLength + e2.originLength, this._inflateLength = this._inflateLength + e2.compressedLength;
        }
        clearInflateData() {
          this._inflateLength = 0, this._deflateLength = 0;
        }
      }
      !function(e2) {
        e2[e2.Default = 0] = "Default", e2[e2.Ack = 1] = "Ack";
      }(ly || (ly = {}));
      class Oy {
        constructor(e2, t2, i2) {
          sh(this, "version", 1), sh(this, "initialRTO", void 0), sh(this, "maxBatchAckCount", void 0), sh(this, "maxRTO", void 0), sh(this, "initialRTT", void 0), sh(this, "ID", void 0), sh(this, "rtt", void 0), sh(this, "packetNumber", 1), sh(this, "rtoRatioMap", /* @__PURE__ */ new Map()), sh(this, "timeoutMap", /* @__PURE__ */ new Map()), sh(this, "unorderedPacketQueue", []), sh(this, "batchAckPacketQueue", []), sh(this, "lastOrderedPacketNumber", 0), sh(this, "batchAckTimer", void 0), sh(this, "sendImpl", void 0), sh(this, "receiveImpl", void 0), this.sendImpl = e2, this.receiveImpl = t2, this.ID = nS(7, "transmitter-"), this.initialRTO = void 0 !== (null == i2 ? void 0 : i2.initialRTO) ? i2.initialRTO : RC("TRANSMITTER_INITIAL_RTO"), this.initialRTT = void 0 !== (null == i2 ? void 0 : i2.initialRTT) ? i2.initialRTT : RC("TRANSMITTER_INITIAL_RTT"), this.rtt = void 0 !== (null == i2 ? void 0 : i2.initialRTT) ? i2.initialRTT : RC("TRANSMITTER_INITIAL_RTT"), this.maxBatchAckCount = void 0 !== (null == i2 ? void 0 : i2.maxBatchAckCount) ? i2.maxBatchAckCount : RC("TRANSMITTER_MAX_BATCH_ACK_COUNT"), this.maxRTO = void 0 !== (null == i2 ? void 0 : i2.maxRTO) ? i2.maxRTO : RC("TRANSMITTER_MAX_RTO");
        }
        packetize(e2, t2) {
          return { type: ly.Default, version: this.version, packetNumber: t2, payload: e2 };
        }
        serialize(e2) {
          switch (e2.type) {
            case ly.Default: {
              let t2;
              if ("string" == typeof e2.payload) {
                t2 = new TextEncoder().encode(e2.payload);
              } else t2 = e2.payload;
              const i2 = new ArrayBuffer(t2.length + 15), n2 = new DataView(i2);
              n2.setUint16(0, e2.version), n2.setUint8(2, e2.type), n2.setUint32(3, e2.packetNumber), tT(n2, 7, BigInt(e2.sendTs));
              return new Uint8Array(n2.buffer).set(t2, 15), i2;
            }
            case ly.Ack: {
              const t2 = new ArrayBuffer(16), i2 = new DataView(t2);
              return i2.setUint16(0, e2.version), i2.setUint8(2, e2.type), i2.setUint32(3, e2.maxAckPacketNumber), i2.setUint8(7, e2.shift), tT(i2, 8, BigInt(e2.ackSendTs)), t2;
            }
          }
        }
        deserialize(e2) {
          const t2 = new DataView(e2), i2 = t2.getUint16(0), n2 = t2.getUint8(2);
          switch (n2) {
            case ly.Default: {
              const r2 = t2.getUint32(3), s2 = eT(t2, 7), o2 = e2.slice(15), a2 = new TextDecoder().decode(o2);
              return { version: i2, type: n2, packetNumber: r2, sendTs: Number(s2), payload: a2 };
            }
            case ly.Ack: {
              const e3 = t2.getUint32(3), r2 = t2.getUint8(7), s2 = eT(t2, 8);
              return { version: i2, type: n2, maxAckPacketNumber: e3, shift: r2, ackSendTs: Number(s2) };
            }
            default:
              throw jC.error("[".concat(this.ID, "] Unrecognized packet type ").concat(n2)), new Error("Unrecognized packet type ".concat(n2));
          }
        }
        sendMessage(e2) {
          const t2 = this.packetize(e2, this.packetNumber);
          this.packetNumber = 4294967295 === this.packetNumber ? 1 : this.packetNumber + 1;
          const i2 = this.calculateRTO(t2), n2 = window.setTimeout(() => {
            this.resendMessage(t2);
          }, i2);
          this.timeoutMap.set(t2.packetNumber, n2), this.sendPacket(t2);
        }
        onData(e2) {
          const t2 = this.deserialize(e2);
          t2.type === ly.Default ? this.ack(t2) : t2.type === ly.Ack && (this.updateRTT(t2, Math.round(performance.now())), this.clearRTO(t2));
        }
        close() {
          this.rtt = this.initialRTT, this.packetNumber = 1, Array.from(this.timeoutMap.entries()).forEach((e2) => {
            let [t2, i2] = e2;
            window.clearTimeout(i2);
          }), this.timeoutMap = /* @__PURE__ */ new Map(), this.rtoRatioMap = /* @__PURE__ */ new Map(), this.unorderedPacketQueue = [], this.batchAckPacketQueue = [], this.lastOrderedPacketNumber = 0, void 0 !== this.batchAckTimer && window.clearTimeout(this.batchAckTimer);
        }
        resendMessage(e2) {
          const t2 = this.calculateRTO(e2), i2 = window.setTimeout(() => {
            this.resendMessage(e2);
          }, t2);
          this.timeoutMap.set(e2.packetNumber, i2), this.sendPacket(e2);
        }
        calculateRTO(e2) {
          const t2 = this.rtoRatioMap.get(e2.packetNumber);
          if (void 0 === t2) return this.rtoRatioMap.set(e2.packetNumber, 1), this.initialRTO;
          {
            const i2 = 9 * this.rtt / 8 * t2;
            return this.rtoRatioMap.set(e2.packetNumber, t2 + 1), i2 > this.maxRTO ? this.maxRTO : i2;
          }
        }
        updateRTT(e2, t2) {
          const i2 = e2.ackSendTs;
          this.rtt = this.rtt * (7 / 8) + (t2 - i2 - this.rtt) / 8;
        }
        ack(e2) {
          if (e2.packetNumber === this.lastOrderedPacketNumber + 1) for (this.batchAckPacketQueue.length >= this.maxBatchAckCount && this.batchAck(), this.batchAckTimer ? this.batchAckPacketQueue.push(e2) : (this.batchAckPacketQueue.push(e2), this.batchAckTimer = window.setTimeout(() => {
            this.batchAck();
          }, this.rtt / 8)), this.lastOrderedPacketNumber += 1, this.receiveImpl(e2.payload); ; ) {
            const e3 = this.unorderedPacketQueue[0];
            if (!e3) {
              this.unorderedPacketQueue.shift();
              break;
            }
            this.batchAckTimer && this.batchAck(), this.receiveImpl(e3.payload), this.unorderedPacketQueue.shift(), this.lastOrderedPacketNumber += 1;
          }
          else if (e2.packetNumber <= this.lastOrderedPacketNumber) {
            const t2 = { ackSendTs: e2.sendTs, maxAckPacketNumber: e2.packetNumber, shift: 0, type: ly.Ack, version: this.version };
            this.sendPacket(t2);
          } else if (e2.packetNumber > this.lastOrderedPacketNumber) {
            this.unorderedPacketQueue[e2.packetNumber - this.lastOrderedPacketNumber - 2] = e2;
            const t2 = { ackSendTs: e2.sendTs, maxAckPacketNumber: e2.packetNumber, shift: 0, type: ly.Ack, version: this.version };
            this.sendPacket(t2);
          }
        }
        batchAck() {
          window.clearTimeout(this.batchAckTimer), this.batchAckTimer = void 0;
          const e2 = { ackSendTs: this.batchAckPacketQueue[this.batchAckPacketQueue.length - 1].sendTs, maxAckPacketNumber: this.batchAckPacketQueue[this.batchAckPacketQueue.length - 1].packetNumber, shift: this.batchAckPacketQueue.length - 1, type: ly.Ack, version: this.version };
          this.sendPacket(e2), this.batchAckPacketQueue = [];
        }
        sendPacket(e2) {
          e2.type === ly.Default && (e2.sendTs = Math.round(performance.now()));
          const t2 = this.serialize(e2);
          this.sendImpl(t2);
        }
        clearRTO(e2) {
          for (let t2 = e2.maxAckPacketNumber - e2.shift; t2 <= e2.maxAckPacketNumber; t2++) {
            const e3 = this.timeoutMap.get(t2);
            void 0 !== e3 && window.clearTimeout(e3), this.timeoutMap.delete(t2), this.rtoRatioMap.delete(t2);
          }
        }
      }
      class Ny extends wy {
        constructor(e2, t2) {
          super(e2, t2, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 ? arguments[3] : void 0), sh(this, "_initMutex", void 0), sh(this, "_reconnectInterrupter", void 0), sh(this, "_url", void 0), sh(this, "_transmitter", void 0), sh(this, "_addresses", void 0), sh(this, "_reliableTransmission", void 0), this._initMutex = new pS("datachannel");
          const { timeout: i2, timeoutFactor: n2 } = t2, r2 = Math.max(300, Math.floor(3 * i2 / 5)), s2 = Math.max(1.2, Math.floor(8 * n2) / 10);
          gT.ONLINE && (this._retryConfig.timeout = r2, this._retryConfig.timeoutFactor = s2), wT.on(TT.NETWORK_STATE_CHANGE, (e3, t3) => {
            e3 !== t3 && (this.resetReconnectCount("network state change: ".concat(t3, " -> ").concat(e3)), e3 === gT.ONLINE ? (this._retryConfig.timeout = r2, this._retryConfig.timeoutFactor = s2) : (this._retryConfig.timeout = i2, this._retryConfig.timeoutFactor = n2));
          });
        }
        getConnection() {
          if (this._reliableTransmission) return this._reliableTransmission;
        }
        async init(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
          this._forceCloseTimeout = t2;
          const i2 = (t3, i3) => {
            this._addresses = e2, this.currentURLIndex = this._addresses.findIndex((e3) => e3.fingerprint || RC("FINGERPRINT"));
            const n2 = this._addresses[this.currentURLIndex];
            this.state = "connecting", this.createTransmitterConnection(n2).then(t3).catch(i3), this.once(gv.CLOSED, () => i3(new LI(Hg.WS_DISCONNECT))), this.once(gv.CONNECTED, () => t3());
          };
          return this._initMutex.lock().then((e3) => new cg((e4, t3) => {
            i2(e4, t3);
          }).then(() => {
            e3();
          }).catch(() => {
            e3();
          }));
        }
        sendMessage(e2) {
          let t2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          if (!this._transmitter || !this._reliableTransmission) throw new LI(Hg.WS_ABORT, "datachannel is not ready");
          try {
            t2 || (e2 = JSON.stringify(e2)), this._reliableTransmission.sendMessage(e2);
          } catch (e3) {
            throw new LI(Hg.WS_ERR, "send datachannel signal message error" + e3.toString());
          }
        }
        unbindDcCloseEventListener() {
          this._transmitter && (this._transmitter.onclose = null);
        }
        sendMessageWithJSON(e2) {
          const t2 = JSON.stringify(e2);
          return { compressed: t2, compressedLength: t2.length, origin: e2 };
        }
        sendMessageWithUint8Array(e2) {
          return { compressed: e2, compressedLength: e2.byteLength, origin: e2 };
        }
        createTransmitterConnection(e2) {
          return this.connectionID += 1, this._joinChannelServiceRecordIndex = void 0, this._url = "dc://".concat(e2.ip, ":").concat(e2.port), new cg((t2, i2) => {
            var n2;
            const r2 = () => {
              jC.debug("[".concat(this._name, "] datachannel opened:"), this._url), this.reconnectMode = "retry", this.state = "connected", this.resetReconnectCount("opened"), t2();
            }, s2 = async (e3) => {
              var n3;
              if (null === (n3 = this._closeEstablishingTransmitter) || void 0 === n3 || n3.call(this), jC.debug("[".concat(this._name, "] datachannel close ").concat(this._url, ", code: ").concat(e3.code, ", reason: ").concat(e3.reason, ", current mode: ").concat(this.reconnectMode)), this._reconnectCount < this._retryConfig.maxRetryCount) {
                "connected" === this.state && (this.reconnectReason = e3.reason, this.state = "reconnecting");
                const n4 = AT(this, gv.WILL_RECONNECT, this.reconnectMode) || this.reconnectMode, r3 = await this.reconnectWithAction(n4);
                if ("closed" === this.state) return void jC.debug("[".concat(this.connectionID, "] dc is closed, no need to reconnect"));
                if (!r3) return i2(new LI(Hg.WS_DISCONNECT, "datachannel reconnect failed: ".concat(e3.code))), void this.close(true);
                t2();
              } else i2(new LI(Hg.WS_DISCONNECT, "datachannel close: ".concat(e3.code))), this.close();
            }, o2 = (e3) => {
              var t3;
              null === (t3 = this._reliableTransmission) || void 0 === t3 || t3.onData(e3.data);
            };
            this._transmitter && (this._transmitter.onclose = null, this._transmitter.close()), this._reliableTransmission && (this._reliableTransmission.close(), this._reliableTransmission = void 0), jC.debug("[".concat(this._name, "] start connect, address: ").concat(JSON.stringify(e2)));
            const a2 = null === (n2 = this._store) || void 0 === n2 ? void 0 : n2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "gateway" }), c2 = Date.now();
            vT(this, gv.TO_CONNECT_DATACHANNEL, e2).then((e3) => {
              var t3, i3;
              if (!e3) throw new Error("transmissonInfo not exist yet");
              const { transmitter: n3, close: d2 } = e3;
              this._transmitter = n3, null === (t3 = this._store) || void 0 === t3 || t3.signalChannelOpen();
              const l2 = Date.now() - c2;
              jC.debug("[choose dc] dc open cost ".concat(l2, "ms"));
              this._reliableTransmission = new Oy((e4) => {
                var t4;
                this._transmitter && "open" === this._transmitter.readyState && (null === (t4 = this._transmitter) || void 0 === t4 || t4.send(e4));
              }, (e4) => {
                "string" == typeof e4 && this.emit(gv.ON_MESSAGE, e4);
              }), this._closeEstablishingTransmitter = () => {
                var e4;
                null === (e4 = this._reliableTransmission) || void 0 === e4 || e4.close(), this._reliableTransmission = void 0, d2();
              }, r2 && r2(), n3.onclose = s2, n3.onmessage = o2, null === (i3 = this._store) || void 0 === i3 || i3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a2), this._joinChannelServiceRecordIndex = a2;
            }).catch((e3) => {
              var t3;
              if (null === (t3 = this._store) || void 0 === t3 || t3.recordJoinChannelService({ endTs: Date.now(), status: e3 instanceof LI && e3.code === Hg.WS_ABORT ? "aborted" : "error", errors: [e3] }, a2), "closed" !== this.state) {
                if (e3 instanceof LI && e3.code === Hg.WS_ERR) {
                  const t4 = new LI(Hg.WS_ERR, "init datachannel failed! Error: ".concat(e3.toString()));
                  return jC.error("[".concat(this._name, "]").concat(t4)), void i2(t4);
                }
                s2 && s2(e3);
              } else i2(new LI(Hg.WS_DISCONNECT, "datachannel is closed: ".concat(e3.toString())));
            });
          });
        }
        async reconnectWithAction(e2) {
          let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (this._reconnectCount >= this._retryConfig.maxRetryCount) return false;
          if (!this._addresses) return false;
          if ("closed" === this.state) return false;
          this._onlineReconnectListener || wT.networkState !== gT.OFFLINE || (this._onlineReconnectListener = wT.onlineWaiter && wT.onlineWaiter.then(() => {
            this._onlineReconnectListener = void 0;
          }));
          let i2 = true;
          if (this._reconnectInterrupter = () => {
            i2 = false;
          }, t2) {
            const t3 = mS(this._reconnectCount, this._retryConfig);
            jC.debug("[".concat(this._name, "] wait ").concat(t3, "ms to reconnect datachannel, mode: ").concat(e2)), await cg.race([iS(t3), this._onlineReconnectListener || new cg(() => {
            })]);
          }
          if ("closed" === this.state || !i2) return false;
          this._reconnectCount += 1;
          const n2 = async (e3, t3) => {
            this.emit(gv.RECONNECT_CREATE_CONNECTION, t3), await this.createTransmitterConnection(e3);
          };
          try {
            if ("retry" === e2) {
              const t3 = this._addresses[this.currentURLIndex];
              this.emit(gv.RECONNECT_WAITTING_FINISH, e2), await n2(t3, e2);
            } else if ("tryNext" === e2) {
              this.currentURLIndex += 1;
              for (let e3 = this.currentURLIndex; e3 < this._addresses.length; e3++) {
                if (this._addresses[e3].fingerprint || RC("FINGERPRINT")) {
                  this.currentURLIndex = e3;
                  break;
                }
                this.currentURLIndex += 1;
              }
              if (this.currentURLIndex >= this._addresses.length) return jC.debug("[".concat(this._name, "] the available addresses are exhausted, change to recover")), await this.reconnectWithAction("recover", false);
              jC.debug("[".concat(this._name, "] datachannel url length: ").concat(this._addresses.length, " current index: ").concat(this.currentURLIndex));
              const t3 = this._addresses[this.currentURLIndex];
              this.emit(gv.RECONNECT_WAITTING_FINISH, e2), await n2(t3, e2);
            } else "recover" === e2 && (jC.debug("[".concat(this._name, "] start to failback to websocket")), this.resetReconnectCount("recover mode"), this.emit(gv.RECONNECT_WAITTING_FINISH, e2), this.emit(gv.FAILBACK));
            return true;
          } catch (i3) {
            var r2, s2;
            return jC.error("[".concat(this._name, "] reconnect failed"), i3.toString()), null != i3 && null !== (r2 = i3.data) && void 0 !== r2 && r2.desc && Array.isArray(i3.data.desc) && i3.data.desc.length && bn(s2 = i3.data.desc).call(s2, "dynamic key expired") ? (this.emit(gv.ON_TOKEN_PRIVILEGE_DID_EXPIRE), false) : await this.reconnectWithAction(e2, t2);
          }
        }
      }
      class Dy extends dT {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          e2 !== this._connectionState && (this._connectionState = e2, e2 === pI.CONNECTED ? this.emit(_I.WS_CONNECTED) : e2 === pI.RECONNECTING ? this.emit(_I.WS_RECONNECTING, this._websocketReconnectReason) : e2 === pI.CLOSED && this.emit(_I.WS_CLOSED, this._disconnectedReason));
        }
        get currentURLIndex() {
          return this.websocket.currentURLIndex;
        }
        get url() {
          return this.websocket ? this.websocket.url : null;
        }
        get rtt() {
          return this.rttRolling.mean();
        }
        constructor(e2, t2) {
          super(), sh(this, "_disconnectedReason", void 0), sh(this, "_websocketReconnectReason", void 0), sh(this, "_connectionState", pI.CLOSED), sh(this, "reconnectToken", void 0), sh(this, "websocket", void 0), sh(this, "openConnectionTime", void 0), sh(this, "clientId", void 0), sh(this, "lastMsgTime", Date.now()), sh(this, "uploadCache", []), sh(this, "uploadCacheInterval", void 0), sh(this, "rttRolling", new gS(5)), sh(this, "pingpongTimer", void 0), sh(this, "inflateDataTimer", void 0), sh(this, "pingpongTimeoutCount", 0), sh(this, "joinResponse", void 0), sh(this, "multiIpOption", void 0), sh(this, "initError", void 0), sh(this, "spec", void 0), sh(this, "store", void 0), sh(this, "onWebsocketMessage", (e3) => {
            if (e3 instanceof ArrayBuffer) return void this.emit(_I.ON_BINARY_DATA, e3);
            const t3 = JSON.parse(e3);
            if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t3, "_id")) {
              const e4 = "res-@".concat(t3._id);
              this.emit(e4, t3._result, t3._message);
            } else if (Object.prototype.hasOwnProperty.call(t3, "_type") && (this.emit(t3._type, t3._message), t3._type === fI.ON_NOTIFICATION && this.handleNotification(t3._message), t3._type === fI.ON_USER_BANNED)) switch (t3._message.error_code) {
              case 14:
                this.close(ET.UID_BANNED);
                break;
              case 15:
                this.close(ET.IP_BANNED);
                break;
              case 16:
                this.close(ET.CHANNEL_BANNED);
            }
          }), this.clientId = e2.clientId, this.spec = e2, this.store = t2, this.websocket = new Ny("gateway-".concat(this.clientId), this.spec.retryConfig, true, t2), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
            this.connectionState === pI.CONNECTED && this.reconnect("retry", fv.OFFLINE);
          });
        }
        async request(e2, t2, i2, n2) {
          const r2 = nS(6, ""), s2 = { _id: r2, _type: e2, _message: t2 }, o2 = this.websocket.connectionID, a2 = () => new cg((t3, i3) => {
            if (this.connectionState === pI.CONNECTED) return t3();
            const n3 = () => {
              this.off(_I.WS_CLOSED, r3), t3();
            }, r3 = () => {
              this.off(_I.WS_CONNECTED, n3), i3(new LI(Hg.WS_ABORT));
            };
            this.once(_I.WS_CONNECTED, n3), this.once(_I.WS_CLOSED, r3), e2 !== EI.PUBLISH && e2 !== EI.SUBSCRIBE && e2 !== EI.UNSUBSCRIBE && e2 !== EI.UNPUBLISH && e2 !== EI.CONTROL && e2 !== EI.RESTART_ICE || this.once(_I.DISCONNECT_P2P, () => {
              i3(new LI(Hg.DISCONNECT_P2P));
            }), e2 !== EI.PUBLISH && e2 !== EI.RESTART_ICE || this.once(_I.ABORT_P2P_EXECUTION, () => {
              i3(new LI(Hg.DISCONNECT_P2P));
            });
          });
          if (this.connectionState !== pI.CONNECTING && this.connectionState !== pI.RECONNECTING || e2 === EI.JOIN || e2 === EI.REJOIN || await a2(), e2 === EI.LEAVE && (this.websocket.unbindDcCloseEventListener(), n2 = true), this.websocket.sendMessage(s2, true, false), n2) return;
          const c2 = new cg((i3, n3) => {
            let s3 = false;
            const a3 = (n4, r3) => {
              s3 = true, i3({ isSuccess: "success" === n4, message: r3 || {} }), this.off(_I.WS_CLOSED, c3), this.off(_I.WS_RECONNECTING, c3), this.emit(_I.REQUEST_SUCCESS, e2, t2);
            };
            this.once("res-@".concat(r2), a3);
            const c3 = () => {
              n3(new LI(Hg.WS_ABORT, "type: ".concat(e2))), this.off(_I.WS_CLOSED, c3), this.off(_I.WS_RECONNECTING, c3), this.off("res-@".concat(r2), a3);
            };
            this.once(_I.WS_CLOSED, c3), this.once(_I.WS_RECONNECTING, c3), iS(RC("SIGNAL_REQUEST_TIMEOUT")).then(() => {
              this.websocket.connectionID !== o2 || s3 || (jC.warning("dc request timeout, type: ".concat(e2)), this.emit(_I.REQUEST_TIMEOUT, e2, t2));
            });
          });
          let d2 = null;
          try {
            d2 = await c2;
          } catch (n3) {
            if (this.connectionState === pI.CLOSED || e2 === EI.LEAVE) throw new LI(Hg.WS_ABORT);
            return !this.spec.forceWaitGatewayResponse || i2 ? n3.throw() : e2 === EI.JOIN || e2 === EI.REJOIN ? null : (await a2(), await this.request(e2, t2));
          }
          if (d2.isSuccess) return d2.message;
          const l2 = Number(d2.message.error_code || d2.message.code), u2 = kv(l2), h3 = new LI(Hg.UNEXPECTED_RESPONSE, "".concat(u2.desc, ": ").concat(d2.message.error_str), { code: l2, data: d2.message });
          return "success" === u2.action ? d2.message : (jC.warning("[".concat(this.websocket.connectionID, "] unexpected response from type ").concat(e2, ", error_code: ").concat(l2, ", message: ").concat(u2.desc, ", action: ").concat(u2.action)), l2 === hI.ERR_TOO_MANY_BROADCASTERS ? e2 === EI.JOIN || e2 === EI.REJOIN ? (this.initError = h3, this.close(), h3.throw()) : h3.throw() : "failed" === u2.action ? h3.throw() : "quit" === u2.action ? (this.initError = h3, this.close(), h3.throw()) : (l2 === hI.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d2.message.option, jC.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", fv.MULTI_IP)) : this.reconnect(u2.action, fv.SERVER_ERROR), e2 === EI.JOIN || e2 === EI.REJOIN ? null : await this.request(e2, t2)));
        }
        waitMessage(e2, t2) {
          return new cg((i2) => {
            const n2 = (r2) => {
              (!t2 || t2(r2)) && (this.off(e2, n2), i2(r2));
            };
            this.on(e2, n2);
          });
        }
        uploadWRTCStats(e2) {
          if (!this.store.sessionId) return void jC.warn("[".concat(this.clientId, "] no session id when upload wrtc stats"));
          const t2 = { lts: Date.now(), sid: this.store.sessionId, uid: this.store.intUid, stats: e2 };
          this.upload(mI.WRTC_STATS, t2);
        }
        upload(e2, t2) {
          const i2 = { _type: e2, _message: t2 };
          try {
            this.websocket.sendMessage(i2);
          } catch (e3) {
            const t3 = RC("MAX_UPLOAD_CACHE") || 50;
            this.uploadCache.push(i2), this.uploadCache.length > t3 && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
              if (this.connectionState !== pI.CONNECTED) return;
              const e4 = this.uploadCache.splice(0, 1)[0];
              0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e4._type, e4._message);
            }, RC("UPLOAD_CACHE_INTERVAL") || 2e3));
          }
        }
        send(e2, t2) {
          const i2 = { _type: e2, _message: t2 };
          this.websocket.sendMessage(i2);
        }
        init(e2, t2) {
          return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new cg((i2, n2) => {
            this.once(_I.WS_CONNECTED, () => i2(this.joinResponse)), this.once(_I.WS_CLOSED, () => n2(this.initError || new LI(Hg.WS_ABORT))), this.connectionState = pI.CONNECTING, this.websocket.init(e2).catch(n2), this.websocket.once(gv.FAILBACK, () => {
              void 0 === this.openConnectionTime && n2(new LI(Hg.INIT_DATACHANNEL_TIMEOUT));
            }), this.inflateDataTimer && window.clearInterval(this.inflateDataTimer), this.inflateDataTimer = window.setInterval(() => {
              this.handleInflateData();
            }, 2e4), setTimeout(() => {
              t2 && void 0 === this.openConnectionTime && (jC.debug("[".concat(this.clientId, "] init datachannel timeout while join with failback to websocket")), n2(new LI(Hg.INIT_DATACHANNEL_TIMEOUT)));
            }, RC("DC_JOIN_WITH_FAILBACK"));
          });
        }
        close(e2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.inflateDataTimer && (this.handleInflateData(), window.clearInterval(this.inflateDataTimer), this.inflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e2 || ET.LEAVE, this.connectionState = pI.CLOSED, jC.debug("[".concat(this.clientId, "] ") + "will close datachannel in signal"), this.websocket.close(), e2 === ET.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new Ny("gateway-".concat(this.clientId), this.spec.retryConfig, true, this.store), this.handleWebsocketEvents());
        }
        async join() {
          if (!this.joinResponse) {
            this.emit(_I.ABORT_P2P_EXECUTION);
            const e2 = await vT(this, _I.DATACHANNEL_CONNECTING), t2 = await this.request(EI.JOIN, e2);
            if (!t2) return this.emit(_I.REPORT_JOIN_GATEWAY, Hg.TIMEOUT, this.url || ""), false;
            this.joinResponse = t2, this.emit(_I.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
          }
          return this.connectionState = pI.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true;
        }
        async rejoin() {
          if (!this.reconnectToken) throw new LI(Hg.UNEXPECTED_ERROR, "can not rejoin, no rejoin token");
          const e2 = bT(this, _I.REQUEST_REJOIN_INFO);
          e2.token = this.reconnectToken;
          const t2 = await this.request(EI.REJOIN, e2);
          return !!t2 && (this.connectionState = pI.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t2.peers && t2.peers.forEach((e3) => {
            this.emit(fI.ON_USER_ONLINE, { uid: e3.uid }), e3.audio && this.emit(fI.ON_ADD_AUDIO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, audio: true, ssrcId: e3.audio_ssrc }), e3.video && this.emit(fI.ON_ADD_VIDEO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, video: true, ssrcId: e3.video_ssrc }), e3.audio_mute ? this.emit(fI.MUTE_AUDIO, { uid: e3.uid }) : this.emit(fI.UNMUTE_AUDIO, { uid: e3.uid }), e3.video_mute ? this.emit(fI.MUTE_VIDEO, { uid: e3.uid }) : this.emit(fI.UNMUTE_VIDEO, { uid: e3.uid }), e3.audio_enable_local ? this.emit(fI.ENABLE_LOCAL_AUDIO, { uid: e3.uid }) : this.emit(fI.DISABLE_LOCAL_AUDIO, { uid: e3.uid }), e3.video_enable_local ? this.emit(fI.ENABLE_LOCAL_VIDEO, { uid: e3.uid }) : this.emit(fI.DISABLE_LOCAL_VIDEO, { uid: e3.uid }), e3.audio || e3.video || this.emit(fI.ON_REMOVE_STREAM, { uid: e3.uid, uint_id: e3.uint_id });
          }), true);
        }
        reconnect(e2, t2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e2, t2);
        }
        handleNotification(e2) {
          jC.debug("[".concat(this.clientId, "] receive notification: "), e2);
          const t2 = kv(e2.code);
          if ("success" !== t2.action) {
            if ("failed" !== t2.action) return "quit" === t2.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t2.desc && this.close(ET.UID_BANNED), void this.close()) : void this.reconnect(t2.action, fv.SERVER_ERROR);
            jC.error("[".concat(this.clientId, "] ignore error: "), t2.desc);
          }
        }
        handlePingPong() {
          if (!this.websocket || "connected" !== this.websocket.state) return;
          this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
          const e2 = RC("PING_PONG_TIME_OUT"), t2 = Date.now();
          this.pingpongTimeoutCount >= e2 && (jC.warning("PINGPONG Timeout. Last Socket Message: ".concat(t2 - this.lastMsgTime, "ms")), t2 - this.lastMsgTime > RC("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", fv.TIMEOUT) : this.request(EI.PING, void 0, true).then(() => {
            this.pingpongTimeoutCount = 0;
            const e3 = Date.now() - t2;
            this.rttRolling.add(e3), RC("REPORT_STATS") && this.send(EI.PING_BACK, { pingpongElapse: e3 });
          }).catch((e3) => {
          });
        }
        handleInflateData() {
          const { inflateLength: e2, deflateLength: t2 } = this.websocket.getInflateData();
          0 !== e2 && 0 !== t2 && this.upload(mI.WS_INFLATE_DATA_LENGTH, { ws_deflate_length: t2, ws_inflate_length: e2 });
        }
        handleWebsocketEvents() {
          this.websocket.on(gv.RECONNECT_WAITTING_FINISH, (e2) => {
            this.emit(_I.WS_RECONNECT_WAITTING_FINISH, e2);
          }), this.websocket.on(gv.RECONNECT_CREATE_CONNECTION, (e2) => {
            this.emit(_I.WS_RECONNECT_CREATE_CONNECTION, e2);
          }), this.websocket.on(gv.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(gv.CLOSED, () => {
            this.connectionState = pI.CLOSED;
          }), this.websocket.on(gv.FAILED, () => {
            this._disconnectedReason = ET.NETWORK_ERROR, this.connectionState = pI.CLOSED;
          }), this.websocket.on(gv.RECONNECTING, (e2) => {
            this._websocketReconnectReason = e2, this.joinResponse = void 0, this.connectionState === pI.CONNECTED ? this.connectionState = pI.RECONNECTING : this.connectionState = pI.CONNECTING;
          }), this.websocket.on(gv.WILL_RECONNECT, (e2, t2) => {
            if (bT(this, _I.IS_P2P_DISCONNECTED) && "retry" === e2) return jC.debug("".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), this.reconnectToken = void 0, this.emit(_I.NEED_RENEW_SESSION), this.emit(_I.DISCONNECT_P2P), t2("tryNext");
            "retry" !== e2 && (jC.debug("".concat(this.clientId, " websockt will_connect event, renewSession reconnectMode is ").concat(e2)), this.reconnectToken = void 0, this.emit(_I.NEED_RENEW_SESSION), this.emit(_I.DISCONNECT_P2P)), t2(e2);
          }), this.websocket.on(gv.CONNECTED, () => {
            this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch((e2) => {
              jC.warning("[".concat(this.clientId, "] rejoin failed ").concat(e2)), this.reconnect("tryNext", fv.SERVER_ERROR);
            }) : this.join().catch((e2) => {
              if (this.emit(_I.REPORT_JOIN_GATEWAY, e2.message || e2.code, this.url || ""), e2 instanceof LI && e2.code === Hg.UNEXPECTED_RESPONSE && e2.data.code === hI.ERR_NO_AUTHORIZED) return jC.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), void this.reconnect("recover", fv.SERVER_ERROR);
              jC.error("[".concat(this.clientId, "] join gateway request failed"), e2.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", fv.SERVER_ERROR) : (this.initError = e2, this.close());
            });
          }), this.websocket.on(gv.REQUEST_NEW_URLS, (e2, t2) => {
            vT(this, _I.REQUEST_RECOVER, this.multiIpOption).then(e2).catch(t2);
          }), this.websocket.on(gv.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
            this.emit(fI.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
          }), this.websocket.on(gv.TO_CONNECT_DATACHANNEL, async (e2, t2, i2) => vT(this, _I.DATACHANNEL_PRECONNECT, e2).then(t2).catch(i2)), this.websocket.on(gv.FAILBACK, () => {
            void 0 !== this.openConnectionTime && this.emit(_I.DATACHANNEL_FAILBACK);
          });
        }
      }
      class Py extends dT {
        constructor(e2, t2) {
          super(), sh(this, "signal", void 0), sh(this, "token", void 0), sh(this, "tokenTimeout", void 0), sh(this, "tokenInterval", void 0), sh(this, "_sequence", 0), sh(this, "userMap", /* @__PURE__ */ new Map()), sh(this, "encoder", new TextEncoder()), this.signal = e2, this.token = t2;
          const i2 = () => {
            this.signal.connectionState === pI.CONNECTED && this.check(), 0 === this.userMap.size ? this.tokenInterval = window.setTimeout(i2, 1e3) : this.tokenInterval = window.setTimeout(i2, 3 * RC("P2P_TOKEN_INTERVAL"));
          };
          i2();
        }
        async send(e2, t2, i2, n2, r2) {
          var s2, o2, a2;
          if (0 === this.userMap.size) return;
          const c2 = Array.from(NI(s2 = this.userMap).call(s2))[0].token;
          "string" != typeof t2 && (t2 = JSON.stringify(t2)), n2 = null !== (o2 = n2) && void 0 !== o2 ? o2 : nS(6, ""), r2 = null !== (a2 = r2) && void 0 !== a2 ? a2 : this._sequence++;
          const d2 = { _id: n2, _type: e2, _seq: r2, _message: t2, token: "".concat(this.token, "_").concat(c2) };
          RC("SHOW_P2P_LOG") && jC.debug("send message", d2, "noNeedResponse : ".concat(i2));
          this.splitMessage(JSON.stringify(d2)).forEach((e3) => {
            this.signal.request(EI.DATA_STREAM, { payload: QT(this.encoder.encode(e3)) });
          });
          const l2 = new cg((t3, r3) => {
            const s3 = window.setTimeout(() => {
              this.off("res-@".concat(n2, "_ack"), o3), this.off("res-@".concat(n2), c3), this.off(yv.ABORT, a3), jC.debug("[external-signal] request timeout, type: ".concat(e2, ", requestId: ").concat(n2)), 0 === this.userMap.size ? r3(new Kg(Hg.INVALID_REMOTE_USER)) : r3(new Kg(Hg.TIMEOUT));
            }, RC("EXTERNAL_SIGNAL_REQUEST_TIMEOUT")), o3 = () => {
              s3 && window.clearTimeout(s3), this.off(yv.ABORT, a3), i2 && t3();
            }, a3 = () => {
              s3 && window.clearTimeout(s3), this.off("res-@".concat(n2, "_ack"), o3), this.off("res-@".concat(n2), c3), r3(new Kg(Hg.EXTERNAL_SIGNAL_ABORT, "type: ".concat(e2, ", requestId: ").concat(n2)));
            };
            this.once(yv.ABORT, a3), this.once("res-@".concat(n2, "_ack"), o3);
            const c3 = (i3, c4) => {
              l3 = true, s3 && window.clearTimeout(s3), this.off("res-@".concat(n2, "_ack"), o3), this.off(yv.ABORT, a3), "success" === i3 ? t3(c4) : r3(new Kg(Hg.P2P_MESSAGE_FAILED, "request ".concat(e2, " failed, requestId: ").concat(n2)));
            };
            let l3 = false;
            i2 || (this.once("res-@".concat(n2), c3), iS(RC("SIGNAL_REQUEST_TIMEOUT")).then(() => {
              l3 || jC.warning("external_signal request timeout, type: ".concat(e2, ", requestId: ").concat(n2, ", ").concat(d2));
            }));
          });
          try {
            return await l2;
          } catch (s3) {
            if (s3.code === Hg.TIMEOUT) return await this.send(e2, t2, i2, n2, r2);
            throw s3;
          }
        }
        onMessage(e2) {
          var t2;
          const { _uid: i2 } = e2;
          let n2, r2 = this.userMap.get(i2);
          if (r2) n2 = r2.splitMessageMap;
          else {
            if (this.userMap.size > 0 || !("_type" in e2) || e2._type !== vv.CHECK) return;
            const { token: t3 } = e2;
            n2 = /* @__PURE__ */ new Map(), r2 = { uid: i2, isStart: true, token: t3, splitMessageMap: n2, nextExpectedSequenceNumber: 0, receivedMessagesMap: /* @__PURE__ */ new Map() }, this.userMap.set(i2, r2), this.signal.emit(fI.ON_USER_ONLINE, { uid: i2 }), this.handleUserOnline();
          }
          if ("id" in e2 && "total" in e2) {
            var s2;
            const { id: t3, total: r3 } = e2, o3 = null !== (s2 = n2.get(t3)) && void 0 !== s2 ? s2 : [];
            if (o3.push(e2), n2.has(t3) || n2.set(t3, o3), o3.length !== r3) return;
            {
              const r4 = ep(o3).call(o3, (e3, t4) => e3.index - t4.index).map((e3) => e3.payload).join("");
              n2.delete(t3), (e2 = JSON.parse(r4))._uid = i2;
            }
          }
          const { _type: o2, token: a2 } = e2;
          if (bn(t2 = [vv.ACK, vv.CHECK]).call(t2, o2)) return o2 === vv.CHECK && this.handleCheckToken(r2, a2), void this.receiveMessage(e2);
          a2 === "".concat(r2.token, "_").concat(this.token) ? this.handleReceivedMessage(e2) : jC.debug('Receive unexpected message", '.concat(a2, ", cur_token: ").concat(r2.token, "_").concat(this.token), e2);
        }
        check() {
          const e2 = { _id: nS(6, ""), token: this.token, _type: vv.CHECK };
          RC("SHOW_P2P_LOG") && jC.debug("send message", e2), this.signal.request(EI.DATA_STREAM, { payload: QT(this.encoder.encode(JSON.stringify(e2))) });
        }
        ack(e2) {
          const t2 = { _id: e2, _type: vv.ACK, token: this.token };
          RC("SHOW_P2P_LOG") && jC.debug("send message", t2), this.signal.request(EI.DATA_STREAM, { payload: QT(this.encoder.encode(JSON.stringify(t2))) });
        }
        response(e2, t2, i2) {
          this.send(vv.RESPONSE, JSON.stringify({ success: !i2, message: t2 }), true, e2);
        }
        handleReceivedMessage(e2) {
          const t2 = () => {
            this.userMap.forEach((e3) => {
              const { receivedMessagesMap: t3, nextExpectedSequenceNumber: i3 } = e3;
              for (; t3.has(i3); ) {
                const n3 = t3.get(i3);
                t3.delete(i3), this.receiveMessage(n3), e3.nextExpectedSequenceNumber++;
              }
            });
          };
          if (!e2) return void t2();
          const { _uid: i2, _seq: n2 } = e2, r2 = this.userMap.get(i2), { receivedMessagesMap: s2, isStart: o2, nextExpectedSequenceNumber: a2 } = r2;
          if (n2 < a2) return this.ack(e2._id), void jC.debug("[external-signal] receive old message, seq: ".concat(n2, ", ").concat(e2._message));
          s2.set(n2, e2), o2 && n2 === a2 && (this.receiveMessage(e2), s2.delete(a2), r2.nextExpectedSequenceNumber++, t2());
        }
        receiveMessage(e2) {
          const { _id: t2, _type: i2, _message: n2, _uid: r2 } = e2;
          if (RC("SHOW_P2P_LOG") && jC.debug("receive message", e2), t2) {
            let s2;
            switch (e2._type !== vv.ACK && (n2 && (s2 = JSON.parse(n2)), this.ack(e2._id)), e2._type) {
              case vv.CANDIDATE:
              case vv.CONTROL:
                this.signal.emit(i2, s2, r2);
                break;
              case vv.PUBLISH:
              case vv.UNPUBLISH:
              case vv.RESTART_ICE:
              case vv.CALL:
                s2.uid = r2, vT(this.signal, i2, s2).then((t3) => {
                  this.response(e2._id, t3);
                }).catch(() => {
                  this.response(e2._id, void 0, true);
                });
                break;
              case vv.ACK:
                this.getListeners("res-@".concat(t2, "_ack")).length > 0 && this.emit("res-@".concat(t2, "_ack"));
                break;
              case vv.RESPONSE: {
                const { success: e3, message: i3 } = s2;
                this.emit("res-@".concat(t2), e3 ? "success" : "failed", i3);
                break;
              }
            }
          }
        }
        splitMessage(e2) {
          if (e2.length < Py.MAX_MESSAGE_SIZE) return [e2];
          const t2 = [], { remoteToken: i2 } = JSON.parse(e2), n2 = nS(6, "");
          let r2 = 0, s2 = 800;
          const o2 = Math.ceil(e2.length / s2);
          for (; e2.length > 0; ) {
            r2++;
            const a2 = { id: n2, index: r2, total: o2, payload: e2.slice(0, s2), token: "".concat(this.token, "_").concat(i2) };
            JSON.stringify(a2).length > Py.MAX_MESSAGE_SIZE ? s2 -= 50 : (t2.push(a2), e2 = e2.slice(s2));
          }
          return t2.map((e3) => JSON.stringify(e3));
        }
        handleCheckToken(e2, t2) {
          return e2.token !== t2 ? (jC.debug("token changed, from ".concat(e2.token, " to ").concat(t2)), this.reset(e2.uid, t2), false) : (this.tokenTimeout && (window.clearTimeout(this.tokenTimeout), this.tokenTimeout = void 0), this.tokenTimeout = window.setTimeout(() => {
            jC.debug("token timeout, ".concat(t2)), this.reset(e2.uid);
          }, RC("MAX_P2P_TIMEOUT")), true);
        }
        async handleUserOnline() {
          const e2 = await vT(this.signal, vv.CALL, void 0), t2 = await this.send(vv.CALL, e2);
          this.signal.emit(_I.P2P_CONNECTION, t2, true);
        }
        async reset(e2, t2) {
          const i2 = this.userMap.get(e2);
          i2 && (this.emit(yv.ABORT), this.signal.emit(fI.ON_USER_OFFLINE, { uid: i2.uid, reason: wv.P2P_TOKEN_CHANGED }), this._sequence = 0, this.userMap.clear(), t2 || (jC.debug("change local token from ".concat(t2, " to ").concat(t2)), this.token = nS(6, "")));
        }
        clear() {
          this._sequence = 0, this.userMap.clear(), this.tokenInterval && window.clearTimeout(this.tokenInterval), this.tokenInterval = void 0, this.tokenTimeout && window.clearTimeout(this.tokenTimeout), this.tokenTimeout = void 0, this.emit(yv.ABORT);
        }
      }
      sh(Py, "MAX_SIZE", 1), sh(Py, "MAX_MESSAGE_SIZE", 1024);
      class Ly extends dT {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          e2 !== this._connectionState && (this._connectionState = e2, e2 === pI.CONNECTED ? this.emit(_I.WS_CONNECTED) : e2 === pI.RECONNECTING ? this.emit(_I.WS_RECONNECTING, this._websocketReconnectReason) : e2 === pI.CLOSED && this.emit(_I.WS_CLOSED, this._disconnectedReason));
        }
        get currentURLIndex() {
          return this.websocket.currentURLIndex;
        }
        get url() {
          return this.websocket && this.websocket.url || null;
        }
        get rtt() {
          return this.rttRolling.mean();
        }
        constructor(e2, t2) {
          super(), sh(this, "_disconnectedReason", void 0), sh(this, "_websocketReconnectReason", void 0), sh(this, "_connectionState", pI.CLOSED), sh(this, "reconnectToken", void 0), sh(this, "p2pToken", void 0), sh(this, "websocket", void 0), sh(this, "openConnectionTime", void 0), sh(this, "clientId", void 0), sh(this, "lastMsgTime", Date.now()), sh(this, "uploadCache", []), sh(this, "uploadCacheInterval", void 0), sh(this, "rttRolling", new gS(5)), sh(this, "pingpongTimer", void 0), sh(this, "pingpongTimeoutCount", 0), sh(this, "joinResponse", void 0), sh(this, "multiIpOption", void 0), sh(this, "initError", void 0), sh(this, "spec", void 0), sh(this, "store", void 0), sh(this, "_external_signal", void 0), sh(this, "onWebsocketMessage", (e3) => {
            if (e3.data instanceof ArrayBuffer) return void this.emit(_I.ON_BINARY_DATA, e3.data);
            const t3 = JSON.parse(e3.data);
            if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t3, "_id")) {
              const e4 = "res-@".concat(t3._id);
              this.emit(e4, t3._result, t3._message);
            } else if (Object.prototype.hasOwnProperty.call(t3, "_type")) {
              switch (t3._type) {
                case fI.ON_DATA_STREAM:
                  return void this.handleDataStream(t3._message);
                case fI.MUTE_AUDIO:
                case fI.MUTE_VIDEO:
                case fI.ON_P2P_LOST:
                case fI.ON_USER_ONLINE:
                  return;
                case fI.ON_USER_OFFLINE:
                  const { uid: e4 } = t3._message;
                  return jC.debug("[".concat(this.clientId, "] user-offline uid: ").concat(e4)), void this._external_signal.reset(e4);
              }
              if (this.emit(t3._type, t3._message), t3._type === fI.ON_NOTIFICATION && this.handleNotification(t3._message), t3._type === fI.ON_USER_BANNED) switch (t3._message.error_code) {
                case 14:
                  this.close(ET.UID_BANNED);
                  break;
                case 15:
                  this.close(ET.IP_BANNED);
                  break;
                case 16:
                  this.close(ET.CHANNEL_BANNED);
              }
              if (t3._type === fI.ON_USER_LICENSE_BANNED) switch (t3._message.error_code) {
                case hI.ERR_LICENSE_MISSING:
                  this.close(ET.LICENSE_MISSING);
                  break;
                case hI.ERR_LICENSE_EXPIRED:
                  this.close(ET.LICENSE_EXPIRED);
                  break;
                case hI.ERR_LICENSE_MINUTES_EXCEEDED:
                  this.close(ET.LICENSE_MINUTES_EXCEEDED);
                  break;
                case hI.ERR_LICENSE_PERIOD_INVALID:
                  this.close(ET.LICENSE_PERIOD_INVALID);
                  break;
                case hI.ERR_LICENSE_MULTIPLE_SDK_SERVICE:
                  this.close(ET.LICENSE_MULTIPLE_SDK_SERVICE);
                  break;
                case hI.ERR_LICENSE_ILLEGAL:
                  this.close(ET.LICENSE_ILLEGAL);
                  break;
                default:
                  this.close();
              }
            }
          }), this.clientId = e2.clientId, this.spec = e2, this.store = t2, this.websocket = new qv("gateway-".concat(this.clientId), this.spec.retryConfig, true, RC("JOIN_GATEWAY_USE_DUAL_DOMAIN"), RC("JOIN_GATEWAY_USE_443PORT_ONLY"), t2), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
            this.connectionState === pI.CONNECTED && this.reconnect("retry", fT.OFFLINE);
          }), this.p2pToken = nS(6, ""), this._external_signal = new Py(this, this.p2pToken);
        }
        async request(e2, t2, i2, n2) {
          const r2 = nS(6, ""), s2 = { _id: r2, _type: e2, _message: t2 }, o2 = this.websocket.connectionID, a2 = () => new cg((e3, t3) => {
            if (this.connectionState === pI.CONNECTED) return e3();
            const i3 = () => {
              this.off(_I.WS_CLOSED, n3), e3();
            }, n3 = () => {
              this.off(_I.WS_CONNECTED, i3), t3(new Kg(Hg.WS_ABORT));
            };
            this.once(_I.WS_CONNECTED, i3), this.once(_I.WS_CLOSED, n3);
          });
          if (this.connectionState !== pI.CONNECTING && this.connectionState !== pI.RECONNECTING || e2 === EI.JOIN || e2 === EI.REJOIN || await a2(), this.websocket.sendMessage(s2, true), n2) return;
          const c2 = new cg((i3, n3) => {
            let s3 = false;
            const a3 = (n4, r3) => {
              s3 = true, i3({ isSuccess: "success" === n4, message: r3 || {} }), this.off(_I.WS_CLOSED, c3), this.off(_I.WS_RECONNECTING, c3), this.emit(_I.REQUEST_SUCCESS, e2, t2);
            };
            this.once("res-@".concat(r2), a3);
            const c3 = () => {
              n3(new Kg(Hg.WS_ABORT, "type: ".concat(e2))), this.off(_I.WS_CLOSED, c3), this.off(_I.WS_RECONNECTING, c3), this.off("res-@".concat(r2), a3);
            };
            this.once(_I.WS_CLOSED, c3), this.once(_I.WS_RECONNECTING, c3), iS(RC("SIGNAL_REQUEST_TIMEOUT")).then(() => {
              this.websocket.connectionID !== o2 || s3 || (jC.warning("[".concat(this.clientId, "] ws request timeout, type: ").concat(e2)), this.emit(_I.REQUEST_TIMEOUT, e2, t2));
            });
          });
          let d2 = null;
          try {
            d2 = await c2;
          } catch (n3) {
            if (this.connectionState === pI.CLOSED || e2 === EI.LEAVE) throw new Kg(Hg.WS_ABORT);
            return !this.spec.forceWaitGatewayResponse || i2 ? n3.throw() : e2 === EI.JOIN || e2 === EI.REJOIN ? null : (await a2(), await this.request(e2, t2));
          }
          if (d2.isSuccess) return d2.message;
          const l2 = Number(d2.message.error_code || d2.message.code), u2 = kv(l2), h3 = new Kg(Hg.UNEXPECTED_RESPONSE, "".concat(u2.desc, ": ").concat(d2.message.error_str), { code: l2, data: d2.message });
          return "success" === u2.action ? d2.message : (jC.warning("[".concat(this.clientId, "] [").concat(this.websocket.connectionID, "] unexpected response from type ").concat(e2, ", error_code: ").concat(l2, ", message: ").concat(u2.desc, ", action: ").concat(u2.action)), l2 === hI.ERR_TOO_MANY_BROADCASTERS ? e2 === EI.JOIN || e2 === EI.REJOIN ? (this.initError = h3, this.close(), h3.throw()) : h3.throw() : "failed" === u2.action ? h3.throw() : "quit" === u2.action ? (this.initError = h3, this.close(), h3.throw()) : (l2 === hI.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d2.message.option, jC.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", fT.MULTI_IP)) : this.reconnect(u2.action, fT.SERVER_ERROR), e2 === EI.JOIN || e2 === EI.REJOIN ? null : await this.request(e2, t2)));
        }
        waitMessage(e2, t2) {
          return new cg((i2) => {
            const n2 = (r2) => {
              (!t2 || t2(r2)) && (this.off(e2, n2), i2(r2));
            };
            this.on(e2, n2);
          });
        }
        uploadWRTCStats(e2) {
          if (!this.store.sessionId) return void jC.warn("[".concat(this.clientId, "] no session id when upload wrtc stats"));
          const t2 = { lts: Date.now(), sid: this.store.sessionId, uid: this.store.intUid, stats: e2 };
          this.upload(mI.WRTC_STATS, t2);
        }
        upload(e2, t2) {
          const i2 = { _type: e2, _message: t2 };
          try {
            this.websocket.sendMessage(i2);
          } catch (e3) {
            const t3 = RC("MAX_UPLOAD_CACHE") || 50;
            this.uploadCache.push(i2), this.uploadCache.length > t3 && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
              if (this.connectionState !== pI.CONNECTED) return;
              const e4 = this.uploadCache.splice(0, 1)[0];
              0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e4._type, e4._message);
            }, RC("UPLOAD_CACHE_INTERVAL") || 2e3));
          }
        }
        send(e2, t2) {
          const i2 = { _type: e2, _message: t2 };
          this.websocket.sendMessage(i2);
        }
        async sendExtensionMessage(e2, t2, i2) {
          return await this._external_signal.send(e2, t2, i2);
        }
        init(e2) {
          return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new cg((t2, i2) => {
            this.once(_I.WS_CONNECTED, () => t2(this.joinResponse)), this.once(_I.WS_CLOSED, () => i2(this.initError || new Kg(Hg.WS_ABORT))), this.connectionState = pI.CONNECTING, this.websocket.init(e2).catch(i2);
          });
        }
        close(e2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._external_signal.clear(), this._disconnectedReason = e2 || ET.LEAVE, this.connectionState = pI.CLOSED, jC.debug("[".concat(this.clientId, "] ") + "will close websocket in signal"), this.websocket.close(), e2 === ET.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new qv("gateway-".concat(this.clientId), this.spec.retryConfig, true, RC("JOIN_GATEWAY_USE_DUAL_DOMAIN"), RC("JOIN_GATEWAY_USE_443PORT_ONLY"), this.store), this.handleWebsocketEvents()), this.p2pToken = nS(6, ""), this._external_signal.clear(), this._external_signal = new Py(this, this.p2pToken);
        }
        async join() {
          if (!this.joinResponse) {
            this.emit(_I.ABORT_P2P_EXECUTION);
            const e2 = await vT(this, _I.REQUEST_JOIN_INFO), t2 = await this.request(EI.JOIN, e2);
            if (!t2) return this.emit(_I.REPORT_JOIN_GATEWAY, Hg.TIMEOUT, this.url || ""), false;
            this.joinResponse = t2, this.emit(_I.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
          }
          return this.connectionState = pI.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true;
        }
        reconnect(e2, t2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e2, t2);
        }
        handleDataStream(e2) {
          try {
            var t2;
            const i2 = XT(e2.payload), n2 = new TextDecoder().decode(i2), r2 = JSON.parse(n2);
            "total" in r2 && "id" in r2 || bn(t2 = Object.values(vv)).call(t2, r2._type) ? (r2._uid = e2.uid, this._external_signal.onMessage(r2)) : this.emit(fI.ON_DATA_STREAM, e2);
          } catch (t3) {
            this.emit(fI.ON_DATA_STREAM, e2);
          }
        }
        handleNotification(e2) {
          jC.debug("[".concat(this.clientId, "] receive notification: "), e2);
          const t2 = kv(e2.code);
          if ("success" !== t2.action) {
            if ("failed" !== t2.action) return "quit" === t2.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t2.desc && this.close(ET.UID_BANNED), void this.close()) : void this.reconnect(t2.action, fT.SERVER_ERROR);
            jC.error("[".concat(this.clientId, "] ignore error: "), t2.desc);
          }
        }
        handlePingPong() {
          if (!this.websocket || "connected" !== this.websocket.state) return;
          this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
          const e2 = RC("PING_PONG_TIME_OUT"), t2 = Date.now();
          this.pingpongTimeoutCount >= e2 && (jC.warning("[".concat(this.clientId, "] PINGPONG Timeout. Last Socket Message: ").concat(t2 - this.lastMsgTime, "ms")), t2 - this.lastMsgTime > RC("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", fT.TIMEOUT) : this.request(EI.PING, void 0, true).then(() => {
            this.pingpongTimeoutCount = 0;
            const e3 = Date.now() - t2;
            this.rttRolling.add(e3), RC("REPORT_STATS") && this.send(EI.PING_BACK, { pingpongElapse: e3 });
          }).catch((e3) => {
          });
        }
        handleWebsocketEvents() {
          this.websocket.on(SI.RECONNECT_WAITTING_FINISH, (e2) => {
            this.emit(_I.WS_RECONNECT_WAITTING_FINISH, e2);
          }), this.websocket.on(SI.RECONNECT_CREATE_CONNECTION, (e2) => {
            this.emit(_I.WS_RECONNECT_CREATE_CONNECTION, e2);
          }), this.websocket.on(SI.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(SI.CLOSED, () => {
            this.connectionState = pI.CLOSED;
          }), this.websocket.on(SI.FAILED, () => {
            this._disconnectedReason = ET.NETWORK_ERROR, this.connectionState = pI.CLOSED;
          }), this.websocket.on(SI.RECONNECTING, (e2) => {
            this._websocketReconnectReason = e2, this.joinResponse = void 0, this.connectionState === pI.CONNECTED ? this.connectionState = pI.RECONNECTING : this.connectionState = pI.CONNECTING;
          }), this.websocket.on(SI.WILL_RECONNECT, (e2, t2, i2) => {
            "retry" !== e2 ? (jC.debug("".concat(this.clientId, " websocket will_connect event, renewSession reconnectMode is ").concat(e2)), this.reconnectToken = void 0, this.emit(_I.NEED_RENEW_SESSION)) : jC.debug("".concat(this.clientId, " reconnect mode is retry, no need to renew session")), i2(e2);
          }), this.websocket.on(SI.CONNECTED, () => {
            this.openConnectionTime = Date.now(), this.join().catch((e2) => {
              if (this.emit(_I.REPORT_JOIN_GATEWAY, e2.message || e2.code, this.url || ""), e2 instanceof Kg && e2.code === Hg.UNEXPECTED_RESPONSE && e2.data.code === hI.ERR_NO_AUTHORIZED) return jC.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), void this.reconnect("recover", fT.SERVER_ERROR);
              jC.error("[".concat(this.clientId, "] join gateway request failed"), e2.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", fT.SERVER_ERROR) : (this.initError = e2, this.close());
            });
          }), this.websocket.on(SI.REQUEST_NEW_URLS, (e2, t2) => {
            vT(this, _I.REQUEST_RECOVER, this.multiIpOption).then(e2).catch(t2);
          }), this.websocket.on(SI.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
            this.emit(fI.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
          });
        }
      }
      function ky(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function My(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? ky(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : ky(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      const Uy = /* @__PURE__ */ new Map();
      class xy extends dT {
        get state() {
          return this._state;
        }
        set state(e2) {
          if (e2 === this._state) return;
          const t2 = this._state;
          this._state = e2, "DISCONNECTED" === e2 && this._disconnectedReason ? this.emit(XI.CONNECTION_STATE_CHANGE, e2, t2, this._disconnectedReason) : this.emit(XI.CONNECTION_STATE_CHANGE, e2, t2);
        }
        get joinGatewayStartTime() {
          return this._joinGatewayStartTime;
        }
        set joinGatewayStartTime(e2) {
          jC.debug("[".concat(this.store.clientId, "] set joinGatewayStartTime at ").concat(e2)), this._joinGatewayStartTime = e2;
        }
        constructor(e2, t2) {
          super(), sh(this, "store", void 0), sh(this, "joinInfo", void 0), sh(this, "key", void 0), sh(this, "ntpOffset", 0), sh(this, "signal", void 0), sh(this, "role", void 0), sh(this, "inChannelInfo", { joinAt: null, duration: 0 }), sh(this, "spec", void 0), sh(this, "_state", "DISCONNECTED"), sh(this, "_statsCollector", void 0), sh(this, "_disconnectedReason", void 0), sh(this, "isSignalRecover", false), sh(this, "hasChangeBGPAddress", false), sh(this, "trafficStatsInterval", void 0), sh(this, "networkQualityInterval", void 0), sh(this, "_joinGatewayStartTime", 0), sh(this, "_signalTimeout", false), sh(this, "_clientRoleOptions", void 0), sh(this, "_isProactiveJoin", false), this.store = e2, this.spec = t2, this.signal = this.store.useP2P ? new Ly(My(My({}, t2), {}, { retryConfig: t2.websocketRetryConfig }), e2) : this.store.useDataChannel ? new Dy(My(My({}, t2), {}, { retryConfig: t2.websocketRetryConfig }), e2) : new Jv(My(My({}, t2), {}, { retryConfig: t2.websocketRetryConfig }), e2), this._statsCollector = t2.statsCollector, this.role = t2.role || "audience", this._clientRoleOptions = t2.clientRoleOptions, this.handleSignalEvents();
        }
        async join(e2, t2, i2) {
          if (this.signal instanceof Dy) {
            let t3 = false;
            "disabled" !== e2.cloudProxyServer ? (jC.debug("[".concat(this.store.clientId, "] Dc is not supported, because cloudProxyServer are not supported (").concat(e2.cloudProxyServer, ")")), t3 = true) : "".concat(e2.apResponse.cid, "_").concat(e2.apResponse.cert).length > 255 || "".concat(e2.apResponse.cid, "_").concat(e2.apResponse.cert).length < 22 ? (jC.debug("[".concat(this.store.clientId, "] Dc is not supported, because ticket length is incorrect, it has to be between 22 and 255")), t3 = true) : e2.apResponse.addresses.some((e3) => e3.fingerprint) || RC("FINGERPRINT") || (jC.debug("[".concat(this.store.clientId, "] Dc is not supported, because fingerprint does not exist")), t3 = true), t3 && this.resetSignal();
          }
          this.store.joinGatewayStart(), "disabled" !== e2.cloudProxyServer && (this.hasChangeBGPAddress = true);
          const n2 = Date.now();
          let r2 = Uy.get(e2.cname);
          if (r2 || (r2 = /* @__PURE__ */ new Map(), Uy.set(e2.cname, r2)), this._isProactiveJoin = true, r2.has(e2.uid)) {
            const t3 = new LI(Hg.UID_CONFLICT);
            throw eI.joinGateway(e2.sid, { lts: n2, succ: false, ec: t3.message, addr: null, uid: e2.uid, cid: e2.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!e2.proxyServer, signalChannel: this.signal instanceof Dy ? "1" : "0" }), this._isProactiveJoin = false, t3;
          }
          r2.set(e2.uid, true), this.joinInfo = e2, this.key = t2;
          let s2 = 0;
          this.joinGatewayStartTime = n2;
          const o2 = e2.proxyServer;
          try {
            let t3;
            if (jC.debug("[".concat(this.store.clientId, "] use ").concat(this.signal instanceof Dy ? "datachannel" : "websocket", " join uid ").concat(s2)), this.signal instanceof Dy) t3 = await this.signal.init(e2.apResponse.addresses, i2);
            else {
              const n3 = e2.gatewayAddrs.map((t4) => {
                let { address: i3 } = t4;
                const [n4, r3] = i3.split(":"), s3 = { host: n4, port: r3 };
                return e2.proxyServer && (s3.proxy = e2.proxyServer), s3;
              });
              t3 = await this.signal.init(n3, i2);
            }
            s2 = t3.uid, jC.debug("[".concat(this.store.clientId, "] ").concat(this.signal instanceof Dy ? "datachannel" : "websocket", " join uid ").concat(s2, " cost ").concat(Date.now() - this.joinGatewayStartTime));
          } catch (t3) {
            if (t3 && t3.code === Hg.INIT_WEBSOCKET_TIMEOUT) throw jC.warning("[".concat(this.store.clientId, "] User join failed"), t3.toString()), t3;
            if (t3 && t3.code === Hg.INIT_DATACHANNEL_TIMEOUT) throw jC.warning("[".concat(this.store.clientId, "] User join datachannel failed"), t3.toString()), this.resetSignal(), t3;
            throw jC.error("[".concat(this.store.clientId, "] User join failed"), t3.toString()), eI.joinGateway(e2.sid, { lts: n2, succ: false, ec: t3.message, addr: this.signal.url, uid: e2.uid, cid: e2.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!o2, signalChannel: this.signal instanceof Dy ? "1" : "0" }), this._isProactiveJoin = false, r2.delete(e2.uid), this.signal.close(), t3;
          }
          return this.state = "CONNECTED", this.inChannelInfo.joinAt = Date.now(), jC.debug("[".concat(this.store.clientId, "] Connected to gateway server")), this.trafficStatsInterval = window.setInterval(() => {
            this.updateTrafficStats().catch((e3) => {
              jC.warning("[".concat(this.store.clientId, "] get traffic stats error"), e3.toString());
            });
          }, 3e3), this.networkQualityInterval = window.setInterval(() => {
            navigator && void 0 !== navigator.onLine && !navigator.onLine ? this.emit(XI.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 }) : this._signalTimeout ? this.emit(XI.NETWORK_QUALITY, { downlinkNetworkQuality: 5, uplinkNetworkQuality: 5 }) : "CONNECTED" === this.state && this._statsCollector.trafficStats ? this.emit(XI.NETWORK_QUALITY, { uplinkNetworkQuality: Cy(this._statsCollector.trafficStats.B_unq), downlinkNetworkQuality: Cy(this._statsCollector.trafficStats.B_dnq) }) : this.emit(XI.NETWORK_QUALITY, { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 });
          }, 2e3), this.store.joinGatewayEnd(), s2;
        }
        async leave() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t2 = arguments.length > 1 ? arguments[1] : void 0;
          if ("DISCONNECTED" !== this.state) {
            t2 !== ET.FALLBACK && (this.state = "DISCONNECTING");
            try {
              e2 || this.signal.connectionState !== pI.CONNECTED || await function(e3, t3) {
                return t3 === 1 / 0 ? e3 : cg.race([e3, tS(t3)]);
              }(this.signal.request(EI.LEAVE, void 0, true), 3e3);
            } catch (e3) {
              jC.warning("[".concat(this.store.clientId, "] leave request failed, ignore"), e3);
            }
            this.signal.close(t2), t2 !== ET.FALLBACK && (this.state = "DISCONNECTED"), this.reset();
          }
        }
        async publish(e2, t2, i2) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new LI(Hg.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
          const n2 = { state: "offer", p2p_id: this.store.p2pId, ortc: t2, mode: this.spec.mode, extend: RC("PUB_EXTEND"), twcc: !!RC("PUBLISH_TWCC"), rtx: !!RC("USE_PUB_RTX") };
          try {
            return (await this.signal.request(EI.PUBLISH, n2, true))._message;
          } catch (n3) {
            if (i2 && n3.data && n3.data.code === hI.ERR_PUBLISH_REQUEST_INVALID) return jC.warning("[".concat(this.store.clientId, "] receive publish error code, retry"), n3.toString()), await this.tryUnpubBeforeRepub(e2, t2), this.publish(e2, t2, false);
            throw n3;
          }
        }
        async publishDataChannel(e2, t2, i2) {
          var n2;
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new LI(Hg.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
          const r2 = { stream_id: t2.streamId, ordered: t2.ordered ? 1 : 0, max_retrans_times: null !== (n2 = t2.maxRetransmits) && void 0 !== n2 ? n2 : 10, channel_id: t2.channelId, metadata: t2.metadata };
          try {
            await this.signal.request(EI.PUBLISH_DATASTREAM, r2, true);
          } catch (n3) {
            if (i2 && n3.data && n3.data.code === hI.ERR_PUBLISH_REQUEST_INVALID) return jC.warning("[".concat(this.store.clientId, "] receive publish datachannels error code, retry"), n3.toString()), await this.tryUnpubDataChannelBeforeRepub(e2, t2), this.publishDataChannel(e2, t2, false);
            throw n3;
          }
        }
        async unpublish(e2, t2) {
          try {
            if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new LI(Hg.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
            await this.signal.request(EI.UNPUBLISH, { stream_id: t2, ortc: e2 }, true);
          } catch (e3) {
            jC.warning("[".concat(this.store.clientId, "] unpublish warning: "), e3);
          }
        }
        async unpublishDataChannel(e2) {
          try {
            if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new LI(Hg.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
            await cg.all(e2.map((e3) => this.signal.request(EI.UNPUBLISH_DATASTREAM, { channel_id: e3 }, true)));
          } catch (e3) {
            jC.warning("unpublish datachannels warning: ", e3);
          }
        }
        async presubscribe(e2, t2, i2) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new LI(Hg.INVALID_OPERATION, "can not presubscribe when connection state is ".concat(this.state));
          const n2 = { stream_id: e2, stream_type: t2, mode: this.spec.mode, codec: this.spec.codec, p2p_id: this.store.p2pId, twcc: !!RC("SUBSCRIBE_TWCC"), rtx: !!RC("USE_SUB_RTX") || void 0, extend: RC("SUB_EXTEND"), svc: Array.isArray(RC("SVC")) && 0 !== RC("SVC").length ? RC("SVC") : void 0 };
          try {
            return await this.signal.request(EI.PRE_SUBSCRIBE, n2, true);
          } catch (n3) {
            if (i2 && n3.data && n3.data.code === hI.ERR_SUBSCRIBE_REQUEST_INVALID) return jC.warning("[".concat(this.store.clientId, "] pre-subscribe error, retry"), n3.toString()), this.presubscribe(e2, t2, false);
            throw n3;
          }
        }
        async subscribe(e2, t2, i2) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new LI(Hg.INVALID_OPERATION, "can not subscribe when connection state is ".concat(this.state));
          const n2 = { stream_id: e2, stream_type: t2.stream_type, mode: this.spec.mode, codec: this.spec.codec, p2p_id: this.store.p2pId, twcc: !!RC("SUBSCRIBE_TWCC"), rtx: !!RC("USE_SUB_RTX"), extend: RC("SUB_EXTEND"), ssrcId: t2.ssrcId, svc: Array.isArray(RC("SVC")) && 0 !== RC("SVC").length ? RC("SVC") : void 0 };
          try {
            return (await this.signal.request(EI.SUBSCRIBE, n2, true))._message;
          } catch (n3) {
            if (i2 && n3.data && n3.data.code === hI.ERR_SUBSCRIBE_REQUEST_INVALID) return jC.warning("[".concat(this.store.clientId, "] receiver subscribe error code, retry"), n3.toString()), await this.tryUnsubBeforeResub(e2, t2), await this.subscribe(e2, t2, false);
            throw n3;
          }
        }
        async subscribeDataChannel(e2, t2, i2) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new LI(Hg.INVALID_OPERATION, "can not subscribe datachannel when connection state is ".concat(this.state));
          const n2 = { uid: e2, stream_id: t2.id, channel_id: t2.datachannelId };
          try {
            return void await this.signal.request(EI.SUBSCRIBE_DATASTREAM, n2, true);
          } catch (n3) {
            if (i2 && n3.data && n3.data.code === hI.ERR_SUBSCRIBE_REQUEST_INVALID) return jC.warning("[".concat(this.store.clientId, "] receiver subscribe datachannel error code, retry"), n3.toString()), await this.tryUnsubDataChannelBeforeResub(e2, t2), await this.subscribeDataChannel(e2, t2, false);
            throw n3;
          }
        }
        async subscribeAll(e2, t2) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new LI(Hg.INVALID_OPERATION, "can not massSubscribe when connection state is ".concat(this.state));
          const i2 = { p2p_id: this.store.p2pId, users: e2, dtx: false, rtx: !!RC("USE_SUB_RTX") };
          try {
            return await this.signal.request(EI.SUBSCRIBE_STREAMS, i2, true);
          } catch (i3) {
            if (t2 && i3.data && i3.data.code === hI.ERR_SUBSCRIBE_REQUEST_INVALID) return jC.warning("[".concat(this.store.clientId, "] receiver massSubscribe error code, retry"), i3.toString()), await this.tryMassUnsubBeforeResub(e2), await this.subscribeAll(e2, false);
            throw i3;
          }
        }
        async setVideoProfile(e2) {
          const t2 = function(e3) {
            if (!(e3.bitrateMax && e3.bitrateMin && e3.frameRate && e3.height && e3.width)) return;
            let t3 = e3.frameRate, i2 = e3.width, n2 = e3.height, r2 = true;
            return "number" != typeof t3 && (t3 = t3.exact || t3.ideal || t3.max || t3.min || 0, t3 || (r2 = false)), "number" != typeof i2 && (i2 = i2.exact || i2.ideal || i2.max || i2.min || 0, i2 || (r2 = false)), "number" != typeof n2 && (n2 = n2.exact || n2.ideal || n2.max || n2.min || 0, t3 || (r2 = false)), r2 ? { stream_type: 0, width: i2, height: n2, fps: t3, start_bps: 1e3 * e3.bitrateMax, min_bps: 1e3 * e3.bitrateMin, target_bps: 1e3 * e3.bitrateMax } : void 0;
          }(e2);
          if (t2) return this.signal.request(EI.SET_VIDEO_PROFILE, t2);
          jC.debug("[".concat(this.store.clientId, "] encoder config is not complete, do not report to gateway"));
        }
        async unsubscribe(e2, t2) {
          try {
            await this.signal.request(EI.UNSUBSCRIBE, { p2p_id: this.store.p2pId, ortc: e2, stream_id: t2 }, true);
          } catch (e3) {
            jC.warning("[".concat(this.store.clientId, "] unsubscribe warning: "), e3);
          }
        }
        async unsubscribeDataChannel(e2, t2) {
          try {
            if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new LI(Hg.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
            await cg.all(e2.map((e3) => this.signal.request(EI.UNSUBSCRIBE_DATASTREAM, { stream_id: e3, uid: t2 }, true)));
          } catch (e3) {
            jC.warning("unsubscribeDataChannel warning: ", e3);
          }
        }
        async massUnsubscribe(e2) {
          try {
            await this.signal.request(EI.UNSUBSCRIBE_STREAMS, e2, true);
          } catch (e3) {
            jC.warning("[".concat(this.store.clientId, "] massUnsubscribeAll warning: "), e3);
          }
        }
        async reconnectPC(e2) {
          const { iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 } = e2;
          return { gatewayEstablishParams: await this.signal.request(EI.CONNECT_PC, { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: { iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 } }, true), gatewayAddress: this.getCurrentGatewayAddress() };
        }
        getGatewayInfo() {
          return this.signal.request(EI.GATEWAY_INFO);
        }
        async renewToken(e2) {
          await this.signal.request(EI.RENEW_TOKEN, e2), this.key = e2.token;
        }
        async setClientRole(e2, t2) {
          if (t2 && (this._clientRoleOptions = Object.assign({}, t2)), "CONNECTED" !== this.state) return void (this.role = e2);
          let i2, n2 = 0;
          "audience" === e2 ? this._clientRoleOptions && this._clientRoleOptions.delay ? (i2 = this._clientRoleOptions.delay, n2 = 1) : n2 = this._clientRoleOptions && this._clientRoleOptions.level ? this._clientRoleOptions.level : 2 : n2 = 0, await this.signal.request(EI.SET_CLIENT_ROLE, { role: e2, level: n2, delay: i2, client_ts: Date.now() }), this.role = e2;
        }
        async setRemoteVideoStreamType(e2, t2) {
          await this.signal.request(EI.SWITCH_VIDEO_STREAM, { stream_id: e2, stream_type: t2 });
        }
        async setDefaultRemoteVideoStreamType(e2) {
          await this.signal.request(EI.DEFAULT_VIDEO_STREAM, { stream_type: e2 });
        }
        async setStreamFallbackOption(e2, t2) {
          await this.signal.request(EI.SET_FALLBACK_OPTION, { stream_id: e2, fallback_type: t2 });
        }
        async pickSVCLayer(e2, t2) {
          await this.signal.request(EI.PICK_SVC_LAYER, { stream_id: e2, spatial_layer: t2.spatialLayer, temporal_layer: t2.temporalLayer });
        }
        async setRTM2Flag(e2) {
          await this.signal.request(EI.SET_RTM2_FLAG, { rtm2_flag: e2 });
        }
        async sendExtensionMessage(e2, t2, i2) {
          if (this.signal instanceof Ly) return this.signal.sendExtensionMessage(e2, t2, i2);
        }
        getInChannelInfo() {
          return this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt), My({}, this.inChannelInfo);
        }
        async getGatewayVersion() {
          return (await this.signal.request(EI.GATEWAY_INFO)).version;
        }
        reset() {
          if (this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt, this.inChannelInfo.joinAt = null), this.trafficStatsInterval && (window.clearInterval(this.trafficStatsInterval), this.trafficStatsInterval = void 0), this.joinInfo) {
            const e2 = Uy.get(this.joinInfo.cname);
            e2 && e2.delete(this.joinInfo.uid);
          }
          this.joinInfo = void 0, this.key = void 0, this.networkQualityInterval && (window.clearInterval(this.networkQualityInterval), this.networkQualityInterval = void 0);
        }
        updateTurnConfigFromSignal() {
          if (!this.joinInfo) return;
          const e2 = function(e3) {
            let t2;
            return t2 = e3.startsWith("dc") ? e3.match(/(dc\:\/\/)?([^:]+):(\d+)/) : e3.match(/(wss\:\/\/)?([^:]+):(\d+)/), t2 ? { username: iI.username, password: iI.password, turnServerURL: t2[2], tcpport: parseInt(t2[3]) + 30, udpport: parseInt(t2[3]) + 30, forceturn: false } : null;
          }(("disabled" === this.joinInfo.cloudProxyServer ? this.signal.url : this.joinInfo.gatewayAddrs[this.signal.currentURLIndex].address) || "");
          this.joinInfo.turnServer.serversFromGateway = [], e2 && "off" !== this.joinInfo.turnServer.mode && "disabled" === this.joinInfo.cloudProxyServer && this.joinInfo.turnServer.serversFromGateway.push(My(My({}, iI), {}, { turnServerURL: e2.turnServerURL, tcpport: e2.tcpport, udpport: e2.udpport, username: this.joinInfo.uid.toString(), password: this.joinInfo.token }));
        }
        async updateTrafficStats() {
          if ("CONNECTED" !== this.state) return;
          const e2 = await this.signal.request(EI.TRAFFIC_STATS, void 0, true);
          e2.timestamp = Date.now(), null != e2.ntp_offset && (this.ntpOffset = e2.ntp_offset), e2.peer_delay.forEach((e3) => {
            const t2 = this._statsCollector.trafficStats && this._statsCollector.trafficStats.peer_delay.find((t3) => t3.peer_uid === e3.peer_uid);
            t2 && t2.B_st !== e3.B_st && KT(() => {
              this.emit(XI.STREAM_TYPE_CHANGE, e3.peer_uid, e3.B_st);
            });
          }), this._statsCollector.updateTrafficStats(e2);
        }
        getJoinMessage(e2) {
          if (!this.joinInfo || !this.key) throw new LI(Hg.UNEXPECTED_ERROR, "can not generate join message, no join info");
          const t2 = Object.assign({}, this.joinInfo.apResponse);
          let i2 = RC("REPORT_APP_SCENARIO");
          if ("string" != typeof i2) try {
            i2 = JSON.stringify(i2);
          } catch (e3) {
            i2 = void 0;
          }
          i2 && i2.length > 128 && (i2 = void 0);
          const n2 = My({ license: this.joinInfo.license, p2p_id: this.store.p2pId, session_id: this.joinInfo.sid, app_id: this.joinInfo.appId, channel_key: this.key, channel_name: this.joinInfo.cname, sdk_version: EC, browser: navigator.userAgent, process_id: RC("PROCESS_ID"), mode: this.store.useP2P ? "p2p" : this.spec.mode, codec: this.spec.codec, role: this.role, has_changed_gateway: this.hasChangeBGPAddress, ap_response: t2, extend: RC("JOIN_EXTEND"), details: { 6: this.joinInfo.stringUid, cservice_map: "proxy3" === this.joinInfo.cloudProxyServer ? "1" : "proxy5" === this.joinInfo.cloudProxyServer ? "2" : void 0 }, features: { rejoin: true }, optionalInfo: this.joinInfo.optionalInfo, appScenario: i2, attributes: { userAttributes: { enablePublishedUserList: RC("ENABLE_PUBLISHED_USER_LIST"), maxSubscription: RC("MAX_SUBSCRIPTION"), subscribeAudioFilterTopN: "number" == typeof RC("SUBSCRIBE_AUDIO_FILTER_TOPN") ? RC("SUBSCRIBE_AUDIO_FILTER_TOPN") : void 0, enablePublishAudioFilter: "boolean" == typeof RC("ENABLE_PUBLISH_AUDIO_FILTER") ? RC("ENABLE_PUBLISH_AUDIO_FILTER") : void 0, enableUserLicenseCheck: "boolean" == typeof RC("ENABLE_USER_LICENSE_CHECK") ? RC("ENABLE_USER_LICENSE_CHECK") : void 0, enableRTX: true === RC("USE_PUB_RTX") || true === RC("USE_SUB_RTX") || void 0, disableFEC: RC("DISABLE_FEC"), enableNTPReport: !!RC("ENABLE_NTP_REPORT") || void 0, enableInstantVideo: !!RC("ENABLE_INSTANT_VIDEO") || void 0, enableDataStream2: "boolean" == typeof RC("ENABLE_DATASTREAM_2") ? RC("ENABLE_DATASTREAM_2") : void 0, rtm2Flag: "number" == typeof this.joinInfo.rtmFlag ? this.joinInfo.rtmFlag : void 0, enableUserAutoRebalanceCheck: !!RC("ENABLE_USER_AUTO_REBALANCE_CHECK"), enableXR: "boolean" == typeof RC("USE_XR") ? RC("USE_XR") : void 0 } }, join_ts: this.joinGatewayStartTime }, e2);
          return this.joinInfo.stringUid && (n2.string_uid = this.joinInfo.stringUid), this.joinInfo.aesmode && this.joinInfo.aespassword && (n2.aes_mode = this.joinInfo.aesmode, RC("ENCRYPT_AES") ? (n2.aes_secret = this.joinInfo.aespassword, n2.aes_encrypt = true) : n2.aes_secret = this.joinInfo.aespassword, this.joinInfo.aessalt && (n2.aes_salt = this.joinInfo.aessalt)), t2.addresses[this.signal.websocket.currentURLIndex] && (n2.ap_response.ticket = t2.addresses[this.signal.websocket.currentURLIndex].ticket, delete t2.addresses), void 0 !== this.joinInfo.defaultVideoStream && (n2.default_video_stream = this.joinInfo.defaultVideoStream), n2;
        }
        getRejoinMessage() {
          if (!this.joinInfo) throw new LI(Hg.UNEXPECTED_ERROR, "can not generate rejoin message, no join info");
          return { session_id: this.joinInfo.sid, channel_name: this.joinInfo.cname, cid: this.joinInfo.cid, uid: this.joinInfo.uid, vid: Number(this.joinInfo.vid) };
        }
        handleSignalEvents() {
          this.signal.on(_I.WS_RECONNECT_WAITTING_FINISH, (e2) => {
            var t2;
            bn(t2 = ["tryNext", "recover"]).call(t2, e2) && this.joinInfo && eI.adjustSessionStartTime(this.joinInfo.sid);
          }), this.signal.on(_I.WS_RECONNECT_CREATE_CONNECTION, (e2) => {
            this.joinGatewayStartTime = Date.now();
          }), this.signal.on(_I.WS_RECONNECTING, (e2) => {
            this.joinInfo && eI.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: e2 || fT.NETWORK_ERROR }), this.joinInfo && (this.state = "RECONNECTING", eI.sessionInit(this.joinInfo.sid, { lts: (/* @__PURE__ */ new Date()).getTime(), extend: this.isSignalRecover ? { recover: true } : { rejoin: true }, cname: this.joinInfo.cname, appid: this.joinInfo.appId, mode: this.spec.mode, stringUid: this.joinInfo.stringUid, channelProfile: "live" === this.spec.mode ? 1 : 0, channelMode: 0, lsid: this.joinInfo.sid, clientRole: "audience" === this.role ? 2 : 1 }), this.isSignalRecover = false, this.joinGatewayStartTime = Date.now());
          }), this.signal.on(_I.WS_CLOSED, (e2) => {
            let t2;
            switch (e2) {
              case ET.LEAVE:
                t2 = fT.LEAVE;
                break;
              case ET.UID_BANNED:
              case ET.IP_BANNED:
              case ET.CHANNEL_BANNED:
              case ET.SERVER_ERROR:
                t2 = fT.SERVER_ERROR;
                break;
              case ET.FALLBACK:
                t2 = fT.FALLBACK;
                break;
              case ET.LICENSE_MISSING:
              case ET.LICENSE_EXPIRED:
              case ET.LICENSE_MINUTES_EXCEEDED:
              case ET.LICENSE_PERIOD_INVALID:
              case ET.LICENSE_MULTIPLE_SDK_SERVICE:
              case ET.LICENSE_ILLEGAL:
              case ET.TOKEN_EXPIRE:
                t2 = e2;
                break;
              default:
                t2 = fT.NETWORK_ERROR;
            }
            jC.debug("[".concat(this.store.clientId, "] [signal] websocket closed, reason: ").concat(t2 || "undefined -> " + fT.NETWORK_ERROR)), this.joinInfo && eI.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: e2 === ET.LEAVE ? 1 : -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: t2 }), this._disconnectedReason = e2, e2 !== ET.FALLBACK && (this.state = "DISCONNECTED"), this.reset();
          }), this.signal.on(_I.WS_CONNECTED, () => {
            if (this.updateTurnConfigFromSignal(), this.state = "CONNECTED", this.joinInfo && ("audience" === this.role && this._clientRoleOptions && (this._clientRoleOptions.level || this._clientRoleOptions.delay) && (jC.debug("[".concat(this.store.clientId, "] patch to send set client role, role: ").concat(this.role, ", mode: ").concat(this.spec.mode, ", level: ").concat(this._clientRoleOptions.level, ", delay: ").concat(this._clientRoleOptions.delay)), this.setClientRole(this.role, this._clientRoleOptions)), eI.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: true, ec: null, vid: this.joinInfo.vid, addr: this.signal.url, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!this.joinInfo.proxyServer, signalChannel: this.signal instanceof Dy ? "1" : "0" }), this._isProactiveJoin = false, this.joinInfo.useLocalAccessPoint && 1 === this.joinInfo.setLocalAPVersion)) {
              const e2 = this.signal.url && this.signal.url.match(/wss\:\/\/([^:]+):(\d+)/);
              if (!e2) return void jC.error("[".concat(this.store.clientId, "] set local access point after joined failed: ").concat(e2));
              SC("EVENT_REPORT_DOMAIN", e2[1]), SC("EVENT_REPORT_BACKUP_DOMAIN", e2[1]), SC("LOG_UPLOAD_SERVER", "".concat(e2[1], ":6444"));
            }
          }), this.signal.on(fI.ON_UPLINK_STATS, (e2) => {
            this._statsCollector.updateUplinkStats(e2);
          }), this.signal.on(_I.REQUEST_RECOVER, (e2, t2, i2) => {
            if (!this.joinInfo) return i2(new LI(Hg.UNEXPECTED_ERROR, "gateway: can not recover, no join info"));
            e2 && (this.joinInfo.multiIP = e2, this.hasChangeBGPAddress = true), this.isSignalRecover = true, vT(this, XI.REQUEST_NEW_GATEWAY_LIST).then(t2).catch(i2);
          }), this.signal.on(_I.REQUEST_JOIN_INFO, async (e2) => {
            var t2;
            if (this.updateTurnConfigFromSignal(), this.store.useP2P) return void e2(this.getJoinMessage({ ortc: {} }));
            const { iceParameters: i2, dtlsParameters: n2, rtpCapabilities: r2 } = await vT(this, XI.REQUEST_P2P_CONNECTION_PARAMS, { turnServer: null === (t2 = this.joinInfo) || void 0 === t2 ? void 0 : t2.turnServer });
            e2(this.getJoinMessage({ ortc: { iceParameters: i2, dtlsParameters: n2, rtpCapabilities: r2, version: "2" } }));
          }), this.signal.on(_I.REQUEST_REJOIN_INFO, (e2) => {
            e2(this.getRejoinMessage());
          }), this.signal.on(_I.REPORT_JOIN_GATEWAY, (e2, t2) => {
            this.joinInfo && (eI.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: false, ec: e2, addr: t2, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!this.joinInfo.proxyServer, signalChannel: this.signal instanceof Dy ? "1" : "0" }), this._isProactiveJoin = false);
          }), this.signal.on(_I.IS_P2P_DISCONNECTED, (e2) => {
            e2(bT(this, XI.IS_P2P_DISCONNECTED));
          }), this.signal.on(_I.DISCONNECT_P2P, () => {
            this.emit(XI.DISCONNECT_P2P);
          }), this.signal.on(_I.NEED_RENEW_SESSION, () => {
            this.emit(XI.NEED_RENEW_SESSION);
          }), this.signal.on(_I.REQUEST_SUCCESS, () => {
            this._signalTimeout = false;
          }), this.signal.on(_I.REQUEST_TIMEOUT, () => {
            this._signalTimeout = true;
          }), this.signal.on(_I.JOIN_RESPONSE, (e2) => {
            const t2 = this.getCurrentGatewayAddress();
            this.emit(XI.JOIN_RESPONSE, e2, t2);
          }), this.signal.on(_I.DATACHANNEL_PRECONNECT, async (e2, t2, i2) => {
            this.updateTurnConfigFromSignal();
            const n2 = this.getCurrentGatewayAddress();
            return vT(this, XI.DATACHANNEL_PRECONNECT, e2, n2).then(t2).catch(i2);
          }), this.signal.on(_I.DATACHANNEL_CONNECTING, async (e2) => {
            const { iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 } = await vT(this, XI.REQUEST_DC_CONNECTION_PARAMS);
            e2(this.getJoinMessage({ ortc: { iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2, version: "2" } }));
          }), this.signal.on(_I.DATACHANNEL_FAILBACK, () => {
            jC.warning("[".concat(this.store.clientId, "] User join datachannel failed")), this.reset(), this.resetSignal(), this.emit(XI.DATACHANNEL_FAILBACK);
          });
        }
        async tryUnsubBeforeResub(e2, t2) {
          try {
            await this.signal.request(EI.UNSUBSCRIBE, { p2p_id: this.store.p2pId, stream_id: e2, ortc: [t2] }, true);
          } catch (e3) {
            throw jC.warning("[".concat(this.store.clientId, "] tryUnsubBeforeResub warning"), e3), e3;
          }
        }
        async tryUnsubDataChannelBeforeResub(e2, t2) {
          try {
            await this.signal.request(EI.UNSUBSCRIBE, { stream_id: t2.id }, true);
          } catch (e3) {
            throw jC.warning("unsubscribe datachannel warning", e3), e3;
          }
        }
        async tryUnpubBeforeRepub(e2, t2) {
          try {
            await this.signal.request(EI.UNPUBLISH, { stream_id: e2, ortc: t2 }, true);
          } catch (e3) {
            throw jC.warning("[".concat(this.store.clientId, "] tryUnpubBeforeRepub warning: "), e3), e3;
          }
        }
        async tryUnpubDataChannelBeforeRepub(e2, t2) {
          try {
            await this.signal.request(EI.UNPUBLISH_DATASTREAM, { channnel_id: t2.channelId }, true);
          } catch (e3) {
            throw jC.warning("unpublish datastream warning: ", e3), e3;
          }
        }
        async tryMassUnsubBeforeResub(e2) {
          const t2 = { users: e2.map((e3) => ({ stream_id: e3.stream_id, stream_type: e3.stream_type })) };
          try {
            await this.signal.request(EI.UNSUBSCRIBE_STREAMS, t2, true);
          } catch (e3) {
            throw jC.warning("[".concat(this.store.clientId, "] tryMassUnsubBeforeResub warning"), e3), e3;
          }
        }
        async muteLocal(e2, t2) {
          const i2 = { action: e2.find((e3) => e3.stream_type === JI.Audio) ? "mute_local_audio" : "mute_local_video", p2p_id: this.store.p2pId, ortc: e2, stream_id: t2 };
          try {
            await this.signal.request(EI.CONTROL, i2, true, true);
          } catch (e3) {
            throw jC.warning("[".concat(this.store.clientId, "] gateway muteLocal warning: "), e3), e3;
          }
        }
        async unmuteLocal(e2, t2) {
          const i2 = { action: e2.find((e3) => e3.stream_type === JI.Audio) ? "unmute_local_audio" : "unmute_local_video", p2p_id: this.store.p2pId, ortc: e2, stream_id: t2 };
          try {
            await this.signal.request(EI.CONTROL, i2, true, true);
          } catch (e3) {
            throw jC.warning("[".concat(this.store.clientId, "] gateway unmuteLocal warning: "), e3), e3;
          }
        }
        async muteRemote(e2, t2) {
          const i2 = { action: e2 === av.AUDIO ? "mute_remote_audio" : "mute_remote_video", p2p_id: this.store.p2pId, stream_id: t2 };
          try {
            await this.signal.request(EI.CONTROL, i2, true, true);
          } catch (e3) {
            throw jC.warning("[".concat(this.store.clientId, "] gateway muteRemote warning: "), e3), e3;
          }
        }
        async unmuteRemote(e2, t2) {
          const i2 = { action: e2 === av.AUDIO ? "unmute_remote_audio" : "unmute_remote_video", p2p_id: this.store.p2pId, stream_id: t2 };
          try {
            await this.signal.request(EI.CONTROL, i2, true, true);
          } catch (e3) {
            throw jC.warning("[".concat(this.store.clientId, "] gateway unmuteRemote warning: "), e3), e3;
          }
        }
        uploadWRTCStats(e2) {
          this.signal.uploadWRTCStats(e2);
        }
        upload(e2, t2) {
          this.signal.upload(e2, t2);
        }
        getSignalRTT() {
          return this.signal.rtt;
        }
        async restartICE(e2) {
          const t2 = { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: e2 };
          try {
            return await this.signal.request(EI.RESTART_ICE, t2, true);
          } catch (e3) {
            throw jC.warning("[".concat(this.store.clientId, "] P2PChannel.restartICE warning: "), e3), e3;
          }
        }
        reconnect() {
          "CONNECTED" === this.state && this.signal.reconnect(void 0, fT.P2P_FAILED);
        }
        getCurrentGatewayAddress() {
          var e2;
          if (!RC("GATEWAY_WSS_ADDRESS")) return null !== (e2 = this.joinInfo) && void 0 !== e2 && e2.gatewayAddrs ? this.joinInfo.gatewayAddrs[this.signal.currentURLIndex] : void 0;
        }
        async setPublishAudioFilterEnabled(e2) {
          await this.signal.request(EI.SET_PARAMETER, { enablePublishAudioFilter: e2 });
        }
        resetSignal() {
          this.signal && (this.signal.removeAllListeners(), this.signal.close(ET.FALLBACK)), this.store.useDataChannel = false, this.signal = new Jv(My(My({}, this.spec), {}, { retryConfig: this.spec.websocketRetryConfig }), this.store), this.handleSignalEvents(), this.emit(XI.RESET_SIGNAL, $I.websocket);
        }
      }
      let Vy = 0, Fy = 0;
      function By(e2, t2, i2, n2) {
        return new cg((r2, s2) => {
          t2.timeout = t2.timeout || RC("HTTP_CONNECT_TIMEOUT"), t2.responseType = t2.responseType || "json", t2.data && !i2 ? (t2.data = JSON.stringify(t2.data), Vy += $T(t2.data)) : i2 && (t2.data.size ? Vy += t2.data.size : t2.data instanceof FormData ? Vy += eS(t2.data) : Vy += $T(JSON.stringify(t2.data))), t2.headers = t2.headers || {}, t2.headers["Content-Type"] = t2.headers["Content-Type"] || "application/json", t2.method = "POST", t2.url = e2, sC.request(t2).then((e3) => {
            "string" == typeof e3.data ? Fy += $T(e3.data) : e3.data instanceof ArrayBuffer || e3.data instanceof Uint8Array ? Fy += e3.data.byteLength : Fy += $T(JSON.stringify(e3.data)), n2 && r2({ data: e3.data, headers: e3.headers }), r2(e3.data);
          }).catch((e3) => {
            sC.isCancel(e3) ? s2(new LI(Hg.OPERATION_ABORTED, "cancel token canceled")) : "ECONNABORTED" === e3.code ? s2(new LI(Hg.NETWORK_TIMEOUT, e3.message)) : e3.response ? s2(new LI(Hg.NETWORK_RESPONSE_ERROR, e3.response.status)) : s2(new LI(Hg.NETWORK_ERROR, e3.message));
          });
        });
      }
      !function() {
        var e2;
        function i2(e3) {
          var t2 = 0;
          return function() {
            return t2 < e3.length ? { done: false, value: e3[t2++] } : { done: true };
          };
        }
        var n2 = "function" == typeof Object.defineProperties ? Object.defineProperty : function(e3, t2, i3) {
          return e3 == Array.prototype || e3 == Object.prototype || (e3[t2] = i3.value), e3;
        };
        var r2, s2 = function(e3) {
          e3 = ["object" == typeof globalThis && globalThis, e3, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof t && t];
          for (var i3 = 0; i3 < e3.length; ++i3) {
            var n3 = e3[i3];
            if (n3 && n3.Math == Math) return n3;
          }
          throw Error("Cannot find global object");
        }(this);
        function o2(e3, t2) {
          if (t2) e: {
            var i3 = s2;
            e3 = e3.split(".");
            for (var r3 = 0; r3 < e3.length - 1; r3++) {
              var o3 = e3[r3];
              if (!(o3 in i3)) break e;
              i3 = i3[o3];
            }
            (t2 = t2(r3 = i3[e3 = e3[e3.length - 1]])) != r3 && null != t2 && n2(i3, e3, { configurable: true, writable: true, value: t2 });
          }
        }
        function a2(e3) {
          return (e3 = { next: e3 })[Symbol.iterator] = function() {
            return this;
          }, e3;
        }
        function c2(e3) {
          var t2 = "undefined" != typeof Symbol && Symbol.iterator && e3[Symbol.iterator];
          return t2 ? t2.call(e3) : { next: i2(e3) };
        }
        if (o2("Symbol", function(e3) {
          function t2(e4, t3) {
            this.A = e4, n2(this, "description", { configurable: true, writable: true, value: t3 });
          }
          if (e3) return e3;
          t2.prototype.toString = function() {
            return this.A;
          };
          var i3 = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", r3 = 0;
          return function e4(n3) {
            if (this instanceof e4) throw new TypeError("Symbol is not a constructor");
            return new t2(i3 + (n3 || "") + "_" + r3++, n3);
          };
        }), o2("Symbol.iterator", function(e3) {
          if (e3) return e3;
          e3 = Symbol("Symbol.iterator");
          for (var t2 = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), r3 = 0; r3 < t2.length; r3++) {
            var o3 = s2[t2[r3]];
            "function" == typeof o3 && "function" != typeof o3.prototype[e3] && n2(o3.prototype, e3, { configurable: true, writable: true, value: function() {
              return a2(i2(this));
            } });
          }
          return e3;
        }), "function" == typeof Object.setPrototypeOf) r2 = Object.setPrototypeOf;
        else {
          var d2;
          e: {
            var l2 = {};
            try {
              l2.__proto__ = { a: true }, d2 = l2.a;
              break e;
            } catch (e3) {
            }
            d2 = false;
          }
          r2 = d2 ? function(e3, t2) {
            if (e3.__proto__ = t2, e3.__proto__ !== t2) throw new TypeError(e3 + " is not extensible");
            return e3;
          } : null;
        }
        var u2 = r2;
        function h3() {
          this.m = false, this.j = null, this.v = void 0, this.h = 1, this.u = this.C = 0, this.l = null;
        }
        function p2(e3) {
          if (e3.m) throw new TypeError("Generator is already running");
          e3.m = true;
        }
        function _2(e3, t2) {
          return e3.h = 3, { value: t2 };
        }
        function E2(e3) {
          this.g = new h3(), this.G = e3;
        }
        function m2(e3, t2, i3, n3) {
          try {
            var r3 = t2.call(e3.g.j, i3);
            if (!(r3 instanceof Object)) throw new TypeError("Iterator result " + r3 + " is not an object");
            if (!r3.done) return e3.g.m = false, r3;
            var s3 = r3.value;
          } catch (t3) {
            return e3.g.j = null, e3.g.s(t3), f2(e3);
          }
          return e3.g.j = null, n3.call(e3.g, s3), f2(e3);
        }
        function f2(e3) {
          for (; e3.g.h; ) try {
            var t2 = e3.G(e3.g);
            if (t2) return e3.g.m = false, { value: t2.value, done: false };
          } catch (t3) {
            e3.g.v = void 0, e3.g.s(t3);
          }
          if (e3.g.m = false, e3.g.l) {
            if (t2 = e3.g.l, e3.g.l = null, t2.F) throw t2.D;
            return { value: t2.return, done: true };
          }
          return { value: void 0, done: true };
        }
        function g2(e3) {
          this.next = function(t2) {
            return e3.o(t2);
          }, this.throw = function(t2) {
            return e3.s(t2);
          }, this.return = function(t2) {
            return function(e4, t3) {
              p2(e4.g);
              var i3 = e4.g.j;
              return i3 ? m2(e4, "return" in i3 ? i3.return : function(e5) {
                return { value: e5, done: true };
              }, t3, e4.g.return) : (e4.g.return(t3), f2(e4));
            }(e3, t2);
          }, this[Symbol.iterator] = function() {
            return this;
          };
        }
        function T2(e3, t2) {
          return t2 = new g2(new E2(t2)), u2 && e3.prototype && u2(t2, e3.prototype), t2;
        }
        if (h3.prototype.o = function(e3) {
          this.v = e3;
        }, h3.prototype.s = function(e3) {
          this.l = { D: e3, F: true }, this.h = this.C || this.u;
        }, h3.prototype.return = function(e3) {
          this.l = { return: e3 }, this.h = this.u;
        }, E2.prototype.o = function(e3) {
          return p2(this.g), this.g.j ? m2(this, this.g.j.next, e3, this.g.o) : (this.g.o(e3), f2(this));
        }, E2.prototype.s = function(e3) {
          return p2(this.g), this.g.j ? m2(this, this.g.j.throw, e3, this.g.o) : (this.g.s(e3), f2(this));
        }, o2("Array.prototype.entries", function(e3) {
          return e3 || function() {
            return function(e4, t2) {
              e4 instanceof String && (e4 += "");
              var i3 = 0, n3 = false, r3 = { next: function() {
                if (!n3 && i3 < e4.length) {
                  var r4 = i3++;
                  return { value: t2(r4, e4[r4]), done: false };
                }
                return n3 = true, { done: true, value: void 0 };
              } };
              return r3[Symbol.iterator] = function() {
                return r3;
              }, r3;
            }(this, function(e4, t2) {
              return [e4, t2];
            });
          };
        }), "undefined" != typeof Blob && ("undefined" == typeof FormData || !FormData.prototype.keys)) {
          var S2 = function(e3, t2) {
            for (var i3 = 0; i3 < e3.length; i3++) t2(e3[i3]);
          }, R2 = function(e3) {
            return e3.replace(/\r?\n|\r/g, "\r\n");
          }, C2 = function(e3, t2, i3) {
            return t2 instanceof Blob ? (i3 = void 0 !== i3 ? String(i3 + "") : "string" == typeof t2.name ? t2.name : "blob", t2.name === i3 && "[object Blob]" !== Object.prototype.toString.call(t2) || (t2 = new File([t2], i3)), [String(e3), t2]) : [String(e3), String(t2)];
          }, I2 = function(e3, t2) {
            if (e3.length < t2) throw new TypeError(t2 + " argument required, but only " + e3.length + " present.");
          }, v2 = "object" == typeof globalThis ? globalThis : "object" == typeof window ? window : "object" == typeof self ? self : this, y2 = v2.FormData, A2 = v2.XMLHttpRequest && v2.XMLHttpRequest.prototype.send, b2 = v2.Request && v2.fetch, w2 = v2.navigator && v2.navigator.sendBeacon, O2 = v2.Element && v2.Element.prototype, N2 = v2.Symbol && Symbol.toStringTag;
          N2 && (Blob.prototype[N2] || (Blob.prototype[N2] = "Blob"), "File" in v2 && !File.prototype[N2] && (File.prototype[N2] = "File"));
          try {
            new File([], "");
          } catch (e3) {
            v2.File = function(e4, t2, i3) {
              return e4 = new Blob(e4, i3 || {}), Object.defineProperties(e4, { name: { value: t2 }, lastModified: { value: +(i3 && void 0 !== i3.lastModified ? new Date(i3.lastModified) : /* @__PURE__ */ new Date()) }, toString: { value: function() {
                return "[object File]";
              } } }), N2 && Object.defineProperty(e4, N2, { value: "File" }), e4;
            };
          }
          var D2 = function(e3) {
            return e3.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
          }, P2 = function(e3) {
            this.i = [];
            var t2 = this;
            e3 && S2(e3.elements, function(e4) {
              if (e4.name && !e4.disabled && "submit" !== e4.type && "button" !== e4.type && !e4.matches("form fieldset[disabled] *")) if ("file" === e4.type) {
                var i3 = e4.files && e4.files.length ? e4.files : [new File([], "", { type: "application/octet-stream" })];
                S2(i3, function(i4) {
                  t2.append(e4.name, i4);
                });
              } else "select-multiple" === e4.type || "select-one" === e4.type ? S2(e4.options, function(i4) {
                !i4.disabled && i4.selected && t2.append(e4.name, i4.value);
              }) : "checkbox" === e4.type || "radio" === e4.type ? e4.checked && t2.append(e4.name, e4.value) : (i3 = "textarea" === e4.type ? R2(e4.value) : e4.value, t2.append(e4.name, i3));
            });
          };
          if ((e2 = P2.prototype).append = function(e3, t2, i3) {
            I2(arguments, 2), this.i.push(C2(e3, t2, i3));
          }, e2.delete = function(e3) {
            I2(arguments, 1);
            var t2 = [];
            e3 = String(e3), S2(this.i, function(i3) {
              i3[0] !== e3 && t2.push(i3);
            }), this.i = t2;
          }, e2.entries = function e3() {
            var t2, i3 = this;
            return T2(e3, function(e4) {
              if (1 == e4.h && (t2 = 0), 3 != e4.h) return t2 < i3.i.length ? e4 = _2(e4, i3.i[t2]) : (e4.h = 0, e4 = void 0), e4;
              t2++, e4.h = 2;
            });
          }, e2.forEach = function(e3, t2) {
            I2(arguments, 1);
            for (var i3 = c2(this), n3 = i3.next(); !n3.done; n3 = i3.next()) {
              var r3 = c2(n3.value);
              n3 = r3.next().value, r3 = r3.next().value, e3.call(t2, r3, n3, this);
            }
          }, e2.get = function(e3) {
            I2(arguments, 1);
            var t2 = this.i;
            e3 = String(e3);
            for (var i3 = 0; i3 < t2.length; i3++) if (t2[i3][0] === e3) return t2[i3][1];
            return null;
          }, e2.getAll = function(e3) {
            I2(arguments, 1);
            var t2 = [];
            return e3 = String(e3), S2(this.i, function(i3) {
              i3[0] === e3 && t2.push(i3[1]);
            }), t2;
          }, e2.has = function(e3) {
            I2(arguments, 1), e3 = String(e3);
            for (var t2 = 0; t2 < this.i.length; t2++) if (this.i[t2][0] === e3) return true;
            return false;
          }, e2.keys = function e3() {
            var t2, i3, n3, r3, s3 = this;
            return T2(e3, function(e4) {
              if (1 == e4.h && (t2 = c2(s3), i3 = t2.next()), 3 != e4.h) return i3.done ? void (e4.h = 0) : (n3 = i3.value, r3 = c2(n3), _2(e4, r3.next().value));
              i3 = t2.next(), e4.h = 2;
            });
          }, e2.set = function(e3, t2, i3) {
            I2(arguments, 2), e3 = String(e3);
            var n3 = [], r3 = C2(e3, t2, i3), s3 = true;
            S2(this.i, function(t3) {
              t3[0] === e3 ? s3 && (s3 = !n3.push(r3)) : n3.push(t3);
            }), s3 && n3.push(r3), this.i = n3;
          }, e2.values = function e3() {
            var t2, i3, n3, r3, s3 = this;
            return T2(e3, function(e4) {
              if (1 == e4.h && (t2 = c2(s3), i3 = t2.next()), 3 != e4.h) return i3.done ? void (e4.h = 0) : (n3 = i3.value, (r3 = c2(n3)).next(), _2(e4, r3.next().value));
              i3 = t2.next(), e4.h = 2;
            });
          }, P2.prototype._asNative = function() {
            for (var e3 = new y2(), t2 = c2(this), i3 = t2.next(); !i3.done; i3 = t2.next()) {
              var n3 = c2(i3.value);
              i3 = n3.next().value, n3 = n3.next().value, e3.append(i3, n3);
            }
            return e3;
          }, P2.prototype._blob = function() {
            var e3 = "----formdata-polyfill-" + Math.random(), t2 = [], i3 = "--" + e3 + '\r\nContent-Disposition: form-data; name="';
            return this.forEach(function(e4, n3) {
              return "string" == typeof e4 ? t2.push(i3 + D2(R2(n3)) + '"\r\n\r\n' + R2(e4) + "\r\n") : t2.push(i3 + D2(R2(n3)) + '"; filename="' + D2(e4.name) + '"\r\nContent-Type: ' + (e4.type || "application/octet-stream") + "\r\n\r\n", e4, "\r\n");
            }), t2.push("--" + e3 + "--"), new Blob(t2, { type: "multipart/form-data; boundary=" + e3 });
          }, P2.prototype[Symbol.iterator] = function() {
            return this.entries();
          }, P2.prototype.toString = function() {
            return "[object FormData]";
          }, O2 && !O2.matches && (O2.matches = O2.matchesSelector || O2.mozMatchesSelector || O2.msMatchesSelector || O2.oMatchesSelector || O2.webkitMatchesSelector || function(e3) {
            for (var t2 = (e3 = (this.document || this.ownerDocument).querySelectorAll(e3)).length; 0 <= --t2 && e3.item(t2) !== this; ) ;
            return -1 < t2;
          }), N2 && (P2.prototype[N2] = "FormData"), A2) {
            var L2 = v2.XMLHttpRequest.prototype.setRequestHeader;
            v2.XMLHttpRequest.prototype.setRequestHeader = function(e3, t2) {
              L2.call(this, e3, t2), "content-type" === e3.toLowerCase() && (this.B = true);
            }, v2.XMLHttpRequest.prototype.send = function(e3) {
              e3 instanceof P2 ? (e3 = e3._blob(), this.B || this.setRequestHeader("Content-Type", e3.type), A2.call(this, e3)) : A2.call(this, e3);
            };
          }
          b2 && (v2.fetch = function(e3, t2) {
            return t2 && t2.body && t2.body instanceof P2 && (t2.body = t2.body._blob()), b2.call(this, e3, t2);
          }), w2 && (v2.navigator.sendBeacon = function(e3, t2) {
            return t2 instanceof P2 && (t2 = t2._asNative()), w2.call(this, e3, t2);
          }), v2.FormData = P2;
        }
      }();
      const jy = () => {
        const e2 = RC("AREAS");
        0 === e2.length && e2.push(ev.GLOBAL);
        return BT(e2).call(e2, (e3, t2, i2) => {
          const n2 = Gy(t2);
          return n2 ? 0 === i2 ? n2 : "".concat(e3, ",").concat(n2) : e3;
        }, "");
      }, Gy = (e2) => e2 === ev.OVERSEA ? "".concat(nv.ASIA, ",").concat(nv.EUROPE, ",").concat(nv.AFRICA, ",").concat(nv.NORTH_AMERICA, ",").concat(nv.SOUTH_AMERICA, ",").concat(nv.OCEANIA) : nv[e2], Wy = (e2) => {
        const t2 = { CODE: "", WEBCS_DOMAIN: [], WEBCS_DOMAIN_BACKUP_LIST: [], PROXY_CS: [], CDS_AP: [], ACCOUNT_REGISTER: [], UAP_AP: [], EVENT_REPORT_DOMAIN: [], EVENT_REPORT_BACKUP_DOMAIN: [], LOG_UPLOAD_SERVER: [], PROXY_SERVER_TYPE3: [] };
        return e2.map((e3) => {
          const i2 = rv[e3], n2 = Object.keys(i2);
          n2 && n2.map((e4) => {
            "CODE" !== e4 && (t2[e4] = t2[e4].concat(i2[e4]));
          });
        }), t2;
      }, Hy = { GLOBAL: { ASIA: [ev.CHINA, ev.JAPAN, ev.INDIA, ev.KOREA, ev.HKMC], EUROPE: [], NORTH_AMERICA: [ev.US], SOUTH_AMERICA: [], OCEANIA: [], AFRICA: [] } }, Ky = Object.keys(Hy[ev.GLOBAL]), Yy = [ev.CHINA, ev.NORTH_AMERICA, ev.EUROPE, ev.ASIA, ev.JAPAN, ev.INDIA, ev.OCEANIA, ev.SOUTH_AMERICA, ev.AFRICA, ev.KOREA, ev.HKMC, ev.US], qy = function(e2, t2) {
        let i2 = [];
        if (bn(e2).call(e2, ev.GLOBAL)) {
          const s2 = [ev.GLOBAL, ev.OVERSEA], o2 = Object.keys(rv);
          if (t2 === ev.GLOBAL) throw new LI(Hg.INVALID_PARAMS, "GLOBAL is an invalid excludedArea value");
          if (t2 === ev.CHINA) i2 = [ev.OVERSEA];
          else if (r2 = t2, bn(Ky).call(Ky, r2)) {
            const e3 = (n2 = t2, Hy[ev.GLOBAL][n2] || []), r3 = [...s2, t2, ...e3];
            i2 = o2.filter((e4) => !bn(r3).call(r3, e4));
          } else if (function(e3) {
            let t3 = false;
            return Ky.forEach((i3) => {
              var n3;
              bn(n3 = Hy[ev.GLOBAL][i3]).call(n3, e3) && (t3 = true);
            }), t3;
          }(t2)) {
            const e3 = function(e4) {
              let t3;
              return Ky.forEach((i3) => {
                var n4;
                bn(n4 = Hy[ev.GLOBAL][i3]).call(n4, e4) && (t3 = i3);
              }), t3;
            }(t2), n3 = [...s2, e3, t2];
            i2 = o2.filter((e4) => !bn(n3).call(n3, e4));
          } else i2 = e2;
          i2 = function(e3) {
            const t3 = [];
            return Yy.forEach((i3) => {
              bn(e3).call(e3, i3) && t3.push(i3);
            }), t3.concat(e3.filter((e4) => !bn(Yy).call(Yy, e4)));
          }(i2);
        } else i2 = e2;
        var n2, r2;
        return i2;
      };
      function zy(e2) {
        var t2, i2;
        if (!e2 && bn(t2 = RC("AREAS")).call(t2, ev.EXTENSIONS)) return jC.debug("update area from ap : reset"), void Jy(tI, true);
        if (!bn(i2 = RC("AREAS")).call(i2, ev.GLOBAL) || !e2) return;
        let n2 = rv.EXTENSIONS;
        n2 && (n2 = { CODE: Gy(ev.EXTENSIONS), WEBCS_DOMAIN: ["ap-web-1-".concat(e2, ".agora.io")], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-".concat(e2, ".ap.sd-rtn.com")], PROXY_CS: ["proxy-ap-web-".concat(e2, ".agora.io")], CDS_AP: ["cds-ap-web-1-".concat(e2, ".agora.io"), "cds-ap-web-2-".concat(e2, ".ap.sd-rtn.com")], ACCOUNT_REGISTER: ["sua-ap-web-1-".concat(e2, ".agora.io"), "sua-ap-web-2-".concat(e2, ".ap.sd-rtn.com")], UAP_AP: ["uap-ap-web-1-".concat(e2, ".agora.io"), "uap-ap-web-2-".concat(e2, ".ap.sd-rtn.com")], EVENT_REPORT_DOMAIN: ["statscollector-1-".concat(e2, ".agora.io")], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-".concat(e2, ".agora.io")], LOG_UPLOAD_SERVER: ["logservice-".concat(e2, ".agora.io")], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy-".concat(e2, ".agora.io")] }, jC.debug("update area from ap success: ".concat(e2, ",config is "), n2), SC("AREAS", [ev.EXTENSIONS], true), Object.keys(n2).map((e3) => {
          if ("LOG_UPLOAD_SERVER" === e3 || "EVENT_REPORT_DOMAIN" === e3 || "EVENT_REPORT_BACKUP_DOMAIN" === e3 || "PROXY_SERVER_TYPE3" === e3) {
            SC(e3, n2[e3][0]);
          } else SC(e3, n2[e3]);
        }));
      }
      function Jy(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        const i2 = eI.reportApiInvoke(null, { name: hT.SET_AREA, options: e2, tag: pT.TRACER });
        try {
          let n2 = [];
          if ("string" == typeof e2 && (n2 = [e2]), Array.isArray(e2) && (e2.forEach((e3) => {
            if (!bn(iv).call(iv, e3)) throw new LI(Hg.INVALID_PARAMS, "invalid area code");
          }), n2 = e2), "[object Object]" === Object.prototype.toString.call(e2)) {
            const { areaCode: t3, excludedArea: i3 } = e2;
            if (!t3) throw new LI(Hg.INVALID_PARAMS, "area code is needed");
            let r3 = t3;
            "string" == typeof t3 && (r3 = [t3]), n2 = i3 ? qy(r3, i3) : r3;
          }
          if (!t2) {
            if (CC.AREAS) {
              const e3 = new LI(Hg.PROHIBITED_OPERATION, "setArea is prohibited because of config-distribute");
              return i2.onError(e3), void jC.warning("setArea is prohibited because of config-distribute");
            }
            if (bn(n2).call(n2, ev.GLOBAL) && RC("AREAS") === ev.EXTENSIONS) {
              const e3 = new LI(Hg.PROHIBITED_OPERATION, "setArea is prohibited because of ap extensions");
              return i2.onError(e3), void jC.warning("setArea is prohibited because of ap extensions");
            }
          }
          SC("AREAS", n2, t2);
          const r2 = Wy(n2);
          Object.keys(r2).map((e3) => {
            if ("LOG_UPLOAD_SERVER" === e3 || "EVENT_REPORT_DOMAIN" === e3 || "EVENT_REPORT_BACKUP_DOMAIN" === e3 || "PROXY_SERVER_TYPE3" === e3) {
              SC(e3, r2[e3][0]);
            } else SC(e3, r2[e3]);
          }), jC.debug("set area success:", n2.join(","));
        } catch (e3) {
          throw i2.onError(e3), e3;
        }
        i2.onSuccess();
      }
      function Xy(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function Qy(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Xy(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : Xy(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      let Zy = 1;
      function $y(e2, t2, i2, n2, r2) {
        Zy += 1;
        const s2 = { sid: i2.sid, command: "convergeAllocateEdge", uid: "666", appId: i2.appId, ts: Math.floor(Date.now() / 1e3), seq: Zy, requestId: Zy, version: EC, cname: i2.cname }, o2 = { service_name: t2, json_body: JSON.stringify(s2) };
        let a2, c2, d2 = e2[0];
        return fS(async () => {
          a2 = Date.now();
          const e3 = await By(d2, { data: o2, cancelToken: n2, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" } });
          if (c2 = Date.now() - a2, 0 !== e3.code) {
            const t3 = new LI(Hg.UNEXPECTED_RESPONSE, "live streaming ap error, code" + e3.code, { retry: true, responseTime: c2 });
            throw jC.error(t3.toString()), t3;
          }
          const i3 = JSON.parse(e3.json_body);
          if (200 !== i3.code) {
            const e4 = new LI(Hg.UNEXPECTED_RESPONSE, "live streaming app center error, code: ".concat(i3.code, ", reason: ").concat(i3.reason), { code: i3.code, responseTime: c2 });
            throw jC.error(e4.toString()), e4;
          }
          if (!i3.servers || 0 === i3.servers.length) {
            const e4 = new LI(Hg.UNEXPECTED_RESPONSE, "live streaming app center empty server", { code: i3.code, responseTime: c2 });
            throw jC.error(e4.toString()), e4;
          }
          const r3 = function(e4, t3) {
            return { addressList: e4.servers.map((e5) => "wss://".concat(e5.address.replace(/\./g, "-"), ".").concat(RC("WORKER_DOMAIN"), ":").concat(e5.wss, "?serviceName=").concat(encodeURIComponent(t3))), workerToken: e4.workerToken, vid: e4.vid };
          }(i3, t2);
          return RC("LIVE_STREAMING_ADDRESS") && (r3.addressList = RC("LIVE_STREAMING_ADDRESS") instanceof Array ? RC("LIVE_STREAMING_ADDRESS") : [RC("LIVE_STREAMING_ADDRESS")]), Qy(Qy({}, r3), {}, { responseTime: c2 });
        }, (n3, r3) => (eI.apworkerEvent(i2.sid, { success: true, sc: 200, serviceName: t2, responseDetail: JSON.stringify(n3.addressList), firstSuccess: 0 === r3, responseTime: c2, serverIp: e2[r3 % e2.length] }), false), (n3, r3) => (eI.apworkerEvent(i2.sid, { success: false, sc: n3.data && n3.data.code || 200, serviceName: t2, responseTime: c2, serverIp: e2[r3 % e2.length] }), !!(n3.code !== Hg.OPERATION_ABORTED && n3.code !== Hg.UNEXPECTED_RESPONSE || n3.data && n3.data.retry) && (d2 = e2[(r3 + 1) % e2.length], true)), r2);
      }
      let eA = 1;
      function tA(e2, t2, i2, n2) {
        let { url: r2, areaCode: s2 } = e2;
        const o2 = Date.now();
        let a2;
        const [c2, d2] = oA(t2, s2, [dy.CHOOSE_SERVER]);
        let l2 = wT.networkState;
        return fS(async () => {
          l2 && wT.networkState === gT.OFFLINE && wT.onlineWaiter && await cg.race([wT.onlineWaiter, iS(n2 && n2.maxRetryTimeout || ES.maxRetryTimeout)]), l2 = wT.networkState;
          const { data: e3, headers: s3 } = await By(r2, { data: c2, cancelToken: i2, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
          a2 = "1" === s3.http3 ? 1 : -1, eI.reportResourceTiming(r2, t2.sid), nA(e3, r2, t2, o2, [dy.CHOOSE_SERVER], a2);
          const d3 = Iy(e3, dy.CHOOSE_SERVER);
          return rA(d3), Ty(d3, r2);
        }, (e3) => (e3 && eI.joinChooseServer(t2.sid, { lts: o2, succ: true, csAddr: r2, opid: d2, serverList: e3.gatewayAddrs.map((e4) => e4.address), ec: null, cid: e3.cid.toString(), uid: e3.uid.toString(), csIp: e3.csIp, unilbsServerIds: [dy.CHOOSE_SERVER].toString(), isHttp3: a2 }), false), (e3) => e3.code !== Hg.OPERATION_ABORTED && (e3.code === Hg.CAN_NOT_GET_GATEWAY_SERVER ? e3.data.retry : (eI.joinChooseServer(t2.sid, { lts: o2, succ: false, csAddr: r2, serverList: null, opid: d2, ec: e3.code, csIp: e3.data && e3.data.csIp, unilbsServerIds: [dy.CHOOSE_SERVER].toString(), extend: JSON.stringify({ networkState: l2 }), isHttp3: a2 }), jC.warning("[".concat(t2.clientId, "] Choose server network error, retry"), e3), true)), n2);
      }
      function iA(e2, t2, i2, n2) {
        let r2, { url: s2, areaCode: o2, serviceIds: a2 } = e2;
        const c2 = Date.now(), [d2, l2] = oA(t2, o2, a2);
        let u2;
        return fS(async () => {
          u2 && wT.networkState === gT.OFFLINE && wT.onlineWaiter && await cg.race([wT.onlineWaiter, iS(n2 && n2.maxRetryTimeout || ES.maxRetryTimeout)]), u2 = wT.networkState;
          const { data: e3, headers: o3 } = await By(s2, { data: d2, cancelToken: i2, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
          r2 = "1" === o3.http3 ? 1 : -1, eI.reportResourceTiming(s2, t2.sid), nA(e3, s2, t2, c2, a2, r2);
          const l3 = Iy(e3, dy.CHOOSE_SERVER), h3 = Iy(e3, "proxy5" === t2.cloudProxyServer ? dy.CLOUD_PROXY_5 : "proxy3" === t2.cloudProxyServer || "proxy4" === t2.cloudProxyServer ? dy.CLOUD_PROXY : dy.CLOUD_PROXY_FALLBACK);
          return rA(l3), { gatewayInfo: Ty(l3, s2), proxyInfo: h3, url: s2 };
        }, (e3) => (e3.gatewayInfo && eI.joinChooseServer(t2.sid, { lts: c2, succ: true, csAddr: s2, serverList: e3.gatewayInfo.gatewayAddrs.map((e4) => e4.address), ec: null, opid: l2, cid: e3.gatewayInfo.cid.toString(), uid: e3.gatewayInfo.uid.toString(), csIp: e3.gatewayInfo.csIp, unilbsServerIds: a2.toString(), isHttp3: r2 }), e3.proxyInfo && eI.joinWebProxyAP(t2.sid, { lts: c2, sucess: 1, apServerAddr: s2, turnServerAddrList: e3.proxyInfo.addresses.map((e4) => e4.ip).join(","), errorCode: null, eventType: t2.cloudProxyServer, unilbsServerIds: a2.toString() }), false), (e3) => e3.code !== Hg.OPERATION_ABORTED && (e3.code === Hg.CAN_NOT_GET_GATEWAY_SERVER ? e3.data.retry : (eI.joinWebProxyAP(t2.sid, { lts: c2, sucess: 0, apServerAddr: s2, turnServerAddrList: null, errorCode: e3.code, eventType: t2.cloudProxyServer, unilbsServerIds: a2.toString(), extend: JSON.stringify({ networkState: u2 }) }), jC.warning("[".concat(t2.clientId, "] multi unilbs network error, retry"), e3), true)), n2);
      }
      const nA = (e2, t2, i2, n2, r2, s2) => {
        const o2 = [], a2 = (o3) => {
          4096 === o3.flag ? eI.joinChooseServer(i2.sid, { lts: n2, succ: false, csAddr: t2, opid: e2.opid, serverList: null, ec: o3.error.message, csIp: o3.error.data && o3.error.data.csIp, unilbsServerIds: r2.toString(), isHttp3: s2 }) : 1048576 !== o3.flag && 4194304 !== o3.flag && 4194310 !== o3.flag || eI.joinWebProxyAP(i2.sid, { lts: n2, sucess: 0, apServerAddr: t2, turnServerAddrList: null, errorCode: o3.error.code, eventType: i2.cloudProxyServer, unilbsServerIds: r2.toString() });
        };
        if (e2.response_body.forEach((t3) => {
          const i3 = t3.buffer.code;
          if (23 === t3.uri && 0 === i3 && !t3.buffer.edges_services) if (4194310 === t3.buffer.flag) jC.warning("no edge services in ap response of proxy fallback, will not set proxy in iceServers"), t3.buffer.edges_services = [];
          else {
            const i4 = { error: new LI(Hg.CAN_NOT_GET_GATEWAY_SERVER, "no edge services in ap response", { retry: true, csIp: e2.detail[502] }), flag: t3.buffer.flag };
            o2.push(i4), a2(i4);
          }
          if (0 !== i3) {
            const n3 = Pv(i3), r3 = { error: new LI(Hg.CAN_NOT_GET_GATEWAY_SERVER, n3.desc, { desc: n3.desc, retry: n3.retry, csIp: e2.detail[502] }), flag: t3.buffer.flag };
            4194310 === t3.buffer.flag ? jC.warning(r3.error.toString()) : o2.push(r3), a2(r3);
          }
        }), o2.length) throw jC.warning("[".concat(i2.clientId, "] multi unilbs ").concat(t2, " failed, ").concat(o2.map((e3) => "flag: ".concat(e3.flag, ", message: ").concat(e3.error.message, ", retry: ").concat(e3.error.data.retry)).join(" | "))), new LI(Hg.CAN_NOT_GET_GATEWAY_SERVER, o2.map((e3) => "flag: ".concat(e3.flag, ", message: ").concat(e3.error.message)).join(" | "), { retry: !!o2.find((e3) => e3.error.data.retry), csIp: e2.detail[502], desc: [...new Set(o2.map((e3) => {
          var t3;
          return null == e3 || null === (t3 = e3.error) || void 0 === t3 || null === (t3 = t3.data) || void 0 === t3 ? void 0 : t3.desc;
        }).filter((e3) => !!e3))] });
      }, rA = (e2) => {
        var t2, i2, n2, r2;
        if (e2.addresses && 0 === e2.addresses.length && 0 === e2.code) throw new LI(Hg.CAN_NOT_GET_GATEWAY_SERVER, "void gateway address", { retry: true, csIp: e2.detail && e2.detail[502] });
        RC("AP_AREA") && (null !== (n2 = e2.detail) && void 0 !== n2 && n2[23] && "string" == typeof (null === (r2 = e2.detail) || void 0 === r2 ? void 0 : r2[23]) ? zy(e2.detail[23].toLowerCase()) : zy());
        if (null !== (t2 = e2.detail) && void 0 !== t2 && t2[19] && "string" == typeof (null === (i2 = e2.detail) || void 0 === i2 ? void 0 : i2[19])) {
          const t3 = e2.detail[19], i3 = null == t3 ? void 0 : t3.split(";");
          for (let t4 = 0; t4 < i3.length; t4++) {
            var s2;
            const n3 = Ey(s2 = i3[t4]).call(s2);
            e2.addresses[t4] && i3 && (e2.addresses[t4].fingerprint = n3);
          }
        }
        if (RC("GATEWAY_ADDRESS") && RC("GATEWAY_ADDRESS").length > 0) {
          jC.debug("assign gateway address to", RC("GATEWAY_ADDRESS"));
          const t3 = RC("GATEWAY_ADDRESS").map((t4) => {
            var i3, n3;
            const r3 = null !== (i3 = null === (n3 = e2.addresses.find((e3) => e3.ip === t4.ip && e3.port === t4.port)) || void 0 === n3 ? void 0 : n3.fingerprint) && void 0 !== i3 ? i3 : "";
            return { ip: t4.ip, port: t4.port, ticket: e2.addresses[0] && e2.addresses[0].ticket, fingerprint: r3 };
          });
          e2.addresses = t3;
        }
      }, sA = (e2, t2) => {
        if (e2.response_body && e2.response_body.length) {
          const t3 = e2.response_body[0];
          if (0 !== t3.buffer.code) {
            const e3 = Pv(t3.buffer.code);
            throw new LI(Hg.UPDATE_TICKET_FAILED, "[".concat(t3.buffer.code, "]: ").concat(e3.desc), { retry: e3.retry });
          }
          return t3.buffer.ticket;
        }
        throw jC.debug("update ticket request received ap response without response body:", t2), new LI(Hg.UPDATE_TICKET_FAILED, "cannot find response body from ap response", { retry: false });
      }, oA = (e2, t2, i2) => {
        const n2 = Math.floor(Math.random() * 10 ** 12), r2 = { appid: e2.appId, client_ts: Date.now(), opid: n2, sid: e2.sid, request_bodies: [{ uri: 22, buffer: { cname: e2.cname, detail: Qy({ 6: e2.stringUid, 11: t2, 12: RC("USE_NEW_TOKEN") ? "1" : void 0, 22: t2 }, e2.apRTM ? { 26: "RTM2" } : {}), key: e2.token, service_ids: i2, uid: e2.uid || 0 } }] };
        r2.request_bodies.forEach((t3) => {
          e2.multiIP && e2.multiIP.gateway_ip && (t3.buffer.detail[5] = JSON.stringify({ vocs_ip: [e2.multiIP.uni_lbs_ip], vos_ip: [e2.multiIP.gateway_ip] }));
        });
        const s2 = new FormData();
        return s2.append("request", JSON.stringify(r2)), [s2, n2];
      }, aA = (e2, t2) => {
        const i2 = Math.floor(Math.random() * 10 ** 12), n2 = { appid: e2.appId, client_ts: Date.now(), opid: i2, sid: e2.sid, request_bodies: [{ uri: 28, buffer: { cname: e2.cname, detail: { 1: "", 6: e2.stringUid, 12: "1" }, token: e2.token, service_ids: t2, uid: e2.uid || 0, edges_services: e2.apResponse.addresses.map((e3) => ({ ip: e3.ip, port: e3.port })) } }] }, r2 = new FormData();
        return r2.append("request", JSON.stringify(n2)), [r2, i2];
      };
      let cA = 0;
      function dA(e2) {
        return cg.all(e2.map((e3) => e3.then((e4) => {
          throw e4;
        }, (e4) => e4))).then((e3) => {
          throw e3;
        }, (e3) => e3);
      }
      const lA = async (e2) => {
        let { fragementLength: t2, referenceList: i2, asyncMapHandler: n2, allFailedhandler: r2, promisesCollector: s2 } = e2, o2 = 0;
        const a2 = t2;
        let c2, d2 = 0;
        const l2 = async () => {
          const e3 = (() => {
            const e4 = o2 * a2, t3 = e4 + a2;
            return i2.slice(e4, t3).map(n2);
          })();
          s2 && s2.push(...e3);
          try {
            c2 = await dA(e3);
          } catch (e4) {
            if (d2 += a2, o2++, !(d2 >= i2.length)) return void await l2();
            r2(e4);
          }
          e3.forEach((e4) => e4.cancel());
        };
        return await l2(), c2;
      };
      async function uA(e2, t2, i2, n2) {
        const r2 = async function(e3, t3, i3, n3) {
          let r3 = null;
          const s2 = [], o2 = async () => {
            const r4 = RC("WEBCS_DOMAIN").slice(0, RC("AJAX_REQUEST_CONCURRENT")).map((t4) => ({ url: e3.proxyServer ? "https://".concat(e3.proxyServer, "/ap/?url=").concat(t4 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t4, "/api/v2/transpond/webrtc?v=2"), areaCode: jy() })), o3 = n3.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r4.map((e4) => e4.url) }), a3 = await lA({ fragementLength: RC("FRAGEMENT_LENGTH"), referenceList: r4, asyncMapHandler: (n4) => (jC.debug("[".concat(e3.clientId, "] Connect to choose_server:"), n4.url), tA(n4, e3, t3, i3)), allFailedhandler: (e4) => {
              throw n3.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e4 }, o3), e4[0];
            }, promisesCollector: s2 });
            return n3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, o3), a3;
          }, a2 = async () => {
            if (await iS(1e3), null !== r3) return r3;
            const o3 = RC("WEBCS_DOMAIN_BACKUP_LIST").map((t4) => ({ url: e3.proxyServer ? "https://".concat(e3.proxyServer, "/ap/?url=").concat(t4 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t4, "/api/v2/transpond/webrtc?v=2"), areaCode: jy() })), a3 = n3.recordJoinChannelService({ endTs: void 0, startTs: Date.now(), status: "pending", service: "chooseServer", urls: o3.map((e4) => e4.url) }), c2 = await lA({ fragementLength: RC("FRAGEMENT_LENGTH"), referenceList: o3, asyncMapHandler: (n4) => (jC.debug("[".concat(e3.clientId, "] Connect to backup choose_server:"), n4.url), tA(n4, e3, t3, i3)), allFailedhandler: (e4) => {
              throw n3.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e4 }, a3), e4[0];
            }, promisesCollector: s2 });
            return n3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a3), c2;
          };
          try {
            return r3 = await dA([o2(), a2()]), s2.length && s2.forEach((e4) => e4.cancel && "function" == typeof e4.cancel && e4.cancel()), r3;
          } catch (e4) {
            throw e4[0];
          }
        }(e2, t2, i2, n2);
        return { gatewayInfo: await r2 };
      }
      async function hA(e2, t2, i2, n2, r2) {
        const s2 = e2.cloudProxyServer;
        if ("disabled" === s2) {
          if (!n2) return;
          if (e2.useLocalAccessPoint) return await uA(e2, t2, i2, r2);
          if (RC("JOIN_WITH_FALLBACK_MEDIA_PROXY")) {
            const { gatewayInfo: n3, proxyInfo: s3 } = await EA(e2, t2, i2, r2);
            if (e2.turnServer && "auto" !== e2.turnServer.mode) return { gatewayInfo: n3 };
            const a3 = s3.map((e3) => ({ turnServerURL: e3.address, tcpport: e3.tcpport || iI.tcpport, udpport: e3.udpport || iI.udpport, username: e3.username || iI.username, password: e3.password || iI.password, forceturn: false, security: true }));
            if (r2.useP2P) {
              var o2;
              const t3 = null !== (o2 = e2.uid) && void 0 !== o2 ? o2 : n3.uid, i3 = "glb:".concat(t3.toString()), r3 = await cT(i3), c3 = s3.map((e3) => ({ turnServerURL: e3.address, tcpport: e3.tcpport || iI.tcpport, udpport: e3.udpport || iI.udpport, username: i3, password: r3, forceturn: false, security: true }));
              a3.push(...c3);
            }
            return e2.turnServer = { mode: "manual", servers: a3 }, { gatewayInfo: n3 };
          }
          return await uA(e2, t2, i2, r2);
        }
        const { proxyInfo: a2, gatewayInfo: c2 } = await EA(e2, t2, i2, r2), d2 = { gatewayInfo: c2 }, l2 = a2.map((e3) => ({ turnServerURL: e3.address, tcpport: "proxy3" === s2 ? void 0 : e3.tcpport ? e3.tcpport : iI.tcpport, udpport: "proxy4" === s2 ? void 0 : e3.udpport ? e3.udpport : iI.udpport, username: e3.username || iI.username, password: e3.password || iI.password, forceturn: "proxy4" !== s2, security: "proxy5" === s2 }));
        if (r2.useP2P) {
          var u2;
          const t3 = null !== (u2 = e2.uid) && void 0 !== u2 ? u2 : c2.uid, i3 = "glb:".concat(t3.toString()), n3 = await cT(i3), r3 = a2.map((e3) => ({ turnServerURL: e3.address, tcpport: "proxy3" === s2 ? void 0 : e3.tcpport || iI.tcpport, udpport: "proxy4" === s2 ? void 0 : e3.udpport || iI.udpport, username: i3, password: n3, forceturn: "proxy4" !== s2, security: "proxy5" === s2 }));
          l2.push(...r3);
        }
        return e2.turnServer = { mode: "manual", servers: l2 }, jC.debug("[".concat(e2.clientId, "] set proxy server: ").concat(e2.proxyServer, ", mode: ").concat(s2)), d2;
      }
      async function pA(e2, t2, i2, n2, r2) {
        const s2 = RC("ACCOUNT_REGISTER").slice(0, RC("AJAX_REQUEST_CONCURRENT"));
        let o2 = [];
        o2 = t2.proxyServer ? s2.map((e3) => "https://".concat(t2.proxyServer, "/ap/?url=").concat(e3 + "/api/v1")) : s2.map((e3) => "https://".concat(e3, "/api/v1"));
        const a2 = null == r2 ? void 0 : r2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "stringUID", urls: o2 });
        try {
          const s3 = await async function(e3, t3, i3, n3, r3) {
            const s4 = Date.now(), o3 = { sid: i3.sid, opid: 10, appid: i3.appId, string_uid: t3 };
            let a3 = e3[0];
            const c2 = await fS(() => By(a3 + "".concat(-1 === a3.indexOf("?") ? "?" : "&", "action=stringuid"), { data: o3, cancelToken: n3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 72 } }), (i4, n4) => {
              if (0 === i4.code) {
                if (i4.uid <= 0 || i4.uid >= Math.pow(2, 32)) throw jC.error("Invalid Uint Uid ".concat(t3, " => ").concat(i4.uid), i4), eI.reqUserAccount(o3.sid, { lts: s4, success: false, serverAddr: a3, stringUid: o3.string_uid, uid: i4.uid, errorCode: Hg.INVALID_UINT_UID_FROM_STRING_UID, extend: o3 }), new LI(Hg.INVALID_UINT_UID_FROM_STRING_UID);
                return eI.reqUserAccount(o3.sid, { lts: s4, success: true, serverAddr: a3, stringUid: o3.string_uid, uid: i4.uid, errorCode: null, extend: o3 }), false;
              }
              const r4 = Pv(i4.code);
              return r4.retry && (a3 = e3[(n4 + 1) % e3.length]), eI.reqUserAccount(o3.sid, { lts: s4, success: false, serverAddr: a3, stringUid: o3.string_uid, uid: i4.uid, errorCode: r4.desc, extend: o3 }), r4.retry;
            }, (t4, i4) => t4.code !== Hg.OPERATION_ABORTED && (eI.reqUserAccount(o3.sid, { lts: s4, success: false, serverAddr: a3, stringUid: o3.string_uid, uid: null, errorCode: t4.code, extend: o3 }), a3 = e3[(i4 + 1) % e3.length], true), r3);
            if (0 !== c2.code) {
              const e4 = Pv(c2.code);
              throw new LI(Hg.UNEXPECTED_RESPONSE, e4.desc);
            }
            return c2;
          }(o2, e2, t2, i2, n2);
          return null == r2 || r2.recordJoinChannelService({ status: "success", endTs: Date.now() }, a2), s3.uid;
        } catch (e3) {
          throw null == r2 || r2.recordJoinChannelService({ status: "error", endTs: Date.now(), errors: [e3] }, a2), e3;
        }
      }
      async function _A(e2, t2, i2) {
        const n2 = RC("CDS_AP").slice(0, RC("AJAX_REQUEST_CONCURRENT")).map((t3) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t3 + "/api/v1") : "https://".concat(t3, "/api/v1?action=config")), r2 = n2.map((n3) => function(e3, t3, i3, n4) {
          const r3 = Sg(), s3 = { flag: 64, cipher_method: 0, features: { device: r3.name, system: r3.os, system_general: navigator.userAgent, vendor: t3.appId, version: EC, cname: t3.cname, sid: t3.sid, session_id: t3.sid, detail: "", proxyServer: t3.proxyServer } };
          return fS(() => By(e3, { data: s3, timeout: 1e3, cancelToken: i3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 54 } }), void 0, (e4) => e4.code !== Hg.OPERATION_ABORTED, n4);
        }(n3, e2, t2, i2));
        let s2 = null, o2 = null, a2 = {};
        try {
          s2 = await dA(r2);
        } catch (e3) {
          if (e3.code === Hg.OPERATION_ABORTED) throw e3;
          o2 = e3;
        }
        r2.forEach((e3) => e3.cancel());
        if (eI.reportApiInvoke(e2.sid, { name: hT.REQUEST_CONFIG_DISTRIBUTE, options: { error: o2, res: s2 } }).onSuccess(), s2 && s2.test_tags) try {
          a2 = function(e3) {
            if (!e3.test_tags) return {};
            const t3 = e3.test_tags, i3 = Object.keys(t3), n3 = {};
            return i3.forEach((e4) => {
              var i4;
              const r3 = Ey(i4 = e4.slice(4)).call(i4), s3 = JSON.parse(t3[e4])[1];
              n3[r3] = s3;
            }), n3;
          }(s2);
        } catch (e3) {
        }
        return a2;
      }
      async function EA(e2, t2, i2, n2) {
        const r2 = RC("PROXY_SERVER_TYPE3"), s2 = (e3, t3, i3) => {
          let n3 = i3 || r2;
          return Array.isArray(n3) && (n3 = t3 % 2 == 0 ? r2[1] : r2[0]), "https://".concat(n3, "/ap/?url=").concat(e3);
        };
        let o2 = null;
        const a2 = [], c2 = async () => {
          const r3 = RC("WEBCS_DOMAIN").slice(0, RC("AJAX_REQUEST_CONCURRENT")).map((t3, i3) => {
            let n3;
            return n3 = "disabled" === e2.cloudProxyServer && e2.proxyServer ? s2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i3, e2.proxyServer) : "disabled" === e2.cloudProxyServer || "fallback" === e2.cloudProxyServer ? "https://".concat(t3, "/api/v2/transpond/webrtc?v=2") : s2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i3), { url: n3, areaCode: jy(), serviceIds: [dy.CHOOSE_SERVER, "proxy5" === e2.cloudProxyServer ? dy.CLOUD_PROXY_5 : "proxy3" === e2.cloudProxyServer || "proxy4" === e2.cloudProxyServer ? dy.CLOUD_PROXY : dy.CLOUD_PROXY_FALLBACK] };
          }), o3 = n2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r3.map((e3) => e3.url) }), c3 = await lA({ fragementLength: RC("FRAGEMENT_LENGTH"), referenceList: r3, asyncMapHandler: (n3) => (jC.debug("[".concat(e2.clientId, "] Connect to choose_server:"), n3.url), iA(n3, e2, t2, i2)), allFailedhandler: (e3) => {
            throw n2.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e3 }, o3), e3[0];
          }, promisesCollector: a2 });
          return n2.recordJoinChannelService({ endTs: Date.now(), status: "success" }, o3), c3;
        }, d2 = async () => {
          if (await iS(1e3), null !== o2) return o2;
          const r3 = RC("WEBCS_DOMAIN_BACKUP_LIST").map((t3, i3) => {
            let n3;
            return n3 = "disabled" === e2.cloudProxyServer && e2.proxyServer ? s2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i3, e2.proxyServer) : "disabled" === e2.cloudProxyServer || "fallback" === e2.cloudProxyServer ? "https://".concat(t3, "/api/v2/transpond/webrtc?v=2") : s2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i3), { url: n3, areaCode: jy(), serviceIds: [dy.CHOOSE_SERVER, "proxy5" === e2.cloudProxyServer ? dy.CLOUD_PROXY_5 : "proxy3" === e2.cloudProxyServer || "proxy4" === e2.cloudProxyServer ? dy.CLOUD_PROXY : dy.CLOUD_PROXY_FALLBACK] };
          }), c3 = n2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r3.map((e3) => e3.url) }), d3 = await lA({ fragementLength: RC("FRAGEMENT_LENGTH"), referenceList: r3, asyncMapHandler: (n3) => (jC.debug("[".concat(e2.clientId, "] Connect to backup choose_server:"), n3.url), iA(n3, e2, t2, i2)), allFailedhandler: (e3) => {
            throw n2.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e3 }, c3), e3[0];
          }, promisesCollector: a2 });
          return n2.recordJoinChannelService({ endTs: Date.now(), status: "success" }, c3), d3;
        };
        let l2, u2, h3;
        try {
          ({ gatewayInfo: l2, proxyInfo: u2, url: h3 } = await dA([c2(), d2()]));
        } catch (e3) {
          throw e3[0];
        }
        if (a2.length && a2.forEach((e3) => e3.cancel && "function" == typeof e3.cancel && e3.cancel()), !l2 || !u2) throw new LI(Hg.UNEXPECTED_ERROR, "missing gateway or proxy response").print();
        if (e2.apUrl = h3, "disabled" !== e2.cloudProxyServer && Array.isArray(r2) && h3) {
          const t3 = /^https?:\/\/(.+?)(\/.*)?$/.exec(h3)[1];
          bn(r2).call(r2, t3) && (e2.proxyServer = t3, jC.setProxyServer(t3), eI.setProxyServer(t3));
        }
        return o2 = { gatewayInfo: l2, proxyInfo: await vy(u2, l2.uid) }, o2;
      }
      async function mA(e2, t2, i2, n2) {
        const r2 = RC("UAP_AP").slice(0, RC("AJAX_REQUEST_CONCURRENT")).map((e3) => t2.proxyServer ? "https://".concat(t2.proxyServer, "/ap/?url=").concat(e3 + "/api/v1?action=uap") : "https://".concat(e3, "/api/v1?action=uap"));
        return await $y(r2, e2, t2, i2, n2);
      }
      async function fA(e2, t2, i2) {
        const n2 = RC("UAP_AP").slice(0, RC("AJAX_REQUEST_CONCURRENT")).map((t3) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t3 + "/api/v1?action=uap") : "https://".concat(t3, "/api/v1?action=uap")), r2 = n2.map((n3) => function(e3, t3, i3, n4) {
          const r3 = { command: "convergeAllocateEdge", sid: t3.sid, appId: t3.appId, token: t3.token, ts: Date.now(), version: EC, cname: t3.cname, uid: t3.uid.toString(), requestId: eA, seq: eA };
          eA += 1;
          const s2 = { service_name: "tele_channel", json_body: JSON.stringify(r3) };
          return fS(async () => {
            const t4 = await By(e3, { data: s2, cancelToken: i3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 61 } });
            if (0 !== t4.code) {
              const e4 = new LI(Hg.UNEXPECTED_RESPONSE, "cross channel ap error, code" + t4.code, { retry: true });
              throw jC.error(e4.toString()), e4;
            }
            const n5 = JSON.parse(t4.json_body);
            if (200 !== n5.code) {
              const e4 = new LI(Hg.UNEXPECTED_RESPONSE, "cross channel app center error, code: ".concat(n5.code, ", reason: ").concat(n5.reason));
              throw jC.error(e4.toString()), e4;
            }
            if (!n5.servers || 0 === n5.servers.length) {
              const e4 = new LI(Hg.UNEXPECTED_RESPONSE, "cross channel app center empty server");
              throw jC.error(e4.toString()), e4;
            }
            return { vid: n5.vid, workerToken: n5.workerToken, addressList: (RC("CHANNEL_MEDIA_RELAY_SERVERS") || n5.servers).map((e4) => "wss://".concat(e4.address.replace(/\./g, "-"), ".").concat(RC("WORKER_DOMAIN"), ":").concat(e4.wss)) };
          }, void 0, (e4) => !!(e4.code !== Hg.OPERATION_ABORTED && e4.code !== Hg.UNEXPECTED_RESPONSE || e4.data && e4.data.retry), n4);
        }(n3, e2, t2, i2));
        try {
          const e3 = await dA(r2);
          return r2.forEach((e4) => e4.cancel()), e3;
        } catch (e3) {
          throw e3[0];
        }
      }
      async function gA(e2, t2, i2) {
        let n2 = null;
        const r2 = [], s2 = async (s3) => {
          const o2 = RC(s3 ? "WEBCS_DOMAIN_BACKUP_LIST" : "WEBCS_DOMAIN").map((t3) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t3 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t3, "/api/v2/transpond/webrtc?v=2"));
          return s3 && (await iS(1e3), null !== n2) ? n2 : await lA({ fragementLength: RC("FRAGEMENT_LENGTH"), referenceList: o2, asyncMapHandler: (n3) => (jC.debug("[".concat(e2.clientId, "] update ticket, Connect to ").concat(s3 ? "backup" : "", " choose_server:"), n3), function(e3, t3, i3, n4) {
            const [r3] = aA(t3, [dy.CHOOSE_SERVER]);
            let s4 = wT.networkState;
            return fS(async () => {
              s4 && wT.networkState === gT.OFFLINE && wT.onlineWaiter && await cg.race([wT.onlineWaiter, iS(n4 && n4.maxRetryTimeout || ES.maxRetryTimeout)]), s4 = wT.networkState;
              const t4 = await By(e3, { data: r3, cancelToken: i3, headers: { "Content-Type": "multipart/form-data;" } }, true);
              return sA(t4, e3);
            }, () => false, (e4) => e4.code !== Hg.OPERATION_ABORTED && (e4.code === Hg.UPDATE_TICKET_FAILED ? e4.data.retry : (jC.warning("[".concat(t3.clientId, "] update ticket network error, retry"), e4), true)), n4);
          }(n3, e2, t2, i2)), allFailedhandler: (e3) => {
            throw e3[0];
          }, promisesCollector: r2 });
        };
        try {
          return n2 = await dA([s2(false), s2(true)]), r2.length && r2.forEach((e3) => e3.cancel && "function" == typeof e3.cancel && e3.cancel()), n2;
        } catch (e3) {
          throw e3[0];
        }
      }
      function TA(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function SA(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? TA(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : TA(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class RA extends dT {
        get isSuccess() {
          return !!this.configs;
        }
        constructor() {
          super(), sh(this, "configs", void 0), sh(this, "joinInfo", void 0), sh(this, "cancelToken", void 0), sh(this, "retryConfig", { timeout: 3e3, timeoutFactor: 1.5, maxRetryCount: 1, maxRetryTimeout: 1e4 }), sh(this, "interval", void 0), sh(this, "mutex", new pS("config-distribute")), sh(this, "mutableParamsRead", false);
        }
        startGetConfigDistribute(e2, t2) {
          this.joinInfo = e2, this.cancelToken = t2, this.interval && this.stopGetConfigDistribute(), RC("ENABLE_CONFIG_DISTRIBUTE") && (this.updateConfigDistribute(), this.interval = window.setInterval(() => {
            this.updateConfigDistribute();
          }, RC("CONFIG_DISTRIBUTE_INTERVAL")));
        }
        stopGetConfigDistribute() {
          this.interval && clearInterval(this.interval), this.interval = void 0, this.joinInfo = void 0, this.cancelToken = void 0;
        }
        async awaitConfigDistributeComplete() {
          if (!this.mutex.isLocked) return;
          (await this.mutex.lock())();
        }
        async updateConfigDistribute() {
          if (!this.mutableParamsRead) {
            this.mutableParamsRead = true;
            eI.reportApiInvoke(null, { options: void 0, name: hT.LOAD_CONFIG_FROM_LOCALSTORAGE, tag: pT.TRACER }).onSuccess(JSON.stringify(CC));
          }
          if (!this.joinInfo || !this.cancelToken || !this.retryConfig) return void jC.debug("[config-distribute] get config distribute interrupted have no joininfo");
          let e2;
          const t2 = await this.mutex.lock();
          try {
            e2 = await _A(this.joinInfo, this.cancelToken, this.retryConfig), jC.debug("[config-distribute] get config distribute", JSON.stringify(e2)), e2.limit_bitrate && this.handleBitrateLimit(e2.limit_bitrate), this.cacheGlobalParameterConfig(e2), this.configs = e2;
          } catch (e3) {
            const t3 = new LI(Hg.NETWORK_RESPONSE_ERROR, e3);
            jC.warning("[config-distribute] ".concat(t3.toString()));
          } finally {
            t2();
          }
        }
        getBitrateLimit() {
          return this.configs ? this.configs.limit_bitrate : void 0;
        }
        handleBitrateLimit(e2) {
          var t2;
          (t2 = e2) && t2.uplink && t2.id && void 0 !== t2.uplink.max_bitrate && void 0 !== t2.uplink.min_bitrate && (this.configs && this.configs.limit_bitrate ? this.configs && this.configs.limit_bitrate && this.configs.limit_bitrate.id !== e2.id && this.emit(sv.UPDATE_BITRATE_LIMIT, e2) : this.emit(sv.UPDATE_BITRATE_LIMIT, e2));
        }
        getLowStreamConfigDistribute() {
          return this.configs && this.configs.limit_bitrate && SA({}, this.configs.limit_bitrate.low_stream_uplink);
        }
        cacheGlobalParameterConfig(e2) {
          var t2;
          const i2 = ep(t2 = Object.keys(e2).filter((e3) => /^webrtc_ng_global_parameter/.test(e3))).call(t2);
          for (let t3 = 0; t3 < i2.length; t3++) for (let n3 = i2.length - 1; n3 > t3; n3--) {
            const t4 = i2[n3];
            if ("number" == typeof e2[t4].__priority) {
              const r2 = e2[t4].__priority, s2 = i2[n3 - 1];
              if ("number" == typeof e2[s2].__priority) {
                if (!(r2 > e2[s2].__priority)) continue;
                {
                  const e3 = t4;
                  i2[n3] = i2[n3 - 1], i2[n3 - 1] = e3;
                }
              } else {
                const e3 = t4;
                i2[n3] = i2[n3 - 1], i2[n3 - 1] = e3;
              }
            }
          }
          const n2 = {};
          i2.forEach((t3) => {
            const i3 = e2[t3], r2 = i3.__expires;
            Object.keys(i3).forEach((e3) => {
              "__priority" === e3 || "__expires" === e3 || Object.prototype.hasOwnProperty.call(n2, e3) || (n2[e3] = SA({ value: i3[e3] }, r2 && { expires: r2 }));
            });
          });
          try {
            !function(e4) {
              try {
                const t4 = Date.now();
                Object.keys(e4).forEach((i3) => {
                  switch (i3) {
                    case "ENABLE_EVENT_REPORT":
                    case "UPLOAD_LOG":
                      if (Object.prototype.hasOwnProperty.call(TC, i3)) {
                        const { value: n3, expires: r2 } = e4[i3];
                        if (r2 && r2 <= t4) return;
                        CC[i3] = n3, TC[i3] = n3, jC.debug("Update global parameters from config distribute", i3, n3);
                      }
                  }
                });
              } catch (t4) {
                jC.error("Error update config immediately: ".concat(e4), t4.message);
              }
            }(n2);
            const e3 = JSON.stringify(n2), t3 = window.btoa(e3);
            window.localStorage.setItem("websdk_ng_global_parameter", t3), jC.debug("Caching global parameters ".concat(e3));
          } catch (e3) {
            jC.error("Error caching global parameters:", e3.message);
          }
        }
      }
      const CA = { getDisplayMedia: false, getStreamFromExtension: false, supportUnifiedPlan: false, supportMinBitrate: false, supportSetRtpSenderParameters: false, supportDualStream: true, webAudioMediaStreamDest: false, supportReplaceTrack: false, supportWebGL: false, webAudioWithAEC: false, supportRequestFrame: false, supportShareAudio: false, supportDualStreamEncoding: false, supportDataChannel: false, supportPCSetConfiguration: false, supportWebRTCEncodedTransform: false, supportWebRTCInsertableStream: false };
      function IA() {
        return CA;
      }
      var vA;
      function yA(e2, t2, i2) {
        return { sampleRate: e2, stereo: t2, bitrate: i2 };
      }
      function AA(e2, t2, i2, n2, r2) {
        return { width: e2, height: t2, frameRate: i2, bitrateMin: n2, bitrateMax: r2 };
      }
      function bA(e2, t2, i2, n2, r2) {
        return { width: { max: e2 }, height: { max: t2 }, frameRate: i2, bitrateMin: n2, bitrateMax: r2 };
      }
      function wA(e2, t2) {
        return { numSpatialLayers: e2, numTemporalLayers: t2 };
      }
      !function(e2) {
        e2.IOS_15_16_INTERRUPTION_START = "ios15_16-interruption-start", e2.IOS_15_16_INTERRUPTION_END = "ios15_16-interruption-end", e2.IOS_INTERRUPTION_START = "ios-interruption-start", e2.IOS_INTERRUPTION_END = "ios-interruption-end", e2.STATE_CHANGE = "state-change";
      }(vA || (vA = {}));
      const OA = { "90p": AA(160, 90), "90p_1": AA(160, 90), "120p": AA(160, 120, 15, 30, 65), "120p_1": AA(160, 120, 15, 30, 65), "120p_3": AA(120, 120, 15, 30, 50), "120p_4": AA(212, 120), "180p": AA(320, 180, 15, 30, 140), "180p_1": AA(320, 180, 15, 30, 140), "180p_3": AA(180, 180, 15, 30, 100), "180p_4": AA(240, 180, 15, 30, 120), "240p": AA(320, 240, 15, 40, 200), "240p_1": AA(320, 240, 15, 40, 200), "240p_3": AA(240, 240, 15, 40, 140), "240p_4": AA(424, 240, 15, 40, 220), "360p": AA(640, 360, 15, 80, 400), "360p_1": AA(640, 360, 15, 80, 400), "360p_3": AA(360, 360, 15, 80, 260), "360p_4": AA(640, 360, 30, 80, 600), "360p_6": AA(360, 360, 30, 80, 400), "360p_7": AA(480, 360, 15, 80, 320), "360p_8": AA(480, 360, 30, 80, 490), "360p_9": AA(640, 360, 15, 80, 800), "360p_10": AA(640, 360, 24, 80, 800), "360p_11": AA(640, 360, 24, 80, 1e3), "480p": AA(640, 480, 15, 100, 500), "480p_1": AA(640, 480, 15, 100, 500), "480p_2": AA(640, 480, 30, 100, 1e3), "480p_3": AA(480, 480, 15, 100, 400), "480p_4": AA(640, 480, 30, 100, 750), "480p_6": AA(480, 480, 30, 100, 600), "480p_8": AA(848, 480, 15, 100, 610), "480p_9": AA(848, 480, 30, 100, 930), "480p_10": AA(640, 480, 10, 100, 400), "720p": AA(1280, 720, 15, 120, 1130), "720p_auto": AA(1280, 720, 30, 900, 3e3), "720p_1": AA(1280, 720, 15, 120, 1130), "720p_2": AA(1280, 720, 30, 120, 2e3), "720p_3": AA(1280, 720, 30, 120, 1710), "720p_5": AA(960, 720, 15, 120, 910), "720p_6": AA(960, 720, 30, 120, 1380), "1080p": AA(1920, 1080, 15, 120, 2080), "1080p_1": AA(1920, 1080, 15, 120, 2080), "1080p_2": AA(1920, 1080, 30, 120, 3e3), "1080p_3": AA(1920, 1080, 30, 120, 3150), "1080p_5": AA(1920, 1080, 60, 120, 4780), "1440p": AA(2560, 1440, 30, 120, 4850), "1440p_1": AA(2560, 1440, 30, 120, 4850), "1440p_2": AA(2560, 1440, 60, 120, 7350), "4k": AA(3840, 2160, 30, 120, 8910), "4k_1": AA(3840, 2160, 30, 120, 8910), "4k_3": AA(3840, 2160, 60, 120, 13500) }, NA = [{ scaleResolutionDownBy: 2, width: 1280, height: 720, frameRate: 30, bitrateMin: 300, bitrateMax: 900 }, { scaleResolutionDownBy: 1.333333, width: 1280, height: 720, frameRate: 30, bitrateMin: 600, bitrateMax: 2e3 }, { scaleResolutionDownBy: 1, width: 1280, height: 720, frameRate: 30, bitrateMin: 900, bitrateMax: 3e3 }], DA = { "480p": bA(640, 480, 5), "480p_1": bA(640, 480, 5), "480p_2": bA(640, 480, 30), "480p_3": bA(640, 480, 15), "720p": bA(1280, 720, 5), "720p_auto": AA(1280, 720, 30, 900, 3e3), "720p_1": bA(1280, 720, 5), "720p_2": bA(1280, 720, 30), "720p_3": bA(1280, 720, 15), "1080p": bA(1920, 1080, 5), "1080p_1": bA(1920, 1080, 5), "1080p_2": bA(1920, 1080, 30), "1080p_3": bA(1920, 1080, 15) }, PA = { "1SL1TL": wA(1, 1), "3SL3TL": wA(3, 3), "2SL3TL": wA(2, 3) };
      function LA(e2) {
        return e2 || (e2 = "480p_1"), "string" == typeof e2 ? Object.assign({}, OA[e2]) : e2;
      }
      function kA(e2) {
        return "string" == typeof e2 ? Object.assign({}, DA[e2]) : e2;
      }
      function MA(e2) {
        return "string" == typeof e2 ? Object.assign({}, PA[e2]) : e2;
      }
      const UA = { speech_low_quality: yA(16e3, false), speech_standard: yA(32e3, false, 18), music_standard: yA(48e3, false), standard_stereo: yA(48e3, true, 56), high_quality: yA(48e3, false, 128), high_quality_stereo: yA(48e3, true, 192) };
      function xA(e2) {
        return "string" == typeof e2 ? Object.assign({}, UA[e2]) : e2;
      }
      const VA = [];
      function FA(e2) {
        return qg(e2, "mediaSource", ["screen", "window", "application"]), true;
      }
      var BA, jA, GA, WA, HA, KA, YA, qA, zA, JA;
      !function(e2) {
        e2.NEED_RENEGOTIATE = "@need_renegotiate", e2.NEED_REPLACE_TRACK = "@need_replace_track", e2.NEED_REPLACE_MIXING_TRACK = "@need_replace_mixing_track", e2.NEED_CLOSE = "@need_close", e2.NEED_ENABLE_TRACK = "@need_enable_track", e2.NEED_DISABLE_TRACK = "@need_disable_track", e2.NEED_SESSION_ID = "@need_sid", e2.SET_OPTIMIZATION_MODE = "@set_optimization_mode", e2.GET_STATS = "@get_stats", e2.GET_RTC_STATS = "@get_rtc_stats", e2.GET_LOW_VIDEO_TRACK = "@get_low_video_track", e2.NEED_RESET_REMOTE_SDP = "@need_reset_remote_sdp", e2.NEED_UPDATE_VIDEO_ENCODER = "@need_update_video_encoder", e2.NEED_MUTE_TRACK = "@need_mute_track", e2.NEED_UNMUTE_TRACK = "@need_unmute_track";
      }(BA || (BA = {})), function(e2) {
        e2.SCREEN_TRACK = "screen_track", e2.CUSTOM_TRACK = "custome_track", e2.LOW_STREAM = "low_stream";
      }(jA || (jA = {})), function(e2) {
        e2[e2.HIGH_STREAM = 0] = "HIGH_STREAM", e2[e2.LOW_STREAM = 1] = "LOW_STREAM";
      }(GA || (GA = {})), function(e2) {
        e2[e2.HIGH_STREAM = 0] = "HIGH_STREAM", e2[e2.LOW_STREAM = 1] = "LOW_STREAM";
      }(WA || (WA = {})), function(e2) {
        e2[e2.DISABLE = 0] = "DISABLE", e2[e2.LOW_STREAM = 1] = "LOW_STREAM", e2[e2.AUDIO_ONLY = 2] = "AUDIO_ONLY";
      }(HA || (HA = {})), function(e2) {
        e2.TRANSCEIVER_UPDATED = "transceiver-updated", e2.SEI_TO_SEND = "sei-to-send", e2.SEI_RECEIVED = "sei-received";
      }(KA || (KA = {})), function(e2) {
        e2.SOURCE_STATE_CHANGE = "source-state-change", e2.TRACK_ENDED = "track-ended", e2.BEAUTY_EFFECT_OVERLOAD = "beauty-effect-overload", e2.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status", e2.CLOSED = "closed";
      }(YA || (YA = {})), function(e2) {
        e2.FIRST_FRAME_DECODED = "first-frame-decoded", e2.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status", e2.VIDEO_STATE_CHANGED = "video-state-changed";
      }(qA || (qA = {})), function(e2) {
        e2.AUDIO_SOURCE_STATE_CHANGE = "audio_source_state_change", e2.RECEIVE_TRACK_BUFFER = "receive_track_buffer", e2.ON_AUDIO_BUFFER = "on_audio_buffer", e2.UPDATE_SOURCE = "update_source";
      }(zA || (zA = {})), function(e2) {
        e2.UPDATE_TRACK_SOURCE = "update-track-source";
      }(JA || (JA = {}));
      const XA = { sendVolumeLevel: 0, sendBitrate: 0, sendBytes: 0, sendPackets: 0, sendPacketsLost: 0, sendJitterMs: 0, sendRttMs: 0, currentPacketLossRate: 0 }, QA = { sendBytes: 0, sendBitrate: 0, sendPackets: 0, sendPacketsLost: 0, sendJitterMs: 0, sendRttMs: 0, sendResolutionHeight: 0, sendResolutionWidth: 0, captureResolutionHeight: 0, captureResolutionWidth: 0, targetSendBitrate: 0, totalDuration: 0, totalFreezeTime: 0, currentPacketLossRate: 0 }, ZA = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveLevel: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 }, $A = { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 }, eb = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, receiveResolutionHeight: 0, receiveResolutionWidth: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 };
      var tb, ib, nb, rb, sb, ob;
      !function(e2) {
        e2.ON_TRACK = "on_track", e2.ON_NODE = "on_node";
      }(tb || (tb = {})), function(e2) {
        e2.REQUEST_UPDATE_CONSTRAINTS = "request_update_constraints", e2.REQUEST_CONSTRAINTS = "request_constraints";
      }(ib || (ib = {})), function(e2) {
        e2.IDLE = "IDLE", e2.INITING = "INITING", e2.INITEND = "INITEND";
      }(nb || (nb = {})), function(e2) {
        e2.STATE_CHANGE = "state_change", e2.RECORDING_DEVICE_CHANGED = "recordingDeviceChanged", e2.PLAYOUT_DEVICE_CHANGED = "playoutDeviceChanged", e2.CAMERA_DEVICE_CHANGED = "cameraDeviceChanged";
      }(rb || (rb = {})), function(e2) {
        e2.NONE = "none", e2.INIT = "init", e2.CANPLAY = "canplay", e2.PLAYING = "playing", e2.PAUSED = "paused", e2.SUSPEND = "suspend", e2.STALLED = "stalled", e2.WAITING = "waiting", e2.ERROR = "error", e2.DESTROYED = "destroyed", e2.ABORT = "abort", e2.ENDED = "ended", e2.EMPTIED = "emptied", e2.LOADEDDATA = "loadeddata";
      }(sb || (sb = {})), function(e2) {
        e2[e2.VideoStateStopped = 0] = "VideoStateStopped", e2[e2.VideoStateStarting = 1] = "VideoStateStarting", e2[e2.VideoStateDecoding = 2] = "VideoStateDecoding", e2[e2.VideoStateFrozen = 3] = "VideoStateFrozen";
      }(ob || (ob = {}));
      const ab = { uninit: 100, none: 110, init: 120, loadeddata: 130, canplay: 200, playing: 210, paused: 220, suspend: 300, stalled: 310, waiting: 320, error: 330, destroyed: 340, abort: 350, ended: 360, emptied: 370 };
      var cb;
      !function(e2) {
        e2.OPEN = "open", e2.MESSAGE = "message", e2.CLOSE = "close", e2.CLOSING = "closing", e2.ERROR = "error";
      }(cb || (cb = {}));
      class db extends dT {
        constructor(e2, t2) {
          super(), sh(this, "_ID", void 0), sh(this, "_rtpTransceiver", void 0), sh(this, "_lowRtpTransceiver", void 0), sh(this, "_hints", []), sh(this, "_isClosed", false), sh(this, "_originMediaStreamTrack", void 0), sh(this, "_mediaStreamTrack", void 0), sh(this, "_external", {}), this._ID = t2 || nS(8, "track-"), this._originMediaStreamTrack = e2, this._mediaStreamTrack = e2, function(e3) {
            bn(VA).call(VA, e3) || VA.push(e3);
          }(this);
        }
        toString() {
          return this._ID;
        }
        getTrackId() {
          return this._ID;
        }
        getMediaStreamTrack(e2) {
          if (!e2) {
            const e3 = eI.reportApiInvoke(null, { name: hT.GET_MEDIA_STREAM_TRACK, options: [], tag: pT.TRACER });
            this._mediaStreamTrack && "string" == typeof this._mediaStreamTrack.label ? e3.onSuccess(this._mediaStreamTrack.label) : e3.onSuccess("");
          }
          return this._mediaStreamTrack;
        }
        getRTCRtpTransceiver(e2) {
          return e2 === GA.LOW_STREAM ? this._lowRtpTransceiver : this._rtpTransceiver;
        }
        getMediaStreamTrackSettings() {
          return this.getMediaStreamTrack(true).getSettings();
        }
        close() {
          this._isClosed = true, this._lowRtpTransceiver = void 0, this._rtpTransceiver = void 0, function(e2) {
            const t2 = VA.indexOf(e2);
            -1 !== t2 && VA.splice(t2, 1);
          }(this), this.emit(YA.CLOSED), this.removeAllListeners(KA.SEI_RECEIVED);
        }
        _updateRtpTransceiver(e2, t2) {
          if (t2 === GA.LOW_STREAM) {
            if (this._lowRtpTransceiver === e2) return;
            this._lowRtpTransceiver = e2;
          } else {
            if (this._rtpTransceiver === e2) return;
            this._rtpTransceiver = e2;
          }
          this.emit(KA.TRANSCEIVER_UPDATED, e2, t2);
        }
      }
      class lb extends db {
        get isExternalTrack() {
          return this._isExternalTrack;
        }
        get muted() {
          return this._muted;
        }
        get enabled() {
          return this._enabled;
        }
        get processorContext() {
          return this._processorContext;
        }
        constructor(e2, t2) {
          super(e2, t2), sh(this, "_enabled", true), sh(this, "_muted", false), sh(this, "_isExternalTrack", false), sh(this, "_isClosed", false), sh(this, "_enabledMutex", void 0), sh(this, "processor", void 0), sh(this, "_handleTrackEnded", () => {
            this.onTrackEnded();
          }), this._enabledMutex = new pS("".concat(this.getTrackId())), e2.addEventListener("ended", this._handleTrackEnded);
        }
        getTrackLabel() {
          var e2, t2;
          return null !== (e2 = null === (t2 = this._originMediaStreamTrack) || void 0 === t2 ? void 0 : t2.label) && void 0 !== e2 ? e2 : "";
        }
        close() {
          this._isClosed || (this.stop(), this._originMediaStreamTrack.stop(), this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack.stop(), this._mediaStreamTrack = null), this._originMediaStreamTrack = null, this._enabledMutex = null, jC.debug("[".concat(this.getTrackId(), "] close")), this.emit(BA.NEED_CLOSE), super.close());
        }
        async _updateOriginMediaStreamTrack(e2, t2) {
          let i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          this._isExternalTrack = i2, e2 !== this._originMediaStreamTrack && (this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), t2 && this._originMediaStreamTrack.stop()), e2.addEventListener("ended", this._handleTrackEnded), this._originMediaStreamTrack = e2, this._muted && (this._originMediaStreamTrack.enabled = false), this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await yT(this, BA.NEED_REPLACE_TRACK, this), this.processor && this._processorContext && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this._processorContext }));
        }
        _getDefaultPlayerConfig() {
          return {};
        }
        onTrackEnded() {
          jC.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(YA.TRACK_ENDED);
        }
        stateCheck(e2, t2) {
          if (jC.debug("check track state, [muted: ".concat(this._muted, ", enabled: ").concat(this._enabled, "] to [").concat(e2, ": ").concat(t2, "]")), Yg(t2, e2), this._enabled && this._muted && "enabled" === e2 && false === t2) throw new Kg(Hg.TRACK_STATE_UNREACHABLE, "cannot set enabled while the track is muted").print("error", jC);
          if (!this._enabled && !this._muted && "muted" === e2 && true === t2) throw new Kg(Hg.TRACK_STATE_UNREACHABLE, "cannot set muted while the track is disabled").print("error", jC);
        }
        getProcessorStats() {
          return this._processorContext && this._processorContext.gatherStats() || [];
        }
        getProcessorUsage() {
          return this._processorContext ? this._processorContext.gatherUsage() : cg.resolve([]);
        }
      }
      function ub(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      const hb = window.AudioContext || window.webkitAudioContext;
      let pb = null;
      const _b = new class extends dT {
        constructor() {
          super(...arguments), sh(this, "prevState", void 0), sh(this, "curState", void 0), sh(this, "currentTime", void 0), sh(this, "currentTimeStuckAt", void 0), sh(this, "interruptDetectorTrack", void 0), sh(this, "onLocalAudioTrackMute", () => {
            jC.info("ios15-interruption-start"), this.emit(vA.IOS_15_16_INTERRUPTION_START);
          }), sh(this, "onLocalAudioTrackUnmute", async () => {
            jC.info("ios15-interruption-end"), "running" !== this.curState || this.duringInterruption ? jC.info("ios15-interruption-end-canceled") : (pb && await pb.suspend(), this.emit(vA.IOS_15_16_INTERRUPTION_END));
          });
        }
        get duringInterruption() {
          return "running" === this.prevState && "interrupted" === this.curState;
        }
        bindInterruptDetectorTrack(e2) {
          jC.debug("webaudio bindInterruptDetectorTrack ".concat(e2.getTrackId())), this.interruptDetectorTrack || (this.interruptDetectorTrack = e2, this.interruptDetectorTrack._mediaStreamTrack.onmute = this.onLocalAudioTrackMute, this.interruptDetectorTrack._mediaStreamTrack.onunmute = this.onLocalAudioTrackUnmute);
        }
        unbindInterruptDetectorTrack(e2) {
          jC.debug("webaudio unbindInterruptDetectorTrack ".concat(e2.getTrackId())), this.interruptDetectorTrack && this.interruptDetectorTrack === e2 && (this.interruptDetectorTrack._mediaStreamTrack && (this.interruptDetectorTrack._mediaStreamTrack.onmute = null, this.interruptDetectorTrack._mediaStreamTrack.onunmute = null), this.interruptDetectorTrack = void 0);
        }
      }();
      function Eb() {
        if (!hb) return void jC.error("your browser is not support web audio");
        jC.info("create audio context");
        const e2 = function(e3) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? ub(Object(i2), true).forEach(function(t3) {
              sh(e3, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i2)) : ub(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e3, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e3;
        }({}, RC("WEBAUDIO_INIT_OPTIONS"));
        jC.debug("audio context init option:", JSON.stringify(e2)), pb = new hb(e2), _b.curState = pb.state, pb.onstatechange = () => {
          _b.prevState = _b.curState, _b.curState = pb ? pb.state : void 0;
          const { prevState: e3, curState: t2 } = _b, i2 = "running" === t2, n2 = "interrupted" === t2, r2 = "running" === e3, s2 = "suspended" === e3, o2 = "interrupted" === e3, a2 = Sg().osVersion;
          (Og() || Vg()) && r2 && n2 && (jC.info("ios".concat(a2, "-interruption-start")), _b.emit(vA.IOS_INTERRUPTION_START)), (Og() || Vg()) && (s2 || o2) && i2 && (jC.info("ios".concat(a2, "-interruption-end")), _b.emit(vA.IOS_INTERRUPTION_END)), e3 !== t2 && _b.emit(vA.STATE_CHANGE, t2, e3);
        }, setInterval(() => {
          var e3;
          const t2 = null === (e3 = pb) || void 0 === e3 ? void 0 : e3.currentTime;
          if (_b.currentTime !== t2) _b.currentTimeStuckAt && (jC.debug("AudioContext current time resume at ".concat(t2)), _b.currentTimeStuckAt = void 0), _b.currentTime = t2;
          else {
            if (t2 !== _b.currentTimeStuckAt) {
              eI.reportApiInvoke(null, { name: "WEB_AUDIO_CURRENT_TIME_STUCK", options: { currentTime: t2 }, tag: pT.TRACER }).onSuccess(), jC.warning("AudioContext current time stuck at ".concat(t2));
            }
            _b.currentTimeStuckAt = t2;
          }
        }, 5e3), async function(e3) {
          const t2 = ["click", "contextmenu", "auxclick", "dblclick", "mousedown", "mouseup", "touchend", "keydown", "keyup"];
          let i2, n2 = false, r2 = false, s2 = false;
          function o2(t3) {
            "running" === e3.state ? a2(false) : Og() || Vg() ? "suspended" === e3.state && (a2(true), t3 && e3.resume().then(d2, d2)) : "closed" !== e3.state && (a2(true), t3 && e3.resume().then(d2, d2));
          }
          function a2(e4) {
            if (n2 !== e4) {
              n2 = e4;
              for (let i3 = 0, n3 = t2; i3 < n3.length; i3 += 1) {
                const t3 = n3[i3];
                e4 ? window.addEventListener(t3, l2, { capture: true, passive: true }) : window.removeEventListener(t3, l2, { capture: true, passive: true });
              }
            }
          }
          function c2() {
            o2(true);
          }
          function d2() {
            o2(false);
          }
          function l2() {
            o2(true);
          }
          function u2(e4) {
            if (!s2) if (i2.paused) if (e4) {
              let e5;
              h3(false), s2 = true;
              try {
                e5 = i2.play(), e5 ? e5.then(p2, p2) : (i2.addEventListener("playing", p2), i2.addEventListener("abort", p2), i2.addEventListener("error", p2));
              } catch (e6) {
                p2();
              }
            } else h3(true);
            else h3(false);
          }
          function h3(e4) {
            if (r2 !== e4) {
              r2 = e4;
              for (let i3 = 0, n3 = t2; i3 < n3.length; i3++) {
                const t3 = n3[i3];
                e4 ? window.addEventListener(t3, _2, { capture: true, passive: true }) : window.removeEventListener(t3, _2, { capture: true, passive: true });
              }
            }
          }
          function p2() {
            i2.removeEventListener("playing", p2), i2.removeEventListener("abort", p2), i2.removeEventListener("error", p2), s2 = false, u2(false);
          }
          function _2() {
            u2(true);
          }
          if (Og()) {
            const t3 = e3.createMediaStreamDestination(), n3 = document.createElement("div");
            n3.innerHTML = "<audio x-webkit-airplay='deny'></audio>", i2 = n3.children.item(0), i2.controls = false, i2.disableRemotePlayback = true, i2.preload = "auto", i2.srcObject = t3.stream, u2(true);
          }
          _b.on(vA.STATE_CHANGE, c2), o2(false);
        }(pb);
      }
      function mb() {
        if (!pb) {
          if (Eb(), !pb) throw new Kg(Hg.NOT_SUPPORTED, "can not create audio context");
          return pb;
        }
        return pb;
      }
      function fb(e2) {
        if (function() {
          if (null !== gb) return gb;
          const e3 = mb(), t3 = e3.createBufferSource(), i3 = e3.createGain(), n2 = e3.createGain();
          t3.connect(i3), t3.connect(n2), t3.disconnect(i3);
          let r2 = false;
          try {
            t3.disconnect(i3);
          } catch (e4) {
            r2 = true;
          }
          return t3.disconnect(), gb = r2, r2;
        }()) return;
        const t2 = e2.connect, i2 = e2.disconnect;
        e2.connect = (i3, n2, r2) => {
          var s2;
          return e2._inputNodes || (e2._inputNodes = []), bn(s2 = e2._inputNodes).call(s2, i3) || (i3 instanceof AudioNode ? (e2._inputNodes.push(i3), t2.call(e2, i3, n2, r2)) : t2.call(e2, i3, n2)), e2;
        }, e2.disconnect = (n2, r2, s2) => {
          i2.call(e2), n2 ? WT(e2._inputNodes, n2) : e2._inputNodes = [];
          for (const i3 of e2._inputNodes) t2.call(e2, i3);
        };
      }
      let gb = null;
      function Tb(e2, t2) {
        let i2 = false;
        const n2 = 1 / t2;
        if (RC("DISABLE_WEBAUDIO")) {
          const t3 = window.setInterval(() => {
            i2 ? window.clearInterval(t3) : e2(performance.now() / 1e3);
          }, 1e3 * n2);
        } else {
          const t3 = mb();
          let r2 = t3.createGain();
          r2.gain.value = 0, r2.connect(t3.destination);
          const s2 = () => {
            if (i2) return void (r2 = null);
            const o2 = t3.createOscillator();
            o2.onended = s2, o2.connect(r2), o2.start(0), o2.stop(t3.currentTime + n2), e2(t3.currentTime);
          };
          s2();
        }
        return () => {
          i2 = true;
        };
      }
      class Sb {
        constructor() {
          sh(this, "context", void 0), sh(this, "analyserNode", void 0), sh(this, "sourceNode", void 0), this.context = mb(), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = 0.4;
        }
        updateSource(e2) {
          if (e2 !== this.sourceNode) {
            if (this.sourceNode) try {
              this.sourceNode.disconnect(this.analyserNode);
            } catch (e3) {
            }
            this.sourceNode = e2, null == e2 || e2.connect(this.analyserNode);
          }
        }
        getVolumeLevel() {
          if (!this.sourceNode) return 0;
          if (!this.context || Og() || Vg() || "running" !== this.context.state && this.context.resume(), !this.analyserNode) return 0;
          const e2 = new Float32Array(this.analyserNode.fftSize);
          if (this.analyserNode.getFloatTimeDomainData) this.analyserNode.getFloatTimeDomainData(e2);
          else {
            const t3 = new Uint8Array(this.analyserNode.fftSize);
            this.analyserNode.getByteTimeDomainData(t3);
            for (let i2 = 0; i2 < e2.length; ++i2) e2[i2] = t3[i2] / 128 - 1;
          }
          const t2 = BT(e2).call(e2, (e3, t3) => e3 + t3 * t3, 0) / e2.length;
          return Math.max(10 * Math.log10(t2) + 100, 0) / 100;
        }
        getAnalyserNode() {
          return this.analyserNode;
        }
        rebuildAnalyser() {
          try {
            var e2, t2;
            null === (e2 = this.sourceNode) || void 0 === e2 || e2.disconnect(this.analyserNode), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = 0.4, null === (t2 = this.sourceNode) || void 0 === t2 || t2.connect(this.analyserNode);
          } catch (e3) {
            jC.warning("rebuild analyser node failed.");
          }
        }
        destroy() {
          this.updateSource(void 0);
        }
      }
      class Rb extends dT {
        get processSourceNode() {
          return this.sourceNode;
        }
        set processedNode(e2) {
          var t2;
          if (!this.isDestroyed && this._processedNode !== e2) {
            try {
              var i2;
              null === (i2 = this.sourceNode) || void 0 === i2 || i2.disconnect(this.outputNode);
            } catch (e3) {
            }
            null === (t2 = this._processedNode) || void 0 === t2 || t2.disconnect(), this._processedNode = e2, this.connect();
          }
        }
        get processedNode() {
          return this._processedNode;
        }
        constructor() {
          super(), sh(this, "outputNode", void 0), sh(this, "outputTrack", void 0), sh(this, "isPlayed", false), sh(this, "context", void 0), sh(this, "audioBufferNode", void 0), sh(this, "destNode", void 0), sh(this, "audioOutputLevel", 0), sh(this, "volumeLevelAnalyser", void 0), sh(this, "_processedNode", void 0), sh(this, "playNode", void 0), sh(this, "isDestroyed", false), sh(this, "onNoAudioInput", void 0), sh(this, "isNoAudioInput", false), sh(this, "_noAudioInputCount", 0), this.context = mb(), this.playNode = this.context.destination, this.outputNode = this.context.createGain(), fb(this.outputNode), this.volumeLevelAnalyser = new Sb();
        }
        startGetAudioBuffer(e2) {
          this.audioBufferNode || (this.audioBufferNode = this.context.createScriptProcessor(e2), this.outputNode.connect(this.audioBufferNode), this.audioBufferNode.connect(this.context.destination), this.audioBufferNode.onaudioprocess = (e3) => {
            this.emit(zA.ON_AUDIO_BUFFER, function(e4) {
              for (let t2 = 0; t2 < e4.outputBuffer.numberOfChannels; t2 += 1) {
                const i2 = e4.outputBuffer.getChannelData(t2);
                for (let e5 = 0; e5 < i2.length; e5 += 1) i2[e5] = 0;
              }
              return e4.inputBuffer;
            }(e3));
          });
        }
        stopGetAudioBuffer() {
          this.audioBufferNode && (this.audioBufferNode.onaudioprocess = null, this.outputNode.disconnect(this.audioBufferNode), this.audioBufferNode = void 0);
        }
        createOutputTrack() {
          if (!IA().webAudioMediaStreamDest) throw new Kg(Hg.NOT_SUPPORTED, "your browser is not support audio processor");
          return this.destNode && this.outputTrack || (this.destNode = this.context.createMediaStreamDestination(), this.outputNode.connect(this.destNode), this.outputTrack = this.destNode.stream.getAudioTracks()[0]), this.outputTrack;
        }
        play(e2) {
          "running" !== this.context.state && KT(() => {
            _b.emit("autoplay-failed");
          }), this.isPlayed = true, this.playNode = e2 || this.context.destination, this.outputNode.connect(this.playNode);
        }
        stop() {
          if (this.isPlayed) try {
            this.outputNode.disconnect(this.playNode);
          } catch (e2) {
          }
          this.isPlayed = false;
        }
        getAccurateVolumeLevel() {
          return this.volumeLevelAnalyser.getVolumeLevel();
        }
        async checkHasAudioInput() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
          if (e2 > 5) return this.isNoAudioInput = true, this.onNoAudioInput && this.onNoAudioInput(), false;
          Og() || Vg() ? "suspended" === this.context.state && this.context.resume() : "running" !== this.context.state && this.context.resume();
          const t2 = this.volumeLevelAnalyser.getAnalyserNode();
          let i2;
          t2.getFloatTimeDomainData ? (i2 = new Float32Array(t2.fftSize), t2.getFloatTimeDomainData(i2)) : (i2 = new Uint8Array(t2.fftSize), t2.getByteTimeDomainData(i2));
          let n2 = false;
          for (let e3 = 0; e3 < i2.length; e3++) 0 !== i2[e3] && (n2 = true);
          return n2 ? (this.isNoAudioInput = false, true) : (await iS(200), await this.checkHasAudioInput(e2 ? e2 + 1 : 1) && n2);
        }
        getAudioVolume() {
          return this.outputNode.gain.value;
        }
        setVolume(e2) {
          this.outputNode.gain.setValueAtTime(e2, this.context.currentTime);
        }
        destroy() {
          this.disconnect(), this.stop(), this.isDestroyed = true, this.onNoAudioInput = void 0;
        }
        disconnect() {
          var e2, t2;
          null === (e2 = this.processedNode) || void 0 === e2 || e2.disconnect(), null === (t2 = this.sourceNode) || void 0 === t2 || t2.disconnect(), this.outputNode && this.outputNode.disconnect();
        }
        connect() {
          var e2;
          this.processedNode ? null === (e2 = this.processedNode) || void 0 === e2 || e2.connect(this.outputNode) : this.sourceNode && this.sourceNode.connect(this.outputNode);
          this.volumeLevelAnalyser.updateSource(this.outputNode);
        }
      }
      class Cb extends Rb {
        get isFreeze() {
          return false;
        }
        constructor(e2, t2, i2) {
          var n2;
          if (super(), sh(this, "sourceNode", void 0), sh(this, "track", void 0), sh(this, "clonedTrack", void 0), sh(this, "audioElement", void 0), sh(this, "isCurrentTrackCloned", false), sh(this, "isRemoteTrack", false), sh(this, "originVolumeLevelAnalyser", void 0), sh(this, "rebuildWebAudio", async () => {
            if (jC.debug("ready to rebuild web audio, state:", this.context.state), this.isNoAudioInput && await this.checkHasAudioInput(), !this.isNoAudioInput || this.isDestroyed) return document.body.removeEventListener("click", this.rebuildWebAudio, true), void jC.debug("rebuild web audio success, current volume status", this.getAccurateVolumeLevel());
            this.context.resume().then(() => jC.info("resume success")), jC.debug("rebuild web audio because of ios 12 bugs"), this.disconnect();
            const e3 = this.track;
            this.track = this.track.clone(), this.isCurrentTrackCloned ? e3.stop() : this.isCurrentTrackCloned = true;
            const t3 = new MediaStream([this.track]);
            this.sourceNode = this.context.createMediaStreamSource(t3), fb(this.sourceNode), this.volumeLevelAnalyser.rebuildAnalyser();
            const i3 = this.outputNode.gain.value;
            this.outputNode = this.context.createGain(), this.outputNode.gain.setValueAtTime(i3, this.context.currentTime), fb(this.outputNode), this.emit(zA.UPDATE_SOURCE), this.connect(), this.audioElement.srcObject = t3, this.isPlayed && this.play(this.playNode), this.checkHasAudioInput();
          }), "audio" !== e2.kind) throw new Kg(Hg.UNEXPECTED_ERROR);
          this.track = e2;
          const r2 = new MediaStream([this.track]);
          if (this.isRemoteTrack = !!t2, this.sourceNode = this.context.createMediaStreamSource(r2), fb(this.sourceNode), i2) {
            const e3 = i2.clone();
            e3.enabled = true, this.clonedTrack = e3, jC.debug("create an unmuted track ".concat(e3.id, " from the original track ").concat(i2.id, " to get the volume"));
            const t3 = this.context.createMediaStreamSource(new MediaStream([e3]));
            fb(t3), this.originVolumeLevelAnalyser = new Sb(), this.originVolumeLevelAnalyser.updateSource(t3);
          }
          this.connect(), this.audioElement = document.createElement("audio"), this.audioElement.srcObject = r2;
          const s2 = Sg();
          t2 && s2.os === _g.IOS && Number(null === (n2 = s2.osVersion) || void 0 === n2 ? void 0 : n2.split(".")[0]) < 15 && (_b.on(vA.STATE_CHANGE, () => {
            "suspended" === this.context.state ? document.body.addEventListener("click", this.rebuildWebAudio, true) : "running" === this.context.state && this.rebuildWebAudio();
          }), this.checkHasAudioInput().then((e3) => {
            e3 || document.body.addEventListener("click", this.rebuildWebAudio, true);
          }));
        }
        updateTrack(e2) {
          this.sourceNode.disconnect(), this.track = e2, this.isCurrentTrackCloned = false;
          const t2 = new MediaStream([e2]);
          this.sourceNode = this.context.createMediaStreamSource(t2), fb(this.sourceNode), this.processedNode || this.sourceNode.connect(this.outputNode), this.emit(zA.UPDATE_SOURCE), this.audioElement.srcObject = t2;
        }
        destroy() {
          var e2;
          this.audioElement.srcObject = null, this.audioElement.remove(), _b.off("state-change", this.rebuildWebAudio), null === (e2 = this.originVolumeLevelAnalyser) || void 0 === e2 || e2.destroy(), this.clonedTrack = void 0, super.destroy();
        }
        createMediaStreamSourceNode(e2) {
          return this.context.createMediaStreamSource(new MediaStream([e2]));
        }
        updateOriginTrack(e2) {
          const t2 = e2.clone();
          t2.enabled = true, this.clonedTrack && (this.clonedTrack.stop(), this.clonedTrack = t2), jC.debug("create an unmuted track ".concat(t2.id, " from the original track ").concat(e2.id, " to get the volume"));
          const i2 = this.context.createMediaStreamSource(new MediaStream([t2]));
          fb(i2), this.originVolumeLevelAnalyser && this.originVolumeLevelAnalyser.updateSource(i2);
        }
        getOriginVolumeLevel() {
          return this.originVolumeLevelAnalyser ? this.originVolumeLevelAnalyser.getVolumeLevel() : this.getAccurateVolumeLevel();
        }
      }
      async function Ib(e2, t2, i2) {
        const n2 = (e3, t3) => e3 ? "number" != typeof e3 ? e3.max || e3.exact || e3.ideal || e3.min || t3 : e3 : t3, r2 = { audio: !!i2 && { mandatory: { chromeMediaSource: "desktop" } }, video: { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: e2, maxHeight: n2(t2.height, 1080), maxWidth: n2(t2.width, 1920) } } };
        return t2.frameRate && "number" != typeof t2.frameRate ? (r2.video.mandatory.maxFrameRate = t2.frameRate.max, r2.video.mandatory.minFrameRate = t2.frameRate.min) : "number" == typeof t2.frameRate && (r2.video.mandatory.maxFrameRate = t2.frameRate), await navigator.mediaDevices.getUserMedia(r2);
      }
      async function vb(e2, t2) {
        const i2 = await yb(e2.mediaSource), { sourceId: n2, audio: r2 } = await function(e3) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          return new cg((i3, n3) => {
            const r3 = document.createElement("div");
            r3.innerText = "share screen", r3.setAttribute("style", "text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;");
            const s2 = document.createElement("div");
            s2.setAttribute("style", "width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;");
            const o2 = document.createElement("div");
            o2.innerText = "Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share.", o2.setAttribute("style", "height: 12%;");
            const a2 = document.createElement("div");
            a2.setAttribute("style", "width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;");
            const c2 = document.createElement("div");
            c2.setAttribute("style", "display: flex; justify-content: space-between; padding: 16px 0;");
            const d2 = document.createElement("button");
            d2.innerHTML = "cancel", d2.setAttribute("style", "width: 85px;"), d2.onclick = () => {
              document.body.removeChild(h3);
              const e4 = new Error("NotAllowedError");
              e4.name = "NotAllowedError", n3(e4);
            };
            let l2 = t3;
            const u2 = document.createElement("div");
            if (t3) {
              const e4 = document.createElement("input");
              e4.setAttribute("type", "checkbox");
              const t4 = document.createElement("span");
              e4.setAttribute("style", "margin-right: 6px;"), t4.innerText = "Share audio", e4.checked = l2, e4.onchange = () => {
                l2 = e4.checked;
              }, u2.appendChild(e4), u2.appendChild(t4);
            }
            c2.appendChild(u2), c2.appendChild(d2), s2.appendChild(o2), s2.appendChild(a2), s2.appendChild(c2);
            const h3 = document.createElement("div");
            h3.setAttribute("style", "position: fixed; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);"), h3.appendChild(r3), h3.appendChild(s2), document.body.appendChild(h3), e3.map((e4) => {
              if (e4.id) {
                const t4 = document.createElement("div");
                t4.setAttribute("style", "width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;");
                let n4 = e4.thumbnail;
                try {
                  const { width: e5 } = n4.getSize();
                  e5 > 1920 && (n4 = n4.resize({ width: 1920 }));
                } catch (e5) {
                  throw e5 && e5.message.startsWith("Illegal invocation") && console.error("Operate thumbnail error, please try to set contextIsolation: false. (https://github.com/electron/electron/issues/34953)"), e5;
                }
                t4.innerHTML = '<div style="height: 120px; display: table-cell; vertical-align: middle;"><img style="width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);" src=' + n4.toDataURL() + ' /></div><span style="	height: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + e4.name.replace(/[\u00A0-\u9999<>\&]/g, function(e5) {
                  return "&#" + e5.charCodeAt(0) + ";";
                }) + "</span>", t4.onclick = () => {
                  document.body.removeChild(h3), i3({ sourceId: e4.id, audio: l2 });
                }, a2.appendChild(t4);
              }
            });
          });
        }(i2, t2);
        return await Ib(n2, e2, r2);
      }
      async function yb(e2) {
        let t2 = ["window", "screen"];
        "application" !== e2 && "window" !== e2 || (t2 = ["window"]), "screen" === e2 && (t2 = ["screen"]);
        const i2 = uT();
        if (!i2) throw console.error("failed to fetch electron, please mount it to window"), new Kg(Hg.ELECTRON_IS_NULL);
        let n2 = null;
        try {
          var r2;
          n2 = (null === (r2 = i2.desktopCapturer) || void 0 === r2 ? void 0 : r2.getSources({ types: t2 })) || i2.ipcRenderer.invoke("DESKTOP_CAPTURER_GET_SOURCES", { types: t2 });
        } catch (e3) {
          n2 = null;
        }
        n2 && n2.then || (n2 = new cg((e3, n3) => {
          i2.desktopCapturer.getSources({ types: t2 }, (t3, i3) => {
            t3 ? n3(t3) : e3(i3);
          });
        }));
        try {
          return await n2;
        } catch (e3) {
          throw new Kg(Hg.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR, e3.toString());
        }
      }
      function Ab(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      const bb = new pS("safari");
      let wb = false, Ob = false;
      async function Nb(e2, t2) {
        let i2 = 0, n2 = null;
        for (; i2 < 2; ) try {
          n2 = await Db(e2, t2, i2 > 0);
          break;
        } catch (e3) {
          if (e3 instanceof Kg) throw jC.error("[".concat(t2, "] ").concat(e3.toString())), e3;
          const n3 = Pb(e3.name || e3.code || e3, e3.message);
          if (n3.code === Hg.MEDIA_OPTION_INVALID) {
            jC.debug("[".concat(t2, "] detect media option invalid, retry")), i2 += 1, await iS(500);
            continue;
          }
          throw jC.error("[".concat(t2, "] ").concat(n3.toString())), n3;
        }
        if (!n2) throw new Kg(Hg.UNEXPECTED_ERROR, "can not find stream after getUserMedia");
        return n2;
      }
      async function Db(e2, t2, i2) {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) throw new Kg(Hg.NOT_SUPPORTED, "can not find getUserMedia");
        i2 && (e2.video && (delete e2.video.width, delete e2.video.height), e2.screen && (delete e2.screen.width, delete e2.screen.height));
        const n2 = IA(), r2 = new MediaStream();
        if (e2.audioSource && r2.addTrack(e2.audioSource), e2.videoSource && r2.addTrack(e2.videoSource), !e2.audio && !e2.video && !e2.screen) return jC.debug("Using Video Source/ Audio Source"), r2;
        if (e2.screen) if (uT()) if (e2.screen.sourceId) {
          Lb(r2, await Ib(e2.screen.sourceId, e2.screen, e2.screenAudio));
        } else {
          Lb(r2, await vb(e2.screen, e2.screenAudio));
        }
        else if (Ag() && e2.screen.extensionId && e2.screen.mandatory) {
          if (!n2.getStreamFromExtension) throw new Kg(Hg.NOT_SUPPORTED, "This browser does not support screen sharing");
          jC.debug("[".concat(t2, '] Screen access on chrome stable, looking for extension"'));
          const i3 = await (o2 = e2.screen.extensionId, a2 = t2, new cg((e3, t3) => {
            try {
              chrome.runtime.sendMessage(o2, { getStream: true }, (i4) => {
                if (!i4 || !i4.streamId) return jC.error("[".concat(a2, "] No response from Chrome Plugin. Plugin not installed properly"), i4), void t3(new Kg(Hg.CHROME_PLUGIN_NO_RESPONSE, "No response from Chrome Plugin. Plugin not installed properly"));
                e3(i4.streamId);
              });
            } catch (e4) {
              jC.error("[".concat(a2, "] AgoraRTC screensharing plugin is not accessible(").concat(o2, ")"), e4.toString()), t3(new Kg(Hg.CHROME_PLUGIN_NOT_INSTALL));
            }
          }));
          e2.screen.mandatory.chromeMediaSourceId = i3;
          Lb(r2, await navigator.mediaDevices.getUserMedia({ video: { mandatory: e2.screen.mandatory } }));
        } else if (n2.getDisplayMedia) {
          var s2;
          e2.screen.mediaSource && FA(e2.screen.mediaSource);
          const i3 = { width: e2.screen.width, height: e2.screen.height, frameRate: e2.screen.frameRate, displaySurface: null !== (s2 = e2.screen.displaySurface) && void 0 !== s2 ? s2 : "screen" === e2.screen.mediaSource ? "monitor" : e2.screen.mediaSource }, { selfBrowserSurface: n3, surfaceSwitching: o3, systemAudio: a3 } = e2.screen, c3 = { selfBrowserSurface: n3, surfaceSwitching: o3, systemAudio: a3 };
          !n3 && delete c3.selfBrowserSurface, !o3 && delete c3.surfaceSwitching, !a3 && delete c3.systemAudio, jC.debug("[".concat(t2, "] getDisplayMedia:"), JSON.stringify({ video: i3, audio: !!e2.screenAudio, controls: c3 }));
          const d3 = await navigator.mediaDevices.getDisplayMedia(function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var i4 = null != arguments[t3] ? arguments[t3] : {};
              t3 % 2 ? Ab(Object(i4), true).forEach(function(t4) {
                sh(e3, t4, i4[t4]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i4)) : Ab(Object(i4)).forEach(function(t4) {
                Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i4, t4));
              });
            }
            return e3;
          }({ video: i3, audio: !!e2.screenAudio }, c3));
          Lb(r2, d3);
        } else {
          if (!wg()) throw jC.error("[".concat(t2, "] This browser does not support screenSharing")), new Kg(Hg.NOT_SUPPORTED, "This browser does not support screen sharing");
          {
            e2.screen.mediaSource && FA(e2.screen.mediaSource);
            const i3 = { video: { mediaSource: e2.screen.mediaSource, width: e2.screen.width, height: e2.screen.height, frameRate: e2.screen.frameRate } };
            jC.debug("[".concat(t2, "] getUserMedia: ").concat(JSON.stringify(i3)));
            Lb(r2, await navigator.mediaDevices.getUserMedia(i3));
          }
        }
        var o2, a2;
        if (!e2.video && !e2.audio) return r2;
        let c2 = { video: e2.video, audio: e2.audio }, d2 = RC("MEDIA_DEVICE_CONSTRAINTS");
        if (d2) try {
          "string" == typeof d2 && (d2 = JSON.parse(d2)), c2 = dS(c2, d2);
        } catch (e3) {
        }
        jC.debug("[".concat(t2, "] GetUserMedia"), JSON.stringify(c2)), Sg();
        let l2, u2 = null;
        (bg() || Og() || Ig()) && (u2 = await bb.lock());
        try {
          l2 = await navigator.mediaDevices.getUserMedia(c2);
        } catch (e3) {
          throw u2 && u2(), e3;
        }
        return c2.audio && (wb = true), c2.video && (Ob = true), Lb(r2, l2), u2 && u2(), r2;
      }
      function Pb(e2, t2) {
        switch (e2) {
          case "Starting video failed":
          case "OverconstrainedError":
          case "TrackStartError":
            return new Kg(Hg.MEDIA_OPTION_INVALID, "".concat(e2, ": ").concat(t2));
          case "NotFoundError":
          case "DevicesNotFoundError":
            return new Kg(Hg.DEVICE_NOT_FOUND, "".concat(e2, ": ").concat(t2));
          case "NotSupportedError":
            return new Kg(Hg.NOT_SUPPORTED, "".concat(e2, ": ").concat(t2));
          case "NotReadableError":
            return new Kg(Hg.NOT_READABLE, "".concat(e2, ": ").concat(t2));
          case "InvalidStateError":
          case "NotAllowedError":
          case "PERMISSION_DENIED":
          case "PermissionDeniedError":
            return new Kg(Hg.PERMISSION_DENIED, "".concat(e2, ": ").concat(t2));
          case "ConstraintNotSatisfiedError":
            return new Kg(Hg.CONSTRAINT_NOT_SATISFIED, "".concat(e2, ": ").concat(t2));
          default:
            return jC.error("getUserMedia unexpected error", e2), new Kg(Hg.UNEXPECTED_ERROR, "".concat(e2, ": ").concat(t2));
        }
      }
      function Lb(e2, t2) {
        const i2 = e2.getVideoTracks()[0], n2 = e2.getAudioTracks()[0], r2 = t2.getVideoTracks()[0], s2 = t2.getAudioTracks()[0];
        s2 && (n2 && e2.removeTrack(n2), e2.addTrack(s2)), r2 && (i2 && e2.removeTrack(i2), e2.addTrack(r2));
      }
      const kb = new class extends dT {
        get state() {
          return this._state;
        }
        set state(e2) {
          e2 !== this._state && (this.emit(rb.STATE_CHANGE, e2), this._state = e2);
        }
        constructor() {
          super(), sh(this, "_state", nb.IDLE), sh(this, "isAccessMicrophonePermission", false), sh(this, "isAccessCameraPermission", false), sh(this, "lastAccessMicrophonePermission", false), sh(this, "lastAccessCameraPermission", false), sh(this, "checkdeviceMatched", false), sh(this, "deviceInfoMap", /* @__PURE__ */ new Map()), this.init().then(() => {
            navigator.mediaDevices.addEventListener && navigator.mediaDevices.addEventListener("devicechange", this.updateDevicesInfo.bind(this)), window.setInterval(() => {
              (RC("ENUMERATE_DEVICES_INTERVAL") || (Gg() || Rg() === _g.HARMONY_OS) && jg()) && this.updateDevicesInfo();
            }, RC("ENUMERATE_DEVICES_INTERVAL_TIME"));
          }).catch((e2) => jC.error(e2.toString()));
        }
        async enumerateDevices(e2, t2) {
          let i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
            return new Kg(Hg.NOT_SUPPORTED, "enumerateDevices() not supported.").throw();
          }
          const n2 = await navigator.mediaDevices.enumerateDevices(), r2 = this.checkMediaDeviceInfoIsOk(n2);
          let s2 = !this.isAccessMicrophonePermission && e2, o2 = !this.isAccessCameraPermission && t2;
          r2.audio && (s2 = false), r2.video && (o2 = false);
          let a2 = null, c2 = null, d2 = null;
          if (!i2 && (s2 || o2)) {
            if (bb.isLocked) {
              jC.debug("[device manager] wait GUM lock");
              (await bb.lock())(), jC.debug("[device manager] GUM unlock");
            }
            if (wb && (s2 = false, this.isAccessMicrophonePermission = true), Ob && (o2 = false, this.isAccessCameraPermission = true), jC.debug("[device manager] check media device permissions", e2, t2, s2, o2), s2 && o2) {
              try {
                d2 = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
              } catch (e3) {
                const t3 = Pb(e3.name || e3.code || e3, e3.message);
                if (t3.code === Hg.PERMISSION_DENIED) throw t3;
                jC.warning("getUserMedia failed in getDevices", t3);
              }
              this.isAccessCameraPermission = true, this.isAccessMicrophonePermission = true;
            } else if (s2) {
              try {
                a2 = await navigator.mediaDevices.getUserMedia({ audio: e2 });
              } catch (e3) {
                const t3 = Pb(e3.name || e3.code || e3, e3.message);
                if (t3.code === Hg.PERMISSION_DENIED) throw t3;
                jC.warning("getUserMedia failed in getDevices", t3);
              }
              this.isAccessMicrophonePermission = true;
            } else if (o2) {
              try {
                c2 = await navigator.mediaDevices.getUserMedia({ video: t2 });
              } catch (e3) {
                const t3 = Pb(e3.name || e3.code || e3, e3.message);
                if (t3.code === Hg.PERMISSION_DENIED) throw t3;
                jC.warning("getUserMedia failed in getDevices", t3);
              }
              this.isAccessCameraPermission = true;
            }
            jC.debug("[device manager] mic permission", e2, "cam permission", t2);
          }
          try {
            const e3 = await navigator.mediaDevices.enumerateDevices();
            return a2 && a2.getTracks().forEach((e4) => e4.stop()), c2 && c2.getTracks().forEach((e4) => e4.stop()), d2 && d2.getTracks().forEach((e4) => e4.stop()), a2 = null, c2 = null, d2 = null, e3;
          } catch (e3) {
            a2 && a2.getTracks().forEach((e4) => e4.stop()), c2 && c2.getTracks().forEach((e4) => e4.stop()), d2 && d2.getTracks().forEach((e4) => e4.stop()), a2 = null, c2 = null, d2 = null;
            return new Kg(Hg.ENUMERATE_DEVICES_FAILED, e3.toString()).throw();
          }
        }
        async getRecordingDevices() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return (await this.enumerateDevices(true, false, e2)).filter((e3) => "audioinput" === e3.kind);
        }
        async getCamerasDevices() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return (await this.enumerateDevices(false, true, e2)).filter((e3) => "videoinput" === e3.kind);
        }
        async getSpeakers() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return (await this.enumerateDevices(true, false, e2)).filter((e3) => "audiooutput" === e3.kind);
        }
        searchDeviceIdByName(e2) {
          let t2 = null;
          return this.deviceInfoMap.forEach((i2) => {
            i2.device.label === e2 && (t2 = i2.device.deviceId);
          }), t2;
        }
        async getDeviceById(e2) {
          const t2 = (await this.enumerateDevices(true, true, true)).find((t3) => t3.deviceId === e2);
          if (!t2) throw new Kg(Hg.DEVICE_NOT_FOUND, "deviceId: ".concat(e2));
          return t2;
        }
        async init() {
          this.state = nb.INITING;
          try {
            await this.updateDevicesInfo(), this.state = nb.INITEND;
          } catch (e2) {
            if (jC.warning("Device Detection functionality cannot start properly.", e2.toString()), this.state = nb.IDLE, !("boolean" == typeof isSecureContext ? isSecureContext : "https:" === location.protocol || "file:" === location.protocol || "localhost" === location.hostname || "127.0.0.1" === location.hostname || "::1" === location.hostname)) {
              new Kg(Hg.WEB_SECURITY_RESTRICT, "Your context is limited by web security, please try using https protocol or localhost.").throw();
            }
            throw e2;
          }
        }
        async updateDevicesInfo() {
          const e2 = await this.enumerateDevices(true, true, true), t2 = Date.now(), i2 = [];
          if (e2[0] && e2[0].label && false === this.checkdeviceMatched) {
            this.checkdeviceMatched = true;
            const t3 = e2.find((e3) => "audioinput" === e3.kind && "default" === e3.deviceId), i3 = e2.find((e3) => "audiooutput" === e3.kind && "default" === e3.deviceId);
            t3 && i3 ? i3.groupId === t3.groupId ? jC.debug("[device-check] default input ".concat(t3.label, " and output ").concat(i3.label, " is the same group")) : jC.warning("[device-check] default input ".concat(t3.label, " and output ").concat(i3.label, " is not the same group")) : jC.debug("[device-check] default input or output not found");
          }
          const n2 = this.checkMediaDeviceInfoIsOk(e2);
          if (e2.forEach((e3) => {
            if (!e3.deviceId) return;
            const n3 = this.deviceInfoMap.get("".concat(e3.kind, "_").concat(e3.deviceId));
            if ("ACTIVE" !== (n3 ? n3.state : "INACTIVE")) {
              const n4 = { initAt: t2, updateAt: t2, device: e3, state: "ACTIVE" };
              this.deviceInfoMap.set("".concat(e3.kind, "_").concat(e3.deviceId), n4), i2.push(n4);
            }
            n3 && (n3.updateAt = t2);
          }), this.deviceInfoMap.forEach((e3, n3) => {
            "ACTIVE" === e3.state && e3.updateAt !== t2 && (e3.state = "INACTIVE", i2.push(e3));
          }), this.state !== nb.INITEND) return n2.audio && (this.lastAccessMicrophonePermission = true, this.isAccessMicrophonePermission = true), void (n2.video && (this.lastAccessCameraPermission = true, this.isAccessCameraPermission = true));
          i2.forEach((e3) => {
            switch (e3.device.kind) {
              case "audioinput":
                this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(rb.RECORDING_DEVICE_CHANGED, e3);
                break;
              case "videoinput":
                this.lastAccessCameraPermission && this.isAccessCameraPermission && this.emit(rb.CAMERA_DEVICE_CHANGED, e3);
                break;
              case "audiooutput":
                this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(rb.PLAYOUT_DEVICE_CHANGED, e3);
            }
          }), n2.audio && (this.lastAccessMicrophonePermission = true, this.isAccessMicrophonePermission = true), n2.video && (this.lastAccessCameraPermission = true, this.isAccessCameraPermission = true);
        }
        checkMediaDeviceInfoIsOk(e2) {
          const t2 = e2.filter((e3) => "audioinput" === e3.kind), i2 = e2.filter((e3) => "videoinput" === e3.kind), n2 = { audio: false, video: false };
          for (const e3 of t2) if (e3.label && e3.deviceId) {
            n2.audio = true;
            break;
          }
          for (const e3 of i2) if (e3.label && e3.deviceId) {
            n2.video = true;
            break;
          }
          return n2;
        }
      }();
      let Mb = false;
      const Ub = new class extends dT {
        constructor() {
          super(...arguments), sh(this, "onAutoplayFailed", void 0), sh(this, "onAudioAutoplayFailed", void 0);
        }
      }();
      function xb() {
        if (Sg(), !Mb) {
          const e2 = (t2) => {
            t2.preventDefault(), Mb = false, Wg() ? document.body.removeEventListener("click", e2, true) : (document.body.removeEventListener("touchstart", e2, true), document.body.removeEventListener("mousedown", e2, true));
          };
          Mb = true, Wg() ? document.body.addEventListener("click", e2, true) : (document.body.addEventListener("touchstart", e2, true), document.body.addEventListener("mousedown", e2, true)), jC.info("detect media autoplay failed, document: https://docs.agora.io/cn/Voice/autoplay_policy_web_ng?platform=Web"), Ub.onAutoplayFailed ? Ub.onAutoplayFailed() : Ub.onAudioAutoplayFailed ? jC.warning("AgoraRTC.onAudioAutoplayFailed has been deprecated in favor of AgoraRTC.onAutoplayFailed.\n\n  Please refer to the Agora document to migrate the newer API, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web .") : jC.warning("We have detected a media autoplay failed event, and found out that you haven't implemented AgoraRTC.onAutoplayFailed callback yet.\n\n  It will cause audio/video element not playing automatically on some browsers without user interaction, possibly hurting user experiences.\n\n  Please refer to the Agora document to properly handle autoplay failed event, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web ."), Ub.emit("autoplay-failed");
        }
      }
      function Vb(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function Fb(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Vb(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : Vb(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      function Bb(e2, t2, i2, n2) {
        if (!e2) return;
        const r2 = eI.getBaseInfoBySessionId(e2);
        if (!r2) return;
        const s2 = r2.info, o2 = Date.now(), a2 = Fb(Fb({}, s2), {}, { vid: void 0 === s2.vid ? 0 : Number(s2.vid), lts: o2, elapse: o2 - r2.startTime, cbRegistered: Ub.onAutoplayFailed || Ub.onAudioAutoplayFailed ? 1 : -1, errorMsg: i2, mediaType: t2, trackId: n2, extend: void 0 });
        eI.send({ type: qC.AUTOPLAY_FAILED, data: a2 }, true);
      }
      const jb = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "error"], Gb = new class {
        constructor() {
          sh(this, "onAutoplayFailed", void 0), sh(this, "elementMap", /* @__PURE__ */ new Map()), sh(this, "elementStateMap", /* @__PURE__ */ new Map()), sh(this, "elementsNeedToResume", []), sh(this, "sinkIdMap", /* @__PURE__ */ new Map()), sh(this, "autoResumeAfterInterruption", (e2) => {
            Array.from(this.elementMap.entries()).forEach((t2) => {
              let [i2, n2] = t2;
              const r2 = this.elementStateMap.get(i2), s2 = n2.srcObject.getAudioTracks()[0], o2 = s2 && s2.readyState;
              if (jC.debug("resume after interrupted, ele: ".concat(r2, " audio: ").concat(o2, " ").concat(e2)), "live" === o2) {
                if (e2) return n2.pause(), void n2.play();
                if ("running" === _b.curState) return Mg() ? (n2.pause(), void n2.play()) : void (r2 && "paused" === r2 && n2.play());
              }
            });
          }), sh(this, "autoResumeAfterInterruptionOnIOS15_16", () => {
            Array.from(this.elementMap.entries()).forEach((e2) => {
              let [t2, i2] = e2;
              const n2 = i2.srcObject.getAudioTracks()[0];
              n2 && "live" === n2.readyState && (jC.debug("auto resume after interruption inside autoResumeAfterInterruptionOnIOS15"), i2.pause(), i2.play());
            });
          }), this.autoResumeAudioElement(), _b.on(vA.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), _b.on(vA.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), _b.on(vA.STATE_CHANGE, () => {
            Og() && "suspended" === _b.prevState && "running" === _b.curState && this.autoResumeAfterInterruption();
          });
        }
        async setSinkID(e2, t2) {
          const i2 = this.elementMap.get(e2);
          if (this.sinkIdMap.set(e2, t2), i2) try {
            await i2.setSinkId(t2);
          } catch (e3) {
            throw new Kg(Hg.PERMISSION_DENIED, "can not set sink id: " + e3.toString());
          }
        }
        play(e2, t2, i2, n2) {
          if (this.elementMap.has(t2)) return;
          const r2 = document.createElement("audio");
          r2.autoplay = true, r2.srcObject = new MediaStream([e2]), this.bindAudioElementEvents(t2, r2), this.elementMap.set(t2, r2), this.elementStateMap.set(t2, sb.INIT), this.setVolume(t2, i2);
          const s2 = this.sinkIdMap.get(t2);
          if (s2) try {
            r2.setSinkId(s2).catch((e3) => {
              jC.warning("[".concat(t2, "] set sink id failed"), e3.toString());
            });
          } catch (e3) {
            jC.warning("[".concat(t2, "] set sink id failed"), e3.toString());
          }
          const o2 = r2.play();
          o2 && o2.then && o2.catch((e3) => {
            n2 && Bb(n2, "audio", e3.message, t2), jC.warning("audio element play warning", e3.toString()), this.elementMap.has(t2) && "NotAllowedError" === e3.name && (jC.warning("detected audio element autoplay failed"), this.elementsNeedToResume.push(r2), KT(() => {
              this.onAutoplayFailed && this.onAutoplayFailed(), xb();
            }));
          });
        }
        updateTrack(e2, t2) {
          const i2 = this.elementMap.get(e2);
          i2 && (i2.srcObject = new MediaStream([t2]));
        }
        isPlaying(e2) {
          return this.elementMap.has(e2) && "playing" === this.elementStateMap.get(e2);
        }
        setVolume(e2, t2) {
          const i2 = this.elementMap.get(e2);
          i2 && (t2 = Math.max(0, Math.min(100, t2)), i2.volume = t2 / 100);
        }
        stop(e2) {
          const t2 = this.elementMap.get(e2);
          if (this.sinkIdMap.delete(e2), !t2) return;
          const i2 = this.elementsNeedToResume.indexOf(t2);
          this.elementsNeedToResume.splice(i2, 1), t2.srcObject = null, t2.remove(), this.elementMap.delete(e2), this.elementStateMap.delete(e2);
        }
        bindAudioElementEvents(e2, t2) {
          jb.forEach((i2) => {
            t2.addEventListener(i2, (i3) => {
              const n2 = this.elementStateMap.get(e2), r2 = "pause" === i3.type ? "paused" : i3.type;
              if (jC.debug("[".concat(e2, "] audio-element-status change ").concat(n2, " => ").concat(r2)), "error" === i3.type) {
                const i4 = null == t2 ? void 0 : t2.error;
                i4 && jC.error("[".concat(e2, "] media error, code: ").concat(i4.code, ", message: ").concat(i4.message));
              }
              this.elementStateMap.set(e2, r2);
            });
          });
        }
        getPlayerState(e2) {
          return this.elementStateMap.get(e2) || "uninit";
        }
        autoResumeAudioElement() {
          const e2 = () => {
            this.elementsNeedToResume.forEach((e3) => {
              e3.play().then((e4) => {
                jC.debug("Auto resume audio element success");
              }).catch((e4) => {
                jC.warning("Auto resume audio element failed!", e4);
              });
            }), this.elementsNeedToResume = [];
          };
          new cg((e3) => {
            document.body ? e3() : window.addEventListener("load", () => e3());
          }).then(() => {
            Wg() ? document.body.addEventListener("click", e2, true) : (document.body.addEventListener("touchstart", e2, true), document.body.addEventListener("mousedown", e2, true));
          });
        }
      }();
      function Wb() {
        return function(e2, t2, i2) {
          const n2 = i2.value;
          return "function" == typeof n2 && (i2.value = function() {
            this._isClosed && new Kg(Hg.INVALID_OPERATION, "[".concat(this.getTrackId(), "] cannot operate a closed track")).print("warning", jC);
            for (var e3 = arguments.length, t3 = new Array(e3), i3 = 0; i3 < e3; i3++) t3[i3] = arguments[i3];
            const r2 = n2.apply(this, t3);
            return r2 instanceof cg ? new cg((e4, t4) => {
              r2.then(e4).catch(t4);
            }) : r2;
          }), i2;
        };
      }
      function Hb(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function Kb(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Hb(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : Hb(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class Yb extends dT {
        constructor(e2) {
          super(), sh(this, "name", "VideoProcessorDestination"), sh(this, "ID", "0"), sh(this, "_source", void 0), sh(this, "videoContext", void 0), sh(this, "inputTrack", void 0), this.videoContext = e2;
        }
        get kind() {
          return "video";
        }
        get enabled() {
          return true;
        }
        pipe() {
          throw new Kg(Hg.NOT_SUPPORTED, "VideoProcessor cannot pipe to any other Processor");
        }
        unpipe() {
          throw new Kg(Hg.NOT_SUPPORTED, "VideoProcessor cannot unpipe to any other Processor");
        }
        enable() {
        }
        disable() {
        }
        updateInput(e2) {
          if (e2.context !== this.videoContext) throw new Error("ProcessorContext passed to VideoTrack.processorDestination doesn't match it's belonging VideoTrack's context.\nProbably you are making pipeline like this:\nvideoTrack1.pipe(processor).pipe(videoTrack2.processorDestination).");
          e2.track && e2.track !== this.inputTrack && (this.videoContext.chained = true, this.inputTrack = e2.track, this.emit(tb.ON_TRACK, e2.track));
        }
        reset() {
          this.inputTrack = void 0, this.videoContext.chained = false, this.emit(tb.ON_TRACK, void 0);
        }
      }
      class qb extends dT {
        set chained(e2) {
          this._chained = e2;
        }
        get chained() {
          return this._chained;
        }
        constructor(e2, t2) {
          super(), sh(this, "constraintsMap", /* @__PURE__ */ new Map()), sh(this, "statsRegistry", []), sh(this, "usageRegistry", []), sh(this, "trackId", void 0), sh(this, "direction", void 0), sh(this, "_chained", false), this.trackId = e2, this.direction = t2;
        }
        async getConstraints() {
          return await vT(this, ib.REQUEST_CONSTRAINTS);
        }
        async requestApplyConstraints(e2, t2) {
          var i2;
          return jC.info("processor ".concat(t2.name, " requestApplyConstraints for ").concat(this.trackId)), e2 && this.constraintsMap.set(t2, e2), yT(this, ib.REQUEST_UPDATE_CONSTRAINTS, Array.from(NI(i2 = this.constraintsMap).call(i2)));
        }
        async requestRevertConstraints(e2) {
          var t2;
          if (this.constraintsMap.has(e2)) return jC.info("processor ".concat(e2.name, " requestRevertConstraints for ").concat(this.trackId)), this.constraintsMap.delete(e2), yT(this, ib.REQUEST_UPDATE_CONSTRAINTS, Array.from(NI(t2 = this.constraintsMap).call(t2)));
        }
        registerStats(e2, t2, i2) {
          this.statsRegistry.find((i3) => i3.processorID === e2.ID && i3.processorName === e2.name && i3.type === t2) || this.statsRegistry.push({ processorName: e2.name, processorID: e2.ID, type: t2, cb: i2 });
        }
        unregisterStats(e2, t2) {
          const i2 = this.statsRegistry.findIndex((i3) => i3.processorID === e2.ID && i3.processorName === e2.name && i3.type === t2);
          -1 !== i2 && this.statsRegistry.splice(i2, 1);
        }
        gatherStats() {
          const e2 = [];
          for (const { processorID: t2, processorName: i2, type: n2, cb: r2 } of this.statsRegistry) try {
            const s2 = r2();
            e2.push({ processorID: t2, processorName: i2, type: n2, stats: s2 });
          } catch (e3) {
            jC.error(new Kg(Hg.UNEXPECTED_ERROR, e3.message));
          }
          return e2;
        }
        registerUsage(e2, t2) {
          this.usageRegistry.find((t3) => t3.processorID === e2.ID && t3.processorName === e2.name) || this.usageRegistry.push({ processorID: e2.ID, processorName: e2.name, cb: t2 });
        }
        unregisterUsage(e2) {
          const t2 = this.usageRegistry.findIndex((t3) => t3.processorID === e2.ID && t3.processorName === e2.name);
          -1 !== t2 && this.usageRegistry.splice(t2, 1);
        }
        async gatherUsage() {
          const e2 = [];
          if (!this.chained) return [];
          for (const { cb: t2 } of this.usageRegistry) try {
            let i2 = t2();
            i2 instanceof cg && (i2 = await i2), e2.push(Kb(Kb({}, i2), {}, { direction: this.direction }));
          } catch (e3) {
            jC.error("gather extension usage error", e3);
          }
          return e2;
        }
        getDirection() {
          return this.direction;
        }
      }
      class zb extends dT {
        constructor(e2) {
          super(), sh(this, "name", "AudioProcessorDestination"), sh(this, "ID", "0"), sh(this, "inputTrack", void 0), sh(this, "inputNode", void 0), sh(this, "audioProcessorContext", void 0), sh(this, "_source", void 0), this.audioProcessorContext = e2;
        }
        get kind() {
          return "audio";
        }
        get enabled() {
          return true;
        }
        pipe() {
          throw new Kg(Hg.NOT_SUPPORTED, "AudioProcessorDestination cannot pipe to any other Processor");
        }
        unpipe() {
          throw new Kg(Hg.NOT_SUPPORTED, "AudioProcessor cannot unpipe to any other Processor");
        }
        enable() {
        }
        disable() {
        }
        reset() {
          this.inputTrack = void 0, this.inputNode = void 0, this.audioProcessorContext.chained = false, this.emit(tb.ON_TRACK, void 0), this.emit(tb.ON_NODE, void 0);
        }
        updateInput(e2) {
          if (e2.context !== this.audioProcessorContext) throw new Error("ProcessorContext passed to AudioTrack.processorDestination doesn't match it's belonging AudioTrack's context.\n        Probably you are making pipeline like this: audioTrack1.pipe(processor).pipe(audioTrack2.processorDestination).");
          e2.track && this.inputTrack !== e2.track && (this.audioProcessorContext.chained = true, this.inputTrack = e2.track, this.emit(tb.ON_TRACK, this.inputTrack)), e2.node && this.inputNode !== e2.node && (this.audioProcessorContext.chained = true, this.inputNode = e2.node, this.emit(tb.ON_NODE, this.inputNode));
        }
      }
      class Jb extends dT {
        set chained(e2) {
          this._chained = e2;
        }
        get chained() {
          return this._chained;
        }
        constructor(e2, t2, i2) {
          super(), sh(this, "constraintsMap", /* @__PURE__ */ new Map()), sh(this, "statsRegistry", []), sh(this, "audioContext", void 0), sh(this, "trackId", void 0), sh(this, "direction", void 0), sh(this, "usageRegistry", []), sh(this, "_chained", false), this.audioContext = e2, this.trackId = t2, this.direction = i2;
        }
        async getConstraints() {
          return vT(this, ib.REQUEST_CONSTRAINTS);
        }
        getAudioContext() {
          return this.audioContext;
        }
        async requestApplyConstraints(e2, t2) {
          var i2;
          return jC.info("processor ".concat(t2.name, " requestApplyConstraints for ").concat(this.trackId)), e2 && this.constraintsMap.set(t2, e2), yT(this, ib.REQUEST_UPDATE_CONSTRAINTS, Array.from(NI(i2 = this.constraintsMap).call(i2)));
        }
        async requestRevertConstraints(e2) {
          var t2;
          if (this.constraintsMap.has(e2)) return this.constraintsMap.delete(e2), yT(this, ib.REQUEST_UPDATE_CONSTRAINTS, Array.from(NI(t2 = this.constraintsMap).call(t2)));
        }
        registerStats(e2, t2, i2) {
          this.statsRegistry.find((i3) => i3.processorID === e2.ID && i3.processorName === e2.name && i3.type === t2) || this.statsRegistry.push({ processorName: e2.name, processorID: e2.ID, type: t2, cb: i2 });
        }
        unregisterStats(e2, t2) {
          const i2 = this.statsRegistry.findIndex((i3) => i3.processorID === e2.ID && i3.processorName === e2.name && i3.type === t2);
          -1 !== i2 && this.statsRegistry.splice(i2, 1);
        }
        gatherStats() {
          const e2 = [];
          for (const { processorID: t2, processorName: i2, type: n2, cb: r2 } of this.statsRegistry) try {
            const s2 = r2();
            e2.push({ processorID: t2, processorName: i2, type: n2, stats: s2 });
          } catch (e3) {
            jC.error(new Kg(Hg.UNEXPECTED_ERROR, e3.message));
          }
          return e2;
        }
        registerUsage(e2, t2) {
          this.usageRegistry.find((t3) => t3.processorID === e2.ID && t3.processorName === e2.name) || this.usageRegistry.push({ processorID: e2.ID, processorName: e2.name, cb: t2 });
        }
        unregisterUsage(e2) {
          const t2 = this.usageRegistry.findIndex((t3) => t3.processorID === e2.ID && t3.processorName === e2.name);
          -1 !== t2 && this.usageRegistry.splice(t2, 1);
        }
        async gatherUsage() {
          const e2 = [];
          if (!this.chained) return [];
          for (const { cb: t2 } of this.usageRegistry) try {
            let i2 = t2();
            i2 instanceof cg && (i2 = await i2), e2.push(Kb(Kb({}, i2), {}, { direction: this.direction }));
          } catch (e3) {
            jC.error("gather extension usage error", e3);
          }
          return e2;
        }
        getDirection() {
          return this.direction;
        }
      }
      class Xb extends dT {
        get isPlayed() {
          return true;
        }
        get isFreeze() {
          return false;
        }
        constructor() {
          super(), sh(this, "context", void 0), sh(this, "processSourceNode", void 0), sh(this, "outputTrack", void 0), sh(this, "processedNode", void 0), sh(this, "clonedTrack", void 0), sh(this, "outputNode", void 0), this.outputNode = new Qb();
        }
        setVolume() {
        }
        createOutputTrack() {
          throw new Kg(Hg.NOT_SUPPORTED, "can not create output MediaStreamTrack when WebAudio disabled");
        }
        getOriginVolumeLevel() {
          return 0;
        }
        getAccurateVolumeLevel() {
          return 0;
        }
        stopGetAudioBuffer() {
        }
        startGetAudioBuffer() {
        }
        play() {
        }
        stop() {
        }
        destroy() {
        }
        updateTrack() {
        }
        updateOriginTrack() {
        }
        createMediaStreamSourceNode() {
        }
      }
      class Qb {
        disconnect() {
        }
        connect() {
        }
      }
      function Zb(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function $b(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Zb(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : Zb(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class ew extends lb {
        get _source() {
          return this.initWebAudio();
        }
        set _source(e2) {
          this._trackSource = e2;
        }
        get processorContext() {
          return this._processorContext || (this._processorContext = this.initProcessor().processorContext), this._processorContext;
        }
        get processorDestination() {
          return this._processorDestination || (this._processorDestination = this.initProcessor().processorDestination), this._processorDestination;
        }
        get isPlaying() {
          return this._useAudioElement ? Gb.isPlaying(this.getTrackId()) : this._source.isPlayed;
        }
        get __className__() {
          return "LocalAudioTrack";
        }
        constructor(e2, t2, i2, n2) {
          super(e2, i2), sh(this, "trackMediaType", "audio"), sh(this, "_encoderConfig", void 0), sh(this, "_trackSource", void 0), sh(this, "_enabled", true), sh(this, "_volume", 100), sh(this, "_useAudioElement", true), sh(this, "_bypassWebAudio", false), sh(this, "processor", void 0), sh(this, "_processorContext", void 0), sh(this, "_processorDestination", void 0), sh(this, "_getOriginVolumeLevel", void 0), this._encoderConfig = t2, this._getOriginVolumeLevel = !!n2, this._trackSource = new Xb(), RC("DISABLE_WEBAUDIO") && (this._bypassWebAudio = true), RC("LOCAL_AUDIO_TRACK_USES_WEB_AUDIO") && (this._useAudioElement = false);
          bg() && !pb ? setTimeout(() => this.initWebAudio()) : this.initWebAudio();
        }
        setVolume(e2) {
          zg(e2, "volume", 0, 1e3), this._volume = e2, this._source.setVolume(e2 / 100), this._useAudioElement && Gb.setVolume(this.getTrackId(), e2);
          try {
            if (this._bypassWebAudio) return void jC.debug("[".concat(this.getTrackId(), "] setVolume returned because no pass through WebAudio."));
            const e3 = this._source.createOutputTrack();
            this._mediaStreamTrack !== e3 && (this._mediaStreamTrack = e3, yT(this, BA.NEED_REPLACE_TRACK, this).then(() => {
              jC.debug("[".concat(this.getTrackId(), "] replace web audio track success"));
            }).catch((e4) => {
              jC.warning("[".concat(this.getTrackId(), "] replace web audio track failed"), e4);
            }));
          } catch (e3) {
          }
        }
        getVolumeLevel() {
          return this._muted && this.enabled && this._getOriginVolumeLevel ? this._source.getOriginVolumeLevel() : this._source.getAccurateVolumeLevel();
        }
        async setPlaybackDevice(e2) {
          if (!this._useAudioElement || !Ag() && RC("RESTRICTION_SET_PLAYBACK_DEVICE")) throw new Kg(Hg.NOT_SUPPORTED, "your browser does not support setting the audio output device");
          await Gb.setSinkID(this.getTrackId(), e2);
        }
        async setEnabled(e2, t2, i2) {
          return this._setEnabled(e2, t2, i2);
        }
        async _setEnabled(e2, t2, i2) {
          if (!i2) {
            if (e2 === this._enabled) return;
            this.stateCheck("enabled", e2);
          }
          if (jC.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), e2) {
            this._originMediaStreamTrack.enabled = true;
            try {
              i2 || (this._enabled = true), await yT(this, BA.NEED_ENABLE_TRACK, this), jC.info("[".concat(this.getTrackId(), "] setEnabled to ").concat(e2, " success"));
            } catch (e3) {
              throw i2 || (this._enabled = false), jC.error("[".concat(this.getTrackId(), "] setEnabled to true error"), e3.toString()), e3;
            }
          } else {
            this._originMediaStreamTrack.enabled = false, i2 || (this._enabled = false);
            try {
              await yT(this, BA.NEED_DISABLE_TRACK, this);
            } catch (e3) {
              throw i2 || (this._enabled = true), jC.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e3.toString()), e3;
            }
          }
        }
        async setMuted(e2) {
          e2 !== this._muted && (this.stateCheck("muted", e2), this._muted = e2, this._originMediaStreamTrack.enabled = !e2, jC.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e2)), e2 ? await yT(this, BA.NEED_MUTE_TRACK, this) : await yT(this, BA.NEED_UNMUTE_TRACK, this));
        }
        getStats() {
          JT(() => {
            jC.warning("[deprecated] LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead");
          }, "localAudioTrackGetStatsWarning");
          const e2 = AT(this, BA.GET_STATS);
          return e2 || $b({}, XA);
        }
        setAudioFrameCallback(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;
          if (!e2) return this._source.removeAllListeners(zA.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
          this._source.startGetAudioBuffer(t2), this._source.removeAllListeners(zA.ON_AUDIO_BUFFER), this._source.on(zA.ON_AUDIO_BUFFER, (t3) => e2(t3));
        }
        play() {
          jC.debug("[".concat(this.getTrackId(), "] start audio playback")), this._useAudioElement ? (jC.debug("[".concat(this.getTrackId(), "] start audio playback in element")), Gb.play(this._mediaStreamTrack, this.getTrackId(), this._volume)) : this._source.play();
        }
        stop() {
          jC.debug("[".concat(this.getTrackId(), "] stop audio playback")), this._useAudioElement ? Gb.stop(this.getTrackId()) : this._source.stop();
        }
        close() {
          super.close(), this._processorDestination && this.unbindProcessorDestinationEvents(this._processorDestination), this._processorContext && this.unbindProcessorContextEvents(this._processorContext), this.unpipe(), this._processorDestination && this._processorDestination._source && this._processorDestination._source.unpipe(), this._source.destroy();
        }
        _updatePlayerSource() {
          let e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
          jC.debug("[".concat(this.getTrackId(), "] update player source track")), e2 && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && Gb.updateTrack(this.getTrackId(), this._mediaStreamTrack);
        }
        async _updateOriginMediaStreamTrack(e2, t2) {
          this._originMediaStreamTrack !== e2 && (this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), t2 && this._originMediaStreamTrack.stop()), e2.addEventListener("ended", this._handleTrackEnded), this._originMediaStreamTrack = e2, this._muted && (this._originMediaStreamTrack.enabled = false), this.processor && this._processorContext && this.processor.updateInput({ track: e2, context: this._processorContext }), this._mediaStreamTrack !== this._source.outputTrack ? (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await yT(this, BA.NEED_REPLACE_TRACK, this)) : this._source.updateTrack(this._originMediaStreamTrack), this._getOriginVolumeLevel && this._source.updateOriginTrack(e2));
        }
        renewMediaStreamTrack(e2) {
          return cg.resolve(void 0);
        }
        pipe(e2) {
          if (this._bypassWebAudio) throw new Kg(Hg.INVALID_OPERATION, "Can not process AudioTrack when bypassWebAudio set to true.");
          if (this.processor === e2) return e2;
          if (e2._source) throw new Kg(Hg.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), e2;
        }
        unpipe() {
          var e2;
          if (!this.processor) return;
          const t2 = this.processor;
          null === (e2 = this._source.processSourceNode) || void 0 === e2 || e2.disconnect(), this.processor._source = false, this.processor = void 0, t2.reset();
        }
        bindProcessorDestinationEvents(e2) {
          e2.on(tb.ON_TRACK, async (e3) => {
            e3 ? e3 !== this._mediaStreamTrack && (this._mediaStreamTrack = e3, this._updatePlayerSource(false), this._source.processedNode = this._source.createMediaStreamSourceNode(e3), await yT(this, BA.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await yT(this, BA.NEED_REPLACE_TRACK, this));
          }), e2.on(tb.ON_NODE, (e3) => {
            this._source.processedNode = e3;
          });
        }
        unbindProcessorDestinationEvents(e2) {
          e2.removeAllListeners(tb.ON_TRACK), e2.removeAllListeners(tb.ON_NODE);
        }
        bindProcessorContextEvents(e2) {
          e2.on(ib.REQUEST_CONSTRAINTS, async (e3) => {
            e3(this._originMediaStreamTrack.getSettings());
          });
        }
        unbindProcessorContextEvents(e2) {
          e2.removeAllListeners(ib.REQUEST_CONSTRAINTS);
        }
        initWebAudio() {
          return this._trackSource instanceof Xb && (this._trackSource = new Cb(this._mediaStreamTrack, false, this._getOriginVolumeLevel ? this._mediaStreamTrack : void 0)), this._trackSource;
        }
        initProcessor() {
          const e2 = new Jb(this._source.context, this.getTrackId(), "local"), t2 = new zb(e2);
          return this._processorContext = e2, this._processorDestination = t2, this.bindProcessorContextEvents(e2), this.bindProcessorDestinationEvents(t2), this._source.on(zA.UPDATE_SOURCE, () => {
            this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: e2 });
          }), this._useAudioElement && (this._useAudioElement = false, this.isPlaying && (Gb.stop(this.getTrackId()), this._source.play()), yT(this, BA.NEED_REPLACE_MIXING_TRACK, this).then(() => {
            jC.debug("[".concat(this.getTrackId(), "] replace from origin track to web audio track success"));
          }).catch((e3) => {
            jC.warning("[".concat(this.getTrackId(), "] replace from origin track to web audio track failed"), e3);
          })), { processorContext: e2, processorDestination: t2 };
        }
      }
      DI([$C({ argsMap: (e2, t2) => [e2.getTrackId(), t2], throttleTime: 300 }), PI("design:type", Function), PI("design:paramtypes", [Number]), PI("design:returntype", void 0)], ew.prototype, "setVolume", null), DI([$C({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), Wb(), PI("design:type", Function), PI("design:paramtypes", [String]), PI("design:returntype", cg)], ew.prototype, "setPlaybackDevice", null), DI([_S("LocalAudioTrack", "_enabledMutex"), $C({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), Wb(), PI("design:type", Function), PI("design:paramtypes", [Boolean, Object, Boolean]), PI("design:returntype", cg)], ew.prototype, "setEnabled", null), DI([_S("LocalAudioTrack", "_enabledMutex"), $C({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), Wb(), PI("design:type", Function), PI("design:paramtypes", [Boolean]), PI("design:returntype", cg)], ew.prototype, "setMuted", null), DI([Wb(), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", Object)], ew.prototype, "getStats", null), DI([Wb(), PI("design:type", Function), PI("design:paramtypes", [Object, Number]), PI("design:returntype", void 0)], ew.prototype, "setAudioFrameCallback", null), DI([$C({ argsMap: (e2) => [e2.getTrackId()] }), Wb(), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], ew.prototype, "play", null), DI([$C({ argsMap: (e2) => [e2.getTrackId()] }), Wb(), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], ew.prototype, "stop", null), DI([$C({ argsMap: (e2) => [e2.getTrackId()] }), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], ew.prototype, "close", null), DI([$C({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), PI("design:type", Function), PI("design:paramtypes", [Object]), PI("design:returntype", Object)], ew.prototype, "pipe", null), DI([$C({ argsMap: (e2) => [e2.getTrackId()] }), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], ew.prototype, "unpipe", null);
      class tw extends ew {
        get __className__() {
          return "MicrophoneAudioTrack";
        }
        constructor(e2, t2, i2, n2) {
          super(e2, t2.encoderConfig ? xA(t2.encoderConfig) : {}, n2, RC("GET_VOLUME_OF_MUTED_AUDIO_TRACK")), sh(this, "_config", void 0), sh(this, "_deviceName", "default"), sh(this, "_constraints", void 0), sh(this, "_originalConstraints", void 0), sh(this, "_enabled", true), this._config = t2, this._constraints = i2, this._originalConstraints = i2, this._deviceName = e2.label, "boolean" == typeof t2.bypassWebAudio && (this._bypassWebAudio = t2.bypassWebAudio), (Mg() || Ug()) && _b.bindInterruptDetectorTrack(this);
        }
        async setDevice(e2) {
          if (jC.info("[".concat(this.getTrackId(), "] start set device to ").concat(e2)), this._enabled) try {
            const t2 = await kb.getDeviceById(e2), i2 = {};
            i2.audio = $b({}, this._constraints), i2.audio.deviceId = { exact: e2 }, this._originMediaStreamTrack.stop();
            let n2 = null;
            try {
              n2 = await Nb(i2, this.getTrackId());
            } catch (e3) {
              throw jC.error("[".concat(this.getTrackId(), "] setDevice failed"), e3.toString()), n2 = await Nb({ audio: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(n2.getAudioTracks()[0], false), e3;
            }
            await this._updateOriginMediaStreamTrack(n2.getAudioTracks()[0], false), this._deviceName = t2.label, this._config.microphoneId = e2, this._constraints.deviceId = { exact: e2 };
          } catch (e3) {
            throw jC.error("[".concat(this.getTrackId(), "] setDevice error"), e3.toString()), e3;
          }
          else try {
            const t2 = await kb.getDeviceById(e2);
            this._deviceName = t2.label, this._config.microphoneId = e2, this._constraints.deviceId = { exact: e2 };
          } catch (e3) {
            throw jC.error("[".concat(this.getTrackId(), "] setDevice error"), e3.toString()), e3;
          }
          jC.info("[".concat(this.getTrackId(), "] set device to ").concat(e2, " success"));
        }
        async setEnabled(e2, t2, i2) {
          if (t2) return jC.debug("[".concat(this.getTrackId(), "] setEnabled false (do not close microphone)")), await super._setEnabled(e2);
          if (!i2) {
            if (e2 === this._enabled) return;
            this.stateCheck("enabled", e2);
          }
          if (jC.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), !e2) {
            var n2;
            this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop(), null === (n2 = this._source.clonedTrack) || void 0 === n2 || n2.stop(), i2 || (this._enabled = false);
            try {
              await yT(this, BA.NEED_DISABLE_TRACK, this);
            } catch (e3) {
              throw jC.error("[".concat(this.getTrackId(), "] setEnabled false failed"), e3.toString()), e3;
            }
            return;
          }
          const r2 = $b({}, this._constraints), s2 = kb.searchDeviceIdByName(this._deviceName);
          s2 && !r2.deviceId && (r2.deviceId = s2);
          try {
            i2 || (this._enabled = true);
            const e3 = await Nb({ audio: this._constraints }, this.getTrackId());
            await this._updateOriginMediaStreamTrack(e3.getAudioTracks()[0], false), await yT(this, BA.NEED_ENABLE_TRACK, this);
          } catch (e3) {
            throw i2 || (this._enabled = false), jC.error("[".concat(this.getTrackId(), "] setEnabled true failed"), e3.toString()), e3;
          }
          jC.info("[".concat(this.getTrackId(), "] setEnabled success"));
        }
        close() {
          super.close(), (Mg() || Ug()) && _b.unbindInterruptDetectorTrack(this);
        }
        onTrackEnded() {
          if ((Og() || Vg()) && this._enabled && !this._isClosed && _b.duringInterruption) {
            const e2 = async () => {
              _b.off(vA.IOS_INTERRUPTION_END, e2), this._enabled && !this._isClosed && (jC.debug("[".concat(this.getTrackId(), "] try capture microphone media device for interrupted iOS device.")), await this.setEnabled(false), await this.setEnabled(true));
            };
            _b.on(vA.IOS_INTERRUPTION_END, e2);
          } else jC.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(YA.TRACK_ENDED);
        }
        async renewMediaStreamTrack(e2) {
          const t2 = e2 || this._constraints, i2 = kb.searchDeviceIdByName(this._deviceName);
          if (i2 && !t2.deviceId && (t2.deviceId = i2), this._constraints = t2, this._enabled) {
            this._originMediaStreamTrack.stop();
            const e3 = await Nb({ audio: this._constraints }, this.getTrackId());
            await this._updateOriginMediaStreamTrack(e3.getAudioTracks()[0], true);
          }
        }
        bindProcessorContextEvents(e2) {
          super.bindProcessorContextEvents(e2), e2.on(ib.REQUEST_UPDATE_CONSTRAINTS, async (e3, t2, i2) => {
            try {
              const i3 = Object.assign({}, this._originalConstraints, ...e3);
              await this.renewMediaStreamTrack(i3), t2();
            } catch (e4) {
              i2(e4);
            }
          });
        }
        unbindProcessorContextEvents(e2) {
          super.unbindProcessorContextEvents(e2), e2.removeAllListeners(ib.REQUEST_UPDATE_CONSTRAINTS);
        }
      }
      DI([$C({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), Wb(), PI("design:type", Function), PI("design:paramtypes", [String]), PI("design:returntype", cg)], tw.prototype, "setDevice", null), DI([_S("MicrophoneAudioTrack", "_enabledMutex"), $C({ argsMap: (e2, t2, i2) => [e2.getTrackId(), t2, i2] }), Wb(), PI("design:type", Function), PI("design:paramtypes", [Boolean, Boolean, Boolean]), PI("design:returntype", cg)], tw.prototype, "setEnabled", null), DI([$C({ argsMap: (e2) => [e2.getTrackId()] }), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], tw.prototype, "close", null);
      class iw extends ew {
        get __className__() {
          return "BufferSourceAudioTrack";
        }
        constructor(e2, t2, i2, n2) {
          super(t2.createOutputTrack(), i2, n2), sh(this, "source", void 0), sh(this, "_bufferSource", void 0), this._useAudioElement = false, this.source = e2, this._bufferSource = t2, this._bufferSource.on(zA.AUDIO_SOURCE_STATE_CHANGE, (e3) => {
            this.safeEmit(YA.SOURCE_STATE_CHANGE, e3);
          });
          try {
            this._mediaStreamTrack = this._source.createOutputTrack();
          } catch (e3) {
          }
        }
        get currentState() {
          return this._bufferSource.currentState;
        }
        get duration() {
          return this._bufferSource.duration;
        }
        get playbackSpeed() {
          return this._bufferSource.playbackSpeed;
        }
        getCurrentTime() {
          return this._bufferSource.currentTime;
        }
        startProcessAudioBuffer(e2) {
          e2 && this._bufferSource.updateOptions(e2), this._bufferSource.startProcessAudioBuffer();
        }
        pauseProcessAudioBuffer() {
          this._bufferSource.pauseProcessAudioBuffer();
        }
        seekAudioBuffer(e2) {
          this._bufferSource.seekAudioBuffer(e2);
        }
        resumeProcessAudioBuffer() {
          this._bufferSource.resumeProcessAudioBuffer();
        }
        stopProcessAudioBuffer() {
          this._bufferSource.stopProcessAudioBuffer();
        }
        close() {
          this.source = null, this._bufferSource.destroy(), super.close();
        }
        setAudioBufferPlaybackSpeed(e2) {
          zg(e2, "speed", 0), this._bufferSource.setAudioBufferPlaybackSpeed(e2);
        }
      }
      DI([$C({ argsMap: (e2, t2) => [e2.getTrackId(), t2, e2.duration] }), Wb(), PI("design:type", Function), PI("design:paramtypes", [Object]), PI("design:returntype", void 0)], iw.prototype, "startProcessAudioBuffer", null), DI([$C({ argsMap: (e2) => [e2.getTrackId()] }), Wb(), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], iw.prototype, "pauseProcessAudioBuffer", null), DI([$C({ argsMap: (e2) => [e2.getTrackId()] }), Wb(), PI("design:type", Function), PI("design:paramtypes", [Number]), PI("design:returntype", void 0)], iw.prototype, "seekAudioBuffer", null), DI([$C({ argsMap: (e2) => [e2.getTrackId()] }), Wb(), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], iw.prototype, "resumeProcessAudioBuffer", null), DI([$C({ argsMap: (e2) => [e2.getTrackId()] }), Wb(), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], iw.prototype, "stopProcessAudioBuffer", null), DI([$C({ argsMap: (e2) => [e2.getTrackId()] }), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], iw.prototype, "close", null), DI([$C({ argsMap: (e2) => [e2.getTrackId()] }), Wb(), PI("design:type", Function), PI("design:paramtypes", [Number]), PI("design:returntype", void 0)], iw.prototype, "setAudioBufferPlaybackSpeed", null);
      class nw extends ew {
        get __className__() {
          return "MixingAudioTrack";
        }
        get isActive() {
          for (const e2 of this.trackList) if (e2._enabled && !e2._isClosed && !e2.muted) return true;
          return false;
        }
        constructor() {
          const e2 = mb().createMediaStreamDestination();
          super(e2.stream.getAudioTracks()[0], void 0, nS(8, "track-mix-")), sh(this, "trackList", void 0), sh(this, "destNode", void 0), this._useAudioElement = false;
          try {
            this._mediaStreamTrack = this._source.createOutputTrack();
          } catch (e3) {
          }
          this.destNode = e2, this.trackList = [];
        }
        hasAudioTrack(e2) {
          return -1 !== this.trackList.indexOf(e2);
        }
        addAudioTrack(e2) {
          -1 === this.trackList.indexOf(e2) ? (jC.debug("add ".concat(e2.getTrackId(), " to mixing track")), e2._source.outputNode.connect(this.destNode), this.trackList.push(e2), this.updateEncoderConfig()) : jC.debug("track ".concat(e2.getTrackId(), " is already added"));
        }
        removeAudioTrack(e2) {
          if (-1 !== this.trackList.indexOf(e2)) {
            jC.debug("remove ".concat(e2.getTrackId(), " from mixing track"));
            try {
              e2._source.outputNode.disconnect(this.destNode);
            } catch (e3) {
            }
            WT(this.trackList, e2), this.updateEncoderConfig();
          }
        }
        updateEncoderConfig() {
          const e2 = {};
          this.trackList.forEach((t2) => {
            t2._encoderConfig && ((t2._encoderConfig.bitrate || 0) > (e2.bitrate || 0) && (e2.bitrate = t2._encoderConfig.bitrate), (t2._encoderConfig.sampleRate || 0) > (e2.sampleRate || 0) && (e2.sampleRate = t2._encoderConfig.sampleRate), (t2._encoderConfig.sampleSize || 0) > (e2.sampleSize || 0) && (e2.sampleSize = t2._encoderConfig.sampleSize), t2._encoderConfig.stereo && (e2.stereo = true));
          }), this._encoderConfig = e2;
        }
        _updateRtpTransceiver(e2) {
          this._rtpTransceiver !== e2 && (this._rtpTransceiver = e2, this.trackList.forEach((t2) => {
            t2 instanceof nw ? t2.emit(KA.TRANSCEIVER_UPDATED, e2) : t2._updateRtpTransceiver(e2);
          }));
        }
      }
      function rw(e2) {
        const t2 = {};
        e2.facingMode && (t2.facingMode = e2.facingMode), e2.cameraId && (t2.deviceId = { exact: e2.cameraId });
        const i2 = LA(e2.encoderConfig);
        return null != i2.width && (t2.width = i2.width), null != i2.height && (t2.height = i2.height), !Bg() && i2.frameRate && (t2.frameRate = i2.frameRate), Sg().name === Eg.EDGE && "object" == typeof t2.frameRate && (t2.frameRate.max = 60), wg() && (t2.frameRate = { ideal: 30, max: 30 }), t2;
      }
      function sw(e2) {
        const t2 = {};
        if (Bg() || (void 0 !== e2.AGC && (t2.autoGainControl = e2.AGC), void 0 !== e2.AEC && (t2.echoCancellation = e2.AEC), void 0 !== e2.ANS && (t2.noiseSuppression = e2.ANS, Ag() && e2.ANS && (t2.googHighpassFilter = e2.ANS))), e2.encoderConfig) {
          const i2 = xA(e2.encoderConfig);
          t2.channelCount = i2.stereo ? 2 : 1, t2.sampleRate = i2.sampleRate, t2.sampleSize = i2.sampleSize;
        }
        return e2.microphoneId && (t2.deviceId = { exact: e2.microphoneId }), Gg() && (t2.sampleRate = void 0), t2;
      }
      class ow extends Rb {
        set currentState(e2) {
          e2 !== this._currentState && (this._currentState = e2, this.safeEmit(zA.AUDIO_SOURCE_STATE_CHANGE, this._currentState));
        }
        get currentState() {
          return this._currentState;
        }
        constructor(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          super(), sh(this, "audioBuffer", void 0), sh(this, "sourceNode", void 0), sh(this, "startPlayTime", 0), sh(this, "startPlayOffset", 0), sh(this, "pausePlayTime", 0), sh(this, "options", void 0), sh(this, "currentLoopCount", 0), sh(this, "currentPlaybackSpeed", 100), sh(this, "_currentState", "stopped"), this.audioBuffer = e2, this.options = t2, this.startPlayOffset = this.options.startPlayTime || 0;
        }
        createWebAudioDiagram() {
          return this.context.createGain();
        }
        get duration() {
          return this.audioBuffer ? this.audioBuffer.duration : 0;
        }
        get playbackSpeed() {
          return this.currentPlaybackSpeed;
        }
        get currentTime() {
          return this.audioBuffer ? "stopped" === this.currentState ? 0 : "paused" === this.currentState ? this.pausePlayTime : ((this.context.currentTime - this.startPlayTime) * (this.playbackSpeed / 100) + this.startPlayOffset) % this.audioBuffer.duration : 0;
        }
        updateOptions(e2) {
          "stopped" === this.currentState ? (this.options = e2, this.startPlayOffset = this.options.startPlayTime || 0) : jC.warning("can not set audio source options");
        }
        startProcessAudioBuffer() {
          this.sourceNode && this.stopProcessAudioBuffer(), this.sourceNode = this.createSourceNode(), this.startSourceNode(), this.currentState = "playing";
        }
        pauseProcessAudioBuffer() {
          this.sourceNode && "playing" === this.currentState && (this.pausePlayTime = this.currentTime, this.sourceNode.onended = null, this.sourceNode.stop(), this.sourceNode.buffer = null, this.sourceNode = this.createSourceNode(), this.currentState = "paused");
        }
        seekAudioBuffer(e2) {
          this.sourceNode && (this.sourceNode.onended = null, "playing" === this.currentState && this.sourceNode.stop(), this.sourceNode = this.createSourceNode(), "playing" === this.currentState ? (this.startPlayOffset = e2, this.startSourceNode()) : "paused" === this.currentState && (this.pausePlayTime = e2));
        }
        resumeProcessAudioBuffer() {
          "paused" === this.currentState && this.sourceNode && (this.startPlayOffset = this.pausePlayTime, this.pausePlayTime = 0, this.startSourceNode(), this.currentState = "playing");
        }
        stopProcessAudioBuffer() {
          if (this.sourceNode) {
            this.sourceNode.onended = null;
            try {
              this.sourceNode.stop();
            } catch (e2) {
            }
            this.reset();
          }
        }
        destroy() {
          this.audioBuffer = null, super.destroy();
        }
        setAudioBufferPlaybackSpeed(e2) {
          this.sourceNode && ("playing" === this.currentState && (this.startPlayOffset = this.currentTime, this.startPlayTime = this.context.currentTime), this.sourceNode.playbackRate.value = e2 / 100), this.currentPlaybackSpeed = e2;
        }
        startSourceNode() {
          this.sourceNode && this.sourceNode.buffer && (this.sourceNode.start(0, this.startPlayOffset), this.startPlayTime = this.context.currentTime, this.sourceNode.onended = this.handleSourceNodeEnded.bind(this));
        }
        createSourceNode() {
          const e2 = this.context.createBufferSource();
          return e2.buffer = this.audioBuffer, e2.loop = !!this.options.loop, e2.connect(this.outputNode), e2.playbackRate.value = this.currentPlaybackSpeed / 100, e2;
        }
        handleSourceNodeEnded() {
          if (this.currentLoopCount += 1, this.options.cycle && this.options.cycle > this.currentLoopCount) return this.startPlayOffset = 0, this.sourceNode = void 0, void this.startProcessAudioBuffer();
          this.reset();
        }
        reset() {
          this.startPlayOffset = this.options.startPlayTime || 0, this.currentState = "stopped", this.sourceNode && (this.sourceNode.disconnect(), this.sourceNode = void 0), this.currentLoopCount = 0;
        }
      }
      const aw = /* @__PURE__ */ new Map();
      async function cw(e2, t2) {
        let i2 = null;
        if ("string" == typeof e2) {
          const t3 = aw.get(e2);
          if (t3) return jC.debug("use cached audio resource: ", e2), t3;
          try {
            i2 = (await fS(() => sC.get(e2, { responseType: "arraybuffer" }), void 0, void 0, { maxRetryCount: 3 })).data;
          } catch (e3) {
            throw new Kg(Hg.FETCH_AUDIO_FILE_FAILED, e3.toString());
          }
        } else {
          const t3 = new cg((t4, i3) => {
            const n3 = new FileReader();
            n3.onload = (e3) => {
              e3.target ? t4(e3.target.result) : i3(new Kg(Hg.READ_LOCAL_AUDIO_FILE_ERROR));
            }, n3.onerror = () => {
              i3(new Kg(Hg.READ_LOCAL_AUDIO_FILE_ERROR));
            }, n3.readAsArrayBuffer(e2);
          });
          i2 = await t3;
        }
        const n2 = await function(e3) {
          const t3 = mb();
          return new cg((i3, n3) => {
            t3.decodeAudioData(e3, (e4) => {
              i3(e4);
            }, (e4) => {
              n3(new Kg(Hg.DECODE_AUDIO_FILE_FAILED, e4.toString()));
            });
          });
        }(i2);
        return "string" == typeof e2 && t2 && aw.set(e2, n2), n2;
      }
      const dw = (e2) => {
        const t2 = document.createElement("canvas");
        return t2.width = 2, t2.height = 2, new cg((i2, n2) => {
          t2.toBlob(async (e3) => {
            if (t2.remove(), e3) {
              const n3 = await lw(e3);
              i2({ buffer: n3, width: t2.width, height: t2.height });
            } else n2(new Kg(Hg.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));
          }, e2, 1);
        });
      }, lw = async (e2) => {
        const t2 = await e2.arrayBuffer();
        return new Uint8Array(t2);
      };
      function uw(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function hw(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? uw(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : uw(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class pw {
        get videoElementStatus() {
          return this._videoElementStatus;
        }
        set videoElementStatus(e2) {
          e2 !== this._videoElementStatus && (jC.debug("[".concat(this.trackId, "] video-element-status change ").concat(this._videoElementStatus, " => ").concat(e2)), this._videoElementStatus = e2);
        }
        get videoState() {
          return this._videoState;
        }
        set videoState(e2) {
          var t2;
          e2 !== this._videoState && (jC.debug("[".concat(this.trackId, "] video-status change ").concat(this._videoState, " => ").concat(e2)), this._videoState = e2, null === (t2 = this.onVideoStateChanged) || void 0 === t2 || t2.call(this, this.videoState));
        }
        constructor(e2) {
          sh(this, "trackId", void 0), sh(this, "config", void 0), sh(this, "onFirstVideoFrameDecoded", void 0), sh(this, "onVideoStateChanged", void 0), sh(this, "freezeTimeCounterList", []), sh(this, "renderFreezeAccTime", 0), sh(this, "isKeepLastFrame", false), sh(this, "timeUpdatedCount", 0), sh(this, "freezeTime", 0), sh(this, "playbackTime", 0), sh(this, "lastTimeUpdatedTime", 0), sh(this, "autoplayFailed", false), sh(this, "videoTrack", void 0), sh(this, "videoElement", void 0), sh(this, "cacheVideoElement", void 0), sh(this, "_videoState", ob.VideoStateStopped), sh(this, "videoElementCheckInterval", void 0), sh(this, "videoElementFreezeTimeout", void 0), sh(this, "_videoElementStatus", sb.NONE), sh(this, "isGettingVideoDimensions", false), sh(this, "startGetVideoDimensions", () => {
            const e3 = () => {
              if (this.isGettingVideoDimensions = true, this.videoElement.videoWidth * this.videoElement.videoHeight > 4) return jC.debug("[".concat(this.trackId, "] current video dimensions:"), this.videoElement.videoWidth, this.videoElement.videoHeight), void (this.isGettingVideoDimensions = false);
              setTimeout(e3, 500);
            };
            !this.isGettingVideoDimensions && e3();
          }), sh(this, "autoResumeAfterInterruption", () => {
            this.videoTrack && "live" === this.videoTrack.readyState && "running" === _b.curState && (jC.debug("[track-".concat(this.trackId, "] video element paused, auto resume for ").concat(Cg())), xg() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play()));
          }), sh(this, "handleVideoEvents", (e3) => {
            switch (e3.type) {
              case "play":
              case "playing":
                this.startGetVideoDimensions(), this.videoElementStatus = sb.PLAYING;
                break;
              case "loadeddata":
                if (this.videoState = ob.VideoStateStarting, this.onFirstVideoFrameDecoded && this.onFirstVideoFrameDecoded(), this.cacheVideoElement) {
                  try {
                    this.cacheVideoElement.srcObject = null, this.cacheVideoElement.remove();
                  } catch (e4) {
                  }
                  this.cacheVideoElement = void 0;
                }
                break;
              case "canplay":
                this.videoElementStatus = sb.CANPLAY;
                break;
              case "stalled":
                this.videoElementStatus = sb.STALLED;
                break;
              case "suspend":
                this.videoElementStatus = sb.SUSPEND;
                break;
              case "pause":
                this.videoElementStatus = sb.PAUSED, Og() || Vg() || bg() && this.autoplayFailed || !this.videoTrack || "live" !== this.videoTrack.readyState || (jC.debug("[track-".concat(this.trackId, "] video element paused, auto resume")), this.videoElement.play());
                break;
              case "waiting":
                this.videoElementStatus = sb.WAITING;
                break;
              case "abort":
                this.videoElementStatus = sb.ABORT;
                break;
              case "ended":
                this.videoElementStatus = sb.ENDED;
                break;
              case "emptied":
                this.videoElementStatus = sb.EMPTIED;
                break;
              case "error": {
                this.videoElementStatus = sb.ERROR;
                const e4 = this.videoElement.error;
                e4 && jC.error("[".concat(this.trackId, "] media error, code: ").concat(e4.code, ", message: ").concat(e4.message));
                break;
              }
              case "timeupdate": {
                const e4 = performance.now();
                if (this.timeUpdatedCount += 1, this.timeUpdatedCount < 10) return void (this.lastTimeUpdatedTime = e4);
                const t2 = e4 - this.lastTimeUpdatedTime, i2 = this.lastTimeUpdatedTime;
                if (this.lastTimeUpdatedTime = e4, Dw.lastVisibleTime < Dw.lastHiddenTime || i2 < Dw.lastHiddenTime || i2 < Dw.lastVisibleTime) return;
                for (t2 > RC("VIDEO_FREEZE_DURATION") && (this.freezeTime += t2), this.playbackTime += t2; this.playbackTime >= 6e3; ) {
                  this.playbackTime -= 6e3;
                  const e5 = Math.min(6e3, this.freezeTime);
                  this.freezeTimeCounterList.push(e5), this.freezeTime = Math.max(0, this.freezeTime - 6e3);
                }
                break;
              }
            }
          }), sh(this, "autoResumeAfterInterruptionOnIOS15_16", () => {
            this.videoTrack && "live" === this.videoTrack.readyState && (jC.debug("[track-".concat(this.trackId, "] video element paused, auto resume for ").concat(Cg())), xg() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play()));
          }), this.trackId = e2.trackId, this.config = e2, e2.element instanceof HTMLVideoElement ? this.videoElement = e2.element : this.videoElement = document.createElement("video"), _b.on(vA.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), _b.on(vA.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16);
        }
        getVideoElement() {
          return this.videoElement;
        }
        getContainerElement() {
          var e2;
          return null !== (e2 = this.videoElement.parentElement) && void 0 !== e2 ? e2 : void 0;
        }
        updateConfig(e2) {
          this.config = e2, this.trackId = e2.trackId, e2.element !== this.videoElement && (this.destroy(), this.videoElement = e2.element), this.videoTrack && this.initVideoElement();
        }
        updateVideoTrack(e2) {
          this.videoTrack !== e2 && (this.videoTrack = e2, this.initVideoElement());
        }
        play(e2) {
          const t2 = this.videoElement.play();
          t2 && t2.catch && t2.catch((t3) => {
            e2 && Bb(e2, "video", t3.message, this.trackId), "NotAllowedError" === t3.name ? (jC.warning("detected video element autoplay failed", t3), this.autoplayFailed = true, this.handleAutoPlayFailed()) : jC.warning("[".concat(this.trackId, "] play warning: "), t3);
          });
          const i2 = Sg();
          if (("Safari" === i2.name && 15 === Number(i2.version) || Mg()) && t2 && t2.then) {
            const e3 = () => {
              this.config.mirror && (this.videoElement.style.transform = "rotateY(180deg)");
            };
            t2.then(e3).catch(e3);
          }
        }
        getCurrentFrame() {
          const e2 = document.createElement("canvas");
          e2.width = this.videoElement.videoWidth, e2.height = this.videoElement.videoHeight;
          const t2 = e2.getContext("2d");
          if (!t2) return jC.error("create canvas context failed!"), new ImageData(2, 2);
          t2.drawImage(this.videoElement, 0, 0, e2.width, e2.height);
          const i2 = t2.getImageData(0, 0, e2.width, e2.height);
          return e2.remove(), i2;
        }
        async getCurrentFrameToUint8Array(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
          const i2 = document.createElement("canvas");
          i2.width = this.videoElement.videoWidth, i2.height = this.videoElement.videoHeight;
          const n2 = i2.getContext("2d");
          return n2 ? (n2.drawImage(this.videoElement, 0, 0, i2.width, i2.height), new cg((n3, r2) => {
            i2.toBlob(async (e3) => {
              if (i2.remove(), e3) {
                const t3 = await lw(e3);
                n3({ buffer: t3, width: i2.width, height: i2.height });
              } else r2(new Kg(Hg.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));
            }, e2, t2 < 0 ? 0.1 : t2 > 1 ? 1 : t2);
          })) : await dw(e2);
        }
        destroy() {
          _b.off(vA.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), _b.off(vA.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), this.videoElement.srcObject = null, this.resetVideoElement(), this.freezeTimeCounterList = [], this.videoState = ob.VideoStateStopped;
        }
        initVideoElement() {
          if (this.videoElementStatus = sb.INIT, !this.videoElementCheckInterval && (_w.forEach((e3) => {
            this.videoElement.addEventListener(e3, this.handleVideoEvents);
          }), this.videoElementCheckInterval = window.setInterval(() => {
            (function(e3) {
              return e3 !== document.body && document.body.contains(e3);
            })(this.videoElement) || (this.videoElementStatus = sb.DESTROYED);
          }, 1e3), RC("ENABLE_VIDEO_FRAME_CALLBACK"))) {
            var e2, t2;
            let i3;
            const n3 = () => {
              "visible" === document.visibilityState && (document.removeEventListener("visibilitychange", n3), this.videoElementFreezeTimeout = window.setTimeout(r2, RC("VIDEO_FREEZE_DURATION")));
            }, r2 = () => {
              this.videoElementFreezeTimeout = void 0, this.videoState === ob.VideoStateDecoding && ("visible" === document.visibilityState ? this.videoState = ob.VideoStateFrozen : document.addEventListener("visibilitychange", n3));
            }, s2 = (e3, t3) => {
              if (this.videoElementStatus === sb.PLAYING) {
                if (i3) {
                  const e4 = t3.presentationTime - i3.presentationTime;
                  this.videoState === ob.VideoStateStarting && (this.videoState = ob.VideoStateDecoding), this.videoState === ob.VideoStateDecoding && this.onVideoStateChanged && (this.videoElementFreezeTimeout && window.clearTimeout(this.videoElementFreezeTimeout), this.videoElementFreezeTimeout = window.setTimeout(r2, RC("VIDEO_FREEZE_DURATION"))), e4 < RC("VIDEO_FREEZE_DURATION") && this.videoState === ob.VideoStateFrozen && (this.videoState = ob.VideoStateDecoding), e4 > RC("VIDEO_FREEZE_DURATION") && Dw.lastVisibleTime >= Dw.lastHiddenTime && i3.timestamp > Dw.lastVisibleTime && i3.timestamp > Dw.lastHiddenTime && (this.renderFreezeAccTime += e4);
                }
                i3 = hw(hw({}, t3), {}, { timestamp: e3 });
              }
              var n4, o2;
              RC("ENABLE_VIDEO_FRAME_CALLBACK") && (null === (n4 = (o2 = this.videoElement).requestVideoFrameCallback) || void 0 === n4 || n4.call(o2, s2));
            };
            null === (e2 = (t2 = this.videoElement).requestVideoFrameCallback) || void 0 === e2 || e2.call(t2, s2);
          }
          this.videoElement.controls = false, this.videoElement.setAttribute("playsinline", ""), Gg() && (this.videoElement.poster = "noposter");
          const i2 = Sg();
          if ("Safari" === i2.name && 15 === Number(i2.version) || Mg() || !this.config.mirror || (this.videoElement.style.transform = "rotateY(180deg)"), this.config.fit ? this.videoElement.style.objectFit = this.config.fit : this.videoElement.style.objectFit = "cover", this.videoElement.setAttribute("muted", ""), this.videoElement.muted = true, this.videoElement.srcObject && this.videoElement.srcObject instanceof MediaStream) {
            this.videoElement.srcObject.getVideoTracks()[0] !== this.videoTrack && (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, wg() && this.videoElement.load());
          } else this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, wg() && this.videoElement.load();
          const n2 = this.videoElement.play();
          void 0 !== n2 && n2.catch((e3) => {
            jC.debug("[".concat(this.trackId, "] playback interrupted"), e3.toString());
          });
        }
        resetVideoElement() {
          _w.forEach((e2) => {
            this.videoElement && this.videoElement.removeEventListener(e2, this.handleVideoEvents);
          }), this.videoElementCheckInterval && (window.clearInterval(this.videoElementCheckInterval), this.videoElementCheckInterval = void 0), this.videoElementStatus = sb.NONE;
        }
        handleAutoPlayFailed() {
          const e2 = (t2) => {
            t2.preventDefault(), this.videoElement.play().then(() => {
              jC.debug("[".concat(this.trackId, "] Video element for trackId:").concat(this.trackId, " autoplay resumed."));
            }).catch((e3) => {
              jC.error(e3);
            }), this.autoplayFailed = false, Wg() ? document.body.removeEventListener("click", e2, true) : (document.body.removeEventListener("touchstart", e2, true), document.body.removeEventListener("mousedown", e2, true));
          };
          Wg() ? document.body.addEventListener("click", e2, true) : (document.body.addEventListener("touchstart", e2, true), document.body.addEventListener("mousedown", e2, true)), xb();
        }
      }
      const _w = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "timeupdate", "error"];
      class Ew extends pw {
        constructor(e2) {
          super(e2), sh(this, "container", void 0), sh(this, "slot", void 0), this.slot = e2.element, this.updateConfig(e2);
        }
        updateConfig(e2) {
          this.config = e2, this.trackId = e2.trackId;
          const t2 = e2.element;
          t2 !== this.slot && (this.destroy(), this.slot = t2), this.createElements();
        }
        updateVideoTrack(e2) {
          this.videoTrack !== e2 && (this.videoTrack = e2, this.createElements());
        }
        play(e2) {
          var t2;
          null !== (t2 = this.container) && void 0 !== t2 && t2.contains(this.videoElement) && super.play(e2);
        }
        getCurrentFrame() {
          var e2;
          return null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement) ? super.getCurrentFrame() : new ImageData(2, 2);
        }
        async getCurrentFrameToUint8Array(e2) {
          var t2;
          let i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
          return null !== (t2 = this.container) && void 0 !== t2 && t2.contains(this.videoElement) ? await super.getCurrentFrameToUint8Array(e2, i2) : await dw(e2);
        }
        destroy() {
          if (super.destroy(), this.videoElement.remove(), this.videoElement = document.createElement("video"), this.container) {
            try {
              this.container.remove(), this.slot.removeChild(this.container);
            } catch (e2) {
            }
            this.container = void 0;
          }
        }
        createElements() {
          this.container || (this.container = document.createElement("div")), this.container.id = "agora-video-player-".concat(this.trackId), this.container.style.width = "100%", this.container.style.height = "100%", this.container.style.position = "relative", this.container.style.overflow = "hidden", this.videoTrack ? (this.container.style.backgroundColor = "black", RC("KEEP_LAST_FRAME") && this.isKeepLastFrame && this.videoElement.paused && this.resetVideoElement(), this.mountedVideoElement()) : this.unmountedVideoElement(), this.slot.appendChild(this.container);
        }
        mountedVideoElement() {
          var e2;
          !this.container || null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement) || this.container.appendChild(this.videoElement), super.initVideoElement(), this.videoElement.id = "video_".concat(this.trackId), this.videoElement.className = "agora_video_player", this.videoElement.style.width = "100%", this.videoElement.style.height = "100%", this.videoElement.style.position = "absolute", this.videoElement.style.left = "0", this.videoElement.style.top = "0";
        }
        unmountedVideoElement() {
          var e2;
          if (null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement)) {
            super.resetVideoElement();
            try {
              this.container && this.container.removeChild(this.videoElement);
            } catch (e3) {
            }
            this.videoElement = document.createElement("video");
          }
        }
        resetVideoElement() {
          var e2;
          null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement) && (super.resetVideoElement(), this.cacheVideoElement = this.videoElement, this.videoElement = document.createElement("video"));
        }
        getContainerElement() {
          return this.container;
        }
      }
      function mw(e2) {
        return new cg((t2, i2) => {
          let n2 = false;
          const r2 = document.createElement("video");
          r2.setAttribute("autoplay", ""), r2.setAttribute("muted", ""), r2.muted = true, r2.autoplay = true, r2.setAttribute("playsinline", ""), r2.setAttribute("style", "position: fixed; top: 0; left: 0; width: 1px; height: 1px"), document.body.appendChild(r2);
          const s2 = Og() ? "canplay" : "playing";
          r2.addEventListener(s2, () => {
            const e3 = r2.videoWidth, i3 = r2.videoHeight;
            !e3 && wg() || (n2 = true, r2.srcObject = null, r2.remove(), t2([e3, i3]));
          }), r2.srcObject = new MediaStream([e2]), r2.play().catch(sS), setTimeout(() => {
            n2 || (r2.srcObject = null, r2.remove(), t2([r2.videoWidth, r2.videoHeight]));
          }, 4e3);
        });
      }
      const fw = async (e2, t2, i2) => {
        const n2 = function(e3) {
          const t3 = [];
          for (let i3 = 0; i3 < e3.length; i3 += 2) t3.push(parseInt(e3.slice(i3, i3 + 2), 16));
          return Uint8Array.from(t3);
        }(function(e3) {
          const t3 = "0123456789abcdef";
          function i3(e4) {
            let i4, n4 = "";
            for (i4 = 0; i4 <= 3; i4++) n4 += t3.charAt(e4 >> 8 * i4 + 4 & 15) + t3.charAt(e4 >> 8 * i4 & 15);
            return n4;
          }
          function n3(e4, t4) {
            const i4 = (65535 & e4) + (65535 & t4);
            return (e4 >> 16) + (t4 >> 16) + (i4 >> 16) << 16 | 65535 & i4;
          }
          function r3(e4, t4, i4, r4, s4, o3) {
            return n3(function(e5, t5) {
              return e5 << t5 | e5 >>> 32 - t5;
            }(n3(n3(t4, e4), n3(r4, o3)), s4), i4);
          }
          function s3(e4, t4, i4, n4, s4, o3, a3) {
            return r3(t4 & i4 | ~t4 & n4, e4, t4, s4, o3, a3);
          }
          function o2(e4, t4, i4, n4, s4, o3, a3) {
            return r3(t4 & n4 | i4 & ~n4, e4, t4, s4, o3, a3);
          }
          function a2(e4, t4, i4, n4, s4, o3, a3) {
            return r3(t4 ^ i4 ^ n4, e4, t4, s4, o3, a3);
          }
          function c2(e4, t4, i4, n4, s4, o3, a3) {
            return r3(i4 ^ (t4 | ~n4), e4, t4, s4, o3, a3);
          }
          const d2 = function(e4) {
            let t4;
            const i4 = 1 + (e4.length + 8 >> 6), n4 = new Array(16 * i4);
            for (t4 = 0; t4 < 16 * i4; t4++) n4[t4] = 0;
            for (t4 = 0; t4 < e4.length; t4++) n4[t4 >> 2] |= e4.charCodeAt(t4) << t4 % 4 * 8;
            return n4[t4 >> 2] |= 128 << t4 % 4 * 8, n4[16 * i4 - 2] = 8 * e4.length, n4;
          }(e3);
          let l2, u2, h3, p2, _2, E2 = 1732584193, m2 = -271733879, f2 = -1732584194, g2 = 271733878;
          for (l2 = 0; l2 < d2.length; l2 += 16) u2 = E2, h3 = m2, p2 = f2, _2 = g2, E2 = s3(E2, m2, f2, g2, d2[l2 + 0], 7, -680876936), g2 = s3(g2, E2, m2, f2, d2[l2 + 1], 12, -389564586), f2 = s3(f2, g2, E2, m2, d2[l2 + 2], 17, 606105819), m2 = s3(m2, f2, g2, E2, d2[l2 + 3], 22, -1044525330), E2 = s3(E2, m2, f2, g2, d2[l2 + 4], 7, -176418897), g2 = s3(g2, E2, m2, f2, d2[l2 + 5], 12, 1200080426), f2 = s3(f2, g2, E2, m2, d2[l2 + 6], 17, -1473231341), m2 = s3(m2, f2, g2, E2, d2[l2 + 7], 22, -45705983), E2 = s3(E2, m2, f2, g2, d2[l2 + 8], 7, 1770035416), g2 = s3(g2, E2, m2, f2, d2[l2 + 9], 12, -1958414417), f2 = s3(f2, g2, E2, m2, d2[l2 + 10], 17, -42063), m2 = s3(m2, f2, g2, E2, d2[l2 + 11], 22, -1990404162), E2 = s3(E2, m2, f2, g2, d2[l2 + 12], 7, 1804603682), g2 = s3(g2, E2, m2, f2, d2[l2 + 13], 12, -40341101), f2 = s3(f2, g2, E2, m2, d2[l2 + 14], 17, -1502002290), m2 = s3(m2, f2, g2, E2, d2[l2 + 15], 22, 1236535329), E2 = o2(E2, m2, f2, g2, d2[l2 + 1], 5, -165796510), g2 = o2(g2, E2, m2, f2, d2[l2 + 6], 9, -1069501632), f2 = o2(f2, g2, E2, m2, d2[l2 + 11], 14, 643717713), m2 = o2(m2, f2, g2, E2, d2[l2 + 0], 20, -373897302), E2 = o2(E2, m2, f2, g2, d2[l2 + 5], 5, -701558691), g2 = o2(g2, E2, m2, f2, d2[l2 + 10], 9, 38016083), f2 = o2(f2, g2, E2, m2, d2[l2 + 15], 14, -660478335), m2 = o2(m2, f2, g2, E2, d2[l2 + 4], 20, -405537848), E2 = o2(E2, m2, f2, g2, d2[l2 + 9], 5, 568446438), g2 = o2(g2, E2, m2, f2, d2[l2 + 14], 9, -1019803690), f2 = o2(f2, g2, E2, m2, d2[l2 + 3], 14, -187363961), m2 = o2(m2, f2, g2, E2, d2[l2 + 8], 20, 1163531501), E2 = o2(E2, m2, f2, g2, d2[l2 + 13], 5, -1444681467), g2 = o2(g2, E2, m2, f2, d2[l2 + 2], 9, -51403784), f2 = o2(f2, g2, E2, m2, d2[l2 + 7], 14, 1735328473), m2 = o2(m2, f2, g2, E2, d2[l2 + 12], 20, -1926607734), E2 = a2(E2, m2, f2, g2, d2[l2 + 5], 4, -378558), g2 = a2(g2, E2, m2, f2, d2[l2 + 8], 11, -2022574463), f2 = a2(f2, g2, E2, m2, d2[l2 + 11], 16, 1839030562), m2 = a2(m2, f2, g2, E2, d2[l2 + 14], 23, -35309556), E2 = a2(E2, m2, f2, g2, d2[l2 + 1], 4, -1530992060), g2 = a2(g2, E2, m2, f2, d2[l2 + 4], 11, 1272893353), f2 = a2(f2, g2, E2, m2, d2[l2 + 7], 16, -155497632), m2 = a2(m2, f2, g2, E2, d2[l2 + 10], 23, -1094730640), E2 = a2(E2, m2, f2, g2, d2[l2 + 13], 4, 681279174), g2 = a2(g2, E2, m2, f2, d2[l2 + 0], 11, -358537222), f2 = a2(f2, g2, E2, m2, d2[l2 + 3], 16, -722521979), m2 = a2(m2, f2, g2, E2, d2[l2 + 6], 23, 76029189), E2 = a2(E2, m2, f2, g2, d2[l2 + 9], 4, -640364487), g2 = a2(g2, E2, m2, f2, d2[l2 + 12], 11, -421815835), f2 = a2(f2, g2, E2, m2, d2[l2 + 15], 16, 530742520), m2 = a2(m2, f2, g2, E2, d2[l2 + 2], 23, -995338651), E2 = c2(E2, m2, f2, g2, d2[l2 + 0], 6, -198630844), g2 = c2(g2, E2, m2, f2, d2[l2 + 7], 10, 1126891415), f2 = c2(f2, g2, E2, m2, d2[l2 + 14], 15, -1416354905), m2 = c2(m2, f2, g2, E2, d2[l2 + 5], 21, -57434055), E2 = c2(E2, m2, f2, g2, d2[l2 + 12], 6, 1700485571), g2 = c2(g2, E2, m2, f2, d2[l2 + 3], 10, -1894986606), f2 = c2(f2, g2, E2, m2, d2[l2 + 10], 15, -1051523), m2 = c2(m2, f2, g2, E2, d2[l2 + 1], 21, -2054922799), E2 = c2(E2, m2, f2, g2, d2[l2 + 8], 6, 1873313359), g2 = c2(g2, E2, m2, f2, d2[l2 + 15], 10, -30611744), f2 = c2(f2, g2, E2, m2, d2[l2 + 6], 15, -1560198380), m2 = c2(m2, f2, g2, E2, d2[l2 + 13], 21, 1309151649), E2 = c2(E2, m2, f2, g2, d2[l2 + 4], 6, -145523070), g2 = c2(g2, E2, m2, f2, d2[l2 + 11], 10, -1120210379), f2 = c2(f2, g2, E2, m2, d2[l2 + 2], 15, 718787259), m2 = c2(m2, f2, g2, E2, d2[l2 + 9], 21, -343485551), E2 = n3(E2, u2), m2 = n3(m2, h3), f2 = n3(f2, p2), g2 = n3(g2, _2);
          return i3(E2) + i3(m2) + i3(f2) + i3(g2);
        }("" + t2 + i2)).slice(0, 16), r2 = n2.slice(0, 12), s2 = await window.crypto.subtle.importKey("raw", n2, "AES-GCM", true, ["encrypt"]);
        return new Uint8Array(await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: r2 }, s2, e2));
      }, gw = async (e2, t2, i2) => await fw(e2.buffer, t2, i2);
      function Tw(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function Sw(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Tw(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : Tw(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class Rw extends lb {
        get isPlaying() {
          return !(!this._player || this._player.videoElementStatus !== sb.PLAYING);
        }
        get processorContext() {
          return this._processorContext;
        }
        set processorContext(e2) {
          this._processorContext = e2;
        }
        get __className__() {
          return "LocalVideoTrack";
        }
        constructor(e2, t2, i2, n2, r2, s2) {
          if (super(e2, r2), sh(this, "trackMediaType", "video"), sh(this, "_player", void 0), sh(this, "isUseScaleResolutionDownBy", false), sh(this, "_videoVisibleTimer", null), sh(this, "_statsTimer", null), sh(this, "_previousVideoVisibleStatus", void 0), sh(this, "_clearPreviousVideoVisibleStatus", () => this._previousVideoVisibleStatus = void 0), sh(this, "_encoderConfig", void 0), sh(this, "_scalabilityMode", { numSpatialLayers: 1, numTemporalLayers: 1 }), sh(this, "_optimizationMode", void 0), sh(this, "_videoHeight", void 0), sh(this, "_videoWidth", void 0), sh(this, "_forceBitrateLimit", void 0), sh(this, "_enabled", true), sh(this, "processorDestination", void 0), sh(this, "_processorContext", void 0), bg()) {
            const { width: t3, height: i3 } = e2.getSettings();
            this._videoWidth = t3, this._videoHeight = i3;
          } else this.updateMediaStreamTrackResolution();
          if (this._encoderConfig = t2, this._scalabilityMode = i2, this._optimizationMode = n2, this._hints = s2 || [], -1 === this._hints.indexOf(jA.SCREEN_TRACK)) this.updateBitrateFromProfile();
          else if (function(e3, t3, i3) {
            const n3 = Sg();
            return !(n3.name !== e3 || !n3.osVersion) && (i3 ? Number(n3.version) >= t3 && Number(n3.version) <= i3 : Number(n3.version) === t3);
          }(Eg.CHROME, 115) && -1 !== Rg().indexOf("Windows")) {
            const t3 = function(e3, t4) {
              if ("VideoFrame" in window && "TransformStream" in window && IA().supportWebRTCInsertableStream) {
                const i3 = new MediaStreamTrackProcessor(e3), n3 = new MediaStreamTrackGenerator({ kind: "video" });
                let r3, s3, o2 = Date.now();
                const a2 = () => {
                  c2 && (clearInterval(c2), c2 = void 0), r3 && (r3.close(), r3 = void 0), e3.stop(), s3 = void 0, n3.removeEventListener("ended", a2);
                };
                let c2 = window.setInterval(() => {
                  if (s3 && r3 && Date.now() - o2 > (null != t4 ? t4 : 1e3)) try {
                    "live" === n3.readyState ? s3.enqueue(r3.clone()) : a2();
                  } catch (e4) {
                    a2();
                  }
                }, null != t4 ? t4 : 1e3);
                const d2 = new TransformStream({ transform: (e4, t5) => {
                  "live" === n3.readyState ? (s3 = t5, o2 = Date.now(), void 0 === r3 ? (r3 = e4, t5.enqueue(e4.clone())) : (t5.enqueue(r3), r3 = e4)) : e4.close();
                } });
                return n3.addEventListener("ended", a2), i3.readable.pipeThrough(d2).pipeTo(n3.writable), n3;
              }
            }(e2);
            t3 && (jC.info("local screen video track begin to inject frame"), this._mediaStreamTrack = t3);
          }
          t2 && -1 !== this._hints.indexOf(jA.CUSTOM_TRACK) && this.setEncoderConfiguration(t2), this._processorContext = new qb(this.getTrackId(), "local"), this.processorDestination = new Yb(this.processorContext), this.bindProcessorDestinationEvents();
        }
        play(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          if ("string" == typeof e2) {
            const t3 = document.getElementById(e2);
            t3 ? e2 = t3 : (jC.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e2, '" element, use document.body')), e2 = document.body);
          }
          jC.debug("[".concat(this.getTrackId(), "] start video playback in ").concat(e2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement"), JSON.stringify(t2));
          const i2 = Sw(Sw(Sw({}, this._getDefaultPlayerConfig()), t2), {}, { trackId: this.getTrackId(), element: e2 });
          this._player ? this._player.updateConfig(i2) : (e2 instanceof HTMLVideoElement ? this._player = new pw(i2) : this._player = new Ew(i2), this._player.updateVideoTrack(this._mediaStreamTrack)), this._player.play(), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {
            try {
              const e3 = this.getVideoElementVisibleStatus();
              this.safeEmit(YA.VIDEO_ELEMENT_VISIBLE_STATUS, e3);
            } catch (e3) {
            }
          }, RC("CHECK_VIDEO_VISIBLE_INTERVAL"));
        }
        stop() {
          this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._statsTimer && (this.isUseScaleResolutionDownBy = false, window.clearInterval(this._statsTimer), this._statsTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, jC.debug("[".concat(this.getTrackId(), "] stop video playback")));
        }
        async setEnabled(e2, t2) {
          if (!t2) {
            if (e2 === this._enabled) return;
            this.stateCheck("enabled", e2);
          }
          if (jC.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), !e2) {
            this._originMediaStreamTrack.enabled = false;
            try {
              await yT(this, BA.NEED_DISABLE_TRACK, this);
            } catch (e3) {
              throw jC.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e3.toString()), e3;
            }
            return t2 || (this._enabled = false), void jC.info("[".concat(this.getTrackId(), "] setEnabled to false success"));
          }
          this._originMediaStreamTrack.enabled = true;
          try {
            await yT(this, BA.NEED_ENABLE_TRACK, this);
          } catch (e3) {
            throw jC.error("[".concat(this.getTrackId(), "] setEnabled to true error"), e3.toString()), e3;
          }
          jC.info("[".concat(this.getTrackId(), "] setEnabled to true success")), t2 || (this._enabled = true);
        }
        async setMuted(e2) {
          e2 !== this._muted && (this.stateCheck("muted", e2), this._muted = e2, this._originMediaStreamTrack.enabled = !e2, jC.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e2)), e2 ? await yT(this, BA.NEED_MUTE_TRACK, this) : await yT(this, BA.NEED_UNMUTE_TRACK, this));
        }
        async setEncoderConfiguration(e2, t2) {
          if (!this._enabled) throw new Kg(Hg.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
          if ("720p_auto" === e2 ? this.startMonitorStats() : this._statsTimer && (window.clearInterval(this._statsTimer), this._statsTimer = null), e2 = LA(e2), this._forceBitrateLimit && (e2.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e2.bitrateMax, e2.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e2.bitrateMin), e2.width || e2.height || e2.frameRate) {
            const t3 = rw({ encoderConfig: e2 });
            (bg() || Og() || Vg()) && (t3.deviceId = void 0), jC.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e2), JSON.stringify(t3));
            try {
              await this._originMediaStreamTrack.applyConstraints(t3), this.updateMediaStreamTrackResolution();
            } catch (e3) {
              const t4 = new Kg(Hg.UNEXPECTED_ERROR, e3.toString());
              throw jC.error("[".concat(this.getTrackId(), "] applyConstraints error"), t4.toString()), t4;
            }
          }
          this._encoderConfig = e2, -1 === this._hints.indexOf(jA.SCREEN_TRACK) && this.updateBitrateFromProfile();
          try {
            await yT(this, BA.NEED_UPDATE_VIDEO_ENCODER, this);
          } catch (e3) {
            return e3.throw(jC);
          }
        }
        getStats() {
          JT(() => {
            jC.warning("[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead");
          }, "localVideoTrackGetStatsWarning");
          const e2 = AT(this, BA.GET_STATS);
          return e2 || Sw({}, QA);
        }
        async setBeautyEffect(e2) {
          jC.error("LocalVideoTrack.setBeautyEffect was deprecated, please migrate to agora-extension-beauty-effect");
        }
        getCurrentFrameData() {
          return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);
        }
        async getCurrentFrameImage(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
          return this._player ? this._player.getCurrentFrameToUint8Array(e2, t2) : await dw(e2);
        }
        async setBitrateLimit(e2) {
          if (jC.debug("[".concat(this.getTrackId(), "] set bitrate limit, ").concat(JSON.stringify(e2))), e2) {
            this._forceBitrateLimit = e2, this._encoderConfig && (this._encoderConfig.bitrateMax ? this._encoderConfig.bitrateMax = this._encoderConfig.bitrateMax < e2.max_bitrate ? this._encoderConfig.bitrateMax : e2.max_bitrate : this._encoderConfig.bitrateMax = e2.max_bitrate, this._encoderConfig.bitrateMin, this._encoderConfig.bitrateMin = e2.min_bitrate);
            try {
              await yT(this, BA.NEED_UPDATE_VIDEO_ENCODER, this);
            } catch (e3) {
              return e3.throw(jC);
            }
          }
        }
        async setOptimizationMode(e2) {
          if ("motion" !== e2 && "detail" !== e2 && "balanced" !== e2) return void jC.error(Hg.INVALID_PARAMS, "optimization mode must be motion, detail or balanced");
          const t2 = this._optimizationMode;
          try {
            this._optimizationMode = e2, await yT(this, BA.SET_OPTIMIZATION_MODE, this);
          } catch (e3) {
            throw this._optimizationMode = t2, jC.error("[".concat(this.getTrackId(), "] set optimization mode failed"), e3.toString()), e3;
          }
          jC.info("[".concat(this.getTrackId(), "] set optimization mode success (").concat(e2, ")"));
        }
        setScalabiltyMode(e2) {
          if (1 === e2.numSpatialLayers && 1 !== e2.numTemporalLayers) return jC.error(Hg.INVALID_PARAMS, "scalability mode currently not supported, no SVC."), void (this._scalabilityMode = { numSpatialLayers: 1, numTemporalLayers: 1 });
          this._scalabilityMode = e2, jC.info("[".concat(this.getTrackId(), "] set scalability mode success (").concat(e2, ")"));
        }
        updateMediaStreamTrackResolution() {
          mw(this._originMediaStreamTrack).then((e2) => {
            let [t2, i2] = e2;
            this._videoHeight = i2, this._videoWidth = t2;
          }).catch(sS);
        }
        _updatePlayerSource() {
          this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
        }
        _getDefaultPlayerConfig() {
          return { fit: "contain" };
        }
        async setSenderConfiguration(e2) {
          if (!this._enabled) throw new Kg(Hg.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
          jC.debug("[".concat(this.getTrackId(), "] setSenderConfiguration applyConstraints"), JSON.stringify(e2)), e2 = LA(e2), this._forceBitrateLimit && (e2.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e2.bitrateMax, e2.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e2.bitrateMin), this._encoderConfig = e2, -1 === this._hints.indexOf(jA.SCREEN_TRACK) && this.updateBitrateFromProfile();
          try {
            await yT(this, BA.NEED_UPDATE_VIDEO_ENCODER, this);
          } catch (e3) {
            return e3.throw(jC);
          }
        }
        updateBitrateFromProfile() {
          if (!this._encoderConfig) return;
          const { width: e2, height: t2, frameRate: i2 } = this.getMediaStreamTrackSettings();
          if (!e2 || !t2 || !i2) return;
          const { bitrateMax: n2, bitrateMin: r2 } = this._encoderConfig;
          if (null == r2 || null == n2) {
            const { max: s2, min: o2 } = function(e3, t3, i3, n3, r3) {
              const s3 = RC("BITRATE_ADAPTER_TYPE");
              if ("DEFAULT_BITRATE" === s3) return { min: n3, max: r3 };
              if (void 0 === r3) {
                var o3;
                const a3 = Math.floor(200 * Math.pow(i3 / 15, 0.6) * Math.pow(e3 * t3 / 640 / 360, 0.75));
                r3 = "STANDARD_BITRATE" === s3 ? 4 * a3 : 2 * a3, n3 = null !== (o3 = n3) && void 0 !== o3 ? o3 : a3;
              } else {
                var a2;
                n3 = null !== (a2 = n3) && void 0 !== a2 ? a2 : Math.floor(r3 / 10);
              }
              return { min: n3, max: r3 };
            }(e2, t2, i2, r2, n2);
            this._encoderConfig.bitrateMin = o2, this._encoderConfig.bitrateMax = s2, jC.debug("[".concat(this.getTrackId(), "] update bitrate from profile, [w: ").concat(e2, ", h: ").concat(t2, ", fps: ").concat(i2, "] => [brMax: ").concat(s2, ", brMin: ").concat(o2, "]"));
          }
        }
        getVideoElementVisibleStatus() {
          try {
            var e2, t2;
            const i2 = null == this || null === (e2 = this._player) || void 0 === e2 ? void 0 : e2.getContainerElement(), n2 = { track: this, element: null == this || null === (t2 = this._player) || void 0 === t2 ? void 0 : t2.getVideoElement(), slot: null == i2 ? void 0 : i2.parentElement }, { element: r2, slot: s2 } = n2;
            if (this.isPlaying && r2 instanceof HTMLVideoElement && s2 instanceof HTMLElement) {
              const e3 = rT.checkOneElementVisible(r2), t3 = Object.assign({}, e3);
              if (t3.visible !== this._previousVideoVisibleStatus) {
                this._previousVideoVisibleStatus = t3.visible;
                const e4 = eI.reportApiInvoke(null, { tag: pT.TRACER, name: hT.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] });
                t3.visible ? e4.onSuccess("Video is visible") : e4.onSuccess("Invisible because of ".concat(t3.reason));
              }
              return t3;
            }
            return;
          } catch (e3) {
            throw new Kg(Hg.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e3.message);
          }
        }
        async renewMediaStreamTrack(e2) {
        }
        pipe(e2) {
          if (this.processor === e2) return e2;
          if (e2._source) throw new Kg(Hg.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), e2;
        }
        unpipe() {
          if (!this.processor) return;
          const e2 = this.processor;
          this.processor._source = void 0, this.processor = void 0, e2.reset();
        }
        close() {
          super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe();
        }
        clone(e2) {
          let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = this._encoderConfig;
          e2 && (i2 = Sw(Sw({}, i2), LA(e2))), i2 = qT(i2);
          const n2 = nS(8, "track-video-cloned-"), r2 = new Rw(t2 ? this._mediaStreamTrack.clone() : this._mediaStreamTrack, i2, qT(this._scalabilityMode), this._optimizationMode, n2, qT(this._hints));
          return e2 && i2 && r2.setEncoderConfiguration(i2), jC.debug("clone video track from ".concat(this.getTrackId(), " to ").concat(n2, ", clone ").concat(t2)), r2;
        }
        async replaceTrack(e2, t2) {
          if (!(e2 instanceof MediaStreamTrack)) throw new Kg(Hg.INVALID_PARAMS, "track should be an instance of MediaStreamTrack");
          if ("video" !== e2.kind) throw new Kg(Hg.INVALID_PARAMS, "track should be a video MediaStreamTrack");
          await this._updateOriginMediaStreamTrack(e2, t2, true), this.updateMediaStreamTrackResolution();
        }
        startMonitorStats() {
          if (!bg() && !Og()) return;
          this._statsTimer && window.clearInterval(this._statsTimer);
          let e2 = 2, t2 = NA[e2];
          let i2 = -1;
          let n2 = Date.now();
          const r2 = (e3) => {
            e3 > 2 || e3 < 0 || (n2 = Date.now(), t2 = NA[e3], this.setSenderConfiguration(t2));
          };
          this.isUseScaleResolutionDownBy = true, this._statsTimer = window.setInterval(() => {
            const s2 = this.getStats(), o2 = AT(this, BA.GET_RTC_STATS);
            if (s2.sendPackets > 0 && o2) {
              -1 === i2 && (i2 = Date.now());
              const a2 = Date.now();
              if (a2 - i2 < 1e3 || a2 - n2 < RC("PROFILE_SWITCH_INTERVAL")) return;
              const c2 = s2.sendFrameRate, d2 = 0.6 * t2.frameRate, l2 = 0.9 * t2.frameRate;
              "number" == typeof c2 && c2 > 0 && c2 < d2 ? e2 > 0 && (e2--, r2(e2), jC.debug("[".concat(this.getTrackId(), "] step down for fps ").concat(c2, ", switchProfile to ").concat(e2))) : o2.OutgoingAvailableBandwidth < t2.bitrateMin ? e2 > 0 && (e2--, r2(e2), jC.debug("[".concat(this.getTrackId(), "] step down for OutgoingAvailableBandwidth ").concat(o2.OutgoingAvailableBandwidth, ", bitrateMin ").concat(t2.bitrateMin, ", switchProfile to ").concat(e2))) : "number" == typeof c2 && c2 > l2 && e2 < NA.length - 1 && o2.OutgoingAvailableBandwidth > 1.2 * NA[e2 + 1].bitrateMin && (e2++, r2(e2), jC.debug("[".concat(this.getTrackId(), "] step up for fps ").concat(c2, ", OutgoingAvailableBandwidth ").concat(o2.OutgoingAvailableBandwidth, ", switchProfile to ").concat(e2)));
            }
          }, RC("CHECK_LOCAL_STATS_INTERVAL"));
        }
        sendSeiData(e2) {
          if (JT(() => {
            eI.reportApiInvoke(null, { name: hT.LOCAL_VIDEO_SEND_SEI_DATA, options: [], tag: pT.TRACER }).onSuccess("");
          }, this._mediaStreamTrack.id || this.getTrackId()), !RC("ENABLE_VIDEO_SEI") || !RC("ENABLE_ENCODED_TRANSFORM")) return void jC.warning('To send/receive SEI, please call AgoraRTC.setParameter("ENABLE_VIDEO_SEI", true) before instantiate IAgoraRtcClient');
          if (e2 instanceof Uint8Array == false) return new Kg(Hg.INVALID_PARAMS, "Invalid argument type, ILocalVideoTrack.sendSeiData() only accept Uint8Array argument.").throw();
          const t2 = this.getRTCRtpTransceiver();
          if (!t2) return void jC.warning("Video track is not published, SEI can not be send");
          const i2 = t2.sender.getParameters();
          if (0 === i2.codecs.length) return;
          const n2 = i2.codecs[0].mimeType.toLocaleLowerCase();
          "video/h264" === n2 ? this.safeEmit("sei-to-send", e2) : jC.warning("SEI is not supported by ".concat(n2));
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(tb.ON_TRACK, async (e2) => {
            e2 ? e2 !== this._mediaStreamTrack && (this._mediaStreamTrack = e2, this._updatePlayerSource(), await yT(this, BA.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await yT(this, BA.NEED_REPLACE_TRACK, this));
          });
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(tb.ON_TRACK);
        }
        unbindProcessorContextEvents() {
          this.processorContext.removeAllListeners(ib.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(ib.REQUEST_CONSTRAINTS);
        }
      }
      DI([$C({ argsMap: (e2, t2, i2) => [e2.getTrackId(), "string" == typeof t2 ? t2 : t2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement", i2] }), Wb(), PI("design:type", Function), PI("design:paramtypes", [Object, Object]), PI("design:returntype", void 0)], Rw.prototype, "play", null), DI([$C({ argsMap: (e2) => [e2.getTrackId()] }), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], Rw.prototype, "stop", null), DI([_S("LocalVideoTrack", "_enabledMutex"), $C({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), Wb(), PI("design:type", Function), PI("design:paramtypes", [Boolean, Boolean]), PI("design:returntype", cg)], Rw.prototype, "setEnabled", null), DI([_S("LocalVideoTrack", "_enabledMutex"), $C({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), Wb(), PI("design:type", Function), PI("design:paramtypes", [Boolean]), PI("design:returntype", cg)], Rw.prototype, "setMuted", null), DI([$C({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), Wb(), PI("design:type", Function), PI("design:paramtypes", [Object, Boolean]), PI("design:returntype", cg)], Rw.prototype, "setEncoderConfiguration", null), DI([Wb(), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", Object)], Rw.prototype, "getStats", null), DI([$C({ argsMap: (e2, t2, i2) => [e2.getTrackId(), t2, i2] }), Wb(), PI("design:type", Function), PI("design:paramtypes", [Boolean, Object]), PI("design:returntype", cg)], Rw.prototype, "setBeautyEffect", null), DI([Wb(), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", ImageData)], Rw.prototype, "getCurrentFrameData", null), DI([Wb(), PI("design:type", Function), PI("design:paramtypes", [String, Number]), PI("design:returntype", cg)], Rw.prototype, "getCurrentFrameImage", null), DI([Wb(), PI("design:type", Function), PI("design:paramtypes", [Object]), PI("design:returntype", cg)], Rw.prototype, "setBitrateLimit", null), DI([Wb(), PI("design:type", Function), PI("design:paramtypes", [String]), PI("design:returntype", cg)], Rw.prototype, "setOptimizationMode", null), DI([Wb(), PI("design:type", Function), PI("design:paramtypes", [Object]), PI("design:returntype", void 0)], Rw.prototype, "setScalabiltyMode", null), DI([Wb(), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], Rw.prototype, "updateMediaStreamTrackResolution", null), DI([$C({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), PI("design:type", Function), PI("design:paramtypes", [Object]), PI("design:returntype", Object)], Rw.prototype, "pipe", null), DI([$C({ argsMap: (e2) => [e2.getTrackId()] }), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], Rw.prototype, "unpipe", null), DI([$C({ argsMap: (e2) => [e2.getTrackId()] }), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], Rw.prototype, "close", null), DI([$C({ argsMap: (e2, t2, i2) => [e2.getTrackId(), t2.label, i2] }), PI("design:type", Function), PI("design:paramtypes", [MediaStreamTrack, Boolean]), PI("design:returntype", cg)], Rw.prototype, "replaceTrack", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], Rw.prototype, "startMonitorStats", null);
      class Cw extends Rw {
        get __className__() {
          return "CameraVideoTrack";
        }
        constructor(e2, t2, i2, n2, r2, s2) {
          super(e2, LA(t2.encoderConfig), n2, r2, s2), sh(this, "_config", void 0), sh(this, "_originalConstraints", void 0), sh(this, "_constraints", void 0), sh(this, "_enabled", true), sh(this, "_deviceName", "default"), sh(this, "tryResumeVideoForIOS15_16WeChat", async () => {
            (Mg() || Ug()) && !function() {
              const e3 = Sg();
              if (e3.os !== _g.IOS || !e3.osVersion) return false;
              const t3 = e3.osVersion.split(".");
              return 15 === Number(t3[0]) && Number(t3[1]) >= 2;
            }() && Fg() && this._enabled && !this._isClosed && (jC.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS 15 device on WeChat.")), await this.renewMediaStreamTrack());
          }), this._config = t2, this._originalConstraints = i2, this._constraints = i2, this._deviceName = e2.label, this._encoderConfig = LA(this._config.encoderConfig), _b.on(vA.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), _b.on(vA.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), this.bindProcessorContextEvents();
        }
        async setDevice(e2) {
          return "string" == typeof e2 ? this._setDeviceById(e2) : e2.deviceId ? this._setDeviceById(e2.deviceId) : e2.facingMode ? this._setDeviceByFacingModel(e2.facingMode) : void 0;
        }
        async _setDeviceById(e2) {
          if (jC.info("[".concat(this.getTrackId(), "] set device to ").concat(e2)), this._enabled) try {
            const t2 = await kb.getDeviceById(e2), i2 = {};
            i2.video = Sw({}, this._constraints), i2.video.deviceId = { exact: e2 }, i2.video.facingMode = void 0, this._originMediaStreamTrack.stop();
            let n2 = null;
            try {
              n2 = await Nb(i2, this.getTrackId());
            } catch (e3) {
              throw jC.error("[".concat(this.getTrackId(), "] setDevice failed"), e3.toString()), n2 = await Nb({ video: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(n2.getVideoTracks()[0], false), e3;
            }
            await this._updateOriginMediaStreamTrack(n2.getVideoTracks()[0], false), this.updateMediaStreamTrackResolution(), this._deviceName = t2.label, this._config.cameraId = e2, this._constraints.deviceId = { exact: e2 };
          } catch (e3) {
            throw jC.error("[".concat(this.getTrackId(), "] setDevice error"), e3.toString()), e3;
          }
          else try {
            const t2 = await kb.getDeviceById(e2);
            this._deviceName = t2.label, this._config.cameraId = e2, this._constraints.deviceId = { exact: e2 };
          } catch (e3) {
            throw jC.error("[".concat(this.getTrackId(), "] setDevice error"), e3.toString()), e3;
          }
          jC.info("[".concat(this.getTrackId(), "] setDevice success"));
        }
        async _setDeviceByFacingModel(e2) {
          jC.info("[".concat(this.getTrackId(), "] set facingMode ").concat(e2));
          const t2 = { video: Sw(Sw({}, this._constraints), {}, { deviceId: void 0, facingMode: { exact: e2 } }) };
          if (this._enabled) {
            this._originMediaStreamTrack.stop();
            let e3 = null;
            try {
              e3 = await Nb(t2, this.getTrackId());
            } catch (t3) {
              throw jC.error("[".concat(this.getTrackId(), "] setDeviceByFacingModel failed"), t3.toString()), e3 = await Nb({ video: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(e3.getVideoTracks()[0], false), t3;
            }
            await this._updateOriginMediaStreamTrack(e3.getVideoTracks()[0], false), this.updateMediaStreamTrackResolution();
          }
          this._deviceName = "", this._config.facingMode = e2, this._config.cameraId = void 0, this._constraints = Sw({}, t2.video), jC.info("[".concat(this.getTrackId(), "] setDeviceByFacingModel success"));
        }
        async setEnabled(e2, t2) {
          if (!t2) {
            if (e2 === this._enabled) return;
            this.stateCheck("enabled", e2);
          }
          if (jC.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), e2) {
            try {
              if (this.isExternalTrack) this._originMediaStreamTrack.enabled = true;
              else {
                const e3 = await Nb({ video: this._constraints }, this.getTrackId());
                await this._updateOriginMediaStreamTrack(e3.getVideoTracks()[0], false);
              }
              await yT(this, BA.NEED_ENABLE_TRACK, this);
            } catch (e3) {
              throw jC.error("[".concat(this.getTrackId(), "] setEnabled true error"), e3.toString()), e3;
            }
            this.updateMediaStreamTrackResolution(), jC.info("[".concat(this.getTrackId(), "] setEnabled to true success")), t2 || (this._enabled = true);
          } else {
            this.isExternalTrack ? this._originMediaStreamTrack.enabled = false : (this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop()), t2 || (this._enabled = false);
            try {
              await yT(this, BA.NEED_DISABLE_TRACK, this);
            } catch (e3) {
              throw jC.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e3.toString()), e3;
            }
            jC.info("[".concat(this.getTrackId(), "] setEnabled to false success"));
          }
        }
        async setEncoderConfiguration(e2, t2) {
          if (!this._enabled) throw new Kg(Hg.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
          "720p_auto" === e2 ? this.startMonitorStats() : this._statsTimer && (window.clearInterval(this._statsTimer), this._statsTimer = null), e2 = LA(e2), this._forceBitrateLimit && (e2.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e2.bitrateMax, e2.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e2.bitrateMin);
          const i2 = YT(this._config);
          i2.encoderConfig = e2;
          const n2 = rw(i2);
          (bg() || Og() || Vg()) && (n2.deviceId = void 0), jC.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e2), JSON.stringify(n2));
          try {
            await this._originMediaStreamTrack.applyConstraints(n2), this.updateMediaStreamTrackResolution();
          } catch (e3) {
            const t3 = new Kg(Hg.UNEXPECTED_ERROR, e3.toString());
            throw jC.error("[".concat(this.getTrackId(), "] applyConstraints error"), t3.toString()), t3;
          }
          this._config = i2, this._constraints = n2, this._originalConstraints = n2, this._encoderConfig = e2, -1 === this._hints.indexOf(jA.SCREEN_TRACK) && this.updateBitrateFromProfile();
          try {
            await yT(this, BA.NEED_UPDATE_VIDEO_ENCODER, this);
          } catch (e3) {
            return e3.throw(jC);
          }
        }
        _getDefaultPlayerConfig() {
          return { mirror: true, fit: "cover" };
        }
        onTrackEnded() {
          if ((Og() || Vg()) && this._enabled && !this._isClosed && _b.duringInterruption) {
            const e2 = async () => {
              _b.off(vA.IOS_INTERRUPTION_END, e2), this._enabled && !this._isClosed && (jC.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS device.")), await this.setEnabled(false), await this.setEnabled(true));
            };
            _b.on(vA.IOS_INTERRUPTION_END, e2);
          } else jC.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(YA.TRACK_ENDED);
        }
        async renewMediaStreamTrack(e2) {
          const t2 = e2 || this._constraints, i2 = kb.searchDeviceIdByName(this._deviceName);
          if (i2 && !t2.deviceId && (t2.deviceId = { exact: i2 }), this._enabled) {
            const e3 = await Nb({ video: t2 }, this.getTrackId());
            this._constraints = t2, await this._updateOriginMediaStreamTrack(e3.getVideoTracks()[0], true), this.updateMediaStreamTrackResolution();
          }
        }
        close() {
          super.close(), _b.off(vA.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), _b.off(vA.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat);
        }
        clone(e2) {
          let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = this._encoderConfig;
          e2 && (i2 = Sw(Sw({}, i2), LA(e2))), i2 = qT(i2);
          const n2 = nS(8, "track-cam-cloned-"), r2 = new Cw(t2 ? this._mediaStreamTrack.clone() : this._mediaStreamTrack, qT(Sw(Sw({}, this._config), {}, { encoderConfig: i2 })), qT(this._constraints), qT(this._scalabilityMode), this._optimizationMode, n2);
          return e2 && i2 && r2.setEncoderConfiguration(i2), jC.debug("clone track from ".concat(this.getTrackId(), " to ").concat(n2, ", clone ").concat(t2)), r2;
        }
        bindProcessorContextEvents() {
          this.processorContext.on(ib.REQUEST_UPDATE_CONSTRAINTS, async (e2, t2, i2) => {
            try {
              const i3 = Object.assign({}, this._originalConstraints, ...e2);
              await this.renewMediaStreamTrack(i3), t2();
            } catch (e3) {
              i2(e3);
            }
          }), this.processorContext.on(ib.REQUEST_CONSTRAINTS, async (e2) => {
            e2(this._originMediaStreamTrack.getSettings());
          });
        }
      }
      function Iw(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function vw(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Iw(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : Iw(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      function yw(e2, t2, i2, n2) {
        i2.optimizationMode && (n2 && n2.width && n2.height ? (i2.encoderConfig = vw(vw({}, n2), {}, { bitrateMin: n2.bitrateMin, bitrateMax: n2.bitrateMax }), "motion" !== i2.optimizationMode && "detail" !== i2.optimizationMode || (t2.contentHint = i2.optimizationMode, t2.contentHint === i2.optimizationMode ? jC.debug("[".concat(e2, "] set content hint to"), i2.optimizationMode) : jC.debug("[".concat(e2, "] set content hint failed")))) : jC.warning("[".concat(e2, "] can not apply optimization mode bitrate config, no encoderConfig")));
      }
      function Aw(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function bw(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Aw(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : Aw(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      DI([$C({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), Wb(), PI("design:type", Function), PI("design:paramtypes", [Object]), PI("design:returntype", cg)], Cw.prototype, "setDevice", null), DI([_S("CameraVideoTrack", "_enabledMutex"), $C({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), Wb(), PI("design:type", Function), PI("design:paramtypes", [Boolean, Boolean]), PI("design:returntype", cg)], Cw.prototype, "setEnabled", null), DI([$C({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), Wb(), PI("design:type", Function), PI("design:paramtypes", [Object, Boolean]), PI("design:returntype", cg)], Cw.prototype, "setEncoderConfiguration", null), DI([$C({ argsMap: (e2) => [e2.getTrackId()] }), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], Cw.prototype, "close", null);
      class ww extends db {
        getUserId() {
          return this._userId;
        }
        constructor(e2, t2, i2, n2) {
          super(e2, "track-".concat(e2.kind, "-").concat(t2, "-").concat(n2.clientId, "_").concat(nS(5, ""))), sh(this, "_userId", void 0), sh(this, "_uintId", void 0), sh(this, "_isDestroyed", false), sh(this, "store", void 0), sh(this, "processor", void 0), this._userId = t2, this._uintId = i2, this.store = n2;
        }
        _updateOriginMediaStreamTrack(e2) {
          this._originMediaStreamTrack = e2, this._mediaStreamTrack = e2, this._updatePlayerSource(), this.processor && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext });
        }
        _destroy() {
          this._isDestroyed = true, jC.info("[".concat(this.getTrackId(), "] is destroyed")), this.stop(), super.close();
        }
        getProcessorStats() {
          return this.processorContext.gatherStats();
        }
        getProcessorUsage() {
          return this.processorContext.gatherUsage();
        }
      }
      class Ow extends ww {
        get isPlaying() {
          return !(!this._player || this._player.videoElementStatus !== sb.PLAYING);
        }
        get __className__() {
          return "RemoteVideoTrack";
        }
        constructor(e2, t2, i2, n2) {
          super(e2, t2, i2, n2), sh(this, "_videoVisibleTimer", null), sh(this, "_previousVideoVisibleStatus", void 0), sh(this, "_clearPreviousVideoVisibleStatus", () => this._previousVideoVisibleStatus = void 0), sh(this, "trackMediaType", "video"), sh(this, "_videoWidth", void 0), sh(this, "_videoHeight", void 0), sh(this, "_player", void 0), sh(this, "processorDestination", void 0), sh(this, "processorContext", void 0), this.updateMediaStreamTrackResolution(), this.processorContext = new qb(this.getTrackId(), "remote"), this.processorDestination = new Yb(this.processorContext), this.bindProcessorDestinationEvents();
        }
        getStats() {
          JT(() => {
            jC.warning("[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead");
          }, "remoteVideoTrackGetStatsWarning");
          return AT(this, BA.GET_STATS) || bw({}, eb);
        }
        play(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          if ("string" == typeof e2) {
            const t3 = document.getElementById(e2);
            t3 ? e2 = t3 : (jC.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e2, '" element, use document.body')), e2 = document.body);
          }
          jC.debug("[".concat(this.getTrackId(), "] start video playback in ").concat(e2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement"), JSON.stringify(t2));
          const i2 = bw(bw({ fit: "cover" }, t2), {}, { trackId: this.getTrackId(), element: e2 });
          this._player ? this._player.updateConfig(i2) : (e2 instanceof HTMLVideoElement ? this._player = new pw(i2) : this._player = new Ew(i2), this._player.updateVideoTrack(this._mediaStreamTrack), this._player.onFirstVideoFrameDecoded = () => {
            this.store.subscribe(this.getUserId(), "video", void 0, void 0, Date.now()), this.safeEmit(qA.FIRST_FRAME_DECODED);
          }, this._player.onVideoStateChanged = (e3) => {
            this.safeEmit(qA.VIDEO_STATE_CHANGED, e3);
          }), this._player.play(this.store.sessionId || void 0), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {
            try {
              const e3 = this.getVideoElementVisibleStatus();
              this.safeEmit(qA.VIDEO_ELEMENT_VISIBLE_STATUS, e3);
            } catch (e3) {
            }
          }, RC("CHECK_VIDEO_VISIBLE_INTERVAL"));
        }
        stop() {
          this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, jC.debug("[".concat(this.getTrackId(), "] stop video playback")));
        }
        getCurrentFrameData() {
          return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);
        }
        updateMediaStreamTrackResolution() {
          mw(this._originMediaStreamTrack).then((e2) => {
            let [t2, i2] = e2;
            this._videoHeight = i2, this._videoWidth = t2;
          }).catch(sS);
        }
        _updatePlayerSource() {
          jC.debug("[".concat(this.getTrackId(), "] update player source track")), this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
        }
        getVideoElementVisibleStatus() {
          try {
            var e2, t2;
            const i2 = null == this || null === (e2 = this._player) || void 0 === e2 ? void 0 : e2.getContainerElement(), n2 = { track: this, element: null == this || null === (t2 = this._player) || void 0 === t2 ? void 0 : t2.getVideoElement(), slot: null == i2 ? void 0 : i2.parentElement }, { element: r2, slot: s2 } = n2;
            if (this.isPlaying && r2 instanceof HTMLVideoElement && s2 instanceof HTMLElement) {
              const e3 = rT.checkOneElementVisible(r2), t3 = Object.assign({}, e3);
              if (t3.visible !== this._previousVideoVisibleStatus) {
                this._previousVideoVisibleStatus = t3.visible;
                const e4 = eI.reportApiInvoke(null, { tag: pT.TRACER, name: hT.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] });
                t3.visible ? e4.onSuccess("Video is visible") : e4.onSuccess("Invisible because of ".concat(t3.reason));
              }
              return t3;
            }
            return;
          } catch (e3) {
            throw new Kg(Hg.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e3.message);
          }
        }
        pipe(e2) {
          if (this.processor === e2) return e2;
          if (e2._source) throw new Kg(Hg.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), e2;
        }
        unpipe() {
          if (!this.processor) return;
          const e2 = this.processor;
          this.processor._source = void 0, this.processor = void 0, e2.reset();
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(tb.ON_TRACK, async (e2) => {
            e2 ? e2 !== this._mediaStreamTrack && (this._mediaStreamTrack = e2, this._updatePlayerSource()) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());
          });
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(tb.ON_TRACK);
        }
        _destroy() {
          super._destroy(), this.unbindProcessorDestinationEvents();
        }
        _onSei(e2) {
          this.emit(KA.SEI_RECEIVED, e2);
        }
      }
      DI([$C({ argsMap: (e2, t2, i2) => [e2.getTrackId(), "string" == typeof t2 ? t2 : t2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement", i2] }), PI("design:type", Function), PI("design:paramtypes", [Object, Object]), PI("design:returntype", void 0)], Ow.prototype, "play", null), DI([$C({ argsMap: (e2) => [e2.getTrackId()] }), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], Ow.prototype, "stop", null), DI([$C({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), PI("design:type", Function), PI("design:paramtypes", [Object]), PI("design:returntype", Object)], Ow.prototype, "pipe", null), DI([$C({ argsMap: (e2) => [e2.getTrackId()] }), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], Ow.prototype, "unpipe", null);
      class Nw extends ww {
        get isPlaying() {
          return this._useAudioElement ? Gb.isPlaying(this.getTrackId()) : this._source.isPlayed;
        }
        get __className__() {
          return "RemoteAudioTrack";
        }
        constructor(e2, t2, i2, n2) {
          super(e2, t2, i2, n2), sh(this, "trackMediaType", "audio"), sh(this, "_source", void 0), sh(this, "_useAudioElement", true), sh(this, "_volume", 100), sh(this, "processorContext", void 0), sh(this, "processorDestination", void 0), sh(this, "_played", false), sh(this, "_bypassWebAudio", false), RC("DISABLE_WEBAUDIO") ? (this._source = new Xb(), this._bypassWebAudio = true, this._useAudioElement = true) : (this._source = new Cb(e2, true), RC("REMOTE_AUDIO_TRACK_USES_WEB_AUDIO") && (this._useAudioElement = false)), this._source.once(zA.RECEIVE_TRACK_BUFFER, () => {
            this.safeEmit(qA.FIRST_FRAME_DECODED);
          }), this.processorContext = new Jb(this._source.context, this.getTrackId(), "remote"), this.processorDestination = new zb(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(zA.UPDATE_SOURCE, () => {
            this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: this.processorContext });
          });
        }
        setAudioFrameCallback(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;
          if (!e2) return this._source.removeAllListeners(zA.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
          this._source.startGetAudioBuffer(t2), this._source.removeAllListeners(zA.ON_AUDIO_BUFFER), this._source.on(zA.ON_AUDIO_BUFFER, (t3) => e2(t3));
        }
        setVolume(e2) {
          this._volume = e2, this._useAudioElement ? Gb.setVolume(this.getTrackId(), e2) : this._source.setVolume(e2 / 100);
        }
        async setPlaybackDevice(e2) {
          if (!this._useAudioElement || !Ag() && RC("RESTRICTION_SET_PLAYBACK_DEVICE")) throw new Kg(Hg.NOT_SUPPORTED, "your browser does not support setting the audio output device");
          await Gb.setSinkID(this.getTrackId(), e2);
        }
        getVolumeLevel() {
          return this._source.getAccurateVolumeLevel();
        }
        getStats() {
          JT(() => {
            jC.warning("[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead");
          }, "remoteAudioTrackGetStatsWarning");
          return AT(this, BA.GET_STATS) || bw({}, ZA);
        }
        play() {
          jC.debug("[".concat(this.getTrackId(), "] start audio playback")), this._played = true, this._useAudioElement ? (jC.debug("[".concat(this.getTrackId(), "] use audio element to play")), Gb.play(this._mediaStreamTrack, this.getTrackId(), this._volume, this.store.sessionId || void 0)) : this._source.play();
        }
        stop() {
          jC.debug("[".concat(this.getTrackId(), "] stop audio playback")), this._played = false, this._useAudioElement ? Gb.stop(this.getTrackId()) : this._source.stop();
        }
        _destroy() {
          super._destroy(), this._played = false, this.unbindProcessorDestinationEvents(), this._source.destroy();
        }
        _isFreeze() {
          return this._source.isFreeze;
        }
        _updatePlayerSource() {
          let e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
          jC.debug("[".concat(this.getTrackId(), "] update player source track")), e2 && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && Gb.updateTrack(this.getTrackId(), this._mediaStreamTrack);
        }
        pipe(e2) {
          if (this._bypassWebAudio) throw new Kg(Hg.NOT_SUPPORTED, "can not pipe extension when WebAudio disabled");
          if (this.processor === e2) return e2;
          if (e2._source) throw new Kg(Hg.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), e2;
        }
        unpipe() {
          var e2;
          if (this._bypassWebAudio) throw new Kg(Hg.NOT_SUPPORTED, "can not unpipe extension when WebAudio disabled");
          if (!this.processor) return;
          const t2 = this.processor;
          null === (e2 = this._source.processSourceNode) || void 0 === e2 || e2.disconnect(), this.processor._source = false, this.processor = void 0, t2.reset();
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(tb.ON_TRACK, async (e2) => {
            e2 ? e2 !== this._mediaStreamTrack && (this._mediaStreamTrack = e2, this._updatePlayerSource(false), this._source.processedNode = this._source.createMediaStreamSourceNode(e2)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());
          }), this.processorDestination.on(tb.ON_NODE, (e2) => {
            this._source.processedNode = e2;
            const t2 = !e2;
            this._useAudioElement !== t2 && (this._played ? (this.stop(), this._useAudioElement = t2, this.play()) : this._useAudioElement = t2);
          });
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(tb.ON_TRACK), this.processorDestination.removeAllListeners(tb.ON_NODE);
        }
      }
      DI([$C({ argsMap: (e2, t2) => [e2.getTrackId(), t2], throttleTime: 300 }), PI("design:type", Function), PI("design:paramtypes", [Number]), PI("design:returntype", void 0)], Nw.prototype, "setVolume", null), DI([$C({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), PI("design:type", Function), PI("design:paramtypes", [String]), PI("design:returntype", cg)], Nw.prototype, "setPlaybackDevice", null), DI([$C({ argsMap: (e2) => [e2.getTrackId()] }), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], Nw.prototype, "play", null), DI([$C({ argsMap: (e2) => [e2.getTrackId()] }), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], Nw.prototype, "stop", null), DI([$C({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), PI("design:type", Function), PI("design:paramtypes", [Object]), PI("design:returntype", Object)], Nw.prototype, "pipe", null), DI([$C({ argsMap: (e2) => [e2.getTrackId()] }), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], Nw.prototype, "unpipe", null);
      const Dw = new class extends dT {
        get visibility() {
          return document.visibilityState;
        }
        get lastHiddenTime() {
          return this._lastHiddenTime;
        }
        get lastVisibleTime() {
          return this._lastVisibleTime;
        }
        constructor() {
          super(), sh(this, "_lastHiddenTime", 0), sh(this, "_lastVisibleTime", 0), document.addEventListener("visibilitychange", () => {
            "hidden" === document.visibilityState ? this._lastHiddenTime = performance.now() : this._lastVisibleTime = performance.now(), jC.debug("document visibility went ".concat(document.visibilityState)), this.emit("VISIBILITY_CHANGE", document.visibilityState);
          });
        }
      }();
      function Pw(e2) {
        let t2 = e2.length;
        for (; --t2 >= 0; ) e2[t2] = 0;
      }
      const Lw = 256, kw = 286, Mw = 30, Uw = 15, xw = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]), Vw = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]), Fw = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]), Bw = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), jw = new Array(576);
      Pw(jw);
      const Gw = new Array(60);
      Pw(Gw);
      const Ww = new Array(512);
      Pw(Ww);
      const Hw = new Array(256);
      Pw(Hw);
      const Kw = new Array(29);
      Pw(Kw);
      const Yw = new Array(Mw);
      function qw(e2, t2, i2, n2, r2) {
        this.static_tree = e2, this.extra_bits = t2, this.extra_base = i2, this.elems = n2, this.max_length = r2, this.has_stree = e2 && e2.length;
      }
      let zw, Jw, Xw;
      function Qw(e2, t2) {
        this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
      }
      Pw(Yw);
      const Zw = (e2) => e2 < 256 ? Ww[e2] : Ww[256 + (e2 >>> 7)], $w = (e2, t2) => {
        e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
      }, eO = (e2, t2, i2) => {
        e2.bi_valid > 16 - i2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, $w(e2, e2.bi_buf), e2.bi_buf = t2 >> 16 - e2.bi_valid, e2.bi_valid += i2 - 16) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += i2);
      }, tO = (e2, t2, i2) => {
        eO(e2, i2[2 * t2], i2[2 * t2 + 1]);
      }, iO = (e2, t2) => {
        let i2 = 0;
        do {
          i2 |= 1 & e2, e2 >>>= 1, i2 <<= 1;
        } while (--t2 > 0);
        return i2 >>> 1;
      }, nO = (e2, t2, i2) => {
        const n2 = new Array(16);
        let r2, s2, o2 = 0;
        for (r2 = 1; r2 <= Uw; r2++) o2 = o2 + i2[r2 - 1] << 1, n2[r2] = o2;
        for (s2 = 0; s2 <= t2; s2++) {
          let t3 = e2[2 * s2 + 1];
          0 !== t3 && (e2[2 * s2] = iO(n2[t3]++, t3));
        }
      }, rO = (e2) => {
        let t2;
        for (t2 = 0; t2 < kw; t2++) e2.dyn_ltree[2 * t2] = 0;
        for (t2 = 0; t2 < Mw; t2++) e2.dyn_dtree[2 * t2] = 0;
        for (t2 = 0; t2 < 19; t2++) e2.bl_tree[2 * t2] = 0;
        e2.dyn_ltree[512] = 1, e2.opt_len = e2.static_len = 0, e2.sym_next = e2.matches = 0;
      }, sO = (e2) => {
        e2.bi_valid > 8 ? $w(e2, e2.bi_buf) : e2.bi_valid > 0 && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
      }, oO = (e2, t2, i2, n2) => {
        const r2 = 2 * t2, s2 = 2 * i2;
        return e2[r2] < e2[s2] || e2[r2] === e2[s2] && n2[t2] <= n2[i2];
      }, aO = (e2, t2, i2) => {
        const n2 = e2.heap[i2];
        let r2 = i2 << 1;
        for (; r2 <= e2.heap_len && (r2 < e2.heap_len && oO(t2, e2.heap[r2 + 1], e2.heap[r2], e2.depth) && r2++, !oO(t2, n2, e2.heap[r2], e2.depth)); ) e2.heap[i2] = e2.heap[r2], i2 = r2, r2 <<= 1;
        e2.heap[i2] = n2;
      }, cO = (e2, t2, i2) => {
        let n2, r2, s2, o2, a2 = 0;
        if (0 !== e2.sym_next) do {
          n2 = 255 & e2.pending_buf[e2.sym_buf + a2++], n2 += (255 & e2.pending_buf[e2.sym_buf + a2++]) << 8, r2 = e2.pending_buf[e2.sym_buf + a2++], 0 === n2 ? tO(e2, r2, t2) : (s2 = Hw[r2], tO(e2, s2 + Lw + 1, t2), o2 = xw[s2], 0 !== o2 && (r2 -= Kw[s2], eO(e2, r2, o2)), n2--, s2 = Zw(n2), tO(e2, s2, i2), o2 = Vw[s2], 0 !== o2 && (n2 -= Yw[s2], eO(e2, n2, o2)));
        } while (a2 < e2.sym_next);
        tO(e2, 256, t2);
      }, dO = (e2, t2) => {
        const i2 = t2.dyn_tree, n2 = t2.stat_desc.static_tree, r2 = t2.stat_desc.has_stree, s2 = t2.stat_desc.elems;
        let o2, a2, c2, d2 = -1;
        for (e2.heap_len = 0, e2.heap_max = 573, o2 = 0; o2 < s2; o2++) 0 !== i2[2 * o2] ? (e2.heap[++e2.heap_len] = d2 = o2, e2.depth[o2] = 0) : i2[2 * o2 + 1] = 0;
        for (; e2.heap_len < 2; ) c2 = e2.heap[++e2.heap_len] = d2 < 2 ? ++d2 : 0, i2[2 * c2] = 1, e2.depth[c2] = 0, e2.opt_len--, r2 && (e2.static_len -= n2[2 * c2 + 1]);
        for (t2.max_code = d2, o2 = e2.heap_len >> 1; o2 >= 1; o2--) aO(e2, i2, o2);
        c2 = s2;
        do {
          o2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], aO(e2, i2, 1), a2 = e2.heap[1], e2.heap[--e2.heap_max] = o2, e2.heap[--e2.heap_max] = a2, i2[2 * c2] = i2[2 * o2] + i2[2 * a2], e2.depth[c2] = (e2.depth[o2] >= e2.depth[a2] ? e2.depth[o2] : e2.depth[a2]) + 1, i2[2 * o2 + 1] = i2[2 * a2 + 1] = c2, e2.heap[1] = c2++, aO(e2, i2, 1);
        } while (e2.heap_len >= 2);
        e2.heap[--e2.heap_max] = e2.heap[1], ((e3, t3) => {
          const i3 = t3.dyn_tree, n3 = t3.max_code, r3 = t3.stat_desc.static_tree, s3 = t3.stat_desc.has_stree, o3 = t3.stat_desc.extra_bits, a3 = t3.stat_desc.extra_base, c3 = t3.stat_desc.max_length;
          let d3, l2, u2, h3, p2, _2, E2 = 0;
          for (h3 = 0; h3 <= Uw; h3++) e3.bl_count[h3] = 0;
          for (i3[2 * e3.heap[e3.heap_max] + 1] = 0, d3 = e3.heap_max + 1; d3 < 573; d3++) l2 = e3.heap[d3], h3 = i3[2 * i3[2 * l2 + 1] + 1] + 1, h3 > c3 && (h3 = c3, E2++), i3[2 * l2 + 1] = h3, l2 > n3 || (e3.bl_count[h3]++, p2 = 0, l2 >= a3 && (p2 = o3[l2 - a3]), _2 = i3[2 * l2], e3.opt_len += _2 * (h3 + p2), s3 && (e3.static_len += _2 * (r3[2 * l2 + 1] + p2)));
          if (0 !== E2) {
            do {
              for (h3 = c3 - 1; 0 === e3.bl_count[h3]; ) h3--;
              e3.bl_count[h3]--, e3.bl_count[h3 + 1] += 2, e3.bl_count[c3]--, E2 -= 2;
            } while (E2 > 0);
            for (h3 = c3; 0 !== h3; h3--) for (l2 = e3.bl_count[h3]; 0 !== l2; ) u2 = e3.heap[--d3], u2 > n3 || (i3[2 * u2 + 1] !== h3 && (e3.opt_len += (h3 - i3[2 * u2 + 1]) * i3[2 * u2], i3[2 * u2 + 1] = h3), l2--);
          }
        })(e2, t2), nO(i2, d2, e2.bl_count);
      }, lO = (e2, t2, i2) => {
        let n2, r2, s2 = -1, o2 = t2[1], a2 = 0, c2 = 7, d2 = 4;
        for (0 === o2 && (c2 = 138, d2 = 3), t2[2 * (i2 + 1) + 1] = 65535, n2 = 0; n2 <= i2; n2++) r2 = o2, o2 = t2[2 * (n2 + 1) + 1], ++a2 < c2 && r2 === o2 || (a2 < d2 ? e2.bl_tree[2 * r2] += a2 : 0 !== r2 ? (r2 !== s2 && e2.bl_tree[2 * r2]++, e2.bl_tree[32]++) : a2 <= 10 ? e2.bl_tree[34]++ : e2.bl_tree[36]++, a2 = 0, s2 = r2, 0 === o2 ? (c2 = 138, d2 = 3) : r2 === o2 ? (c2 = 6, d2 = 3) : (c2 = 7, d2 = 4));
      }, uO = (e2, t2, i2) => {
        let n2, r2, s2 = -1, o2 = t2[1], a2 = 0, c2 = 7, d2 = 4;
        for (0 === o2 && (c2 = 138, d2 = 3), n2 = 0; n2 <= i2; n2++) if (r2 = o2, o2 = t2[2 * (n2 + 1) + 1], !(++a2 < c2 && r2 === o2)) {
          if (a2 < d2) do {
            tO(e2, r2, e2.bl_tree);
          } while (0 != --a2);
          else 0 !== r2 ? (r2 !== s2 && (tO(e2, r2, e2.bl_tree), a2--), tO(e2, 16, e2.bl_tree), eO(e2, a2 - 3, 2)) : a2 <= 10 ? (tO(e2, 17, e2.bl_tree), eO(e2, a2 - 3, 3)) : (tO(e2, 18, e2.bl_tree), eO(e2, a2 - 11, 7));
          a2 = 0, s2 = r2, 0 === o2 ? (c2 = 138, d2 = 3) : r2 === o2 ? (c2 = 6, d2 = 3) : (c2 = 7, d2 = 4);
        }
      };
      let hO = false;
      const pO = (e2, t2, i2, n2) => {
        eO(e2, 0 + (n2 ? 1 : 0), 3), sO(e2), $w(e2, i2), $w(e2, ~i2), i2 && e2.pending_buf.set(e2.window.subarray(t2, t2 + i2), e2.pending), e2.pending += i2;
      };
      var _O = (e2) => {
        hO || ((() => {
          let e3, t2, i2, n2, r2;
          const s2 = new Array(16);
          for (i2 = 0, n2 = 0; n2 < 28; n2++) for (Kw[n2] = i2, e3 = 0; e3 < 1 << xw[n2]; e3++) Hw[i2++] = n2;
          for (Hw[i2 - 1] = n2, r2 = 0, n2 = 0; n2 < 16; n2++) for (Yw[n2] = r2, e3 = 0; e3 < 1 << Vw[n2]; e3++) Ww[r2++] = n2;
          for (r2 >>= 7; n2 < Mw; n2++) for (Yw[n2] = r2 << 7, e3 = 0; e3 < 1 << Vw[n2] - 7; e3++) Ww[256 + r2++] = n2;
          for (t2 = 0; t2 <= Uw; t2++) s2[t2] = 0;
          for (e3 = 0; e3 <= 143; ) jw[2 * e3 + 1] = 8, e3++, s2[8]++;
          for (; e3 <= 255; ) jw[2 * e3 + 1] = 9, e3++, s2[9]++;
          for (; e3 <= 279; ) jw[2 * e3 + 1] = 7, e3++, s2[7]++;
          for (; e3 <= 287; ) jw[2 * e3 + 1] = 8, e3++, s2[8]++;
          for (nO(jw, 287, s2), e3 = 0; e3 < Mw; e3++) Gw[2 * e3 + 1] = 5, Gw[2 * e3] = iO(e3, 5);
          zw = new qw(jw, xw, 257, kw, Uw), Jw = new qw(Gw, Vw, 0, Mw, Uw), Xw = new qw(new Array(0), Fw, 0, 19, 7);
        })(), hO = true), e2.l_desc = new Qw(e2.dyn_ltree, zw), e2.d_desc = new Qw(e2.dyn_dtree, Jw), e2.bl_desc = new Qw(e2.bl_tree, Xw), e2.bi_buf = 0, e2.bi_valid = 0, rO(e2);
      }, EO = (e2, t2, i2, n2) => {
        let r2, s2, o2 = 0;
        e2.level > 0 ? (2 === e2.strm.data_type && (e2.strm.data_type = ((e3) => {
          let t3, i3 = 4093624447;
          for (t3 = 0; t3 <= 31; t3++, i3 >>>= 1) if (1 & i3 && 0 !== e3.dyn_ltree[2 * t3]) return 0;
          if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26]) return 1;
          for (t3 = 32; t3 < Lw; t3++) if (0 !== e3.dyn_ltree[2 * t3]) return 1;
          return 0;
        })(e2)), dO(e2, e2.l_desc), dO(e2, e2.d_desc), o2 = ((e3) => {
          let t3;
          for (lO(e3, e3.dyn_ltree, e3.l_desc.max_code), lO(e3, e3.dyn_dtree, e3.d_desc.max_code), dO(e3, e3.bl_desc), t3 = 18; t3 >= 3 && 0 === e3.bl_tree[2 * Bw[t3] + 1]; t3--) ;
          return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
        })(e2), r2 = e2.opt_len + 3 + 7 >>> 3, s2 = e2.static_len + 3 + 7 >>> 3, s2 <= r2 && (r2 = s2)) : r2 = s2 = i2 + 5, i2 + 4 <= r2 && -1 !== t2 ? pO(e2, t2, i2, n2) : 4 === e2.strategy || s2 === r2 ? (eO(e2, 2 + (n2 ? 1 : 0), 3), cO(e2, jw, Gw)) : (eO(e2, 4 + (n2 ? 1 : 0), 3), ((e3, t3, i3, n3) => {
          let r3;
          for (eO(e3, t3 - 257, 5), eO(e3, i3 - 1, 5), eO(e3, n3 - 4, 4), r3 = 0; r3 < n3; r3++) eO(e3, e3.bl_tree[2 * Bw[r3] + 1], 3);
          uO(e3, e3.dyn_ltree, t3 - 1), uO(e3, e3.dyn_dtree, i3 - 1);
        })(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, o2 + 1), cO(e2, e2.dyn_ltree, e2.dyn_dtree)), rO(e2), n2 && sO(e2);
      }, mO = (e2, t2, i2) => (e2.pending_buf[e2.sym_buf + e2.sym_next++] = t2, e2.pending_buf[e2.sym_buf + e2.sym_next++] = t2 >> 8, e2.pending_buf[e2.sym_buf + e2.sym_next++] = i2, 0 === t2 ? e2.dyn_ltree[2 * i2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (Hw[i2] + Lw + 1)]++, e2.dyn_dtree[2 * Zw(t2)]++), e2.sym_next === e2.sym_end), fO = { _tr_init: _O, _tr_stored_block: pO, _tr_flush_block: EO, _tr_tally: mO, _tr_align: (e2) => {
        eO(e2, 2, 3), tO(e2, 256, jw), ((e3) => {
          16 === e3.bi_valid ? ($w(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : e3.bi_valid >= 8 && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
        })(e2);
      } };
      var gO = (e2, t2, i2, n2) => {
        let r2 = 65535 & e2 | 0, s2 = e2 >>> 16 & 65535 | 0, o2 = 0;
        for (; 0 !== i2; ) {
          o2 = i2 > 2e3 ? 2e3 : i2, i2 -= o2;
          do {
            r2 = r2 + t2[n2++] | 0, s2 = s2 + r2 | 0;
          } while (--o2);
          r2 %= 65521, s2 %= 65521;
        }
        return r2 | s2 << 16 | 0;
      };
      const TO = new Uint32Array((() => {
        let e2, t2 = [];
        for (var i2 = 0; i2 < 256; i2++) {
          e2 = i2;
          for (var n2 = 0; n2 < 8; n2++) e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
          t2[i2] = e2;
        }
        return t2;
      })());
      var SO = (e2, t2, i2, n2) => {
        const r2 = TO, s2 = n2 + i2;
        e2 ^= -1;
        for (let i3 = n2; i3 < s2; i3++) e2 = e2 >>> 8 ^ r2[255 & (e2 ^ t2[i3])];
        return -1 ^ e2;
      }, RO = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" }, CO = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      const { _tr_init: IO, _tr_stored_block: vO, _tr_flush_block: yO, _tr_tally: AO, _tr_align: bO } = fO, { Z_NO_FLUSH: wO, Z_PARTIAL_FLUSH: OO, Z_FULL_FLUSH: NO, Z_FINISH: DO, Z_BLOCK: PO, Z_OK: LO, Z_STREAM_END: kO, Z_STREAM_ERROR: MO, Z_DATA_ERROR: UO, Z_BUF_ERROR: xO, Z_DEFAULT_COMPRESSION: VO, Z_FILTERED: FO, Z_HUFFMAN_ONLY: BO, Z_RLE: jO, Z_FIXED: GO, Z_DEFAULT_STRATEGY: WO, Z_UNKNOWN: HO, Z_DEFLATED: KO } = CO, YO = 286, qO = 30, zO = 19, JO = 2 * YO + 1, XO = 15, QO = 258, ZO = 262, $O = 42, eN = 113, tN = 666, iN = (e2, t2) => (e2.msg = RO[t2], t2), nN = (e2) => 2 * e2 - (e2 > 4 ? 9 : 0), rN = (e2) => {
        let t2 = e2.length;
        for (; --t2 >= 0; ) e2[t2] = 0;
      }, sN = (e2) => {
        let t2, i2, n2, r2 = e2.w_size;
        t2 = e2.hash_size, n2 = t2;
        do {
          i2 = e2.head[--n2], e2.head[n2] = i2 >= r2 ? i2 - r2 : 0;
        } while (--t2);
        t2 = r2, n2 = t2;
        do {
          i2 = e2.prev[--n2], e2.prev[n2] = i2 >= r2 ? i2 - r2 : 0;
        } while (--t2);
      };
      let oN = (e2, t2, i2) => (t2 << e2.hash_shift ^ i2) & e2.hash_mask;
      const aN = (e2) => {
        const t2 = e2.state;
        let i2 = t2.pending;
        i2 > e2.avail_out && (i2 = e2.avail_out), 0 !== i2 && (e2.output.set(t2.pending_buf.subarray(t2.pending_out, t2.pending_out + i2), e2.next_out), e2.next_out += i2, t2.pending_out += i2, e2.total_out += i2, e2.avail_out -= i2, t2.pending -= i2, 0 === t2.pending && (t2.pending_out = 0));
      }, cN = (e2, t2) => {
        yO(e2, e2.block_start >= 0 ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, aN(e2.strm);
      }, dN = (e2, t2) => {
        e2.pending_buf[e2.pending++] = t2;
      }, lN = (e2, t2) => {
        e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
      }, uN = (e2, t2, i2, n2) => {
        let r2 = e2.avail_in;
        return r2 > n2 && (r2 = n2), 0 === r2 ? 0 : (e2.avail_in -= r2, t2.set(e2.input.subarray(e2.next_in, e2.next_in + r2), i2), 1 === e2.state.wrap ? e2.adler = gO(e2.adler, t2, r2, i2) : 2 === e2.state.wrap && (e2.adler = SO(e2.adler, t2, r2, i2)), e2.next_in += r2, e2.total_in += r2, r2);
      }, hN = (e2, t2) => {
        let i2, n2, r2 = e2.max_chain_length, s2 = e2.strstart, o2 = e2.prev_length, a2 = e2.nice_match;
        const c2 = e2.strstart > e2.w_size - ZO ? e2.strstart - (e2.w_size - ZO) : 0, d2 = e2.window, l2 = e2.w_mask, u2 = e2.prev, h3 = e2.strstart + QO;
        let p2 = d2[s2 + o2 - 1], _2 = d2[s2 + o2];
        e2.prev_length >= e2.good_match && (r2 >>= 2), a2 > e2.lookahead && (a2 = e2.lookahead);
        do {
          if (i2 = t2, d2[i2 + o2] === _2 && d2[i2 + o2 - 1] === p2 && d2[i2] === d2[s2] && d2[++i2] === d2[s2 + 1]) {
            s2 += 2, i2++;
            do {
            } while (d2[++s2] === d2[++i2] && d2[++s2] === d2[++i2] && d2[++s2] === d2[++i2] && d2[++s2] === d2[++i2] && d2[++s2] === d2[++i2] && d2[++s2] === d2[++i2] && d2[++s2] === d2[++i2] && d2[++s2] === d2[++i2] && s2 < h3);
            if (n2 = QO - (h3 - s2), s2 = h3 - QO, n2 > o2) {
              if (e2.match_start = t2, o2 = n2, n2 >= a2) break;
              p2 = d2[s2 + o2 - 1], _2 = d2[s2 + o2];
            }
          }
        } while ((t2 = u2[t2 & l2]) > c2 && 0 != --r2);
        return o2 <= e2.lookahead ? o2 : e2.lookahead;
      }, pN = (e2) => {
        const t2 = e2.w_size;
        let i2, n2, r2;
        do {
          if (n2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= t2 + (t2 - ZO) && (e2.window.set(e2.window.subarray(t2, t2 + t2 - n2), 0), e2.match_start -= t2, e2.strstart -= t2, e2.block_start -= t2, e2.insert > e2.strstart && (e2.insert = e2.strstart), sN(e2), n2 += t2), 0 === e2.strm.avail_in) break;
          if (i2 = uN(e2.strm, e2.window, e2.strstart + e2.lookahead, n2), e2.lookahead += i2, e2.lookahead + e2.insert >= 3) for (r2 = e2.strstart - e2.insert, e2.ins_h = e2.window[r2], e2.ins_h = oN(e2, e2.ins_h, e2.window[r2 + 1]); e2.insert && (e2.ins_h = oN(e2, e2.ins_h, e2.window[r2 + 3 - 1]), e2.prev[r2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = r2, r2++, e2.insert--, !(e2.lookahead + e2.insert < 3)); ) ;
        } while (e2.lookahead < ZO && 0 !== e2.strm.avail_in);
      }, _N = (e2, t2) => {
        let i2, n2, r2, s2 = e2.pending_buf_size - 5 > e2.w_size ? e2.w_size : e2.pending_buf_size - 5, o2 = 0, a2 = e2.strm.avail_in;
        do {
          if (i2 = 65535, r2 = e2.bi_valid + 42 >> 3, e2.strm.avail_out < r2) break;
          if (r2 = e2.strm.avail_out - r2, n2 = e2.strstart - e2.block_start, i2 > n2 + e2.strm.avail_in && (i2 = n2 + e2.strm.avail_in), i2 > r2 && (i2 = r2), i2 < s2 && (0 === i2 && t2 !== DO || t2 === wO || i2 !== n2 + e2.strm.avail_in)) break;
          o2 = t2 === DO && i2 === n2 + e2.strm.avail_in ? 1 : 0, vO(e2, 0, 0, o2), e2.pending_buf[e2.pending - 4] = i2, e2.pending_buf[e2.pending - 3] = i2 >> 8, e2.pending_buf[e2.pending - 2] = ~i2, e2.pending_buf[e2.pending - 1] = ~i2 >> 8, aN(e2.strm), n2 && (n2 > i2 && (n2 = i2), e2.strm.output.set(e2.window.subarray(e2.block_start, e2.block_start + n2), e2.strm.next_out), e2.strm.next_out += n2, e2.strm.avail_out -= n2, e2.strm.total_out += n2, e2.block_start += n2, i2 -= n2), i2 && (uN(e2.strm, e2.strm.output, e2.strm.next_out, i2), e2.strm.next_out += i2, e2.strm.avail_out -= i2, e2.strm.total_out += i2);
        } while (0 === o2);
        return a2 -= e2.strm.avail_in, a2 && (a2 >= e2.w_size ? (e2.matches = 2, e2.window.set(e2.strm.input.subarray(e2.strm.next_in - e2.w_size, e2.strm.next_in), 0), e2.strstart = e2.w_size, e2.insert = e2.strstart) : (e2.window_size - e2.strstart <= a2 && (e2.strstart -= e2.w_size, e2.window.set(e2.window.subarray(e2.w_size, e2.w_size + e2.strstart), 0), e2.matches < 2 && e2.matches++, e2.insert > e2.strstart && (e2.insert = e2.strstart)), e2.window.set(e2.strm.input.subarray(e2.strm.next_in - a2, e2.strm.next_in), e2.strstart), e2.strstart += a2, e2.insert += a2 > e2.w_size - e2.insert ? e2.w_size - e2.insert : a2), e2.block_start = e2.strstart), e2.high_water < e2.strstart && (e2.high_water = e2.strstart), o2 ? 4 : t2 !== wO && t2 !== DO && 0 === e2.strm.avail_in && e2.strstart === e2.block_start ? 2 : (r2 = e2.window_size - e2.strstart, e2.strm.avail_in > r2 && e2.block_start >= e2.w_size && (e2.block_start -= e2.w_size, e2.strstart -= e2.w_size, e2.window.set(e2.window.subarray(e2.w_size, e2.w_size + e2.strstart), 0), e2.matches < 2 && e2.matches++, r2 += e2.w_size, e2.insert > e2.strstart && (e2.insert = e2.strstart)), r2 > e2.strm.avail_in && (r2 = e2.strm.avail_in), r2 && (uN(e2.strm, e2.window, e2.strstart, r2), e2.strstart += r2, e2.insert += r2 > e2.w_size - e2.insert ? e2.w_size - e2.insert : r2), e2.high_water < e2.strstart && (e2.high_water = e2.strstart), r2 = e2.bi_valid + 42 >> 3, r2 = e2.pending_buf_size - r2 > 65535 ? 65535 : e2.pending_buf_size - r2, s2 = r2 > e2.w_size ? e2.w_size : r2, n2 = e2.strstart - e2.block_start, (n2 >= s2 || (n2 || t2 === DO) && t2 !== wO && 0 === e2.strm.avail_in && n2 <= r2) && (i2 = n2 > r2 ? r2 : n2, o2 = t2 === DO && 0 === e2.strm.avail_in && i2 === n2 ? 1 : 0, vO(e2, e2.block_start, i2, o2), e2.block_start += i2, aN(e2.strm)), o2 ? 3 : 1);
      }, EN = (e2, t2) => {
        let i2, n2;
        for (; ; ) {
          if (e2.lookahead < ZO) {
            if (pN(e2), e2.lookahead < ZO && t2 === wO) return 1;
            if (0 === e2.lookahead) break;
          }
          if (i2 = 0, e2.lookahead >= 3 && (e2.ins_h = oN(e2, e2.ins_h, e2.window[e2.strstart + 3 - 1]), i2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== i2 && e2.strstart - i2 <= e2.w_size - ZO && (e2.match_length = hN(e2, i2)), e2.match_length >= 3) if (n2 = AO(e2, e2.strstart - e2.match_start, e2.match_length - 3), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= 3) {
            e2.match_length--;
            do {
              e2.strstart++, e2.ins_h = oN(e2, e2.ins_h, e2.window[e2.strstart + 3 - 1]), i2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart;
            } while (0 != --e2.match_length);
            e2.strstart++;
          } else e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = oN(e2, e2.ins_h, e2.window[e2.strstart + 1]);
          else n2 = AO(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
          if (n2 && (cN(e2, false), 0 === e2.strm.avail_out)) return 1;
        }
        return e2.insert = e2.strstart < 2 ? e2.strstart : 2, t2 === DO ? (cN(e2, true), 0 === e2.strm.avail_out ? 3 : 4) : e2.sym_next && (cN(e2, false), 0 === e2.strm.avail_out) ? 1 : 2;
      }, mN = (e2, t2) => {
        let i2, n2, r2;
        for (; ; ) {
          if (e2.lookahead < ZO) {
            if (pN(e2), e2.lookahead < ZO && t2 === wO) return 1;
            if (0 === e2.lookahead) break;
          }
          if (i2 = 0, e2.lookahead >= 3 && (e2.ins_h = oN(e2, e2.ins_h, e2.window[e2.strstart + 3 - 1]), i2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = 2, 0 !== i2 && e2.prev_length < e2.max_lazy_match && e2.strstart - i2 <= e2.w_size - ZO && (e2.match_length = hN(e2, i2), e2.match_length <= 5 && (e2.strategy === FO || 3 === e2.match_length && e2.strstart - e2.match_start > 4096) && (e2.match_length = 2)), e2.prev_length >= 3 && e2.match_length <= e2.prev_length) {
            r2 = e2.strstart + e2.lookahead - 3, n2 = AO(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - 3), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2;
            do {
              ++e2.strstart <= r2 && (e2.ins_h = oN(e2, e2.ins_h, e2.window[e2.strstart + 3 - 1]), i2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart);
            } while (0 != --e2.prev_length);
            if (e2.match_available = 0, e2.match_length = 2, e2.strstart++, n2 && (cN(e2, false), 0 === e2.strm.avail_out)) return 1;
          } else if (e2.match_available) {
            if (n2 = AO(e2, 0, e2.window[e2.strstart - 1]), n2 && cN(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out) return 1;
          } else e2.match_available = 1, e2.strstart++, e2.lookahead--;
        }
        return e2.match_available && (n2 = AO(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < 2 ? e2.strstart : 2, t2 === DO ? (cN(e2, true), 0 === e2.strm.avail_out ? 3 : 4) : e2.sym_next && (cN(e2, false), 0 === e2.strm.avail_out) ? 1 : 2;
      };
      function fN(e2, t2, i2, n2, r2) {
        this.good_length = e2, this.max_lazy = t2, this.nice_length = i2, this.max_chain = n2, this.func = r2;
      }
      const gN = [new fN(0, 0, 0, 0, _N), new fN(4, 4, 8, 4, EN), new fN(4, 5, 16, 8, EN), new fN(4, 6, 32, 32, EN), new fN(4, 4, 16, 16, mN), new fN(8, 16, 32, 32, mN), new fN(8, 16, 128, 128, mN), new fN(8, 32, 128, 256, mN), new fN(32, 128, 258, 1024, mN), new fN(32, 258, 258, 4096, mN)];
      function TN() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = KO, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(2 * JO), this.dyn_dtree = new Uint16Array(2 * (2 * qO + 1)), this.bl_tree = new Uint16Array(2 * (2 * zO + 1)), rN(this.dyn_ltree), rN(this.dyn_dtree), rN(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(XO + 1), this.heap = new Uint16Array(2 * YO + 1), rN(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * YO + 1), rN(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      const SN = (e2) => {
        if (!e2) return 1;
        const t2 = e2.state;
        return !t2 || t2.strm !== e2 || t2.status !== $O && 57 !== t2.status && 69 !== t2.status && 73 !== t2.status && 91 !== t2.status && 103 !== t2.status && t2.status !== eN && t2.status !== tN ? 1 : 0;
      }, RN = (e2) => {
        if (SN(e2)) return iN(e2, MO);
        e2.total_in = e2.total_out = 0, e2.data_type = HO;
        const t2 = e2.state;
        return t2.pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = 2 === t2.wrap ? 57 : t2.wrap ? $O : eN, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = -2, IO(t2), LO;
      }, CN = (e2) => {
        const t2 = RN(e2);
        var i2;
        return t2 === LO && ((i2 = e2.state).window_size = 2 * i2.w_size, rN(i2.head), i2.max_lazy_match = gN[i2.level].max_lazy, i2.good_match = gN[i2.level].good_length, i2.nice_match = gN[i2.level].nice_length, i2.max_chain_length = gN[i2.level].max_chain, i2.strstart = 0, i2.block_start = 0, i2.lookahead = 0, i2.insert = 0, i2.match_length = i2.prev_length = 2, i2.match_available = 0, i2.ins_h = 0), t2;
      }, IN = (e2, t2, i2, n2, r2, s2) => {
        if (!e2) return MO;
        let o2 = 1;
        if (t2 === VO && (t2 = 6), n2 < 0 ? (o2 = 0, n2 = -n2) : n2 > 15 && (o2 = 2, n2 -= 16), r2 < 1 || r2 > 9 || i2 !== KO || n2 < 8 || n2 > 15 || t2 < 0 || t2 > 9 || s2 < 0 || s2 > GO || 8 === n2 && 1 !== o2) return iN(e2, MO);
        8 === n2 && (n2 = 9);
        const a2 = new TN();
        return e2.state = a2, a2.strm = e2, a2.status = $O, a2.wrap = o2, a2.gzhead = null, a2.w_bits = n2, a2.w_size = 1 << a2.w_bits, a2.w_mask = a2.w_size - 1, a2.hash_bits = r2 + 7, a2.hash_size = 1 << a2.hash_bits, a2.hash_mask = a2.hash_size - 1, a2.hash_shift = ~~((a2.hash_bits + 3 - 1) / 3), a2.window = new Uint8Array(2 * a2.w_size), a2.head = new Uint16Array(a2.hash_size), a2.prev = new Uint16Array(a2.w_size), a2.lit_bufsize = 1 << r2 + 6, a2.pending_buf_size = 4 * a2.lit_bufsize, a2.pending_buf = new Uint8Array(a2.pending_buf_size), a2.sym_buf = a2.lit_bufsize, a2.sym_end = 3 * (a2.lit_bufsize - 1), a2.level = t2, a2.strategy = s2, a2.method = i2, CN(e2);
      };
      var vN = (e2, t2) => {
        if (SN(e2) || t2 > PO || t2 < 0) return e2 ? iN(e2, MO) : MO;
        const i2 = e2.state;
        if (!e2.output || 0 !== e2.avail_in && !e2.input || i2.status === tN && t2 !== DO) return iN(e2, 0 === e2.avail_out ? xO : MO);
        const n2 = i2.last_flush;
        if (i2.last_flush = t2, 0 !== i2.pending) {
          if (aN(e2), 0 === e2.avail_out) return i2.last_flush = -1, LO;
        } else if (0 === e2.avail_in && nN(t2) <= nN(n2) && t2 !== DO) return iN(e2, xO);
        if (i2.status === tN && 0 !== e2.avail_in) return iN(e2, xO);
        if (i2.status === $O && 0 === i2.wrap && (i2.status = eN), i2.status === $O) {
          let t3 = KO + (i2.w_bits - 8 << 4) << 8, n3 = -1;
          if (n3 = i2.strategy >= BO || i2.level < 2 ? 0 : i2.level < 6 ? 1 : 6 === i2.level ? 2 : 3, t3 |= n3 << 6, 0 !== i2.strstart && (t3 |= 32), t3 += 31 - t3 % 31, lN(i2, t3), 0 !== i2.strstart && (lN(i2, e2.adler >>> 16), lN(i2, 65535 & e2.adler)), e2.adler = 1, i2.status = eN, aN(e2), 0 !== i2.pending) return i2.last_flush = -1, LO;
        }
        if (57 === i2.status) {
          if (e2.adler = 0, dN(i2, 31), dN(i2, 139), dN(i2, 8), i2.gzhead) dN(i2, (i2.gzhead.text ? 1 : 0) + (i2.gzhead.hcrc ? 2 : 0) + (i2.gzhead.extra ? 4 : 0) + (i2.gzhead.name ? 8 : 0) + (i2.gzhead.comment ? 16 : 0)), dN(i2, 255 & i2.gzhead.time), dN(i2, i2.gzhead.time >> 8 & 255), dN(i2, i2.gzhead.time >> 16 & 255), dN(i2, i2.gzhead.time >> 24 & 255), dN(i2, 9 === i2.level ? 2 : i2.strategy >= BO || i2.level < 2 ? 4 : 0), dN(i2, 255 & i2.gzhead.os), i2.gzhead.extra && i2.gzhead.extra.length && (dN(i2, 255 & i2.gzhead.extra.length), dN(i2, i2.gzhead.extra.length >> 8 & 255)), i2.gzhead.hcrc && (e2.adler = SO(e2.adler, i2.pending_buf, i2.pending, 0)), i2.gzindex = 0, i2.status = 69;
          else if (dN(i2, 0), dN(i2, 0), dN(i2, 0), dN(i2, 0), dN(i2, 0), dN(i2, 9 === i2.level ? 2 : i2.strategy >= BO || i2.level < 2 ? 4 : 0), dN(i2, 3), i2.status = eN, aN(e2), 0 !== i2.pending) return i2.last_flush = -1, LO;
        }
        if (69 === i2.status) {
          if (i2.gzhead.extra) {
            let t3 = i2.pending, n3 = (65535 & i2.gzhead.extra.length) - i2.gzindex;
            for (; i2.pending + n3 > i2.pending_buf_size; ) {
              let r3 = i2.pending_buf_size - i2.pending;
              if (i2.pending_buf.set(i2.gzhead.extra.subarray(i2.gzindex, i2.gzindex + r3), i2.pending), i2.pending = i2.pending_buf_size, i2.gzhead.hcrc && i2.pending > t3 && (e2.adler = SO(e2.adler, i2.pending_buf, i2.pending - t3, t3)), i2.gzindex += r3, aN(e2), 0 !== i2.pending) return i2.last_flush = -1, LO;
              t3 = 0, n3 -= r3;
            }
            let r2 = new Uint8Array(i2.gzhead.extra);
            i2.pending_buf.set(r2.subarray(i2.gzindex, i2.gzindex + n3), i2.pending), i2.pending += n3, i2.gzhead.hcrc && i2.pending > t3 && (e2.adler = SO(e2.adler, i2.pending_buf, i2.pending - t3, t3)), i2.gzindex = 0;
          }
          i2.status = 73;
        }
        if (73 === i2.status) {
          if (i2.gzhead.name) {
            let t3, n3 = i2.pending;
            do {
              if (i2.pending === i2.pending_buf_size) {
                if (i2.gzhead.hcrc && i2.pending > n3 && (e2.adler = SO(e2.adler, i2.pending_buf, i2.pending - n3, n3)), aN(e2), 0 !== i2.pending) return i2.last_flush = -1, LO;
                n3 = 0;
              }
              t3 = i2.gzindex < i2.gzhead.name.length ? 255 & i2.gzhead.name.charCodeAt(i2.gzindex++) : 0, dN(i2, t3);
            } while (0 !== t3);
            i2.gzhead.hcrc && i2.pending > n3 && (e2.adler = SO(e2.adler, i2.pending_buf, i2.pending - n3, n3)), i2.gzindex = 0;
          }
          i2.status = 91;
        }
        if (91 === i2.status) {
          if (i2.gzhead.comment) {
            let t3, n3 = i2.pending;
            do {
              if (i2.pending === i2.pending_buf_size) {
                if (i2.gzhead.hcrc && i2.pending > n3 && (e2.adler = SO(e2.adler, i2.pending_buf, i2.pending - n3, n3)), aN(e2), 0 !== i2.pending) return i2.last_flush = -1, LO;
                n3 = 0;
              }
              t3 = i2.gzindex < i2.gzhead.comment.length ? 255 & i2.gzhead.comment.charCodeAt(i2.gzindex++) : 0, dN(i2, t3);
            } while (0 !== t3);
            i2.gzhead.hcrc && i2.pending > n3 && (e2.adler = SO(e2.adler, i2.pending_buf, i2.pending - n3, n3));
          }
          i2.status = 103;
        }
        if (103 === i2.status) {
          if (i2.gzhead.hcrc) {
            if (i2.pending + 2 > i2.pending_buf_size && (aN(e2), 0 !== i2.pending)) return i2.last_flush = -1, LO;
            dN(i2, 255 & e2.adler), dN(i2, e2.adler >> 8 & 255), e2.adler = 0;
          }
          if (i2.status = eN, aN(e2), 0 !== i2.pending) return i2.last_flush = -1, LO;
        }
        if (0 !== e2.avail_in || 0 !== i2.lookahead || t2 !== wO && i2.status !== tN) {
          let n3 = 0 === i2.level ? _N(i2, t2) : i2.strategy === BO ? ((e3, t3) => {
            let i3;
            for (; ; ) {
              if (0 === e3.lookahead && (pN(e3), 0 === e3.lookahead)) {
                if (t3 === wO) return 1;
                break;
              }
              if (e3.match_length = 0, i3 = AO(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, i3 && (cN(e3, false), 0 === e3.strm.avail_out)) return 1;
            }
            return e3.insert = 0, t3 === DO ? (cN(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : e3.sym_next && (cN(e3, false), 0 === e3.strm.avail_out) ? 1 : 2;
          })(i2, t2) : i2.strategy === jO ? ((e3, t3) => {
            let i3, n4, r2, s2;
            const o2 = e3.window;
            for (; ; ) {
              if (e3.lookahead <= QO) {
                if (pN(e3), e3.lookahead <= QO && t3 === wO) return 1;
                if (0 === e3.lookahead) break;
              }
              if (e3.match_length = 0, e3.lookahead >= 3 && e3.strstart > 0 && (r2 = e3.strstart - 1, n4 = o2[r2], n4 === o2[++r2] && n4 === o2[++r2] && n4 === o2[++r2])) {
                s2 = e3.strstart + QO;
                do {
                } while (n4 === o2[++r2] && n4 === o2[++r2] && n4 === o2[++r2] && n4 === o2[++r2] && n4 === o2[++r2] && n4 === o2[++r2] && n4 === o2[++r2] && n4 === o2[++r2] && r2 < s2);
                e3.match_length = QO - (s2 - r2), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
              }
              if (e3.match_length >= 3 ? (i3 = AO(e3, 1, e3.match_length - 3), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (i3 = AO(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), i3 && (cN(e3, false), 0 === e3.strm.avail_out)) return 1;
            }
            return e3.insert = 0, t3 === DO ? (cN(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : e3.sym_next && (cN(e3, false), 0 === e3.strm.avail_out) ? 1 : 2;
          })(i2, t2) : gN[i2.level].func(i2, t2);
          if (3 !== n3 && 4 !== n3 || (i2.status = tN), 1 === n3 || 3 === n3) return 0 === e2.avail_out && (i2.last_flush = -1), LO;
          if (2 === n3 && (t2 === OO ? bO(i2) : t2 !== PO && (vO(i2, 0, 0, false), t2 === NO && (rN(i2.head), 0 === i2.lookahead && (i2.strstart = 0, i2.block_start = 0, i2.insert = 0))), aN(e2), 0 === e2.avail_out)) return i2.last_flush = -1, LO;
        }
        return t2 !== DO ? LO : i2.wrap <= 0 ? kO : (2 === i2.wrap ? (dN(i2, 255 & e2.adler), dN(i2, e2.adler >> 8 & 255), dN(i2, e2.adler >> 16 & 255), dN(i2, e2.adler >> 24 & 255), dN(i2, 255 & e2.total_in), dN(i2, e2.total_in >> 8 & 255), dN(i2, e2.total_in >> 16 & 255), dN(i2, e2.total_in >> 24 & 255)) : (lN(i2, e2.adler >>> 16), lN(i2, 65535 & e2.adler)), aN(e2), i2.wrap > 0 && (i2.wrap = -i2.wrap), 0 !== i2.pending ? LO : kO);
      }, yN = (e2, t2) => {
        let i2 = t2.length;
        if (SN(e2)) return MO;
        const n2 = e2.state, r2 = n2.wrap;
        if (2 === r2 || 1 === r2 && n2.status !== $O || n2.lookahead) return MO;
        if (1 === r2 && (e2.adler = gO(e2.adler, t2, i2, 0)), n2.wrap = 0, i2 >= n2.w_size) {
          0 === r2 && (rN(n2.head), n2.strstart = 0, n2.block_start = 0, n2.insert = 0);
          let e3 = new Uint8Array(n2.w_size);
          e3.set(t2.subarray(i2 - n2.w_size, i2), 0), t2 = e3, i2 = n2.w_size;
        }
        const s2 = e2.avail_in, o2 = e2.next_in, a2 = e2.input;
        for (e2.avail_in = i2, e2.next_in = 0, e2.input = t2, pN(n2); n2.lookahead >= 3; ) {
          let e3 = n2.strstart, t3 = n2.lookahead - 2;
          do {
            n2.ins_h = oN(n2, n2.ins_h, n2.window[e3 + 3 - 1]), n2.prev[e3 & n2.w_mask] = n2.head[n2.ins_h], n2.head[n2.ins_h] = e3, e3++;
          } while (--t3);
          n2.strstart = e3, n2.lookahead = 2, pN(n2);
        }
        return n2.strstart += n2.lookahead, n2.block_start = n2.strstart, n2.insert = n2.lookahead, n2.lookahead = 0, n2.match_length = n2.prev_length = 2, n2.match_available = 0, e2.next_in = o2, e2.input = a2, e2.avail_in = s2, n2.wrap = r2, LO;
      }, AN = { deflateInit: (e2, t2) => IN(e2, t2, KO, 15, 8, WO), deflateInit2: IN, deflateReset: CN, deflateResetKeep: RN, deflateSetHeader: (e2, t2) => SN(e2) || 2 !== e2.state.wrap ? MO : (e2.state.gzhead = t2, LO), deflate: vN, deflateEnd: (e2) => {
        if (SN(e2)) return MO;
        const t2 = e2.state.status;
        return e2.state = null, t2 === eN ? iN(e2, UO) : LO;
      }, deflateSetDictionary: yN, deflateInfo: "pako deflate (from Nodeca project)" };
      const bN = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2);
      var wN = { assign: function(e2) {
        const t2 = Array.prototype.slice.call(arguments, 1);
        for (; t2.length; ) {
          const i2 = t2.shift();
          if (i2) {
            if ("object" != typeof i2) throw new TypeError(i2 + "must be non-object");
            for (const t3 in i2) bN(i2, t3) && (e2[t3] = i2[t3]);
          }
        }
        return e2;
      }, flattenChunks: (e2) => {
        let t2 = 0;
        for (let i3 = 0, n2 = e2.length; i3 < n2; i3++) t2 += e2[i3].length;
        const i2 = new Uint8Array(t2);
        for (let t3 = 0, n2 = 0, r2 = e2.length; t3 < r2; t3++) {
          let r3 = e2[t3];
          i2.set(r3, n2), n2 += r3.length;
        }
        return i2;
      } };
      let ON = true;
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (e2) {
        ON = false;
      }
      const NN = new Uint8Array(256);
      for (let e2 = 0; e2 < 256; e2++) NN[e2] = e2 >= 252 ? 6 : e2 >= 248 ? 5 : e2 >= 240 ? 4 : e2 >= 224 ? 3 : e2 >= 192 ? 2 : 1;
      NN[254] = NN[254] = 1;
      var DN = { string2buf: (e2) => {
        if ("function" == typeof TextEncoder && TextEncoder.prototype.encode) return new TextEncoder().encode(e2);
        let t2, i2, n2, r2, s2, o2 = e2.length, a2 = 0;
        for (r2 = 0; r2 < o2; r2++) i2 = e2.charCodeAt(r2), 55296 == (64512 & i2) && r2 + 1 < o2 && (n2 = e2.charCodeAt(r2 + 1), 56320 == (64512 & n2) && (i2 = 65536 + (i2 - 55296 << 10) + (n2 - 56320), r2++)), a2 += i2 < 128 ? 1 : i2 < 2048 ? 2 : i2 < 65536 ? 3 : 4;
        for (t2 = new Uint8Array(a2), s2 = 0, r2 = 0; s2 < a2; r2++) i2 = e2.charCodeAt(r2), 55296 == (64512 & i2) && r2 + 1 < o2 && (n2 = e2.charCodeAt(r2 + 1), 56320 == (64512 & n2) && (i2 = 65536 + (i2 - 55296 << 10) + (n2 - 56320), r2++)), i2 < 128 ? t2[s2++] = i2 : i2 < 2048 ? (t2[s2++] = 192 | i2 >>> 6, t2[s2++] = 128 | 63 & i2) : i2 < 65536 ? (t2[s2++] = 224 | i2 >>> 12, t2[s2++] = 128 | i2 >>> 6 & 63, t2[s2++] = 128 | 63 & i2) : (t2[s2++] = 240 | i2 >>> 18, t2[s2++] = 128 | i2 >>> 12 & 63, t2[s2++] = 128 | i2 >>> 6 & 63, t2[s2++] = 128 | 63 & i2);
        return t2;
      }, buf2string: (e2, t2) => {
        const i2 = t2 || e2.length;
        if ("function" == typeof TextDecoder && TextDecoder.prototype.decode) return new TextDecoder().decode(e2.subarray(0, t2));
        let n2, r2;
        const s2 = new Array(2 * i2);
        for (r2 = 0, n2 = 0; n2 < i2; ) {
          let t3 = e2[n2++];
          if (t3 < 128) {
            s2[r2++] = t3;
            continue;
          }
          let o2 = NN[t3];
          if (o2 > 4) s2[r2++] = 65533, n2 += o2 - 1;
          else {
            for (t3 &= 2 === o2 ? 31 : 3 === o2 ? 15 : 7; o2 > 1 && n2 < i2; ) t3 = t3 << 6 | 63 & e2[n2++], o2--;
            o2 > 1 ? s2[r2++] = 65533 : t3 < 65536 ? s2[r2++] = t3 : (t3 -= 65536, s2[r2++] = 55296 | t3 >> 10 & 1023, s2[r2++] = 56320 | 1023 & t3);
          }
        }
        return ((e3, t3) => {
          if (t3 < 65534 && e3.subarray && ON) return String.fromCharCode.apply(null, e3.length === t3 ? e3 : e3.subarray(0, t3));
          let i3 = "";
          for (let n3 = 0; n3 < t3; n3++) i3 += String.fromCharCode(e3[n3]);
          return i3;
        })(s2, r2);
      }, utf8border: (e2, t2) => {
        (t2 = t2 || e2.length) > e2.length && (t2 = e2.length);
        let i2 = t2 - 1;
        for (; i2 >= 0 && 128 == (192 & e2[i2]); ) i2--;
        return i2 < 0 || 0 === i2 ? t2 : i2 + NN[e2[i2]] > t2 ? i2 : t2;
      } };
      var PN = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
      const LN = Object.prototype.toString, { Z_NO_FLUSH: kN, Z_SYNC_FLUSH: MN, Z_FULL_FLUSH: UN, Z_FINISH: xN, Z_OK: VN, Z_STREAM_END: FN, Z_DEFAULT_COMPRESSION: BN, Z_DEFAULT_STRATEGY: jN, Z_DEFLATED: GN } = CO;
      function WN(e2) {
        this.options = wN.assign({ level: BN, method: GN, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: jN }, e2 || {});
        let t2 = this.options;
        t2.raw && t2.windowBits > 0 ? t2.windowBits = -t2.windowBits : t2.gzip && t2.windowBits > 0 && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new PN(), this.strm.avail_out = 0;
        let i2 = AN.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
        if (i2 !== VN) throw new Error(RO[i2]);
        if (t2.header && AN.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
          let e3;
          if (e3 = "string" == typeof t2.dictionary ? DN.string2buf(t2.dictionary) : "[object ArrayBuffer]" === LN.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, i2 = AN.deflateSetDictionary(this.strm, e3), i2 !== VN) throw new Error(RO[i2]);
          this._dict_set = true;
        }
      }
      function HN(e2, t2) {
        const i2 = new WN(t2);
        if (i2.push(e2, true), i2.err) throw i2.msg || RO[i2.err];
        return i2.result;
      }
      WN.prototype.push = function(e2, t2) {
        const i2 = this.strm, n2 = this.options.chunkSize;
        let r2, s2;
        if (this.ended) return false;
        for (s2 = t2 === ~~t2 ? t2 : true === t2 ? xN : kN, "string" == typeof e2 ? i2.input = DN.string2buf(e2) : "[object ArrayBuffer]" === LN.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length; ; ) if (0 === i2.avail_out && (i2.output = new Uint8Array(n2), i2.next_out = 0, i2.avail_out = n2), (s2 === MN || s2 === UN) && i2.avail_out <= 6) this.onData(i2.output.subarray(0, i2.next_out)), i2.avail_out = 0;
        else {
          if (r2 = AN.deflate(i2, s2), r2 === FN) return i2.next_out > 0 && this.onData(i2.output.subarray(0, i2.next_out)), r2 = AN.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === VN;
          if (0 !== i2.avail_out) {
            if (s2 > 0 && i2.next_out > 0) this.onData(i2.output.subarray(0, i2.next_out)), i2.avail_out = 0;
            else if (0 === i2.avail_in) break;
          } else this.onData(i2.output);
        }
        return true;
      }, WN.prototype.onData = function(e2) {
        this.chunks.push(e2);
      }, WN.prototype.onEnd = function(e2) {
        e2 === VN && (this.result = wN.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
      };
      var KN = { Deflate: WN, deflate: HN, deflateRaw: function(e2, t2) {
        return (t2 = t2 || {}).raw = true, HN(e2, t2);
      }, gzip: function(e2, t2) {
        return (t2 = t2 || {}).gzip = true, HN(e2, t2);
      }, constants: CO };
      const YN = 16209;
      var qN = function(e2, t2) {
        let i2, n2, r2, s2, o2, a2, c2, d2, l2, u2, h3, p2, _2, E2, m2, f2, g2, T2, S2, R2, C2, I2, v2, y2;
        const A2 = e2.state;
        i2 = e2.next_in, v2 = e2.input, n2 = i2 + (e2.avail_in - 5), r2 = e2.next_out, y2 = e2.output, s2 = r2 - (t2 - e2.avail_out), o2 = r2 + (e2.avail_out - 257), a2 = A2.dmax, c2 = A2.wsize, d2 = A2.whave, l2 = A2.wnext, u2 = A2.window, h3 = A2.hold, p2 = A2.bits, _2 = A2.lencode, E2 = A2.distcode, m2 = (1 << A2.lenbits) - 1, f2 = (1 << A2.distbits) - 1;
        e: do {
          p2 < 15 && (h3 += v2[i2++] << p2, p2 += 8, h3 += v2[i2++] << p2, p2 += 8), g2 = _2[h3 & m2];
          t: for (; ; ) {
            if (T2 = g2 >>> 24, h3 >>>= T2, p2 -= T2, T2 = g2 >>> 16 & 255, 0 === T2) y2[r2++] = 65535 & g2;
            else {
              if (!(16 & T2)) {
                if (0 == (64 & T2)) {
                  g2 = _2[(65535 & g2) + (h3 & (1 << T2) - 1)];
                  continue t;
                }
                if (32 & T2) {
                  A2.mode = 16191;
                  break e;
                }
                e2.msg = "invalid literal/length code", A2.mode = YN;
                break e;
              }
              S2 = 65535 & g2, T2 &= 15, T2 && (p2 < T2 && (h3 += v2[i2++] << p2, p2 += 8), S2 += h3 & (1 << T2) - 1, h3 >>>= T2, p2 -= T2), p2 < 15 && (h3 += v2[i2++] << p2, p2 += 8, h3 += v2[i2++] << p2, p2 += 8), g2 = E2[h3 & f2];
              i: for (; ; ) {
                if (T2 = g2 >>> 24, h3 >>>= T2, p2 -= T2, T2 = g2 >>> 16 & 255, !(16 & T2)) {
                  if (0 == (64 & T2)) {
                    g2 = E2[(65535 & g2) + (h3 & (1 << T2) - 1)];
                    continue i;
                  }
                  e2.msg = "invalid distance code", A2.mode = YN;
                  break e;
                }
                if (R2 = 65535 & g2, T2 &= 15, p2 < T2 && (h3 += v2[i2++] << p2, p2 += 8, p2 < T2 && (h3 += v2[i2++] << p2, p2 += 8)), R2 += h3 & (1 << T2) - 1, R2 > a2) {
                  e2.msg = "invalid distance too far back", A2.mode = YN;
                  break e;
                }
                if (h3 >>>= T2, p2 -= T2, T2 = r2 - s2, R2 > T2) {
                  if (T2 = R2 - T2, T2 > d2 && A2.sane) {
                    e2.msg = "invalid distance too far back", A2.mode = YN;
                    break e;
                  }
                  if (C2 = 0, I2 = u2, 0 === l2) {
                    if (C2 += c2 - T2, T2 < S2) {
                      S2 -= T2;
                      do {
                        y2[r2++] = u2[C2++];
                      } while (--T2);
                      C2 = r2 - R2, I2 = y2;
                    }
                  } else if (l2 < T2) {
                    if (C2 += c2 + l2 - T2, T2 -= l2, T2 < S2) {
                      S2 -= T2;
                      do {
                        y2[r2++] = u2[C2++];
                      } while (--T2);
                      if (C2 = 0, l2 < S2) {
                        T2 = l2, S2 -= T2;
                        do {
                          y2[r2++] = u2[C2++];
                        } while (--T2);
                        C2 = r2 - R2, I2 = y2;
                      }
                    }
                  } else if (C2 += l2 - T2, T2 < S2) {
                    S2 -= T2;
                    do {
                      y2[r2++] = u2[C2++];
                    } while (--T2);
                    C2 = r2 - R2, I2 = y2;
                  }
                  for (; S2 > 2; ) y2[r2++] = I2[C2++], y2[r2++] = I2[C2++], y2[r2++] = I2[C2++], S2 -= 3;
                  S2 && (y2[r2++] = I2[C2++], S2 > 1 && (y2[r2++] = I2[C2++]));
                } else {
                  C2 = r2 - R2;
                  do {
                    y2[r2++] = y2[C2++], y2[r2++] = y2[C2++], y2[r2++] = y2[C2++], S2 -= 3;
                  } while (S2 > 2);
                  S2 && (y2[r2++] = y2[C2++], S2 > 1 && (y2[r2++] = y2[C2++]));
                }
                break;
              }
            }
            break;
          }
        } while (i2 < n2 && r2 < o2);
        S2 = p2 >> 3, i2 -= S2, p2 -= S2 << 3, h3 &= (1 << p2) - 1, e2.next_in = i2, e2.next_out = r2, e2.avail_in = i2 < n2 ? n2 - i2 + 5 : 5 - (i2 - n2), e2.avail_out = r2 < o2 ? o2 - r2 + 257 : 257 - (r2 - o2), A2.hold = h3, A2.bits = p2;
      };
      const zN = 15, JN = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]), XN = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]), QN = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]), ZN = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
      var $N = (e2, t2, i2, n2, r2, s2, o2, a2) => {
        const c2 = a2.bits;
        let d2, l2, u2, h3, p2, _2, E2 = 0, m2 = 0, f2 = 0, g2 = 0, T2 = 0, S2 = 0, R2 = 0, C2 = 0, I2 = 0, v2 = 0, y2 = null;
        const A2 = new Uint16Array(16), b2 = new Uint16Array(16);
        let w2, O2, N2, D2 = null;
        for (E2 = 0; E2 <= zN; E2++) A2[E2] = 0;
        for (m2 = 0; m2 < n2; m2++) A2[t2[i2 + m2]]++;
        for (T2 = c2, g2 = zN; g2 >= 1 && 0 === A2[g2]; g2--) ;
        if (T2 > g2 && (T2 = g2), 0 === g2) return r2[s2++] = 20971520, r2[s2++] = 20971520, a2.bits = 1, 0;
        for (f2 = 1; f2 < g2 && 0 === A2[f2]; f2++) ;
        for (T2 < f2 && (T2 = f2), C2 = 1, E2 = 1; E2 <= zN; E2++) if (C2 <<= 1, C2 -= A2[E2], C2 < 0) return -1;
        if (C2 > 0 && (0 === e2 || 1 !== g2)) return -1;
        for (b2[1] = 0, E2 = 1; E2 < zN; E2++) b2[E2 + 1] = b2[E2] + A2[E2];
        for (m2 = 0; m2 < n2; m2++) 0 !== t2[i2 + m2] && (o2[b2[t2[i2 + m2]]++] = m2);
        if (0 === e2 ? (y2 = D2 = o2, _2 = 20) : 1 === e2 ? (y2 = JN, D2 = XN, _2 = 257) : (y2 = QN, D2 = ZN, _2 = 0), v2 = 0, m2 = 0, E2 = f2, p2 = s2, S2 = T2, R2 = 0, u2 = -1, I2 = 1 << T2, h3 = I2 - 1, 1 === e2 && I2 > 852 || 2 === e2 && I2 > 592) return 1;
        for (; ; ) {
          w2 = E2 - R2, o2[m2] + 1 < _2 ? (O2 = 0, N2 = o2[m2]) : o2[m2] >= _2 ? (O2 = D2[o2[m2] - _2], N2 = y2[o2[m2] - _2]) : (O2 = 96, N2 = 0), d2 = 1 << E2 - R2, l2 = 1 << S2, f2 = l2;
          do {
            l2 -= d2, r2[p2 + (v2 >> R2) + l2] = w2 << 24 | O2 << 16 | N2 | 0;
          } while (0 !== l2);
          for (d2 = 1 << E2 - 1; v2 & d2; ) d2 >>= 1;
          if (0 !== d2 ? (v2 &= d2 - 1, v2 += d2) : v2 = 0, m2++, 0 == --A2[E2]) {
            if (E2 === g2) break;
            E2 = t2[i2 + o2[m2]];
          }
          if (E2 > T2 && (v2 & h3) !== u2) {
            for (0 === R2 && (R2 = T2), p2 += f2, S2 = E2 - R2, C2 = 1 << S2; S2 + R2 < g2 && (C2 -= A2[S2 + R2], !(C2 <= 0)); ) S2++, C2 <<= 1;
            if (I2 += 1 << S2, 1 === e2 && I2 > 852 || 2 === e2 && I2 > 592) return 1;
            u2 = v2 & h3, r2[u2] = T2 << 24 | S2 << 16 | p2 - s2 | 0;
          }
        }
        return 0 !== v2 && (r2[p2 + v2] = E2 - R2 << 24 | 64 << 16 | 0), a2.bits = T2, 0;
      };
      const { Z_FINISH: eD, Z_BLOCK: tD, Z_TREES: iD, Z_OK: nD, Z_STREAM_END: rD, Z_NEED_DICT: sD, Z_STREAM_ERROR: oD, Z_DATA_ERROR: aD, Z_MEM_ERROR: cD, Z_BUF_ERROR: dD, Z_DEFLATED: lD } = CO, uD = 16180, hD = 16190, pD = 16191, _D = 16192, ED = 16194, mD = 16199, fD = 16200, gD = 16206, TD = 16209, SD = (e2) => (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
      function RD() {
        this.strm = null, this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      const CD = (e2) => {
        if (!e2) return 1;
        const t2 = e2.state;
        return !t2 || t2.strm !== e2 || t2.mode < uD || t2.mode > 16211 ? 1 : 0;
      }, ID = (e2) => {
        if (CD(e2)) return oD;
        const t2 = e2.state;
        return e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = uD, t2.last = 0, t2.havedict = 0, t2.flags = -1, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new Int32Array(852), t2.distcode = t2.distdyn = new Int32Array(592), t2.sane = 1, t2.back = -1, nD;
      }, vD = (e2) => {
        if (CD(e2)) return oD;
        const t2 = e2.state;
        return t2.wsize = 0, t2.whave = 0, t2.wnext = 0, ID(e2);
      }, yD = (e2, t2) => {
        let i2;
        if (CD(e2)) return oD;
        const n2 = e2.state;
        return t2 < 0 ? (i2 = 0, t2 = -t2) : (i2 = 5 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || t2 > 15) ? oD : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = i2, n2.wbits = t2, vD(e2));
      }, AD = (e2, t2) => {
        if (!e2) return oD;
        const i2 = new RD();
        e2.state = i2, i2.strm = e2, i2.window = null, i2.mode = uD;
        const n2 = yD(e2, t2);
        return n2 !== nD && (e2.state = null), n2;
      };
      let bD, wD, OD = true;
      const ND = (e2) => {
        if (OD) {
          bD = new Int32Array(512), wD = new Int32Array(32);
          let t2 = 0;
          for (; t2 < 144; ) e2.lens[t2++] = 8;
          for (; t2 < 256; ) e2.lens[t2++] = 9;
          for (; t2 < 280; ) e2.lens[t2++] = 7;
          for (; t2 < 288; ) e2.lens[t2++] = 8;
          for ($N(1, e2.lens, 0, 288, bD, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; ) e2.lens[t2++] = 5;
          $N(2, e2.lens, 0, 32, wD, 0, e2.work, { bits: 5 }), OD = false;
        }
        e2.lencode = bD, e2.lenbits = 9, e2.distcode = wD, e2.distbits = 5;
      }, DD = (e2, t2, i2, n2) => {
        let r2;
        const s2 = e2.state;
        return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new Uint8Array(s2.wsize)), n2 >= s2.wsize ? (s2.window.set(t2.subarray(i2 - s2.wsize, i2), 0), s2.wnext = 0, s2.whave = s2.wsize) : (r2 = s2.wsize - s2.wnext, r2 > n2 && (r2 = n2), s2.window.set(t2.subarray(i2 - n2, i2 - n2 + r2), s2.wnext), (n2 -= r2) ? (s2.window.set(t2.subarray(i2 - n2, i2), 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += r2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += r2))), 0;
      };
      var PD = (e2, t2) => {
        let i2, n2, r2, s2, o2, a2, c2, d2, l2, u2, h3, p2, _2, E2, m2, f2, g2, T2, S2, R2, C2, I2, v2 = 0;
        const y2 = new Uint8Array(4);
        let A2, b2;
        const w2 = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
        if (CD(e2) || !e2.output || !e2.input && 0 !== e2.avail_in) return oD;
        i2 = e2.state, i2.mode === pD && (i2.mode = _D), o2 = e2.next_out, r2 = e2.output, c2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, a2 = e2.avail_in, d2 = i2.hold, l2 = i2.bits, u2 = a2, h3 = c2, I2 = nD;
        e: for (; ; ) switch (i2.mode) {
          case uD:
            if (0 === i2.wrap) {
              i2.mode = _D;
              break;
            }
            for (; l2 < 16; ) {
              if (0 === a2) break e;
              a2--, d2 += n2[s2++] << l2, l2 += 8;
            }
            if (2 & i2.wrap && 35615 === d2) {
              0 === i2.wbits && (i2.wbits = 15), i2.check = 0, y2[0] = 255 & d2, y2[1] = d2 >>> 8 & 255, i2.check = SO(i2.check, y2, 2, 0), d2 = 0, l2 = 0, i2.mode = 16181;
              break;
            }
            if (i2.head && (i2.head.done = false), !(1 & i2.wrap) || (((255 & d2) << 8) + (d2 >> 8)) % 31) {
              e2.msg = "incorrect header check", i2.mode = TD;
              break;
            }
            if ((15 & d2) !== lD) {
              e2.msg = "unknown compression method", i2.mode = TD;
              break;
            }
            if (d2 >>>= 4, l2 -= 4, C2 = 8 + (15 & d2), 0 === i2.wbits && (i2.wbits = C2), C2 > 15 || C2 > i2.wbits) {
              e2.msg = "invalid window size", i2.mode = TD;
              break;
            }
            i2.dmax = 1 << i2.wbits, i2.flags = 0, e2.adler = i2.check = 1, i2.mode = 512 & d2 ? 16189 : pD, d2 = 0, l2 = 0;
            break;
          case 16181:
            for (; l2 < 16; ) {
              if (0 === a2) break e;
              a2--, d2 += n2[s2++] << l2, l2 += 8;
            }
            if (i2.flags = d2, (255 & i2.flags) !== lD) {
              e2.msg = "unknown compression method", i2.mode = TD;
              break;
            }
            if (57344 & i2.flags) {
              e2.msg = "unknown header flags set", i2.mode = TD;
              break;
            }
            i2.head && (i2.head.text = d2 >> 8 & 1), 512 & i2.flags && 4 & i2.wrap && (y2[0] = 255 & d2, y2[1] = d2 >>> 8 & 255, i2.check = SO(i2.check, y2, 2, 0)), d2 = 0, l2 = 0, i2.mode = 16182;
          case 16182:
            for (; l2 < 32; ) {
              if (0 === a2) break e;
              a2--, d2 += n2[s2++] << l2, l2 += 8;
            }
            i2.head && (i2.head.time = d2), 512 & i2.flags && 4 & i2.wrap && (y2[0] = 255 & d2, y2[1] = d2 >>> 8 & 255, y2[2] = d2 >>> 16 & 255, y2[3] = d2 >>> 24 & 255, i2.check = SO(i2.check, y2, 4, 0)), d2 = 0, l2 = 0, i2.mode = 16183;
          case 16183:
            for (; l2 < 16; ) {
              if (0 === a2) break e;
              a2--, d2 += n2[s2++] << l2, l2 += 8;
            }
            i2.head && (i2.head.xflags = 255 & d2, i2.head.os = d2 >> 8), 512 & i2.flags && 4 & i2.wrap && (y2[0] = 255 & d2, y2[1] = d2 >>> 8 & 255, i2.check = SO(i2.check, y2, 2, 0)), d2 = 0, l2 = 0, i2.mode = 16184;
          case 16184:
            if (1024 & i2.flags) {
              for (; l2 < 16; ) {
                if (0 === a2) break e;
                a2--, d2 += n2[s2++] << l2, l2 += 8;
              }
              i2.length = d2, i2.head && (i2.head.extra_len = d2), 512 & i2.flags && 4 & i2.wrap && (y2[0] = 255 & d2, y2[1] = d2 >>> 8 & 255, i2.check = SO(i2.check, y2, 2, 0)), d2 = 0, l2 = 0;
            } else i2.head && (i2.head.extra = null);
            i2.mode = 16185;
          case 16185:
            if (1024 & i2.flags && (p2 = i2.length, p2 > a2 && (p2 = a2), p2 && (i2.head && (C2 = i2.head.extra_len - i2.length, i2.head.extra || (i2.head.extra = new Uint8Array(i2.head.extra_len)), i2.head.extra.set(n2.subarray(s2, s2 + p2), C2)), 512 & i2.flags && 4 & i2.wrap && (i2.check = SO(i2.check, n2, p2, s2)), a2 -= p2, s2 += p2, i2.length -= p2), i2.length)) break e;
            i2.length = 0, i2.mode = 16186;
          case 16186:
            if (2048 & i2.flags) {
              if (0 === a2) break e;
              p2 = 0;
              do {
                C2 = n2[s2 + p2++], i2.head && C2 && i2.length < 65536 && (i2.head.name += String.fromCharCode(C2));
              } while (C2 && p2 < a2);
              if (512 & i2.flags && 4 & i2.wrap && (i2.check = SO(i2.check, n2, p2, s2)), a2 -= p2, s2 += p2, C2) break e;
            } else i2.head && (i2.head.name = null);
            i2.length = 0, i2.mode = 16187;
          case 16187:
            if (4096 & i2.flags) {
              if (0 === a2) break e;
              p2 = 0;
              do {
                C2 = n2[s2 + p2++], i2.head && C2 && i2.length < 65536 && (i2.head.comment += String.fromCharCode(C2));
              } while (C2 && p2 < a2);
              if (512 & i2.flags && 4 & i2.wrap && (i2.check = SO(i2.check, n2, p2, s2)), a2 -= p2, s2 += p2, C2) break e;
            } else i2.head && (i2.head.comment = null);
            i2.mode = 16188;
          case 16188:
            if (512 & i2.flags) {
              for (; l2 < 16; ) {
                if (0 === a2) break e;
                a2--, d2 += n2[s2++] << l2, l2 += 8;
              }
              if (4 & i2.wrap && d2 !== (65535 & i2.check)) {
                e2.msg = "header crc mismatch", i2.mode = TD;
                break;
              }
              d2 = 0, l2 = 0;
            }
            i2.head && (i2.head.hcrc = i2.flags >> 9 & 1, i2.head.done = true), e2.adler = i2.check = 0, i2.mode = pD;
            break;
          case 16189:
            for (; l2 < 32; ) {
              if (0 === a2) break e;
              a2--, d2 += n2[s2++] << l2, l2 += 8;
            }
            e2.adler = i2.check = SD(d2), d2 = 0, l2 = 0, i2.mode = hD;
          case hD:
            if (0 === i2.havedict) return e2.next_out = o2, e2.avail_out = c2, e2.next_in = s2, e2.avail_in = a2, i2.hold = d2, i2.bits = l2, sD;
            e2.adler = i2.check = 1, i2.mode = pD;
          case pD:
            if (t2 === tD || t2 === iD) break e;
          case _D:
            if (i2.last) {
              d2 >>>= 7 & l2, l2 -= 7 & l2, i2.mode = gD;
              break;
            }
            for (; l2 < 3; ) {
              if (0 === a2) break e;
              a2--, d2 += n2[s2++] << l2, l2 += 8;
            }
            switch (i2.last = 1 & d2, d2 >>>= 1, l2 -= 1, 3 & d2) {
              case 0:
                i2.mode = 16193;
                break;
              case 1:
                if (ND(i2), i2.mode = mD, t2 === iD) {
                  d2 >>>= 2, l2 -= 2;
                  break e;
                }
                break;
              case 2:
                i2.mode = 16196;
                break;
              case 3:
                e2.msg = "invalid block type", i2.mode = TD;
            }
            d2 >>>= 2, l2 -= 2;
            break;
          case 16193:
            for (d2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
              if (0 === a2) break e;
              a2--, d2 += n2[s2++] << l2, l2 += 8;
            }
            if ((65535 & d2) != (d2 >>> 16 ^ 65535)) {
              e2.msg = "invalid stored block lengths", i2.mode = TD;
              break;
            }
            if (i2.length = 65535 & d2, d2 = 0, l2 = 0, i2.mode = ED, t2 === iD) break e;
          case ED:
            i2.mode = 16195;
          case 16195:
            if (p2 = i2.length, p2) {
              if (p2 > a2 && (p2 = a2), p2 > c2 && (p2 = c2), 0 === p2) break e;
              r2.set(n2.subarray(s2, s2 + p2), o2), a2 -= p2, s2 += p2, c2 -= p2, o2 += p2, i2.length -= p2;
              break;
            }
            i2.mode = pD;
            break;
          case 16196:
            for (; l2 < 14; ) {
              if (0 === a2) break e;
              a2--, d2 += n2[s2++] << l2, l2 += 8;
            }
            if (i2.nlen = 257 + (31 & d2), d2 >>>= 5, l2 -= 5, i2.ndist = 1 + (31 & d2), d2 >>>= 5, l2 -= 5, i2.ncode = 4 + (15 & d2), d2 >>>= 4, l2 -= 4, i2.nlen > 286 || i2.ndist > 30) {
              e2.msg = "too many length or distance symbols", i2.mode = TD;
              break;
            }
            i2.have = 0, i2.mode = 16197;
          case 16197:
            for (; i2.have < i2.ncode; ) {
              for (; l2 < 3; ) {
                if (0 === a2) break e;
                a2--, d2 += n2[s2++] << l2, l2 += 8;
              }
              i2.lens[w2[i2.have++]] = 7 & d2, d2 >>>= 3, l2 -= 3;
            }
            for (; i2.have < 19; ) i2.lens[w2[i2.have++]] = 0;
            if (i2.lencode = i2.lendyn, i2.lenbits = 7, A2 = { bits: i2.lenbits }, I2 = $N(0, i2.lens, 0, 19, i2.lencode, 0, i2.work, A2), i2.lenbits = A2.bits, I2) {
              e2.msg = "invalid code lengths set", i2.mode = TD;
              break;
            }
            i2.have = 0, i2.mode = 16198;
          case 16198:
            for (; i2.have < i2.nlen + i2.ndist; ) {
              for (; v2 = i2.lencode[d2 & (1 << i2.lenbits) - 1], m2 = v2 >>> 24, f2 = v2 >>> 16 & 255, g2 = 65535 & v2, !(m2 <= l2); ) {
                if (0 === a2) break e;
                a2--, d2 += n2[s2++] << l2, l2 += 8;
              }
              if (g2 < 16) d2 >>>= m2, l2 -= m2, i2.lens[i2.have++] = g2;
              else {
                if (16 === g2) {
                  for (b2 = m2 + 2; l2 < b2; ) {
                    if (0 === a2) break e;
                    a2--, d2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (d2 >>>= m2, l2 -= m2, 0 === i2.have) {
                    e2.msg = "invalid bit length repeat", i2.mode = TD;
                    break;
                  }
                  C2 = i2.lens[i2.have - 1], p2 = 3 + (3 & d2), d2 >>>= 2, l2 -= 2;
                } else if (17 === g2) {
                  for (b2 = m2 + 3; l2 < b2; ) {
                    if (0 === a2) break e;
                    a2--, d2 += n2[s2++] << l2, l2 += 8;
                  }
                  d2 >>>= m2, l2 -= m2, C2 = 0, p2 = 3 + (7 & d2), d2 >>>= 3, l2 -= 3;
                } else {
                  for (b2 = m2 + 7; l2 < b2; ) {
                    if (0 === a2) break e;
                    a2--, d2 += n2[s2++] << l2, l2 += 8;
                  }
                  d2 >>>= m2, l2 -= m2, C2 = 0, p2 = 11 + (127 & d2), d2 >>>= 7, l2 -= 7;
                }
                if (i2.have + p2 > i2.nlen + i2.ndist) {
                  e2.msg = "invalid bit length repeat", i2.mode = TD;
                  break;
                }
                for (; p2--; ) i2.lens[i2.have++] = C2;
              }
            }
            if (i2.mode === TD) break;
            if (0 === i2.lens[256]) {
              e2.msg = "invalid code -- missing end-of-block", i2.mode = TD;
              break;
            }
            if (i2.lenbits = 9, A2 = { bits: i2.lenbits }, I2 = $N(1, i2.lens, 0, i2.nlen, i2.lencode, 0, i2.work, A2), i2.lenbits = A2.bits, I2) {
              e2.msg = "invalid literal/lengths set", i2.mode = TD;
              break;
            }
            if (i2.distbits = 6, i2.distcode = i2.distdyn, A2 = { bits: i2.distbits }, I2 = $N(2, i2.lens, i2.nlen, i2.ndist, i2.distcode, 0, i2.work, A2), i2.distbits = A2.bits, I2) {
              e2.msg = "invalid distances set", i2.mode = TD;
              break;
            }
            if (i2.mode = mD, t2 === iD) break e;
          case mD:
            i2.mode = fD;
          case fD:
            if (a2 >= 6 && c2 >= 258) {
              e2.next_out = o2, e2.avail_out = c2, e2.next_in = s2, e2.avail_in = a2, i2.hold = d2, i2.bits = l2, qN(e2, h3), o2 = e2.next_out, r2 = e2.output, c2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, a2 = e2.avail_in, d2 = i2.hold, l2 = i2.bits, i2.mode === pD && (i2.back = -1);
              break;
            }
            for (i2.back = 0; v2 = i2.lencode[d2 & (1 << i2.lenbits) - 1], m2 = v2 >>> 24, f2 = v2 >>> 16 & 255, g2 = 65535 & v2, !(m2 <= l2); ) {
              if (0 === a2) break e;
              a2--, d2 += n2[s2++] << l2, l2 += 8;
            }
            if (f2 && 0 == (240 & f2)) {
              for (T2 = m2, S2 = f2, R2 = g2; v2 = i2.lencode[R2 + ((d2 & (1 << T2 + S2) - 1) >> T2)], m2 = v2 >>> 24, f2 = v2 >>> 16 & 255, g2 = 65535 & v2, !(T2 + m2 <= l2); ) {
                if (0 === a2) break e;
                a2--, d2 += n2[s2++] << l2, l2 += 8;
              }
              d2 >>>= T2, l2 -= T2, i2.back += T2;
            }
            if (d2 >>>= m2, l2 -= m2, i2.back += m2, i2.length = g2, 0 === f2) {
              i2.mode = 16205;
              break;
            }
            if (32 & f2) {
              i2.back = -1, i2.mode = pD;
              break;
            }
            if (64 & f2) {
              e2.msg = "invalid literal/length code", i2.mode = TD;
              break;
            }
            i2.extra = 15 & f2, i2.mode = 16201;
          case 16201:
            if (i2.extra) {
              for (b2 = i2.extra; l2 < b2; ) {
                if (0 === a2) break e;
                a2--, d2 += n2[s2++] << l2, l2 += 8;
              }
              i2.length += d2 & (1 << i2.extra) - 1, d2 >>>= i2.extra, l2 -= i2.extra, i2.back += i2.extra;
            }
            i2.was = i2.length, i2.mode = 16202;
          case 16202:
            for (; v2 = i2.distcode[d2 & (1 << i2.distbits) - 1], m2 = v2 >>> 24, f2 = v2 >>> 16 & 255, g2 = 65535 & v2, !(m2 <= l2); ) {
              if (0 === a2) break e;
              a2--, d2 += n2[s2++] << l2, l2 += 8;
            }
            if (0 == (240 & f2)) {
              for (T2 = m2, S2 = f2, R2 = g2; v2 = i2.distcode[R2 + ((d2 & (1 << T2 + S2) - 1) >> T2)], m2 = v2 >>> 24, f2 = v2 >>> 16 & 255, g2 = 65535 & v2, !(T2 + m2 <= l2); ) {
                if (0 === a2) break e;
                a2--, d2 += n2[s2++] << l2, l2 += 8;
              }
              d2 >>>= T2, l2 -= T2, i2.back += T2;
            }
            if (d2 >>>= m2, l2 -= m2, i2.back += m2, 64 & f2) {
              e2.msg = "invalid distance code", i2.mode = TD;
              break;
            }
            i2.offset = g2, i2.extra = 15 & f2, i2.mode = 16203;
          case 16203:
            if (i2.extra) {
              for (b2 = i2.extra; l2 < b2; ) {
                if (0 === a2) break e;
                a2--, d2 += n2[s2++] << l2, l2 += 8;
              }
              i2.offset += d2 & (1 << i2.extra) - 1, d2 >>>= i2.extra, l2 -= i2.extra, i2.back += i2.extra;
            }
            if (i2.offset > i2.dmax) {
              e2.msg = "invalid distance too far back", i2.mode = TD;
              break;
            }
            i2.mode = 16204;
          case 16204:
            if (0 === c2) break e;
            if (p2 = h3 - c2, i2.offset > p2) {
              if (p2 = i2.offset - p2, p2 > i2.whave && i2.sane) {
                e2.msg = "invalid distance too far back", i2.mode = TD;
                break;
              }
              p2 > i2.wnext ? (p2 -= i2.wnext, _2 = i2.wsize - p2) : _2 = i2.wnext - p2, p2 > i2.length && (p2 = i2.length), E2 = i2.window;
            } else E2 = r2, _2 = o2 - i2.offset, p2 = i2.length;
            p2 > c2 && (p2 = c2), c2 -= p2, i2.length -= p2;
            do {
              r2[o2++] = E2[_2++];
            } while (--p2);
            0 === i2.length && (i2.mode = fD);
            break;
          case 16205:
            if (0 === c2) break e;
            r2[o2++] = i2.length, c2--, i2.mode = fD;
            break;
          case gD:
            if (i2.wrap) {
              for (; l2 < 32; ) {
                if (0 === a2) break e;
                a2--, d2 |= n2[s2++] << l2, l2 += 8;
              }
              if (h3 -= c2, e2.total_out += h3, i2.total += h3, 4 & i2.wrap && h3 && (e2.adler = i2.check = i2.flags ? SO(i2.check, r2, h3, o2 - h3) : gO(i2.check, r2, h3, o2 - h3)), h3 = c2, 4 & i2.wrap && (i2.flags ? d2 : SD(d2)) !== i2.check) {
                e2.msg = "incorrect data check", i2.mode = TD;
                break;
              }
              d2 = 0, l2 = 0;
            }
            i2.mode = 16207;
          case 16207:
            if (i2.wrap && i2.flags) {
              for (; l2 < 32; ) {
                if (0 === a2) break e;
                a2--, d2 += n2[s2++] << l2, l2 += 8;
              }
              if (4 & i2.wrap && d2 !== (4294967295 & i2.total)) {
                e2.msg = "incorrect length check", i2.mode = TD;
                break;
              }
              d2 = 0, l2 = 0;
            }
            i2.mode = 16208;
          case 16208:
            I2 = rD;
            break e;
          case TD:
            I2 = aD;
            break e;
          case 16210:
            return cD;
          default:
            return oD;
        }
        return e2.next_out = o2, e2.avail_out = c2, e2.next_in = s2, e2.avail_in = a2, i2.hold = d2, i2.bits = l2, (i2.wsize || h3 !== e2.avail_out && i2.mode < TD && (i2.mode < gD || t2 !== eD)) && DD(e2, e2.output, e2.next_out, h3 - e2.avail_out), u2 -= e2.avail_in, h3 -= e2.avail_out, e2.total_in += u2, e2.total_out += h3, i2.total += h3, 4 & i2.wrap && h3 && (e2.adler = i2.check = i2.flags ? SO(i2.check, r2, h3, e2.next_out - h3) : gO(i2.check, r2, h3, e2.next_out - h3)), e2.data_type = i2.bits + (i2.last ? 64 : 0) + (i2.mode === pD ? 128 : 0) + (i2.mode === mD || i2.mode === ED ? 256 : 0), (0 === u2 && 0 === h3 || t2 === eD) && I2 === nD && (I2 = dD), I2;
      }, LD = { inflateReset: vD, inflateReset2: yD, inflateResetKeep: ID, inflateInit: (e2) => AD(e2, 15), inflateInit2: AD, inflate: PD, inflateEnd: (e2) => {
        if (CD(e2)) return oD;
        let t2 = e2.state;
        return t2.window && (t2.window = null), e2.state = null, nD;
      }, inflateGetHeader: (e2, t2) => {
        if (CD(e2)) return oD;
        const i2 = e2.state;
        return 0 == (2 & i2.wrap) ? oD : (i2.head = t2, t2.done = false, nD);
      }, inflateSetDictionary: (e2, t2) => {
        const i2 = t2.length;
        let n2, r2, s2;
        return CD(e2) ? oD : (n2 = e2.state, 0 !== n2.wrap && n2.mode !== hD ? oD : n2.mode === hD && (r2 = 1, r2 = gO(r2, t2, i2, 0), r2 !== n2.check) ? aD : (s2 = DD(e2, t2, i2, i2), s2 ? (n2.mode = 16210, cD) : (n2.havedict = 1, nD)));
      }, inflateInfo: "pako inflate (from Nodeca project)" };
      var kD = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      };
      const MD = Object.prototype.toString, { Z_NO_FLUSH: UD, Z_FINISH: xD, Z_OK: VD, Z_STREAM_END: FD, Z_NEED_DICT: BD, Z_STREAM_ERROR: jD, Z_DATA_ERROR: GD, Z_MEM_ERROR: WD } = CO;
      function HD(e2) {
        this.options = wN.assign({ chunkSize: 65536, windowBits: 15, to: "" }, e2 || {});
        const t2 = this.options;
        t2.raw && t2.windowBits >= 0 && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(t2.windowBits >= 0 && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), t2.windowBits > 15 && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new PN(), this.strm.avail_out = 0;
        let i2 = LD.inflateInit2(this.strm, t2.windowBits);
        if (i2 !== VD) throw new Error(RO[i2]);
        if (this.header = new kD(), LD.inflateGetHeader(this.strm, this.header), t2.dictionary && ("string" == typeof t2.dictionary ? t2.dictionary = DN.string2buf(t2.dictionary) : "[object ArrayBuffer]" === MD.call(t2.dictionary) && (t2.dictionary = new Uint8Array(t2.dictionary)), t2.raw && (i2 = LD.inflateSetDictionary(this.strm, t2.dictionary), i2 !== VD))) throw new Error(RO[i2]);
      }
      function KD(e2, t2) {
        const i2 = new HD(t2);
        if (i2.push(e2), i2.err) throw i2.msg || RO[i2.err];
        return i2.result;
      }
      HD.prototype.push = function(e2, t2) {
        const i2 = this.strm, n2 = this.options.chunkSize, r2 = this.options.dictionary;
        let s2, o2, a2;
        if (this.ended) return false;
        for (o2 = t2 === ~~t2 ? t2 : true === t2 ? xD : UD, "[object ArrayBuffer]" === MD.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length; ; ) {
          for (0 === i2.avail_out && (i2.output = new Uint8Array(n2), i2.next_out = 0, i2.avail_out = n2), s2 = LD.inflate(i2, o2), s2 === BD && r2 && (s2 = LD.inflateSetDictionary(i2, r2), s2 === VD ? s2 = LD.inflate(i2, o2) : s2 === GD && (s2 = BD)); i2.avail_in > 0 && s2 === FD && i2.state.wrap > 0 && 0 !== e2[i2.next_in]; ) LD.inflateReset(i2), s2 = LD.inflate(i2, o2);
          switch (s2) {
            case jD:
            case GD:
            case BD:
            case WD:
              return this.onEnd(s2), this.ended = true, false;
          }
          if (a2 = i2.avail_out, i2.next_out && (0 === i2.avail_out || s2 === FD)) if ("string" === this.options.to) {
            let e3 = DN.utf8border(i2.output, i2.next_out), t3 = i2.next_out - e3, r3 = DN.buf2string(i2.output, e3);
            i2.next_out = t3, i2.avail_out = n2 - t3, t3 && i2.output.set(i2.output.subarray(e3, e3 + t3), 0), this.onData(r3);
          } else this.onData(i2.output.length === i2.next_out ? i2.output : i2.output.subarray(0, i2.next_out));
          if (s2 !== VD || 0 !== a2) {
            if (s2 === FD) return s2 = LD.inflateEnd(this.strm), this.onEnd(s2), this.ended = true, true;
            if (0 === i2.avail_in) break;
          }
        }
        return true;
      }, HD.prototype.onData = function(e2) {
        this.chunks.push(e2);
      }, HD.prototype.onEnd = function(e2) {
        e2 === VD && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = wN.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
      };
      var YD = { Inflate: HD, inflate: KD, inflateRaw: function(e2, t2) {
        return (t2 = t2 || {}).raw = true, KD(e2, t2);
      }, ungzip: KD, constants: CO };
      const { Deflate: qD, deflate: zD, deflateRaw: JD, gzip: XD } = KN, { Inflate: QD, inflate: ZD, inflateRaw: $D, ungzip: eP } = YD;
      var tP, iP = zD, nP = ZD;
      !function(e2) {
        e2[e2.ONE_BYTE = 0] = "ONE_BYTE", e2[e2.TWO_BYTE = 1] = "TWO_BYTE";
      }(tP || (tP = {}));
      class rP {
        constructor() {
          sh(this, "_sequence", 0), sh(this, "_startTime", Date.now()), sh(this, "isUseOneByte", true);
        }
        get startTime() {
          const e2 = Date.now() - this._startTime;
          return e2 < Math.pow(2, 16) ? e2 : (this._startTime += Math.pow(2, 16), this.startTime);
        }
        get sequence() {
          return this._sequence < Math.pow(2, 32) ? this._sequence++ : (this._sequence -= Math.pow(2, 32), this.sequence);
        }
        serialize(e2) {
          const t2 = { commonPacketHeader: { length: 0, reserved: 0, extension: 0, sequence: this.sequence }, commonStreamHeader: this.startTime, extension: void 0, payload: e2 };
          if (e2.byteLength > 128) {
            const i3 = new Uint8Array(4);
            i3.set([1, 0, 0, 0]);
            const n3 = { id: 0, length: 4, data: i3.buffer }, r3 = { profile: this.isUseOneByte ? 0 : 1, length: this.isUseOneByte ? 5 : 6, datas: [n3] };
            t2.commonPacketHeader.extension = 1, t2.extension = r3, t2.payload = this.compress(e2), t2.commonPacketHeader.length = 8 + (t2.extension.length + 2) + t2.payload.byteLength;
          } else t2.commonPacketHeader.length = 8 + t2.payload.byteLength;
          RC("SHOW_DATASTREAM2_LOG") && jC.debug("send data header: ".concat(JSON.stringify(t2.commonPacketHeader)));
          const i2 = new ArrayBuffer(t2.commonPacketHeader.length), n2 = new Uint8Array(i2), r2 = new DataView(i2);
          let s2 = 0;
          if (r2.setUint16(s2, t2.commonPacketHeader.extension << 15 | t2.commonPacketHeader.reserved << 14 | t2.commonPacketHeader.length, true), s2 += 2, r2.setUint32(s2, t2.commonPacketHeader.sequence, true), s2 += 4, r2.setUint16(s2, t2.commonStreamHeader, true), s2 += 2, t2.extension) {
            const e3 = this.serializeExtension(t2.extension);
            n2.set(new Uint8Array(e3), s2), s2 += e3.byteLength;
          }
          if (n2.set(new Uint8Array(t2.payload), s2), s2 += t2.payload.byteLength, s2 !== t2.commonPacketHeader.length) throw Error("serialize error!");
          return i2;
        }
        deserialize(e2) {
          if (e2.byteLength < 4) return new ArrayBuffer(0);
          const t2 = new DataView(e2);
          let i2 = 0;
          const n2 = t2.getUint16(i2, true);
          i2 += 2;
          const r2 = { length: 16383 & n2, reserved: (16384 & n2) >> 14, extension: (32768 & n2) >> 15, sequence: t2.getUint16(i2 + 2, true) << 16 | t2.getUint16(i2, true) };
          let s2, o2;
          if (i2 += 4, RC("SHOW_DATASTREAM2_LOG") && jC.debug("receive data header: ".concat(JSON.stringify(r2))), t2.getUint16(i2, true), i2 += 2, r2.extension) {
            o2 = this.deserializeExtension(e2.slice(i2)), i2 += 2 + o2.length, s2 = e2.slice(i2);
            let t3 = false;
            if (o2.datas.length > 0) {
              const e3 = o2.datas.find((e4) => 0 === e4.id);
              if (e3) {
                t3 = 1 == (1 & new DataView(e3.data).getUint32(0, true));
              }
            }
            s2 = t3 ? this.decompress(s2) : s2;
          } else s2 = e2.slice(8);
          return s2;
        }
        serializeExtension(e2) {
          const { profile: t2, length: i2, datas: n2 } = e2, r2 = new ArrayBuffer(i2 + 2), s2 = new Uint8Array(r2), o2 = new DataView(r2);
          let a2 = 0;
          if (o2.setUint8(a2++, t2), o2.setUint8(a2++, i2), n2.forEach((e3) => {
            t2 ? (o2.setUint8(a2++, e3.id), o2.setUint8(a2++, e3.length), s2.set(new Uint8Array(e3.data), a2), a2 += e3.data.byteLength) : (o2.setUint8(a2++, e3.id | e3.length << 4), s2.set(new Uint8Array(e3.data), a2), a2 += e3.data.byteLength);
          }), a2 !== i2 + 2) throw Error("serialize extension error, is ".concat(a2, "!==").concat(i2 + 2));
          return r2;
        }
        deserializeExtension(e2) {
          const t2 = new DataView(e2);
          let i2 = 0;
          const n2 = t2.getUint8(i2);
          i2++;
          const r2 = t2.getUint8(i2);
          i2++;
          const s2 = n2 === tP.TWO_BYTE, o2 = [], a2 = new DataView(e2, 2);
          let c2 = 0;
          for (; c2 < r2; ) {
            let e3 = 0, t3 = 0, i3 = new ArrayBuffer(0);
            s2 ? (e3 = a2.getUint8(c2), c2++, t3 = a2.getUint8(c2), c2++) : (e3 = 15 & a2.getUint8(c2), t3 = a2.getUint8(c2) >> 4, c2++), t3 > 0 && (i3 = a2.buffer.slice(c2 + 2, c2 + 2 + t3), c2 += i3.byteLength), o2.push({ id: e3, length: t3, data: i3 });
          }
          if (c2 !== r2) throw Error("parse error");
          return { profile: n2, length: r2, datas: o2 };
        }
        decompress(e2) {
          return nP(new Uint8Array(e2));
        }
        compress(e2) {
          return iP(new Uint8Array(e2));
        }
      }
      class sP extends dT {
        constructor(e2, t2) {
          super(), sh(this, "_version", 1), sh(this, "_type", 3), sh(this, "_config", void 0), sh(this, "_originDataChannel", void 0), sh(this, "_dataStreamPacketHeader", new ArrayBuffer(4)), sh(this, "_dataStreamPacketHandler", void 0), sh(this, "_datachannelEventMap", /* @__PURE__ */ new Map()), this._config = e2, t2 && (this._originDataChannel = t2, this._bandDataChannelEvents(t2)), this._initPacketHeader(), this._dataStreamPacketHandler = new rP();
        }
        get id() {
          return this._config.id;
        }
        get ordered() {
          return this._config.ordered;
        }
        get maxRetransmits() {
          return RC("DATASTREAM_MAX_RETRANSMITS");
        }
        get metadata() {
          return this._config.metadata;
        }
        get readyState() {
          var e2, t2;
          return null !== (e2 = null === (t2 = this._originDataChannel) || void 0 === t2 ? void 0 : t2.readyState) && void 0 !== e2 ? e2 : "connecting";
        }
        get _originDataChannelId() {
          var e2, t2;
          return null !== (e2 = null === (t2 = this._originDataChannel) || void 0 === t2 ? void 0 : t2.id) && void 0 !== e2 ? e2 : null;
        }
        getChannelId() {
          return this.id;
        }
        getConfig() {
          return this._config;
        }
        _close() {
          this._originDataChannel && (this._unbindDataChannelEvents(this._originDataChannel), this._originDataChannel = void 0);
        }
        async _waitTillOpen() {
          return new cg((e2, t2) => {
            if (this._originDataChannel) {
              "open" === this._originDataChannel.readyState && e2();
              const i2 = setTimeout(() => {
                var e3;
                t2(new Kg(Hg.DATACHANNEL_CONNECTION_TIMEOUT, "Cannot create datachannel, id: ".concat(null === (e3 = this._originDataChannel) || void 0 === e3 ? void 0 : e3.id)));
              }, 1e4);
              this._originDataChannel.onopen = () => {
                clearTimeout(i2), this._originDataChannel && this._bandDataChannelEvents(this._originDataChannel), e2();
              }, this._originDataChannel.onerror = () => {
                throw clearTimeout(i2), new Kg(Hg.DATACHANNEL_CONNECTION_TIMEOUT);
              };
            } else t2(new Kg(Hg.DATACHANNEL_CONNECTION_TIMEOUT, "cannot find dataChannel"));
          });
        }
        _updateOriginDataChannel(e2) {
          this._originDataChannel = e2, this._bandDataChannelEvents(e2);
        }
        _initPacketHeader() {
          const e2 = new DataView(this._dataStreamPacketHeader);
          e2.setUint16(0, this._version), e2.setUint8(2, this._type), e2.setUint8(3, this._config.id);
        }
        _bandDataChannelEvents(e2) {
          this._unbindDataChannelEvents(e2), [cb.OPEN, cb.CLOSE, cb.ERROR].forEach((t2) => {
            const i2 = () => {
              this.emit(t2);
            };
            this._datachannelEventMap.set(t2, i2), e2.addEventListener(t2, i2);
          });
        }
        _unbindDataChannelEvents(e2) {
          Array.from(this._datachannelEventMap.entries()).forEach((t2) => {
            let [i2, n2] = t2;
            e2.removeEventListener(i2, n2);
          }), this._datachannelEventMap.clear();
        }
      }
      class oP extends sP {
        constructor(e2) {
          super(e2), sh(this, "_messageListener", void 0), this._messageListener = (e3) => {
            if (e3.data.byteLength < this._dataStreamPacketHeader.byteLength) throw Error("invalid byteLength: the byte length must exceed " + this._dataStreamPacketHeader.byteLength);
            const t2 = e3.data.slice(0, this._dataStreamPacketHeader.byteLength), i2 = new DataView(t2).getUint8(3);
            if (i2 !== this.id) return void (RC("SHOW_DATASTREAM2_LOG") && jC.debug("invalid datachannel id: ".concat(i2, " !== ").concat(this.id)));
            let n2 = e3.data.slice(this._dataStreamPacketHeader.byteLength);
            n2 = this._dataStreamPacketHandler.deserialize(n2), this.emit(cb.MESSAGE, n2);
          };
        }
        _updateOriginDataChannel(e2) {
          super._updateOriginDataChannel(e2), this._bandRemoteDataChannelEvents();
        }
        _close() {
          this._originDataChannel && (this._originDataChannel.removeEventListener("message", this._messageListener), super._close());
        }
        _bandRemoteDataChannelEvents() {
          this._originDataChannel && this._originDataChannel.addEventListener("message", this._messageListener);
        }
      }
      class aP extends sP {
        send(e2) {
          if (this._originDataChannel) {
            let t2 = e2;
            t2 = this._dataStreamPacketHandler.serialize(e2);
            const i2 = new Uint8Array(this._dataStreamPacketHeader.byteLength + t2.byteLength);
            i2.set(new Uint8Array(this._dataStreamPacketHeader), 0), i2.set(new Uint8Array(t2), this._dataStreamPacketHeader.byteLength), this._originDataChannel.send(i2.buffer);
          }
        }
      }
      var cP = n, dP = ht("iterator"), lP = !cP(function() {
        var e2 = new URL("b?a=1&b=2&c=3", "http://a"), t2 = e2.searchParams, i2 = new URLSearchParams("a=1&a=2"), n2 = "";
        return e2.pathname = "c%20d", t2.forEach(function(e3, i3) {
          t2.delete("b"), n2 += i3 + e3;
        }), i2.delete("a", 2), !e2.toJSON || !i2.has("a", 1) || i2.has("a", 2) || !t2.size && true || !t2.sort || "http://a/c%20d?a=1&c=3" !== e2.href || "3" !== t2.get("c") || "a=1" !== String(new URLSearchParams("?a=1")) || !t2[dP] || "a" !== new URL("https://a@b").username || "b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") || "xn--e1aybc" !== new URL("http://ÑÐµÑÑ").host || "#%D0%B1" !== new URL("http://a#Ð±").hash || "a1c3" !== n2 || "x" !== new URL("http://x", void 0).host;
      }), uP = Uo, hP = wi, pP = h2, _P = L, EP = d, mP = N, fP = lP, gP = Uo, TP = Vo, SP = function(e2, t2, i2) {
        for (var n2 in t2) i2 && i2.unsafe && e2[n2] ? e2[n2] = t2[n2] : uP(e2, n2, t2[n2], i2);
        return e2;
      }, RP = ca, CP = Sl, IP = va, vP = k_, yP = w, AP = Ze, bP = Xt, wP = ln, OP = ii, NP = te, DP = pn, PP = go, LP = B, kP = Bp, MP = Lp, UP = H_, xP = Rh, VP = ht("iterator"), FP = "URLSearchParams", BP = FP + "Iterator", jP = IP.set, GP = IP.getterFor(FP), WP = IP.getterFor(BP), HP = Object.getOwnPropertyDescriptor, KP = function(e2) {
        if (!mP) return pP[e2];
        var t2 = HP(pP, e2);
        return t2 && t2.value;
      }, YP = KP("fetch"), qP = KP("Request"), zP = KP("Headers"), JP = qP && qP.prototype, XP = zP && zP.prototype, QP = pP.RegExp, ZP = pP.TypeError, $P = pP.decodeURIComponent, eL = pP.encodeURIComponent, tL = EP("".charAt), iL = EP([].join), nL = EP([].push), rL = EP("".replace), sL = EP([].shift), oL = EP([].splice), aL = EP("".split), cL = EP("".slice), dL = /\+/g, lL = Array(4), uL = function(e2) {
        return lL[e2 - 1] || (lL[e2 - 1] = QP("((?:%[\\da-f]{2}){" + e2 + "})", "gi"));
      }, hL = function(e2) {
        try {
          return $P(e2);
        } catch (t2) {
          return e2;
        }
      }, pL = function(e2) {
        var t2 = rL(e2, dL, " "), i2 = 4;
        try {
          return $P(t2);
        } catch (e3) {
          for (; i2; ) t2 = rL(t2, uL(i2--), hL);
          return t2;
        }
      }, _L = /[!'()~]|%20/g, EL = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+" }, mL = function(e2) {
        return EL[e2];
      }, fL = function(e2) {
        return rL(eL(e2), _L, mL);
      }, gL = CP(function(e2, t2) {
        jP(this, { type: BP, iterator: kP(GP(e2).entries), kind: t2 });
      }, "Iterator", function() {
        var e2 = WP(this), t2 = e2.kind, i2 = e2.iterator.next(), n2 = i2.value;
        return i2.done || (i2.value = "keys" === t2 ? n2.key : "values" === t2 ? n2.value : [n2.key, n2.value]), i2;
      }, true), TL = function(e2) {
        this.entries = [], this.url = null, void 0 !== e2 && (NP(e2) ? this.parseObject(e2) : this.parseQuery("string" == typeof e2 ? "?" === tL(e2, 0) ? cL(e2, 1) : e2 : DP(e2)));
      };
      TL.prototype = { type: FP, bindURL: function(e2) {
        this.url = e2, this.update();
      }, parseObject: function(e2) {
        var t2, i2, n2, r2, s2, o2, a2, c2 = MP(e2);
        if (c2) for (i2 = (t2 = kP(e2, c2)).next; !(n2 = _P(i2, t2)).done; ) {
          if (s2 = (r2 = kP(OP(n2.value))).next, (o2 = _P(s2, r2)).done || (a2 = _P(s2, r2)).done || !_P(s2, r2).done) throw ZP("Expected sequence with length 2");
          nL(this.entries, { key: DP(o2.value), value: DP(a2.value) });
        }
        else for (var d2 in e2) AP(e2, d2) && nL(this.entries, { key: d2, value: DP(e2[d2]) });
      }, parseQuery: function(e2) {
        if (e2) for (var t2, i2, n2 = aL(e2, "&"), r2 = 0; r2 < n2.length; ) (t2 = n2[r2++]).length && (i2 = aL(t2, "="), nL(this.entries, { key: pL(sL(i2)), value: pL(iL(i2, "=")) }));
      }, serialize: function() {
        for (var e2, t2 = this.entries, i2 = [], n2 = 0; n2 < t2.length; ) e2 = t2[n2++], nL(i2, fL(e2.key) + "=" + fL(e2.value));
        return iL(i2, "&");
      }, update: function() {
        this.entries.length = 0, this.parseQuery(this.url.query);
      }, updateURL: function() {
        this.url && this.url.update();
      } };
      var SL = function() {
        vP(this, RL);
        var e2 = jP(this, new TL(arguments.length > 0 ? arguments[0] : void 0));
        mP || (this.size = e2.entries.length);
      }, RL = SL.prototype;
      if (SP(RL, { append: function(e2, t2) {
        var i2 = GP(this);
        UP(arguments.length, 2), nL(i2.entries, { key: DP(e2), value: DP(t2) }), mP || this.length++, i2.updateURL();
      }, delete: function(e2) {
        for (var t2 = GP(this), i2 = UP(arguments.length, 1), n2 = t2.entries, r2 = DP(e2), s2 = i2 < 2 ? void 0 : arguments[1], o2 = void 0 === s2 ? s2 : DP(s2), a2 = 0; a2 < n2.length; ) {
          var c2 = n2[a2];
          if (c2.key !== r2 || void 0 !== o2 && c2.value !== o2) a2++;
          else if (oL(n2, a2, 1), void 0 !== o2) break;
        }
        mP || (this.size = n2.length), t2.updateURL();
      }, get: function(e2) {
        var t2 = GP(this).entries;
        UP(arguments.length, 1);
        for (var i2 = DP(e2), n2 = 0; n2 < t2.length; n2++) if (t2[n2].key === i2) return t2[n2].value;
        return null;
      }, getAll: function(e2) {
        var t2 = GP(this).entries;
        UP(arguments.length, 1);
        for (var i2 = DP(e2), n2 = [], r2 = 0; r2 < t2.length; r2++) t2[r2].key === i2 && nL(n2, t2[r2].value);
        return n2;
      }, has: function(e2) {
        for (var t2 = GP(this).entries, i2 = UP(arguments.length, 1), n2 = DP(e2), r2 = i2 < 2 ? void 0 : arguments[1], s2 = void 0 === r2 ? r2 : DP(r2), o2 = 0; o2 < t2.length; ) {
          var a2 = t2[o2++];
          if (a2.key === n2 && (void 0 === s2 || a2.value === s2)) return true;
        }
        return false;
      }, set: function(e2, t2) {
        var i2 = GP(this);
        UP(arguments.length, 1);
        for (var n2, r2 = i2.entries, s2 = false, o2 = DP(e2), a2 = DP(t2), c2 = 0; c2 < r2.length; c2++) (n2 = r2[c2]).key === o2 && (s2 ? oL(r2, c2--, 1) : (s2 = true, n2.value = a2));
        s2 || nL(r2, { key: o2, value: a2 }), mP || (this.size = r2.length), i2.updateURL();
      }, sort: function() {
        var e2 = GP(this);
        xP(e2.entries, function(e3, t2) {
          return e3.key > t2.key ? 1 : -1;
        }), e2.updateURL();
      }, forEach: function(e2) {
        for (var t2, i2 = GP(this).entries, n2 = bP(e2, arguments.length > 1 ? arguments[1] : void 0), r2 = 0; r2 < i2.length; ) n2((t2 = i2[r2++]).value, t2.key, this);
      }, keys: function() {
        return new gL(this, "keys");
      }, values: function() {
        return new gL(this, "values");
      }, entries: function() {
        return new gL(this, "entries");
      } }, { enumerable: true }), gP(RL, VP, RL.entries, { name: "entries" }), gP(RL, "toString", function() {
        return GP(this).serialize();
      }, { enumerable: true }), mP && TP(RL, "size", { get: function() {
        return GP(this).entries.length;
      }, configurable: true, enumerable: true }), RP(SL, FP), hP({ global: true, constructor: true, forced: !fP }, { URLSearchParams: SL }), !fP && yP(zP)) {
        var CL = EP(XP.has), IL = EP(XP.set), vL = function(e2) {
          if (NP(e2)) {
            var t2, i2 = e2.body;
            if (wP(i2) === FP) return t2 = e2.headers ? new zP(e2.headers) : new zP(), CL(t2, "content-type") || IL(t2, "content-type", "application/x-www-form-urlencoded;charset=UTF-8"), PP(e2, { body: LP(0, DP(i2)), headers: LP(0, t2) });
          }
          return e2;
        };
        if (yP(YP) && hP({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, { fetch: function(e2) {
          return YP(e2, arguments.length > 1 ? vL(arguments[1]) : {});
        } }), yP(qP)) {
          var yL = function(e2) {
            return vP(this, JP), new qP(e2, arguments.length > 1 ? vL(arguments[1]) : {});
          };
          JP.constructor = yL, yL.prototype = JP, hP({ global: true, constructor: true, dontCallGetSet: true, forced: true }, { Request: yL });
        }
      }
      var AL, bL = { URLSearchParams: SL, getState: GP }, wL = N, OL = d, NL = L, DL = n, PL = Ys, LL = ko, kL = k, ML = Je, UL = K, xL = Object.assign, VL = Object.defineProperty, FL = OL([].concat), BL = !xL || DL(function() {
        if (wL && 1 !== xL({ b: 1 }, xL(VL({}, "a", { enumerable: true, get: function() {
          VL(this, "b", { value: 3, enumerable: false });
        } }), { b: 2 })).b) return true;
        var e2 = {}, t2 = {}, i2 = Symbol(), n2 = "abcdefghijklmnopqrst";
        return e2[i2] = 7, n2.split("").forEach(function(e3) {
          t2[e3] = e3;
        }), 7 != xL({}, e2)[i2] || PL(xL({}, t2)).join("") != n2;
      }) ? function(e2, t2) {
        for (var i2 = ML(e2), n2 = arguments.length, r2 = 1, s2 = LL.f, o2 = kL.f; n2 > r2; ) for (var a2, c2 = UL(arguments[r2++]), d2 = s2 ? FL(PL(c2), s2(c2)) : PL(c2), l2 = d2.length, u2 = 0; l2 > u2; ) a2 = d2[u2++], wL && !NL(o2, c2, a2) || (i2[a2] = c2[a2]);
        return i2;
      } : xL, jL = ii, GL = Hp, WL = Xt, HL = L, KL = Je, YL = function(e2, t2, i2, n2) {
        try {
          return n2 ? t2(jL(i2)[0], i2[1]) : t2(i2);
        } catch (t3) {
          GL(e2, "throw", t3);
        }
      }, qL = bp, zL = ls, JL = Bi, XL = Yr, QL = Bp, ZL = Lp, $L = Array, ek = d, tk = 2147483647, ik = /[^\0-\u007E]/, nk = /[.\u3002\uFF0E\uFF61]/g, rk = "Overflow: input needs wider integers to process", sk = RangeError, ok = ek(nk.exec), ak = Math.floor, ck = String.fromCharCode, dk = ek("".charCodeAt), lk = ek([].join), uk = ek([].push), hk = ek("".replace), pk = ek("".split), _k = ek("".toLowerCase), Ek = function(e2) {
        return e2 + 22 + 75 * (e2 < 26);
      }, mk = function(e2, t2, i2) {
        var n2 = 0;
        for (e2 = i2 ? ak(e2 / 700) : e2 >> 1, e2 += ak(e2 / t2); e2 > 455; ) e2 = ak(e2 / 35), n2 += 36;
        return ak(n2 + 36 * e2 / (e2 + 38));
      }, fk = function(e2) {
        var t2 = [];
        e2 = function(e3) {
          for (var t3 = [], i3 = 0, n3 = e3.length; i3 < n3; ) {
            var r3 = dk(e3, i3++);
            if (r3 >= 55296 && r3 <= 56319 && i3 < n3) {
              var s3 = dk(e3, i3++);
              56320 == (64512 & s3) ? uk(t3, ((1023 & r3) << 10) + (1023 & s3) + 65536) : (uk(t3, r3), i3--);
            } else uk(t3, r3);
          }
          return t3;
        }(e2);
        var i2, n2, r2 = e2.length, s2 = 128, o2 = 0, a2 = 72;
        for (i2 = 0; i2 < e2.length; i2++) (n2 = e2[i2]) < 128 && uk(t2, ck(n2));
        var c2 = t2.length, d2 = c2;
        for (c2 && uk(t2, "-"); d2 < r2; ) {
          var l2 = tk;
          for (i2 = 0; i2 < e2.length; i2++) (n2 = e2[i2]) >= s2 && n2 < l2 && (l2 = n2);
          var u2 = d2 + 1;
          if (l2 - s2 > ak((tk - o2) / u2)) throw sk(rk);
          for (o2 += (l2 - s2) * u2, s2 = l2, i2 = 0; i2 < e2.length; i2++) {
            if ((n2 = e2[i2]) < s2 && ++o2 > tk) throw sk(rk);
            if (n2 == s2) {
              for (var h3 = o2, p2 = 36; ; ) {
                var _2 = p2 <= a2 ? 1 : p2 >= a2 + 26 ? 26 : p2 - a2;
                if (h3 < _2) break;
                var E2 = h3 - _2, m2 = 36 - _2;
                uk(t2, ck(Ek(_2 + E2 % m2))), h3 = ak(E2 / m2), p2 += 36;
              }
              uk(t2, ck(Ek(h3))), a2 = mk(o2, u2, d2 == c2), o2 = 0, d2++;
            }
          }
          o2++, s2++;
        }
        return lk(t2, "");
      }, gk = wi, Tk = N, Sk = lP, Rk = h2, Ck = Xt, Ik = d, vk = Uo, yk = Vo, Ak = k_, bk = Ze, wk = BL, Ok = function(e2) {
        var t2 = KL(e2), i2 = zL(this), n2 = arguments.length, r2 = n2 > 1 ? arguments[1] : void 0, s2 = void 0 !== r2;
        s2 && (r2 = WL(r2, n2 > 2 ? arguments[2] : void 0));
        var o2, a2, c2, d2, l2, u2, h3 = ZL(t2), p2 = 0;
        if (!h3 || this === $L && qL(h3)) for (o2 = JL(t2), a2 = i2 ? new this(o2) : $L(o2); o2 > p2; p2++) u2 = s2 ? r2(t2[p2], p2) : t2[p2], XL(a2, p2, u2);
        else for (l2 = (d2 = QL(t2, h3)).next, a2 = i2 ? new this() : []; !(c2 = HL(l2, d2)).done; p2++) u2 = s2 ? YL(d2, r2, [c2.value, p2], true) : c2.value, XL(a2, p2, u2);
        return a2.length = p2, a2;
      }, Nk = wo, Dk = Yu.codeAt, Pk = function(e2) {
        var t2, i2, n2 = [], r2 = pk(hk(_k(e2), nk, "."), ".");
        for (t2 = 0; t2 < r2.length; t2++) i2 = r2[t2], uk(n2, ok(ik, i2) ? "xn--" + fk(i2) : i2);
        return lk(n2, ".");
      }, Lk = pn, kk = ca, Mk = H_, Uk = bL, xk = va, Vk = xk.set, Fk = xk.getterFor("URL"), Bk = Uk.URLSearchParams, jk = Uk.getState, Gk = Rk.URL, Wk = Rk.TypeError, Hk = Rk.parseInt, Kk = Math.floor, Yk = Math.pow, qk = Ik("".charAt), zk = Ik(/./.exec), Jk = Ik([].join), Xk = Ik(1 .toString), Qk = Ik([].pop), Zk = Ik([].push), $k = Ik("".replace), eM = Ik([].shift), tM = Ik("".split), iM = Ik("".slice), nM = Ik("".toLowerCase), rM = Ik([].unshift), sM = "Invalid scheme", oM = "Invalid host", aM = "Invalid port", cM = /[a-z]/i, dM = /[\d+-.a-z]/i, lM = /\d/, uM = /^0x/i, hM = /^[0-7]+$/, pM = /^\d+$/, _M = /^[\da-f]+$/i, EM = /[\0\t\n\r #%/:<>?@[\\\]^|]/, mM = /[\0\t\n\r #/:<>?@[\\\]^|]/, fM = /^[\u0000-\u0020]+/, gM = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/, TM = /[\t\n\r]/g, SM = function(e2) {
        var t2, i2, n2, r2;
        if ("number" == typeof e2) {
          for (t2 = [], i2 = 0; i2 < 4; i2++) rM(t2, e2 % 256), e2 = Kk(e2 / 256);
          return Jk(t2, ".");
        }
        if ("object" == typeof e2) {
          for (t2 = "", n2 = function(e3) {
            for (var t3 = null, i3 = 1, n3 = null, r3 = 0, s2 = 0; s2 < 8; s2++) 0 !== e3[s2] ? (r3 > i3 && (t3 = n3, i3 = r3), n3 = null, r3 = 0) : (null === n3 && (n3 = s2), ++r3);
            return r3 > i3 && (t3 = n3, i3 = r3), t3;
          }(e2), i2 = 0; i2 < 8; i2++) r2 && 0 === e2[i2] || (r2 && (r2 = false), n2 === i2 ? (t2 += i2 ? ":" : "::", r2 = true) : (t2 += Xk(e2[i2], 16), i2 < 7 && (t2 += ":")));
          return "[" + t2 + "]";
        }
        return e2;
      }, RM = {}, CM = wk({}, RM, { " ": 1, '"': 1, "<": 1, ">": 1, "`": 1 }), IM = wk({}, CM, { "#": 1, "?": 1, "{": 1, "}": 1 }), vM = wk({}, IM, { "/": 1, ":": 1, ";": 1, "=": 1, "@": 1, "[": 1, "\\": 1, "]": 1, "^": 1, "|": 1 }), yM = function(e2, t2) {
        var i2 = Dk(e2, 0);
        return i2 > 32 && i2 < 127 && !bk(t2, e2) ? e2 : encodeURIComponent(e2);
      }, AM = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 }, bM = function(e2, t2) {
        var i2;
        return 2 == e2.length && zk(cM, qk(e2, 0)) && (":" == (i2 = qk(e2, 1)) || !t2 && "|" == i2);
      }, wM = function(e2) {
        var t2;
        return e2.length > 1 && bM(iM(e2, 0, 2)) && (2 == e2.length || "/" === (t2 = qk(e2, 2)) || "\\" === t2 || "?" === t2 || "#" === t2);
      }, OM = function(e2) {
        return "." === e2 || "%2e" === nM(e2);
      }, NM = {}, DM = {}, PM = {}, LM = {}, kM = {}, MM = {}, UM = {}, xM = {}, VM = {}, FM = {}, BM = {}, jM = {}, GM = {}, WM = {}, HM = {}, KM = {}, YM = {}, qM = {}, zM = {}, JM = {}, XM = {}, QM = function(e2, t2, i2) {
        var n2, r2, s2, o2 = Lk(e2);
        if (t2) {
          if (r2 = this.parse(o2)) throw Wk(r2);
          this.searchParams = null;
        } else {
          if (void 0 !== i2 && (n2 = new QM(i2, true)), r2 = this.parse(o2, null, n2)) throw Wk(r2);
          (s2 = jk(new Bk())).bindURL(this), this.searchParams = s2;
        }
      };
      QM.prototype = { type: "URL", parse: function(e2, t2, i2) {
        var n2, r2, s2, o2, a2, c2 = this, d2 = t2 || NM, l2 = 0, u2 = "", h3 = false, p2 = false, _2 = false;
        for (e2 = Lk(e2), t2 || (c2.scheme = "", c2.username = "", c2.password = "", c2.host = null, c2.port = null, c2.path = [], c2.query = null, c2.fragment = null, c2.cannotBeABaseURL = false, e2 = $k(e2, fM, ""), e2 = $k(e2, gM, "$1")), e2 = $k(e2, TM, ""), n2 = Ok(e2); l2 <= n2.length; ) {
          switch (r2 = n2[l2], d2) {
            case NM:
              if (!r2 || !zk(cM, r2)) {
                if (t2) return sM;
                d2 = PM;
                continue;
              }
              u2 += nM(r2), d2 = DM;
              break;
            case DM:
              if (r2 && (zk(dM, r2) || "+" == r2 || "-" == r2 || "." == r2)) u2 += nM(r2);
              else {
                if (":" != r2) {
                  if (t2) return sM;
                  u2 = "", d2 = PM, l2 = 0;
                  continue;
                }
                if (t2 && (c2.isSpecial() != bk(AM, u2) || "file" == u2 && (c2.includesCredentials() || null !== c2.port) || "file" == c2.scheme && !c2.host)) return;
                if (c2.scheme = u2, t2) return void (c2.isSpecial() && AM[c2.scheme] == c2.port && (c2.port = null));
                u2 = "", "file" == c2.scheme ? d2 = WM : c2.isSpecial() && i2 && i2.scheme == c2.scheme ? d2 = LM : c2.isSpecial() ? d2 = xM : "/" == n2[l2 + 1] ? (d2 = kM, l2++) : (c2.cannotBeABaseURL = true, Zk(c2.path, ""), d2 = zM);
              }
              break;
            case PM:
              if (!i2 || i2.cannotBeABaseURL && "#" != r2) return sM;
              if (i2.cannotBeABaseURL && "#" == r2) {
                c2.scheme = i2.scheme, c2.path = Nk(i2.path), c2.query = i2.query, c2.fragment = "", c2.cannotBeABaseURL = true, d2 = XM;
                break;
              }
              d2 = "file" == i2.scheme ? WM : MM;
              continue;
            case LM:
              if ("/" != r2 || "/" != n2[l2 + 1]) {
                d2 = MM;
                continue;
              }
              d2 = VM, l2++;
              break;
            case kM:
              if ("/" == r2) {
                d2 = FM;
                break;
              }
              d2 = qM;
              continue;
            case MM:
              if (c2.scheme = i2.scheme, r2 == AL) c2.username = i2.username, c2.password = i2.password, c2.host = i2.host, c2.port = i2.port, c2.path = Nk(i2.path), c2.query = i2.query;
              else if ("/" == r2 || "\\" == r2 && c2.isSpecial()) d2 = UM;
              else if ("?" == r2) c2.username = i2.username, c2.password = i2.password, c2.host = i2.host, c2.port = i2.port, c2.path = Nk(i2.path), c2.query = "", d2 = JM;
              else {
                if ("#" != r2) {
                  c2.username = i2.username, c2.password = i2.password, c2.host = i2.host, c2.port = i2.port, c2.path = Nk(i2.path), c2.path.length--, d2 = qM;
                  continue;
                }
                c2.username = i2.username, c2.password = i2.password, c2.host = i2.host, c2.port = i2.port, c2.path = Nk(i2.path), c2.query = i2.query, c2.fragment = "", d2 = XM;
              }
              break;
            case UM:
              if (!c2.isSpecial() || "/" != r2 && "\\" != r2) {
                if ("/" != r2) {
                  c2.username = i2.username, c2.password = i2.password, c2.host = i2.host, c2.port = i2.port, d2 = qM;
                  continue;
                }
                d2 = FM;
              } else d2 = VM;
              break;
            case xM:
              if (d2 = VM, "/" != r2 || "/" != qk(u2, l2 + 1)) continue;
              l2++;
              break;
            case VM:
              if ("/" != r2 && "\\" != r2) {
                d2 = FM;
                continue;
              }
              break;
            case FM:
              if ("@" == r2) {
                h3 && (u2 = "%40" + u2), h3 = true, s2 = Ok(u2);
                for (var E2 = 0; E2 < s2.length; E2++) {
                  var m2 = s2[E2];
                  if (":" != m2 || _2) {
                    var f2 = yM(m2, vM);
                    _2 ? c2.password += f2 : c2.username += f2;
                  } else _2 = true;
                }
                u2 = "";
              } else if (r2 == AL || "/" == r2 || "?" == r2 || "#" == r2 || "\\" == r2 && c2.isSpecial()) {
                if (h3 && "" == u2) return "Invalid authority";
                l2 -= Ok(u2).length + 1, u2 = "", d2 = BM;
              } else u2 += r2;
              break;
            case BM:
            case jM:
              if (t2 && "file" == c2.scheme) {
                d2 = KM;
                continue;
              }
              if (":" != r2 || p2) {
                if (r2 == AL || "/" == r2 || "?" == r2 || "#" == r2 || "\\" == r2 && c2.isSpecial()) {
                  if (c2.isSpecial() && "" == u2) return oM;
                  if (t2 && "" == u2 && (c2.includesCredentials() || null !== c2.port)) return;
                  if (o2 = c2.parseHost(u2)) return o2;
                  if (u2 = "", d2 = YM, t2) return;
                  continue;
                }
                "[" == r2 ? p2 = true : "]" == r2 && (p2 = false), u2 += r2;
              } else {
                if ("" == u2) return oM;
                if (o2 = c2.parseHost(u2)) return o2;
                if (u2 = "", d2 = GM, t2 == jM) return;
              }
              break;
            case GM:
              if (!zk(lM, r2)) {
                if (r2 == AL || "/" == r2 || "?" == r2 || "#" == r2 || "\\" == r2 && c2.isSpecial() || t2) {
                  if ("" != u2) {
                    var g2 = Hk(u2, 10);
                    if (g2 > 65535) return aM;
                    c2.port = c2.isSpecial() && g2 === AM[c2.scheme] ? null : g2, u2 = "";
                  }
                  if (t2) return;
                  d2 = YM;
                  continue;
                }
                return aM;
              }
              u2 += r2;
              break;
            case WM:
              if (c2.scheme = "file", "/" == r2 || "\\" == r2) d2 = HM;
              else {
                if (!i2 || "file" != i2.scheme) {
                  d2 = qM;
                  continue;
                }
                if (r2 == AL) c2.host = i2.host, c2.path = Nk(i2.path), c2.query = i2.query;
                else if ("?" == r2) c2.host = i2.host, c2.path = Nk(i2.path), c2.query = "", d2 = JM;
                else {
                  if ("#" != r2) {
                    wM(Jk(Nk(n2, l2), "")) || (c2.host = i2.host, c2.path = Nk(i2.path), c2.shortenPath()), d2 = qM;
                    continue;
                  }
                  c2.host = i2.host, c2.path = Nk(i2.path), c2.query = i2.query, c2.fragment = "", d2 = XM;
                }
              }
              break;
            case HM:
              if ("/" == r2 || "\\" == r2) {
                d2 = KM;
                break;
              }
              i2 && "file" == i2.scheme && !wM(Jk(Nk(n2, l2), "")) && (bM(i2.path[0], true) ? Zk(c2.path, i2.path[0]) : c2.host = i2.host), d2 = qM;
              continue;
            case KM:
              if (r2 == AL || "/" == r2 || "\\" == r2 || "?" == r2 || "#" == r2) {
                if (!t2 && bM(u2)) d2 = qM;
                else if ("" == u2) {
                  if (c2.host = "", t2) return;
                  d2 = YM;
                } else {
                  if (o2 = c2.parseHost(u2)) return o2;
                  if ("localhost" == c2.host && (c2.host = ""), t2) return;
                  u2 = "", d2 = YM;
                }
                continue;
              }
              u2 += r2;
              break;
            case YM:
              if (c2.isSpecial()) {
                if (d2 = qM, "/" != r2 && "\\" != r2) continue;
              } else if (t2 || "?" != r2) if (t2 || "#" != r2) {
                if (r2 != AL && (d2 = qM, "/" != r2)) continue;
              } else c2.fragment = "", d2 = XM;
              else c2.query = "", d2 = JM;
              break;
            case qM:
              if (r2 == AL || "/" == r2 || "\\" == r2 && c2.isSpecial() || !t2 && ("?" == r2 || "#" == r2)) {
                if (".." === (a2 = nM(a2 = u2)) || "%2e." === a2 || ".%2e" === a2 || "%2e%2e" === a2 ? (c2.shortenPath(), "/" == r2 || "\\" == r2 && c2.isSpecial() || Zk(c2.path, "")) : OM(u2) ? "/" == r2 || "\\" == r2 && c2.isSpecial() || Zk(c2.path, "") : ("file" == c2.scheme && !c2.path.length && bM(u2) && (c2.host && (c2.host = ""), u2 = qk(u2, 0) + ":"), Zk(c2.path, u2)), u2 = "", "file" == c2.scheme && (r2 == AL || "?" == r2 || "#" == r2)) for (; c2.path.length > 1 && "" === c2.path[0]; ) eM(c2.path);
                "?" == r2 ? (c2.query = "", d2 = JM) : "#" == r2 && (c2.fragment = "", d2 = XM);
              } else u2 += yM(r2, IM);
              break;
            case zM:
              "?" == r2 ? (c2.query = "", d2 = JM) : "#" == r2 ? (c2.fragment = "", d2 = XM) : r2 != AL && (c2.path[0] += yM(r2, RM));
              break;
            case JM:
              t2 || "#" != r2 ? r2 != AL && ("'" == r2 && c2.isSpecial() ? c2.query += "%27" : c2.query += "#" == r2 ? "%23" : yM(r2, RM)) : (c2.fragment = "", d2 = XM);
              break;
            case XM:
              r2 != AL && (c2.fragment += yM(r2, CM));
          }
          l2++;
        }
      }, parseHost: function(e2) {
        var t2, i2, n2;
        if ("[" == qk(e2, 0)) {
          if ("]" != qk(e2, e2.length - 1)) return oM;
          if (t2 = function(e3) {
            var t3, i3, n3, r2, s2, o2, a2, c2 = [0, 0, 0, 0, 0, 0, 0, 0], d2 = 0, l2 = null, u2 = 0, h3 = function() {
              return qk(e3, u2);
            };
            if (":" == h3()) {
              if (":" != qk(e3, 1)) return;
              u2 += 2, l2 = ++d2;
            }
            for (; h3(); ) {
              if (8 == d2) return;
              if (":" != h3()) {
                for (t3 = i3 = 0; i3 < 4 && zk(_M, h3()); ) t3 = 16 * t3 + Hk(h3(), 16), u2++, i3++;
                if ("." == h3()) {
                  if (0 == i3) return;
                  if (u2 -= i3, d2 > 6) return;
                  for (n3 = 0; h3(); ) {
                    if (r2 = null, n3 > 0) {
                      if (!("." == h3() && n3 < 4)) return;
                      u2++;
                    }
                    if (!zk(lM, h3())) return;
                    for (; zk(lM, h3()); ) {
                      if (s2 = Hk(h3(), 10), null === r2) r2 = s2;
                      else {
                        if (0 == r2) return;
                        r2 = 10 * r2 + s2;
                      }
                      if (r2 > 255) return;
                      u2++;
                    }
                    c2[d2] = 256 * c2[d2] + r2, 2 != ++n3 && 4 != n3 || d2++;
                  }
                  if (4 != n3) return;
                  break;
                }
                if (":" == h3()) {
                  if (u2++, !h3()) return;
                } else if (h3()) return;
                c2[d2++] = t3;
              } else {
                if (null !== l2) return;
                u2++, l2 = ++d2;
              }
            }
            if (null !== l2) for (o2 = d2 - l2, d2 = 7; 0 != d2 && o2 > 0; ) a2 = c2[d2], c2[d2--] = c2[l2 + o2 - 1], c2[l2 + --o2] = a2;
            else if (8 != d2) return;
            return c2;
          }(iM(e2, 1, -1)), !t2) return oM;
          this.host = t2;
        } else if (this.isSpecial()) {
          if (e2 = Pk(e2), zk(EM, e2)) return oM;
          if (t2 = function(e3) {
            var t3, i3, n3, r2, s2, o2, a2, c2 = tM(e3, ".");
            if (c2.length && "" == c2[c2.length - 1] && c2.length--, (t3 = c2.length) > 4) return e3;
            for (i3 = [], n3 = 0; n3 < t3; n3++) {
              if ("" == (r2 = c2[n3])) return e3;
              if (s2 = 10, r2.length > 1 && "0" == qk(r2, 0) && (s2 = zk(uM, r2) ? 16 : 8, r2 = iM(r2, 8 == s2 ? 1 : 2)), "" === r2) o2 = 0;
              else {
                if (!zk(10 == s2 ? pM : 8 == s2 ? hM : _M, r2)) return e3;
                o2 = Hk(r2, s2);
              }
              Zk(i3, o2);
            }
            for (n3 = 0; n3 < t3; n3++) if (o2 = i3[n3], n3 == t3 - 1) {
              if (o2 >= Yk(256, 5 - t3)) return null;
            } else if (o2 > 255) return null;
            for (a2 = Qk(i3), n3 = 0; n3 < i3.length; n3++) a2 += i3[n3] * Yk(256, 3 - n3);
            return a2;
          }(e2), null === t2) return oM;
          this.host = t2;
        } else {
          if (zk(mM, e2)) return oM;
          for (t2 = "", i2 = Ok(e2), n2 = 0; n2 < i2.length; n2++) t2 += yM(i2[n2], RM);
          this.host = t2;
        }
      }, cannotHaveUsernamePasswordPort: function() {
        return !this.host || this.cannotBeABaseURL || "file" == this.scheme;
      }, includesCredentials: function() {
        return "" != this.username || "" != this.password;
      }, isSpecial: function() {
        return bk(AM, this.scheme);
      }, shortenPath: function() {
        var e2 = this.path, t2 = e2.length;
        !t2 || "file" == this.scheme && 1 == t2 && bM(e2[0], true) || e2.length--;
      }, serialize: function() {
        var e2 = this, t2 = e2.scheme, i2 = e2.username, n2 = e2.password, r2 = e2.host, s2 = e2.port, o2 = e2.path, a2 = e2.query, c2 = e2.fragment, d2 = t2 + ":";
        return null !== r2 ? (d2 += "//", e2.includesCredentials() && (d2 += i2 + (n2 ? ":" + n2 : "") + "@"), d2 += SM(r2), null !== s2 && (d2 += ":" + s2)) : "file" == t2 && (d2 += "//"), d2 += e2.cannotBeABaseURL ? o2[0] : o2.length ? "/" + Jk(o2, "/") : "", null !== a2 && (d2 += "?" + a2), null !== c2 && (d2 += "#" + c2), d2;
      }, setHref: function(e2) {
        var t2 = this.parse(e2);
        if (t2) throw Wk(t2);
        this.searchParams.update();
      }, getOrigin: function() {
        var e2 = this.scheme, t2 = this.port;
        if ("blob" == e2) try {
          return new ZM(e2.path[0]).origin;
        } catch (e3) {
          return "null";
        }
        return "file" != e2 && this.isSpecial() ? e2 + "://" + SM(this.host) + (null !== t2 ? ":" + t2 : "") : "null";
      }, getProtocol: function() {
        return this.scheme + ":";
      }, setProtocol: function(e2) {
        this.parse(Lk(e2) + ":", NM);
      }, getUsername: function() {
        return this.username;
      }, setUsername: function(e2) {
        var t2 = Ok(Lk(e2));
        if (!this.cannotHaveUsernamePasswordPort()) {
          this.username = "";
          for (var i2 = 0; i2 < t2.length; i2++) this.username += yM(t2[i2], vM);
        }
      }, getPassword: function() {
        return this.password;
      }, setPassword: function(e2) {
        var t2 = Ok(Lk(e2));
        if (!this.cannotHaveUsernamePasswordPort()) {
          this.password = "";
          for (var i2 = 0; i2 < t2.length; i2++) this.password += yM(t2[i2], vM);
        }
      }, getHost: function() {
        var e2 = this.host, t2 = this.port;
        return null === e2 ? "" : null === t2 ? SM(e2) : SM(e2) + ":" + t2;
      }, setHost: function(e2) {
        this.cannotBeABaseURL || this.parse(e2, BM);
      }, getHostname: function() {
        var e2 = this.host;
        return null === e2 ? "" : SM(e2);
      }, setHostname: function(e2) {
        this.cannotBeABaseURL || this.parse(e2, jM);
      }, getPort: function() {
        var e2 = this.port;
        return null === e2 ? "" : Lk(e2);
      }, setPort: function(e2) {
        this.cannotHaveUsernamePasswordPort() || ("" == (e2 = Lk(e2)) ? this.port = null : this.parse(e2, GM));
      }, getPathname: function() {
        var e2 = this.path;
        return this.cannotBeABaseURL ? e2[0] : e2.length ? "/" + Jk(e2, "/") : "";
      }, setPathname: function(e2) {
        this.cannotBeABaseURL || (this.path = [], this.parse(e2, YM));
      }, getSearch: function() {
        var e2 = this.query;
        return e2 ? "?" + e2 : "";
      }, setSearch: function(e2) {
        "" == (e2 = Lk(e2)) ? this.query = null : ("?" == qk(e2, 0) && (e2 = iM(e2, 1)), this.query = "", this.parse(e2, JM)), this.searchParams.update();
      }, getSearchParams: function() {
        return this.searchParams.facade;
      }, getHash: function() {
        var e2 = this.fragment;
        return e2 ? "#" + e2 : "";
      }, setHash: function(e2) {
        "" != (e2 = Lk(e2)) ? ("#" == qk(e2, 0) && (e2 = iM(e2, 1)), this.fragment = "", this.parse(e2, XM)) : this.fragment = null;
      }, update: function() {
        this.query = this.searchParams.serialize() || null;
      } };
      var ZM = function(e2) {
        var t2 = Ak(this, $M), i2 = Mk(arguments.length, 1) > 1 ? arguments[1] : void 0, n2 = Vk(t2, new QM(e2, false, i2));
        Tk || (t2.href = n2.serialize(), t2.origin = n2.getOrigin(), t2.protocol = n2.getProtocol(), t2.username = n2.getUsername(), t2.password = n2.getPassword(), t2.host = n2.getHost(), t2.hostname = n2.getHostname(), t2.port = n2.getPort(), t2.pathname = n2.getPathname(), t2.search = n2.getSearch(), t2.searchParams = n2.getSearchParams(), t2.hash = n2.getHash());
      }, $M = ZM.prototype, eU = function(e2, t2) {
        return { get: function() {
          return Fk(this)[e2]();
        }, set: t2 && function(e3) {
          return Fk(this)[t2](e3);
        }, configurable: true, enumerable: true };
      };
      if (Tk && (yk($M, "href", eU("serialize", "setHref")), yk($M, "origin", eU("getOrigin")), yk($M, "protocol", eU("getProtocol", "setProtocol")), yk($M, "username", eU("getUsername", "setUsername")), yk($M, "password", eU("getPassword", "setPassword")), yk($M, "host", eU("getHost", "setHost")), yk($M, "hostname", eU("getHostname", "setHostname")), yk($M, "port", eU("getPort", "setPort")), yk($M, "pathname", eU("getPathname", "setPathname")), yk($M, "search", eU("getSearch", "setSearch")), yk($M, "searchParams", eU("getSearchParams")), yk($M, "hash", eU("getHash", "setHash"))), vk($M, "toJSON", function() {
        return Fk(this).serialize();
      }, { enumerable: true }), vk($M, "toString", function() {
        return Fk(this).serialize();
      }, { enumerable: true }), Gk) {
        var tU = Gk.createObjectURL, iU = Gk.revokeObjectURL;
        tU && vk(ZM, "createObjectURL", Ck(tU, Gk)), iU && vk(ZM, "revokeObjectURL", Ck(iU, Gk));
      }
      kk(ZM, "URL"), gk({ global: true, constructor: true, forced: !Sk, sham: !Tk }, { URL: ZM });
      var nU = wi, rU = n, sU = H_, oU = pn, aU = lP, cU = ae("URL");
      nU({ target: "URL", stat: true, forced: !(aU && rU(function() {
        cU.canParse();
      })) }, { canParse: function(e2) {
        var t2 = sU(arguments.length, 1), i2 = oU(e2), n2 = t2 < 2 || void 0 === arguments[1] ? void 0 : oU(arguments[1]);
        try {
          return !!new cU(i2, n2);
        } catch (e3) {
          return false;
        }
      } });
      var dU = i(ie.URL);
      function lU() {
        const e2 = new Blob([atob("ZnVuY3Rpb24gZShlKXtjb25zdCB0PW5ldyBEYXRhVmlldyhlLmRhdGEpO2lmKDA9PT10LmdldFVpbnQ4KDApJiYwPT09dC5nZXRVaW50OCgxKSYmMD09PXQuZ2V0VWludDgoMikmJjE9PT10LmdldFVpbnQ4KDMpJiY2PT09dC5nZXRVaW50OCg0KSl7bGV0IG49NixyPTAsbz0wO2Zvcig7MjU1PT09KG89dC5nZXRVaW50OChuKyspKTspcis9MjU1O3IrPW87Y29uc3QgYT1mdW5jdGlvbihlLHQsbil7bGV0IHI9bmV3IFVpbnQ4QXJyYXkoZSx0LG4pLG89W10sYT0wO2Zvcig7YTxuOylhKzM8biYmMD09PXJbYV0mJjA9PT1yW2ErMV0mJjM9PT1yW2ErMl0mJigwPT09clthKzNdfHwxPT09clthKzNdfHwyPT09clthKzNdfHwzPT09clthKzNdKT8oby5wdXNoKHJbYV0sclthKzFdLHJbYSszXSksYSs9NCk6KG8ucHVzaChyW2FdKSxhKyspO3JldHVybiBuZXcgVWludDhBcnJheShvKX0oZS5kYXRhLG4scik7cmV0dXJuIG5ldyBVaW50OEFycmF5KGEpfXJldHVybiBudWxsfWZ1bmN0aW9uIHQoZSx0KXtjb25zdCBuPWZ1bmN0aW9uKGUpe2NvbnN0IHQ9ZS5sZW5ndGg7bGV0IG49W10scj0wO2Zvcig7cjx0OylyKzI8dCYmMD09PWVbcl0mJjA9PT1lW3IrMV0mJigwPT09ZVtyKzJdfHwxPT09ZVtyKzJdfHwyPT09ZVtyKzJdfHwzPT09ZVtyKzJdKT8obi5wdXNoKGVbcl0sZVtyKzFdLDMsZVtyKzJdKSxyKz0zKToobi5wdXNoKGVbcl0pLHIrKyk7cmV0dXJuIG5ldyBVaW50OEFycmF5KG4pfSh0KSxyPW4ubGVuZ3RoLG89TWF0aC5mbG9vcihyLzI1NSksYT1yJTI1NSxzPW5ldyBVaW50OEFycmF5KDYrbysxK3IrZS5ieXRlTGVuZ3RoKTtzWzBdPTAsc1sxXT0wLHNbMl09MCxzWzNdPTEsc1s0XT02LHNbNV09MTAxO2xldCBpPTA7Zm9yKDtpPG87KXNbNitpXT0yNTUsaSsrO3JldHVybiBzWzYraV09YSxpKysscy5zZXQobiw2K2kpLHMuc2V0KG5ldyBVaW50OEFycmF5KGUpLDYraStyKSxzLmJ1ZmZlcn1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIlNhZmFyaSIpPi0xJiYtMT09PW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiQ2hyb21lIikmJihzZWxmLm9ucnRjdHJhbnNmb3JtPW49Pntjb25zdCByPW4udHJhbnNmb3JtZXI7bGV0IG89W107ci5vcHRpb25zLnBvcnQub25tZXNzYWdlPWU9PntlLmRhdGEuc2VpJiZvLnB1c2goZS5kYXRhLnNlaSl9LHNlbGYucG9zdE1lc3NhZ2UoInN0YXJ0ZWQiKTtjb25zdCBhPXIucmVhZGFibGUuZ2V0UmVhZGVyKCkscz1yLndyaXRhYmxlLmdldFdyaXRlcigpOyJyeCI9PT1yLm9wdGlvbnMubmFtZT9mdW5jdGlvbiB0KG4pe2EucmVhZCgpLnRoZW4oKHI9PntpZighci5kb25lKXtpZihyLnZhbHVlIGluc3RhbmNlb2YgUlRDRW5jb2RlZFZpZGVvRnJhbWUpe2NvbnN0IHQ9ZShyLnZhbHVlKTt0JiZuLm9wdGlvbnMucG9ydC5wb3N0TWVzc2FnZSh7c2VpOnR9KX1zLndyaXRlKHIudmFsdWUpLG4ub3B0aW9ucy5wb3J0LnBvc3RNZXNzYWdlKHt0cmFuc2Zvcm1lZDohMH0pLHQobil9fSkpfShyKToidHgiPT09ci5vcHRpb25zLm5hbWUmJmZ1bmN0aW9uIGUobil7YS5yZWFkKCkudGhlbigocj0+e2lmKCFyLmRvbmUpe2lmKHIudmFsdWUgaW5zdGFuY2VvZiBSVENFbmNvZGVkVmlkZW9GcmFtZSl7Y29uc3QgZT1vLnNoaWZ0KCk7ZSYmKHIudmFsdWUuZGF0YT10KHIudmFsdWUuZGF0YSxlKSl9cy53cml0ZShyLnZhbHVlKSxuLm9wdGlvbnMucG9ydC5wb3N0TWVzc2FnZSh7dHJhbnNmb3JtZWQ6ITB9KSxlKG4pfX0pKX0ocil9LHNlbGYucG9zdE1lc3NhZ2UoInJlZ2lzdGVyZWQiKSk7Cg==")], { type: "text/javascript" });
        return setTimeout(() => dU.revokeObjectURL(e2), 0), new Worker(dU.createObjectURL(e2));
      }
      const uU = /* @__PURE__ */ new Map();
      const hU = /* @__PURE__ */ new Map();
      async function pU(e2) {
        if (!IA().supportWebRTCEncodedTransform) return void jC.warning("browser not support audio encoded transform");
        if (hU.has(e2)) return;
        const t2 = { track: e2.track };
        if (Ag()) {
          if (!e2.createEncodedStreams) return void jC.warning("browser not support createEncodedStreams() API");
          let n2 = null;
          try {
            n2 = e2.createEncodedStreams();
          } catch (e3) {
            return void jC.error("create audio-encoded-streams error", e3 && e3.message);
          }
          const r2 = new TransformStream({ transform(n3, r3) {
            t2.controller || (t2.controller = r3), e2.track && e2.track.id !== t2.track.id && (jC.debug("audio track changed: ".concat(t2.track.id, " => ").concat(e2.track.id)), t2.track.removeEventListener("ended", i2), t2.track = e2.track, t2.track.addEventListener("ended", i2)), r3.enqueue(n3);
          } });
          n2.readable.pipeThrough(r2).pipeTo(n2.writable);
        } else if (bg()) {
          if ("undefined" == typeof RTCRtpScriptTransform) return void jC.warning("browser not support RTCRtpScriptTransform");
          const n2 = lU(), r2 = new MessageChannel();
          await new cg((e3) => n2.onmessage = (t3) => {
            "registered" === t3.data && e3(void 0);
          });
          const s2 = new RTCRtpScriptTransform(n2, { name: "rx", port: r2.port2 }, [r2.port2]);
          e2.transform = s2, await new cg((e3) => n2.onmessage = (t3) => {
            "started" === t3.data && e3(void 0);
          }), r2.port1.onmessage = (n3) => {
            var r3;
            n3.data.transformed && e2.track && (null === (r3 = e2.track) || void 0 === r3 ? void 0 : r3.id) !== t2.track.id && (jC.debug("audio track changed: ".concat(t2.track.id, " => ").concat(e2.track.id)), t2.track.removeEventListener("ended", i2), t2.track = e2.track, t2.track.addEventListener("ended", i2));
          }, t2.worker = n2;
        }
        function i2() {
          e2.track.removeEventListener("ended", i2), function(e3) {
            const t3 = hU.get(e3);
            if (t3) {
              hU.delete(e3);
              try {
                var i3, n2;
                null === (i3 = t3.controller) || void 0 === i3 || i3.terminate(), null === (n2 = t3.worker) || void 0 === n2 || n2.terminate();
              } catch (e4) {
                jC.warning(e4 && e4.message);
              }
            }
          }(e2);
        }
        hU.set(e2, t2), e2.track.addEventListener("ended", i2);
      }
      function _U(e2) {
        const t2 = new DataView(e2.data);
        if (0 === t2.getUint8(0) && 0 === t2.getUint8(1) && 0 === t2.getUint8(2) && 1 === t2.getUint8(3) && 6 === t2.getUint8(4)) {
          let i2 = 6, n2 = 0, r2 = 0;
          for (; 255 === (r2 = t2.getUint8(i2++)); ) n2 += 255;
          n2 += r2;
          const s2 = function(e3, t3, i3) {
            let n3 = new Uint8Array(e3, t3, i3), r3 = [], s3 = 0;
            for (; s3 < i3; ) s3 + 3 < i3 && 0 === n3[s3] && 0 === n3[s3 + 1] && 3 === n3[s3 + 2] && (0 === n3[s3 + 3] || 1 === n3[s3 + 3] || 2 === n3[s3 + 3] || 3 === n3[s3 + 3]) ? (r3.push(n3[s3], n3[s3 + 1], n3[s3 + 3]), s3 += 4) : (r3.push(n3[s3]), s3++);
            return new Uint8Array(r3);
          }(e2.data, i2, n2);
          return new Uint8Array(s2);
        }
        return null;
      }
      function EU(e2, t2) {
        const i2 = function(e3) {
          const t3 = e3.length;
          let i3 = [], n3 = 0;
          for (; n3 < t3; ) n3 + 2 < t3 && 0 === e3[n3] && 0 === e3[n3 + 1] && (0 === e3[n3 + 2] || 1 === e3[n3 + 2] || 2 === e3[n3 + 2] || 3 === e3[n3 + 2]) ? (i3.push(e3[n3], e3[n3 + 1], 3, e3[n3 + 2]), n3 += 3) : (i3.push(e3[n3]), n3++);
          return new Uint8Array(i3);
        }(t2), n2 = i2.length, r2 = Math.floor(n2 / 255), s2 = n2 % 255, o2 = new Uint8Array(6 + r2 + 1 + n2 + e2.byteLength);
        o2[0] = 0, o2[1] = 0, o2[2] = 0, o2[3] = 1, o2[4] = 6, o2[5] = 101;
        let a2 = 0;
        for (; a2 < r2; ) o2[6 + a2] = 255, a2++;
        return o2[6 + a2] = s2, a2++, o2.set(i2, 6 + a2), o2.set(new Uint8Array(e2), 6 + a2 + n2), o2.buffer;
      }
      const mU = /* @__PURE__ */ new Map();
      const fU = /* @__PURE__ */ new Map();
      async function gU(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (!IA().supportWebRTCEncodedTransform) return void jC.warning("browser not support video encoded transform");
        if (!e2.track) return;
        if (fU.has(e2)) {
          const i3 = fU.get(e2);
          return void (i3 && (i3.onSei = t2.onSei));
        }
        const i2 = { track: e2.track, onSei: t2.onSei };
        if (Ag()) {
          if (!e2.createEncodedStreams) return void jC.warning("browser not support createEncodedStreams() API");
          let t3 = null;
          try {
            t3 = e2.createEncodedStreams();
          } catch (e3) {
            return void jC.error("create video-encoded-streams error", e3 && e3.message);
          }
          const r2 = new TransformStream({ transform(t4, r3) {
            i2.controller || (i2.controller = r3), e2.track && e2.track.id !== i2.track.id && (jC.debug("video track changed: ".concat(i2.track.id, " => ").concat(e2.track.id)), i2.track.removeEventListener("ended", n2), i2.track = e2.track, i2.track.addEventListener("ended", n2));
            const s2 = _U(t4);
            s2 && i2.onSei && i2.onSei(s2), r3.enqueue(t4);
          } });
          t3.readable.pipeThrough(r2).pipeTo(t3.writable);
        } else if (bg()) {
          if ("undefined" == typeof RTCRtpScriptTransform) return void jC.warning("browser not support RTCRtpScriptTransform");
          const t3 = lU(), r2 = new MessageChannel();
          await new cg((e3) => t3.onmessage = (t4) => {
            "registered" === t4.data && e3(void 0);
          });
          const s2 = new RTCRtpScriptTransform(t3, { name: "rx", port: r2.port2 }, [r2.port2]);
          e2.transform = s2, await new cg((e3) => t3.onmessage = (t4) => {
            "started" === t4.data && e3(void 0);
          }), r2.port1.onmessage = (t4) => {
            var r3;
            t4.data.transformed && e2.track && (null === (r3 = e2.track) || void 0 === r3 ? void 0 : r3.id) !== i2.track.id ? (jC.debug("video track changed: ".concat(i2.track.id, " => ").concat(e2.track.id)), i2.track.removeEventListener("ended", n2), i2.track = e2.track, i2.track.addEventListener("ended", n2)) : t4.data.sei && i2.onSei && i2.onSei(t4.data.sei);
          }, i2.worker = t3;
        }
        function n2() {
          if (e2.track) {
            if (this.id !== e2.track.id) return;
            e2.track.removeEventListener("ended", n2);
          }
          !function(e3) {
            const t3 = fU.get(e3);
            if (t3) {
              fU.delete(e3);
              try {
                var i3, n3;
                null === (i3 = t3.controller) || void 0 === i3 || i3.terminate(), null === (n3 = t3.worker) || void 0 === n3 || n3.terminate();
              } catch (e4) {
                jC.warning(e4 && e4.message);
              }
            }
          }(e2);
        }
        fU.set(e2, i2), e2.track.addEventListener("ended", n2);
      }
      !function() {
        const e2 = Sg();
        CA.getDisplayMedia = function(e3) {
          if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) return true;
          return false;
        }(), CA.getStreamFromExtension = e2.name === Eg.CHROME && Number(e2.version) > 34, CA.supportUnifiedPlan = function() {
          if (!window.RTCRtpTransceiver) return false;
          if (!("currentDirection" in RTCRtpTransceiver.prototype)) return false;
          const e3 = new RTCPeerConnection();
          let t2 = false;
          try {
            e3.addTransceiver("audio"), t2 = true;
          } catch (e4) {
          }
          return e3.close(), t2;
        }(), CA.supportMinBitrate = e2.name === Eg.CHROME || e2.name === Eg.EDGE, CA.supportSetRtpSenderParameters = function() {
          const e3 = Sg();
          if (!window.RTCRtpSender || !window.RTCRtpSender.prototype.setParameters || !window.RTCRtpSender.prototype.getParameters) return false;
          return !!jg() || (!(!bg() && !Ig()) || e3.name === Eg.FIREFOX && Number(e3.version) >= 64);
        }(), e2.name === Eg.SAFARI && (Number(e2.version) >= 14 ? CA.supportDualStream = true : CA.supportDualStream = false), CA.webAudioMediaStreamDest = function() {
          const e3 = Sg();
          if (e3.name === Eg.SAFARI && Number(e3.version) < 12) return false;
          return true;
        }(), CA.supportReplaceTrack = function() {
          if (!window.RTCRtpSender) return false;
          if ("function" == typeof RTCRtpSender.prototype.replaceTrack) return true;
          return false;
        }(), CA.supportWebGL = "undefined" != typeof WebGLRenderingContext, CA.supportRequestFrame = !!window.CanvasCaptureMediaStreamTrack, jg() || (CA.webAudioWithAEC = true), CA.supportShareAudio = function() {
          const e3 = Sg();
          if ((e3.os === _g.WIN_10 || e3.os === _g.WIN_81 || e3.os === _g.WIN_7 || e3.os === _g.LINUX || e3.os === _g.MAC_OS || e3.os === _g.CHROMIUM_OS) && e3.name === Eg.CHROME && Number(e3.version) >= 74) return true;
          return false;
        }(), CA.supportDataChannel = function() {
          if (Ng(76) || function(e3) {
            const t2 = Sg();
            return !(t2.name !== Eg.FIREFOX || !t2.osVersion) && Number(t2.version) >= e3;
          }(68) || function(e3) {
            const t2 = Sg();
            return !(t2.name !== Eg.SAFARI || !t2.osVersion) && Number(t2.version) >= e3;
          }(14)) return true;
          return false;
        }(), CA.supportPCSetConfiguration = function() {
          const e3 = window.RTCPeerConnection;
          return !wg() && !!e3 && e3.prototype.setConfiguration instanceof Function;
        }(), CA.supportWebRTCEncodedTransform = function() {
          const e3 = Sg();
          return "Chrome" === e3.name && Number(e3.version) >= 86 || "Safari" === e3.name && Number(e3.version) >= 15;
        }(), CA.supportWebRTCInsertableStream = function() {
          const e3 = Sg();
          return (e3.name === Eg.CHROME || e3.name === Eg.EDGE) && Number(e3.version) >= 94 && "MediaStreamTrackGenerator" in window && "MediaStreamTrackProcessor" in window;
        }(), KT(() => {
          CA.supportDualStreamEncoding = function() {
            const e3 = Sg();
            if (RC("DISABLE_WEBAUDIO")) return true;
            return "Safari" === e3.name && Number(e3.version) >= 14 || !!("Chrome" === e3.name && /Windows/i.test(e3.os || "") && Number(e3.version) >= 100 && RC("CHROME_DUAL_STREAM_USE_ENCODING"));
          }(), jC.info("browser compatibility", JSON.stringify(CA), JSON.stringify(e2));
        });
      }();
      class TU extends dT {
        constructor() {
          super(...arguments), sh(this, "resultStorage", /* @__PURE__ */ new Map());
        }
        setLocalAudioStats(e2, t2, i2) {
          this.record("AUDIO_INPUT_LEVEL_TOO_LOW", e2, this.checkAudioInputLevel(i2, t2)), this.record("SEND_AUDIO_BITRATE_TOO_LOW", e2, this.checkSendAudioBitrate(i2, t2));
        }
        setLocalVideoStats(e2, t2, i2) {
          this.record("SEND_VIDEO_BITRATE_TOO_LOW", e2, this.checkSendVideoBitrate(i2, t2)), this.record("FRAMERATE_INPUT_TOO_LOW", e2, this.checkFramerateInput(i2, t2)), this.record("FRAMERATE_SENT_TOO_LOW", e2, this.checkFramerateSent(i2));
        }
        setRemoteAudioStats(e2, t2) {
          const i2 = e2.getUserId();
          this.record("AUDIO_OUTPUT_LEVEL_TOO_LOW", i2, this.checkAudioOutputLevel(t2));
        }
        setRemoteVideoStats(e2, t2) {
          const i2 = e2.getUserId();
          this.record("RECV_VIDEO_DECODE_FAILED", i2, this.checkVideoDecode(t2));
        }
        record(e2, t2, i2) {
          if (RC("STATS_UPDATE_INTERVAL") > 500) return;
          this.resultStorage.has(e2) || this.resultStorage.set(e2, { result: [], isPrevNormal: true });
          const n2 = this.resultStorage.get(e2);
          if (n2 && (n2.result.push(i2), n2.result.length >= 5)) {
            var r2;
            const i3 = bn(r2 = n2.result).call(r2, true);
            n2.isPrevNormal && !i3 && this.emit("exception", SU[e2], e2, t2), !n2.isPrevNormal && i3 && this.emit("exception", SU[e2] + 2e3, e2 + "_RECOVER", t2), n2.isPrevNormal = i3, n2.result = [];
          }
        }
        checkAudioOutputLevel(e2) {
          return !(e2.receiveBitrate > 0 && 0 === e2.receiveLevel);
        }
        checkAudioInputLevel(e2, t2) {
          return t2 instanceof nw && !t2.isActive || (!!t2.muted || 0 !== e2.sendVolumeLevel);
        }
        checkFramerateInput(e2, t2) {
          let i2 = null;
          t2._encoderConfig && t2._encoderConfig.frameRate && (i2 = Sy(t2._encoderConfig.frameRate));
          const n2 = e2.captureFrameRate;
          return !i2 || !n2 || !(i2 > 10 && n2 < 5 || i2 < 10 && i2 >= 5 && n2 <= 1);
        }
        checkFramerateSent(e2) {
          return !(e2.captureFrameRate && e2.sendFrameRate && e2.captureFrameRate > 5 && e2.sendFrameRate <= 1);
        }
        checkSendVideoBitrate(e2, t2) {
          return !!t2.muted || 0 !== e2.sendBitrate;
        }
        checkSendAudioBitrate(e2, t2) {
          return t2 instanceof nw && !t2.isActive || (!!t2.muted || 0 !== e2.sendBitrate);
        }
        checkVideoDecode(e2) {
          return 0 === e2.receiveBitrate || 0 !== e2.decodeFrameRate;
        }
      }
      const SU = { FRAMERATE_INPUT_TOO_LOW: 1001, FRAMERATE_SENT_TOO_LOW: 1002, SEND_VIDEO_BITRATE_TOO_LOW: 1003, RECV_VIDEO_DECODE_FAILED: 1005, AUDIO_INPUT_LEVEL_TOO_LOW: 2001, AUDIO_OUTPUT_LEVEL_TOO_LOW: 2002, SEND_AUDIO_BITRATE_TOO_LOW: 2003 };
      const RU = new class {
        markSubscribeStart(e2, t2) {
          performance.mark("agora-web-sdk/".concat(e2, "/subscribe-").concat(t2));
        }
        markPublishStart(e2, t2) {
          performance.mark("agora-web-sdk/".concat(e2, "/publish-").concat(t2));
        }
        measureFromSubscribeStart(e2, t2) {
          const i2 = performance.getEntriesByName("agora-web-sdk/".concat(e2, "/subscribe-").concat(t2));
          if (i2.length > 0) {
            const e3 = i2[i2.length - 1];
            return Math.round(performance.now() - e3.startTime);
          }
          return 0;
        }
        measureFromPublishStart(e2, t2) {
          const i2 = performance.getEntriesByName("agora-web-sdk/".concat(e2, "/publish-").concat(t2));
          if (i2.length > 0) {
            const e3 = i2[i2.length - 1];
            return Math.round(performance.now() - e3.startTime);
          }
          return 0;
        }
      }();
      function CU(e2, t2) {
        this.v = e2, this.k = t2;
      }
      function IU(e2) {
        return new CU(e2, 0);
      }
      var vU = ag, yU = um;
      wi({ target: "Promise", stat: true, forced: true }, { withResolvers: function() {
        var e2 = yU.f(this);
        return { promise: e2.promise, resolve: e2.resolve, reject: e2.reject };
      } });
      var AU = um, bU = YE;
      wi({ target: "Promise", stat: true, forced: true }, { try: function(e2) {
        var t2 = AU.f(this), i2 = bU(e2);
        return (i2.error ? t2.reject : t2.resolve)(i2.value), t2.promise;
      } });
      var wU = i(vU), OU = Fo.f("asyncIterator"), NU = i(OU);
      function DU(e2) {
        var t2, i2;
        function n2(t3, i3) {
          try {
            var s2 = e2[t3](i3), o2 = s2.value, a2 = o2 instanceof CU;
            wU.resolve(a2 ? o2.v : o2).then(function(i4) {
              if (a2) {
                var c2 = "return" === t3 ? "return" : "next";
                if (!o2.k || i4.done) return n2(c2, i4);
                i4 = e2[c2](i4).value;
              }
              r2(s2.done ? "return" : "normal", i4);
            }, function(e3) {
              n2("throw", e3);
            });
          } catch (e3) {
            r2("throw", e3);
          }
        }
        function r2(e3, r3) {
          switch (e3) {
            case "return":
              t2.resolve({ value: r3, done: true });
              break;
            case "throw":
              t2.reject(r3);
              break;
            default:
              t2.resolve({ value: r3, done: false });
          }
          (t2 = t2.next) ? n2(t2.key, t2.arg) : i2 = null;
        }
        this._invoke = function(e3, r3) {
          return new wU(function(s2, o2) {
            var a2 = { key: e3, arg: r3, resolve: s2, reject: o2, next: null };
            i2 ? i2 = i2.next = a2 : (t2 = i2 = a2, n2(e3, r3));
          });
        }, "function" != typeof e2.return && (this.return = void 0);
      }
      function PU(e2) {
        return function() {
          return new DU(e2.apply(this, arguments));
        };
      }
      DU.prototype["function" == typeof xu && NU || "@@asyncIterator"] = function() {
        return this;
      }, DU.prototype.next = function(e2) {
        return this._invoke("next", e2);
      }, DU.prototype.throw = function(e2) {
        return this._invoke("throw", e2);
      }, DU.prototype.return = function(e2) {
        return this._invoke("return", e2);
      };
      var LU = i(ie.Object.getOwnPropertySymbols), kU = wi, MU = Ki.indexOf, UU = Ih, xU = v([].indexOf), VU = !!xU && 1 / xU([1], 1, -0) < 0;
      kU({ target: "Array", proto: true, forced: VU || !UU("indexOf") }, { indexOf: function(e2) {
        var t2 = arguments.length > 1 ? arguments[1] : void 0;
        return VU ? xU(this, e2, t2) || 0 : MU(this, e2, t2);
      } });
      var FU = zi("Array").indexOf, BU = l, jU = FU, GU = Array.prototype, WU = i(function(e2) {
        var t2 = e2.indexOf;
        return e2 === GU || BU(GU, e2) && t2 === GU.indexOf ? jU : t2;
      }), HU = Je, KU = Ys;
      wi({ target: "Object", stat: true, forced: n(function() {
        KU(1);
      }) }, { keys: function(e2) {
        return KU(HU(e2));
      } });
      var YU = i(ie.Object.keys);
      function qU(e2, t2) {
        if (null == e2) return {};
        var i2, n2, r2 = function(e3, t3) {
          if (null == e3) return {};
          var i3, n3, r3 = {}, s3 = YU(e3);
          for (n3 = 0; n3 < s3.length; n3++) i3 = s3[n3], WU(t3).call(t3, i3) >= 0 || (r3[i3] = e3[i3]);
          return r3;
        }(e2, t2);
        if (LU) {
          var s2 = LU(e2);
          for (n2 = 0; n2 < s2.length; n2++) i2 = s2[n2], WU(t2).call(t2, i2) >= 0 || Object.prototype.propertyIsEnumerable.call(e2, i2) && (r2[i2] = e2[i2]);
        }
        return r2;
      }
      var zU = { exports: {} };
      !function(e2, t2) {
        e2.exports = (() => {
          var e3 = { 8: (e4, t4, i3) => {
            i3.r(t4), i3.d(t4, { Parser: () => C2, Printer: () => b2, parse: () => D2, print: () => P2 });
            const n2 = "\n", r2 = "".concat("\r").concat(n2), s2 = " ";
            let o2;
            function a2(e5) {
              return e5 >= "0" && e5 <= "9";
            }
            function c2(e5) {
              return e5 >= "!" && e5 <= "~";
            }
            function d2(e5) {
              return c2(e5) || e5 >= "Â" && e5 <= "Ã¿";
            }
            function l2(e5) {
              return "!" === e5 || e5 >= "#" && e5 <= "'" || e5 >= "*" && e5 <= "+" || e5 >= "-" && e5 <= "." || e5 >= "0" && e5 <= "9" || e5 >= "A" && e5 <= "Z" || e5 >= "^" && e5 <= "~";
            }
            function u2(e5) {
              return e5 >= "1" && e5 <= "9";
            }
            function h3(e5) {
              return e5 >= "A" && e5 <= "Z" || e5 >= "a" && e5 <= "z";
            }
            function p2(e5) {
              return "d" === e5 || "h" === e5 || "m" === e5 || "s" === e5;
            }
            function _2(e5) {
              return e5 > "" && e5 < "	" || e5 > "\v" && e5 < "\f" || e5 > "" && e5 < "Ã¿";
            }
            function E2(e5) {
              return h3(e5) || a2(e5) || "+" === e5 || "/" === e5;
            }
            function m2(e5) {
              return a2(e5) || h3(e5) || "+" === e5 || "/" === e5 || "-" === e5 || "_" === e5;
            }
            function f2(e5) {
              return h3(e5) || a2(e5) || "+" === e5 || "/" === e5;
            }
            function g2(e5, t5) {
              var i4 = Object.keys(e5);
              if (Object.getOwnPropertySymbols) {
                var n3 = Object.getOwnPropertySymbols(e5);
                t5 && (n3 = n3.filter(function(t6) {
                  return Object.getOwnPropertyDescriptor(e5, t6).enumerable;
                })), i4.push.apply(i4, n3);
              }
              return i4;
            }
            function T2(e5) {
              for (var t5 = 1; t5 < arguments.length; t5++) {
                var i4 = null != arguments[t5] ? arguments[t5] : {};
                t5 % 2 ? g2(Object(i4), true).forEach(function(t6) {
                  S2(e5, t6, i4[t6]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(i4)) : g2(Object(i4)).forEach(function(t6) {
                  Object.defineProperty(e5, t6, Object.getOwnPropertyDescriptor(i4, t6));
                });
              }
              return e5;
            }
            function S2(e5, t5, i4) {
              return t5 in e5 ? Object.defineProperty(e5, t5, { value: i4, enumerable: true, configurable: true, writable: true }) : e5[t5] = i4, e5;
            }
            !function(e5) {
              e5.VERSION = "v", e5.ORIGIN = "o", e5.SESSION_NAME = "s", e5.INFORMATION = "i", e5.URI = "u", e5.EMAIL = "e", e5.PHONE = "p", e5.CONNECTION = "c", e5.BANDWIDTH = "b", e5.TIME = "t", e5.REPEAT = "r", e5.ZONE_ADJUSTMENTS = "z", e5.KEY = "k", e5.ATTRIBUTE = "a", e5.MEDIA = "m";
            }(o2 || (o2 = {}));
            class R2 {
              consumeText(e5, t5) {
                let i4 = t5;
                for (; i4 < e5.length; ) {
                  const t6 = e5[i4];
                  if ("\0" === t6 || "\r" === t6 || t6 === n2) break;
                  i4 += 1;
                }
                if (i4 - t5 == 0) throw new Error("Invalid text, at ".concat(e5));
                return i4;
              }
              consumeUnicastAddress(e5, t5, i4) {
                return this.consumeTill(e5, t5, s2);
              }
              consumeOneOrMore(e5, t5, i4) {
                let n3 = t5;
                for (; i4(e5[n3]); ) n3++;
                if (n3 - t5 == 0) throw new Error("Invalid rule at ".concat(t5, "."));
                return n3;
              }
              consumeSpace(e5, t5) {
                if (e5[t5] === s2) return t5 + 1;
                throw new Error("Invalid space at ".concat(t5, "."));
              }
              consumeIP4Address(e5, t5) {
                let i4 = t5;
                for (let t6 = 0; t6 < 4; t6++) if (i4 = this.consumeDecimalUChar(e5, i4), 3 !== t6) {
                  if ("." !== e5[i4]) throw new Error("Invalid IP4 address.");
                  i4++;
                }
                return i4;
              }
              consumeDecimalUChar(e5, t5) {
                let i4 = t5;
                for (let t6 = 0; t6 < 3 && a2(e5[i4]); t6++, i4++) ;
                if (i4 - t5 == 0) throw new Error("Invalid decimal uchar.");
                const n3 = parseInt(e5.slice(t5, i4));
                if (n3 >= 0 && n3 <= 255) return i4;
                throw new Error("Invalid decimal uchar");
              }
              consumeIP6Address(e5, t5) {
                let i4 = this.consumeHexpart(e5, t5);
                return ":" === e5[i4] ? (i4 += 1, i4 = this.consumeIP4Address(e5, i4), i4) : i4;
              }
              consumeHexpart(e5, t5) {
                let i4 = t5;
                if (":" === e5[i4] && ":" === e5[i4 + 1]) {
                  i4 += 2;
                  try {
                    i4 = this.consumeHexseq(e5, i4);
                  } catch (e6) {
                  }
                  return i4;
                }
                if (i4 = this.consumeHexseq(e5, i4), ":" === e5[i4] && ":" === e5[i4 + 1]) {
                  i4 += 2;
                  try {
                    i4 = this.consumeHexseq(e5, i4);
                  } catch (e6) {
                  }
                  return i4;
                }
                return i4;
              }
              consumeHexseq(e5, t5) {
                let i4 = t5;
                for (; i4 = this.consumeHex4(e5, i4), ":" === e5[i4] && ":" !== e5[i4 + 1]; ) i4 += 1;
                return i4;
              }
              consumeHex4(e5, t5) {
                let i4 = 0;
                for (; i4 < 4; i4++) if (!((n3 = e5[t5 + i4]) >= "0" && n3 <= "9" || n3 >= "a" && n3 <= "f" || n3 >= "A" && n3 <= "F")) {
                  if (0 === i4) throw new Error("Invalid hex 4");
                  break;
                }
                var n3;
                return t5 + i4;
              }
              consumeFQDN(e5, t5) {
                let i4 = t5;
                for (; a2(e5[i4]) || h3(e5[i4]) || "-" === e5[i4] || "." === e5[i4]; ) i4 += 1;
                if (i4 - t5 < 4) throw new Error("Invalid FQDN");
                return i4;
              }
              consumeExtnAddr(e5, t5) {
                return this.consumeOneOrMore(e5, t5, d2);
              }
              consumeMulticastAddress(e5, t5, i4) {
                switch (i4) {
                  case "IP4":
                  case "ip4":
                    return this.consumeIP4MulticastAddress(e5, t5);
                  case "IP6":
                  case "ip6":
                    return this.consumeIP6MulticastAddress(e5, t5);
                  default:
                    try {
                      return this.consumeFQDN(e5, t5);
                    } catch (i5) {
                      return this.consumeExtnAddr(e5, t5);
                    }
                }
              }
              consumeIP6MulticastAddress(e5, t5) {
                const i4 = this.consumeHexpart(e5, t5);
                return "/" === e5[i4] ? this.consumeInteger(e5, i4 + 1) : i4;
              }
              consumeIP4MulticastAddress(e5, t5) {
                let i4 = t5 + 3;
                const n3 = e5.slice(t5, i4), r3 = parseInt(n3);
                if (r3 < 224 || r3 > 239) throw new Error("Invalid IP4 multicast address, IPv4 multicast addresses may be in the range 224.0.0.0 to 239.255.255.255.");
                for (let t6 = 0; t6 < 3; t6++) {
                  if ("." !== e5[i4]) throw new Error("Invalid IP4 multicast address.");
                  i4 += 1, i4 = this.consumeDecimalUChar(e5, i4);
                }
                return "/" === e5[i4] && (i4 += 1), i4 = this.consumeTTL(e5, i4), "/" === e5[i4] && (i4 = this.consumeInteger(e5, i4)), i4;
              }
              consumeInteger(e5, t5) {
                if (!u2(e5[t5])) throw new Error("Invalid integer.");
                for (t5 += 1; a2(e5[t5]); ) t5 += 1;
                return t5;
              }
              consumeTTL(e5, t5) {
                if ("0" === e5[t5]) return t5 + 1;
                if (!u2(e5[t5])) throw new Error("Invalid TTL.");
                t5 += 1;
                for (let i4 = 0; i4 < 2 && a2(e5[t5]); i4++) t5 += 1;
                return t5;
              }
              consumeToken(e5, t5) {
                return this.consumeOneOrMore(e5, t5, l2);
              }
              consumeTime(e5, t5) {
                let i4 = t5;
                if ("0" === e5[i4]) return i4 + 1;
                for (u2(e5[i4]) && (i4 += 1); a2(e5[i4]); ) i4++;
                if (i4 - t5 < 10) throw new Error("Invalid time");
                return i4;
              }
              consumeAddress(e5, t5) {
                return this.consumeTill(e5, t5, s2);
              }
              consumeTypedTime(e5, t5) {
                let i4 = t5;
                return i4 = this.consumeOneOrMore(e5, i4, a2), p2(e5[i4]) ? i4 + 1 : i4;
              }
              consumeRepeatInterval(e5, t5) {
                if (!u2(e5[t5])) throw new Error("Invalid repeat interval");
                for (t5 += 1; a2(e5[t5]); ) t5 += 1;
                return p2(e5[t5]) && (t5 += 1), t5;
              }
              consumePort(e5, t5) {
                return this.consumeOneOrMore(e5, t5, a2);
              }
              consume(e5, t5, i4) {
                for (let n3 = 0; n3 < i4.length; n3++) {
                  if (t5 + n3 >= e5.length) throw new Error("consume exceeding value length");
                  if (e5[t5 + n3] !== i4[n3]) throw new Error("consume ".concat(i4, " failed at ").concat(n3));
                }
                return t5 + i4.length;
              }
              consumeTill(e5, t5, i4) {
                let n3 = t5;
                for (; n3 < e5.length && ("string" != typeof i4 || e5[n3] !== i4) && ("function" != typeof i4 || !i4(e5[n3])); ) n3++;
                return n3;
              }
            }
            class C2 extends R2 {
              constructor() {
                super(), S2(this, "records", []), S2(this, "currentLine", 0);
              }
              parse(e5) {
                const t5 = this.probeEOL(e5);
                this.records = e5.split(t5).filter((e6) => !!e6.trim()).map(this.parseLine), this.currentLine = 0;
                const i4 = this.parseVersion(), n3 = this.parseOrigin(), r3 = this.parseSessionName(), s3 = this.parseInformation(), o3 = this.parseUri(), a3 = this.parseEmail(), c3 = this.parsePhone(), d3 = this.parseConnection(), l3 = this.parseBandWidth(), u3 = this.parseTimeFields(), h4 = this.parseKey(), p3 = this.parseSessionAttribute(), _3 = this.parseMediaDescription();
                if (this.currentLine !== this.records.length) throw new Error("parsing failed, non exhaustive sdp lines.");
                return { version: i4, origin: n3, sessionName: r3, information: s3, uri: o3, emails: a3, phones: c3, connection: d3, bandwidths: l3, timeFields: u3, key: h4, attributes: p3, mediaDescriptions: _3 };
              }
              getCurrentRecord() {
                const e5 = this.records[this.currentLine];
                if (!e5) throw new Error("Record doesn't exit.");
                return e5;
              }
              probeEOL(e5) {
                for (let t5 = 0; t5 < e5.length; t5++) if (e5[t5] === n2) return "\r" === e5[t5 - 1] ? r2 : n2;
                throw new Error("Invalid newline character.");
              }
              parseLine(e5, t5) {
                if (e5.length < 2) throw new Error("Invalid sdp line, sdp line should be of form <type>=<value>.");
                const i4 = e5[0];
                if ("=" !== e5[1]) throw new Error('Invalid sdp line, <type> should be a single character followed by an "=" sign.');
                return { type: i4, value: e5.slice(2), line: t5, cur: 0 };
              }
              parseSessionAttribute() {
                const e5 = new v2();
                for (; this.currentLine < this.records.length; ) {
                  const t5 = this.getCurrentRecord();
                  if (t5.type !== o2.ATTRIBUTE) break;
                  const i4 = { attField: this.extractOneOrMore(t5, (e6) => l2(e6) && ":" !== e6), _cur: 0 };
                  ":" === t5.value[t5.cur] && (t5.cur += 1, i4.attValue = this.extractOneOrMore(t5, _2)), e5.parse(i4), this.currentLine++;
                }
                return e5.digest();
              }
              parseMediaAttributes(e5) {
                const t5 = new y2(e5);
                for (; this.currentLine < this.records.length; ) {
                  const e6 = this.getCurrentRecord();
                  if (e6.type !== o2.ATTRIBUTE) break;
                  const i4 = { attField: this.extractOneOrMore(e6, (e7) => l2(e7) && ":" !== e7), _cur: 0 };
                  ":" === e6.value[e6.cur] && (e6.cur += 1, i4.attValue = this.extractOneOrMore(e6, _2)), t5.parse(i4), this.currentLine++;
                }
                return t5.digest();
              }
              parseKey() {
                const e5 = this.getCurrentRecord();
                if (e5.type === o2.KEY) {
                  if ("prompt" === e5.value || "clear:" === e5.value || "base64:" === e5.value || "uri:" === e5.value) return e5.value;
                  throw this.currentLine++, new Error("Invalid key.");
                }
              }
              parseZone() {
                const e5 = this.getCurrentRecord();
                if (e5.type === o2.ZONE_ADJUSTMENTS) {
                  const t5 = [];
                  for (; ; ) try {
                    const i4 = this.extract(e5, this.consumeTime);
                    this.consumeSpaceForRecord(e5);
                    let n3 = false;
                    "-" === e5.value[e5.cur] && (n3 = true, e5.cur += 1);
                    const r3 = this.extract(e5, this.consumeTypedTime);
                    t5.push({ time: i4, typedTime: r3, back: n3 });
                  } catch (e6) {
                    break;
                  }
                  if (0 === t5.length) throw new Error("Invalid zone adjustments");
                  return this.currentLine++, t5;
                }
                return [];
              }
              parseRepeat() {
                const e5 = [];
                for (; ; ) {
                  const t5 = this.getCurrentRecord();
                  if (t5.type !== o2.REPEAT) break;
                  {
                    const i4 = this.extract(t5, this.consumeRepeatInterval), n3 = this.parseTypedTime(t5);
                    e5.push({ repeatInterval: i4, typedTimes: n3 }), this.currentLine++;
                  }
                }
                return e5;
              }
              parseTypedTime(e5) {
                const t5 = [];
                for (; ; ) try {
                  this.consumeSpaceForRecord(e5), t5.push(this.extract(e5, this.consumeTypedTime));
                } catch (e6) {
                  break;
                }
                if (0 === t5.length) throw new Error("Invalid typed time.");
                return t5;
              }
              parseTime() {
                const e5 = this.getCurrentRecord(), t5 = this.extract(e5, this.consumeTime);
                this.consumeSpaceForRecord(e5);
                const i4 = this.extract(e5, this.consumeTime);
                return this.currentLine++, { startTime: t5, stopTime: i4 };
              }
              parseBandWidth() {
                const e5 = [];
                for (; this.currentLine < this.records.length; ) {
                  const t5 = this.getCurrentRecord();
                  if (t5.type !== o2.BANDWIDTH) break;
                  {
                    const i4 = this.extractOneOrMore(t5, l2);
                    if (":" !== t5.value[t5.cur]) throw new Error("Invalid bandwidth field.");
                    t5.cur++;
                    const n3 = this.extractOneOrMore(t5, a2);
                    e5.push({ bwtype: i4, bandwidth: n3 }), this.currentLine++;
                  }
                }
                return e5;
              }
              parseVersion() {
                const e5 = this.getCurrentRecord();
                if (e5.type !== o2.VERSION) throw new Error("first sdp record must be version");
                const t5 = e5.value.slice(0, this.consumeOneOrMore(e5.value, 0, a2));
                if (t5.length !== e5.value.length) throw new Error('invalid proto version, "v='.concat(e5.value, '"'));
                return this.currentLine++, t5;
              }
              parseOrigin() {
                const e5 = this.getCurrentRecord();
                if (e5.type !== o2.ORIGIN) throw new Error("second line of sdp must be origin");
                const t5 = this.extractOneOrMore(e5, d2);
                this.consumeSpaceForRecord(e5);
                const i4 = this.extractOneOrMore(e5, a2);
                this.consumeSpaceForRecord(e5);
                const n3 = this.extractOneOrMore(e5, a2);
                this.consumeSpaceForRecord(e5);
                const r3 = this.extractOneOrMore(e5, l2);
                this.consumeSpaceForRecord(e5);
                const s3 = this.extractOneOrMore(e5, l2);
                this.consumeSpaceForRecord(e5);
                const c3 = this.extract(e5, this.consumeUnicastAddress);
                return this.currentLine++, { username: t5, sessId: i4, sessVersion: n3, nettype: r3, addrtype: s3, unicastAddress: c3 };
              }
              parseSessionName() {
                const e5 = this.getCurrentRecord();
                if (e5.type === o2.SESSION_NAME) {
                  const t5 = this.extract(e5, this.consumeText);
                  return this.currentLine++, t5;
                }
              }
              parseInformation() {
                const e5 = this.getCurrentRecord();
                if (e5.type !== o2.INFORMATION) return;
                const t5 = this.extract(e5, this.consumeText);
                return this.currentLine++, t5;
              }
              parseUri() {
                const e5 = this.getCurrentRecord();
                if (e5.type === o2.URI) return this.currentLine++, e5.value;
              }
              parseEmail() {
                const e5 = [];
                for (; ; ) {
                  const t5 = this.getCurrentRecord();
                  if (t5.type !== o2.EMAIL) break;
                  e5.push(t5.value), this.currentLine++;
                }
                return e5;
              }
              parsePhone() {
                const e5 = [];
                for (; ; ) {
                  const t5 = this.getCurrentRecord();
                  if (t5.type !== o2.PHONE) break;
                  e5.push(t5.value), this.currentLine++;
                }
                return e5;
              }
              parseConnection() {
                const e5 = this.getCurrentRecord();
                if (e5.type === o2.CONNECTION) {
                  const t5 = this.extractOneOrMore(e5, l2);
                  this.consumeSpaceForRecord(e5);
                  const i4 = this.extractOneOrMore(e5, l2);
                  this.consumeSpaceForRecord(e5);
                  const n3 = this.extract(e5, this.consumeAddress);
                  return this.currentLine++, { nettype: t5, addrtype: i4, address: n3 };
                }
              }
              parseMedia() {
                const e5 = this.getCurrentRecord(), t5 = this.extract(e5, this.consumeToken);
                this.consumeSpaceForRecord(e5);
                let i4 = this.extract(e5, this.consumePort);
                "/" === e5.value[e5.cur] && (e5.cur += 1, i4 += this.extract(e5, this.consumeInteger)), this.consumeSpaceForRecord(e5);
                const n3 = [];
                for (n3.push(this.extract(e5, this.consumeToken)); "/" === e5.value[e5.cur]; ) e5.cur += 1, n3.push(this.extract(e5, this.consumeToken));
                if (0 === n3.length) throw new Error("Invalid proto");
                const r3 = this.parseFmt(e5);
                return this.currentLine++, { mediaType: t5, port: i4, protos: n3, fmts: r3 };
              }
              parseTimeFields() {
                const e5 = [];
                for (; this.getCurrentRecord().type === o2.TIME; ) {
                  const t5 = this.parseTime(), i4 = this.parseRepeat(), n3 = this.parseZone();
                  e5.push({ time: t5, repeats: i4, zones: n3 });
                }
                return e5;
              }
              parseMediaDescription() {
                const e5 = [];
                for (; this.currentLine < this.records.length && this.getCurrentRecord().type === o2.MEDIA; ) {
                  const t5 = this.parseMedia(), i4 = this.parseInformation(), n3 = this.parseConnections(), r3 = this.parseBandWidth(), s3 = this.parseKey(), o3 = this.parseMediaAttributes(t5);
                  e5.push({ media: t5, information: i4, connections: n3, bandwidths: r3, key: s3, attributes: o3 });
                }
                return e5;
              }
              parseConnections() {
                const e5 = [];
                for (; this.currentLine < this.records.length && this.getCurrentRecord().type === o2.CONNECTION; ) e5.push(this.parseConnection());
                return e5;
              }
              parseFmt(e5) {
                const t5 = [];
                for (; ; ) try {
                  this.consumeSpaceForRecord(e5), t5.push(this.extract(e5, this.consumeToken));
                } catch (e6) {
                  break;
                }
                if (0 === t5.length) throw new Error("Invalid fmts");
                return t5;
              }
              extract(e5, t5, ...i4) {
                const n3 = t5.call(this, e5.value, e5.cur, ...i4), r3 = e5.value.slice(e5.cur, n3);
                return e5.cur = n3, r3;
              }
              extractOneOrMore(e5, t5) {
                const i4 = this.consumeOneOrMore(e5.value, e5.cur, t5), n3 = e5.value.slice(e5.cur, i4);
                return e5.cur = i4, n3;
              }
              consumeSpaceForRecord(e5) {
                if (e5.value[e5.cur] !== s2) throw new Error("Invalid space at ".concat(e5.cur, "."));
                e5.cur += 1;
              }
            }
            class I2 extends R2 {
              constructor(...e5) {
                super(...e5), S2(this, "attributes", void 0), S2(this, "digested", false);
              }
              extractOneOrMore(e5, t5, i4) {
                const n3 = this.consumeOneOrMore(e5.attValue, e5._cur, t5), r3 = e5.attValue.slice(e5._cur, n3), [s3, o3] = i4 || [];
                if ("number" == typeof s3 && r3.length < s3) throw new Error("error in length, should be more or equal than ".concat(s3, " characters."));
                if ("number" == typeof o3 && r3.length > o3) throw new Error("error in length, should be less or equal than ".concat(o3, " characters."));
                return e5._cur = n3, r3;
              }
              consumeAttributeSpace(e5) {
                if (e5.attValue[e5._cur] !== s2) throw new Error("Invalid space at ".concat(e5._cur, "."));
                e5._cur += 1;
              }
              extract(e5, t5, ...i4) {
                if (!e5.attValue) throw new Error("Nothing to extract from attValue.");
                const n3 = t5.call(this, e5.attValue, e5._cur, ...i4), r3 = e5.attValue.slice(e5._cur, n3);
                return e5._cur = n3, r3;
              }
              atEnd(e5) {
                if (!e5.attValue) throw new Error();
                return e5._cur >= e5.attValue.length;
              }
              peekChar(e5) {
                if (!e5.attValue) throw new Error();
                return e5.attValue[e5._cur];
              }
              peek(e5, t5) {
                if (!e5.attValue) throw new Error();
                for (let i4 = 0; i4 < t5.length; i4++) if (t5[i4] !== e5.attValue[e5._cur + i4]) return false;
                return true;
              }
              parseIceUfrag(e5) {
                if (this.attributes.iceUfrag) throw new Error("Invalid ice-ufrag, should be only a single line if 'a=ice-ufrag'");
                this.attributes.iceUfrag = this.extractOneOrMore(e5, E2, [4, 256]);
              }
              parseIcePwd(e5) {
                if (this.attributes.icePwd) throw new Error("Invalid ice-pwd, should be only a single line if 'a=ice-pwd'");
                this.attributes.icePwd = this.extractOneOrMore(e5, E2, [22, 256]);
              }
              parseIceOptions(e5) {
                if (this.attributes.iceOptions) throw new Error("Invalid ice-options, should be only one 'ice-options' line");
                const t5 = [];
                for (; !this.atEnd(e5); ) {
                  t5.push(this.extractOneOrMore(e5, E2));
                  try {
                    this.consumeAttributeSpace(e5);
                  } catch (t6) {
                    if (this.atEnd(e5)) break;
                    throw t6;
                  }
                }
                this.attributes.iceOptions = t5;
              }
              parseFingerprint(e5) {
                const t5 = this.extract(e5, this.consumeToken);
                this.consumeAttributeSpace(e5);
                const i4 = this.extract(e5, this.consumeTill);
                this.attributes.fingerprints.push({ hashFunction: t5, fingerprint: i4 });
              }
              parseExtmap(e5) {
                const t5 = this.extractOneOrMore(e5, a2);
                let i4;
                "/" === this.peekChar(e5) && (this.extract(e5, this.consume, "/"), i4 = this.extract(e5, this.consumeToken)), this.consumeAttributeSpace(e5);
                const n3 = this.extract(e5, this.consumeTill, s2), r3 = T2(T2({ entry: parseInt(t5, 10) }, i4 && { direction: i4 }), {}, { extensionName: n3 });
                this.peekChar(e5) === s2 && (this.consumeAttributeSpace(e5), r3.extensionAttributes = this.extract(e5, this.consumeTill)), this.attributes.extmaps.push(r3);
              }
              parseSetup(e5) {
                if (this.attributes.setup) throw new Error("must only be one single 'a=setup' line.");
                const t5 = this.extract(e5, this.consumeTill);
                if ("active" !== t5 && "passive" !== t5 && "actpass" !== t5 && "holdconn" !== t5) throw new Error("role must be one of 'active', 'passive', 'actpass', 'holdconn'.");
                this.attributes.setup = t5;
              }
            }
            class v2 extends I2 {
              constructor(...e5) {
                super(...e5), S2(this, "attributes", { unrecognized: [], groups: [], extmaps: [], fingerprints: [], identities: [] });
              }
              parse(e5) {
                if (this.digested) throw new Error("already digested");
                try {
                  switch (e5.attField) {
                    case "group":
                      this.parseGroup(e5);
                      break;
                    case "ice-lite":
                      this.parseIceLite();
                      break;
                    case "ice-ufrag":
                      this.parseIceUfrag(e5);
                      break;
                    case "ice-pwd":
                      this.parseIcePwd(e5);
                      break;
                    case "ice-options":
                      this.parseIceOptions(e5);
                      break;
                    case "fingerprint":
                      this.parseFingerprint(e5);
                      break;
                    case "setup":
                      this.parseSetup(e5);
                      break;
                    case "tls-id":
                      this.parseTlsId(e5);
                      break;
                    case "identity":
                      this.parseIdentity(e5);
                      break;
                    case "extmap":
                      this.parseExtmap(e5);
                      break;
                    case "msid-semantic":
                      this.parseMsidSemantic(e5);
                      break;
                    default:
                      e5.ignored = true, this.attributes.unrecognized.push(e5);
                  }
                } catch (t5) {
                  throw console.error("parsing session attribute ".concat(e5.attField, ' error, "a=').concat(e5.attField, ":").concat(e5.attValue, '"')), t5;
                }
                if (!e5.ignored && e5.attValue && !this.atEnd(e5)) throw new Error("attribute parsing error");
              }
              digest() {
                return this.digested = true, this.attributes;
              }
              parseGroup(e5) {
                const t5 = this.extract(e5, this.consumeToken), i4 = [];
                for (; !this.atEnd(e5) && this.peekChar(e5) === s2; ) this.consumeAttributeSpace(e5), i4.push(this.extract(e5, this.consumeToken));
                this.attributes.groups.push({ semantic: t5, identificationTag: i4 });
              }
              parseIceLite() {
                if (this.attributes.iceLite) throw new Error("Invalid ice-lite, should be only a single line of 'a=ice-lite'");
                this.attributes.iceLite = true;
              }
              parseTlsId(e5) {
                if (this.attributes.tlsId) throw new Error("must be only one tld-id line");
                this.attributes.tlsId = this.extractOneOrMore(e5, m2);
              }
              parseIdentity(e5) {
                const t5 = this.extractOneOrMore(e5, f2), i4 = [];
                for (; !this.atEnd(e5) && this.peekChar(e5) === s2; ) {
                  this.consumeAttributeSpace(e5);
                  const t6 = this.extract(e5, this.consumeToken);
                  this.extract(e5, this.consume, "=");
                  const n3 = this.extractOneOrMore(e5, (e6) => e6 !== s2 && _2(e6));
                  i4.push({ name: t6, value: n3 });
                }
                this.attributes.identities.push({ assertionValue: t5, extensions: i4 });
              }
              parseMsidSemantic(e5) {
                this.peekChar(e5) === s2 && this.consumeAttributeSpace(e5);
                const t5 = { semantic: this.extract(e5, this.consumeToken), identifierList: [] };
                for (; ; ) {
                  try {
                    this.consumeAttributeSpace(e5);
                  } catch (e6) {
                    break;
                  }
                  if ("*" === this.peekChar(e5)) {
                    this.extract(e5, this.consume, "*"), t5.applyForAll = true;
                    break;
                  }
                  {
                    const i4 = this.extract(e5, this.consumeTill, s2);
                    t5.identifierList.push(i4);
                  }
                }
                this.attributes.msidSemantic = t5;
              }
            }
            class y2 extends I2 {
              constructor(e5) {
                super(), S2(this, "attributes", void 0), -1 !== e5.protos.indexOf("RTP") || e5.protos.indexOf("rtp"), this.attributes = { unrecognized: [], candidates: [], extmaps: [], fingerprints: [], imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: [], ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: [] };
              }
              parse(e5) {
                if (this.digested) throw new Error("already digested");
                try {
                  switch (e5.attField) {
                    case "extmap":
                      this.parseExtmap(e5);
                      break;
                    case "setup":
                      this.parseSetup(e5);
                      break;
                    case "ice-ufrag":
                      this.parseIceUfrag(e5);
                      break;
                    case "ice-pwd":
                      this.parseIcePwd(e5);
                      break;
                    case "ice-options":
                      this.parseIceOptions(e5);
                      break;
                    case "candidate":
                      this.parseCandidate(e5);
                      break;
                    case "remote-candidate":
                      this.parseRemoteCandidate(e5);
                      break;
                    case "end-of-candidates":
                      this.parseEndOfCandidates();
                      break;
                    case "fingerprint":
                      this.parseFingerprint(e5);
                      break;
                    case "rtpmap":
                      this.parseRtpmap(e5);
                      break;
                    case "ptime":
                      this.parsePtime(e5);
                      break;
                    case "maxptime":
                      this.parseMaxPtime(e5);
                      break;
                    case "sendrecv":
                    case "recvonly":
                    case "sendonly":
                    case "inactive":
                      this.parseDirection(e5);
                      break;
                    case "ssrc":
                      this.parseSSRC(e5);
                      break;
                    case "fmtp":
                      this.parseFmtp(e5);
                      break;
                    case "rtcp-fb":
                      this.parseRtcpFb(e5);
                      break;
                    case "rtcp-mux":
                      this.parseRTCPMux();
                      break;
                    case "rtcp-mux-only":
                      this.parseRTCPMuxOnly();
                      break;
                    case "rtcp-rsize":
                      this.parseRTCPRsize();
                      break;
                    case "rtcp":
                      this.parseRTCP(e5);
                      break;
                    case "mid":
                      this.parseMid(e5);
                      break;
                    case "msid":
                      this.parseMsid(e5);
                      break;
                    case "imageattr":
                      this.parseImageAttr(e5);
                      break;
                    case "rid":
                      this.parseRid(e5);
                      break;
                    case "simulcast":
                      this.parseSimulcast(e5);
                      break;
                    case "sctp-port":
                      this.parseSctpPort(e5);
                      break;
                    case "max-message-size":
                      this.parseMaxMessageSize(e5);
                      break;
                    case "ssrc-group":
                      this.parseSSRCGroup(e5);
                      break;
                    default:
                      e5.ignored = true, this.attributes.unrecognized.push(e5);
                  }
                } catch (t5) {
                  throw console.error("parsing media attribute ".concat(e5.attField, ' error, "a=').concat(e5.attField, ":").concat(e5.attValue, '"')), t5;
                }
                if (!e5.ignored && e5.attValue && !this.atEnd(e5)) throw new Error("attribute parsing error");
              }
              parseCandidate(e5) {
                const t5 = this.extractOneOrMore(e5, E2, [1, 32]);
                this.consumeAttributeSpace(e5);
                const i4 = this.extractOneOrMore(e5, a2, [1, 5]);
                this.consumeAttributeSpace(e5);
                const n3 = this.extract(e5, this.consumeToken);
                this.consumeAttributeSpace(e5);
                const r3 = this.extractOneOrMore(e5, a2, [1, 10]);
                this.consumeAttributeSpace(e5);
                const o3 = this.extract(e5, this.consumeAddress);
                this.consumeAttributeSpace(e5);
                const d3 = this.extract(e5, this.consumePort);
                this.consumeAttributeSpace(e5), this.extract(e5, this.consume, "typ"), this.consumeAttributeSpace(e5);
                const l3 = { foundation: t5, componentId: i4, transport: n3, priority: r3, connectionAddress: o3, port: d3, type: this.extract(e5, this.consumeToken), extension: {} };
                for (this.peek(e5, " raddr") && (this.extract(e5, this.consume, " raddr"), this.consumeAttributeSpace(e5), l3.relAddr = this.extract(e5, this.consumeAddress)), this.peek(e5, " rport") && (this.extract(e5, this.consume, " rport"), this.consumeAttributeSpace(e5), l3.relPort = this.extract(e5, this.consumePort)); this.peekChar(e5) === s2; ) {
                  this.consumeAttributeSpace(e5);
                  const t6 = this.extract(e5, this.consumeToken);
                  this.consumeAttributeSpace(e5), l3.extension[t6] = this.extractOneOrMore(e5, c2);
                }
                this.attributes.candidates.push(l3);
              }
              parseRemoteCandidate(e5) {
                const t5 = [];
                for (; ; ) {
                  const i4 = this.extractOneOrMore(e5, a2, [1, 5]);
                  this.consumeAttributeSpace(e5);
                  const n3 = this.extract(e5, this.consumeAddress);
                  this.consumeAttributeSpace(e5);
                  const r3 = this.extract(e5, this.consumePort);
                  t5.push({ componentId: i4, connectionAddress: n3, port: r3 });
                  try {
                    this.consumeAttributeSpace(e5);
                  } catch (e6) {
                    break;
                  }
                }
                this.attributes.remoteCandidatesList.push(t5);
              }
              parseEndOfCandidates() {
                if (this.attributes.endOfCandidates) throw new Error("must be only one line of end-of-candidates");
                this.attributes.endOfCandidates = true;
              }
              parseRtpmap(e5) {
                const t5 = this.extract(e5, this.consumeToken);
                this.consumeAttributeSpace(e5);
                const i4 = this.extract(e5, this.consumeTill, "/");
                this.extract(e5, this.consume, "/");
                const n3 = { encodingName: i4, clockRate: this.extractOneOrMore(e5, a2) };
                this.atEnd(e5) || "/" !== this.peekChar(e5) || (this.extract(e5, this.consume, "/"), n3.encodingParameters = parseInt(this.extract(e5, this.consumeTill), 10));
                const r3 = this.attributes.payloads.find((e6) => e6.payloadType === parseInt(t5, 10));
                r3 ? r3.rtpMap = n3 : this.attributes.payloads.push({ payloadType: parseInt(t5, 10), rtpMap: n3, rtcpFeedbacks: [] });
              }
              parsePtime(e5) {
                if (this.attributes.ptime) throw new Error("must be only one line of ptime");
                this.attributes.ptime = this.extract(e5, this.consumeTill);
              }
              parseMaxPtime(e5) {
                if (this.attributes.maxPtime) throw new Error("must be only one line of ptime");
                this.attributes.maxPtime = this.extract(e5, this.consumeTill);
              }
              parseDirection(e5) {
                if (this.attributes.direction) throw new Error("must be only one line of direction info");
                this.attributes.direction = e5.attField;
              }
              parseSSRC(e5) {
                const t5 = this.extractOneOrMore(e5, a2);
                this.consumeAttributeSpace(e5);
                const i4 = this.extract(e5, this.consumeTill, ":");
                let n3;
                ":" === this.peekChar(e5) && (this.extract(e5, this.consume, ":"), n3 = this.extract(e5, this.consumeTill));
                const r3 = this.attributes.ssrcs.find((e6) => e6.ssrcId === parseInt(t5, 10));
                r3 ? r3.attributes[i4] = n3 : this.attributes.ssrcs.push({ ssrcId: parseInt(t5, 10), attributes: { [i4]: n3 } });
              }
              parseFmtp(e5) {
                const t5 = this.extract(e5, this.consumeTill, s2);
                this.consumeAttributeSpace(e5);
                const i4 = this.extract(e5, this.consumeTill), n3 = {};
                i4.split(";").forEach((e6) => {
                  let [t6, i5] = e6.split("=");
                  t6 = t6.trim();
                  const r4 = "string" == typeof i5 ? i5.trim() : null;
                  "string" == typeof t6 && t6.length > 0 && (n3[t6] = r4);
                });
                const r3 = this.attributes.payloads.find((e6) => e6.payloadType === parseInt(t5, 10));
                r3 ? r3.fmtp = { parameters: n3 } : this.attributes.payloads.push({ payloadType: parseInt(t5, 10), rtcpFeedbacks: [], fmtp: { parameters: n3 } });
              }
              parseFmtParameters(e5) {
                const t5 = {}, i4 = this.extract(e5, this.consumeTill, "=");
                e5._cur++;
                const n3 = this.extract(e5, this.consumeTill, ";");
                for (t5[i4] = n3; ";" === e5.attValue[e5._cur]; ) {
                  const i5 = this.extract(e5, this.consumeTill, "=");
                  e5._cur++;
                  const n4 = this.extract(e5, this.consumeTill, ";");
                  t5[i5] = n4;
                }
                return t5;
              }
              parseRtcpFb(e5) {
                let t5 = "";
                t5 = "*" === this.peekChar(e5) ? this.extract(e5, this.consume, "*") : this.extract(e5, this.consumeTill, s2), this.consumeAttributeSpace(e5);
                const i4 = this.extract(e5, this.consumeTill, s2);
                let n3;
                if ("trr-int" === i4) n3 = { type: i4, interval: this.extract(e5, this.consumeTill) };
                else {
                  const t6 = { type: i4 };
                  this.peekChar(e5) === s2 && (this.consumeAttributeSpace(e5), t6.parameter = this.extract(e5, this.consumeToken), this.peekChar(e5) === s2 && (t6.additional = this.extract(e5, this.consumeTill))), n3 = t6;
                }
                if ("*" === t5) this.attributes.rtcpFeedbackWildcards.push(n3);
                else {
                  const e6 = this.attributes.payloads.find((e7) => e7.payloadType === parseInt(t5, 10));
                  e6 ? e6.rtcpFeedbacks.push(n3) : this.attributes.payloads.push({ payloadType: parseInt(t5, 10), rtcpFeedbacks: [n3] });
                }
              }
              parseRTCPMux() {
                if (this.attributes.rtcpMux) throw new Error("must be single line of rtcp-mux");
                this.attributes.rtcpMux = true;
              }
              parseRTCPMuxOnly() {
                if (this.attributes.rtcpMuxOnly) throw new Error("must be single line of rtcp-only");
                this.attributes.rtcpMuxOnly = true;
              }
              parseRTCPRsize() {
                if (this.attributes.rtcpRsize) throw new Error("must be single line of rtcp-rsize");
                this.attributes.rtcpRsize = true;
              }
              parseRTCP(e5) {
                if (this.attributes.rtcp) throw new Error("must be single line of rtcp");
                const t5 = { port: this.extract(e5, this.consumePort) };
                this.peekChar(e5) === s2 && (this.consumeAttributeSpace(e5), t5.netType = this.extractOneOrMore(e5, l2), this.consumeAttributeSpace(e5), t5.addressType = this.extractOneOrMore(e5, l2), this.consumeAttributeSpace(e5), t5.address = this.extract(e5, this.consumeAddress)), this.attributes.rtcp = t5;
              }
              parseMsid(e5) {
                const t5 = { id: this.extractOneOrMore(e5, l2, [1, 64]) };
                this.peekChar(e5) === s2 && (this.consumeAttributeSpace(e5), t5.appdata = this.extractOneOrMore(e5, l2, [1, 64])), this.attributes.msids.push(t5);
              }
              parseImageAttr(e5) {
                this.attributes.imageattr.push(e5.attValue);
              }
              parseRid(e5) {
                const t5 = this.extractOneOrMore(e5, (e6) => h3(e6) || a2(e6) || "_" === e6 || "-" === e6);
                this.consumeAttributeSpace(e5);
                const i4 = { id: t5, direction: this.extract(e5, this.consumeToken), params: [] };
                if (this.peekChar(e5) === s2) {
                  if (this.consumeAttributeSpace(e5), this.peek(e5, "pt=")) {
                    this.extract(e5, this.consume, "pt=");
                    const t6 = [];
                    for (; ; ) {
                      const i5 = this.extract(e5, this.consumeToken);
                      t6.push(i5);
                      try {
                        this.extract(e5, this.consume, ",");
                      } catch (e6) {
                        break;
                      }
                    }
                    i4.payloads = t6, this.peekChar(e5) === s2 && this.extract(e5, this.consume, s2);
                  }
                  for (; ; ) {
                    const t6 = this.extract(e5, this.consumeToken);
                    switch (t6) {
                      case "depend": {
                        const n3 = { type: t6, rids: this.extract(e5, this.consume, "=").split(",") };
                        i4.params.push(n3);
                        break;
                      }
                      default: {
                        const n3 = { type: t6 };
                        "=" === this.peekChar(e5) && (this.extract(e5, this.consume, "="), n3.val = this.extract(e5, this.consumeTill, ";")), i4.params.push(n3);
                      }
                    }
                    try {
                      this.extract(e5, this.consume, ";");
                    } catch (e6) {
                      break;
                    }
                  }
                }
                this.attributes.rids.push(i4);
              }
              parseSimulcast(e5) {
                if (this.attributes.simulcast) throw new Error("must be single line of simulcast");
                this.attributes.simulcast = e5.attValue, this.extract(e5, this.consumeTill);
              }
              parseSctpPort(e5) {
                this.attributes.sctpPort = this.extractOneOrMore(e5, a2, [1, 5]);
              }
              parseMaxMessageSize(e5) {
                this.attributes.maxMessageSize = this.extractOneOrMore(e5, a2, [1, void 0]);
              }
              digest() {
                return this.digested = true, this.attributes;
              }
              parseMid(e5) {
                this.attributes.mid = this.extract(e5, this.consumeToken);
              }
              parseSSRCGroup(e5) {
                const t5 = this.extract(e5, this.consumeToken), i4 = [];
                for (; ; ) try {
                  this.consumeAttributeSpace(e5);
                  const t6 = this.extract(e5, this.consumeInteger);
                  i4.push(parseInt(t6, 10));
                } catch (e6) {
                  break;
                }
                this.attributes.ssrcGroups.push({ semantic: t5, ssrcIds: i4 });
              }
            }
            function A2(e5, t5, i4) {
              return t5 in e5 ? Object.defineProperty(e5, t5, { value: i4, enumerable: true, configurable: true, writable: true }) : e5[t5] = i4, e5;
            }
            class b2 {
              constructor() {
                A2(this, "eol", r2);
              }
              print(e5, t5) {
                let i4 = "";
                return t5 && (this.eol = t5), i4 += this.printVersion(e5.version), i4 += this.printOrigin(e5.origin), i4 += this.printSessionName(e5.sessionName), i4 += this.printInformation(e5.information), i4 += this.printUri(e5.uri), i4 += this.printEmail(e5.emails), i4 += this.printPhone(e5.phones), i4 += this.printConnection(e5.connection), i4 += this.printBandwidth(e5.bandwidths), i4 += this.printTimeFields(e5.timeFields), i4 += this.printKey(e5.key), i4 += this.printSessionAttributes(e5.attributes), i4 += this.printMediaDescription(e5.mediaDescriptions), i4;
              }
              printVersion(e5) {
                return "v=".concat(e5).concat(this.eol);
              }
              printOrigin(e5) {
                return "o=".concat(e5.username, " ").concat(e5.sessId, " ").concat(e5.sessVersion, " ").concat(e5.nettype, " ").concat(e5.addrtype, " ").concat(e5.unicastAddress).concat(this.eol);
              }
              printSessionName(e5) {
                return e5 ? "s=".concat(e5).concat(this.eol) : "";
              }
              printInformation(e5) {
                return e5 ? "i=".concat(e5).concat(this.eol) : "";
              }
              printUri(e5) {
                return e5 ? "u=".concat(e5).concat(this.eol) : "";
              }
              printEmail(e5) {
                let t5 = "";
                for (const i4 of e5) t5 += "e=".concat(i4).concat(this.eol);
                return t5;
              }
              printPhone(e5) {
                let t5 = "";
                for (const i4 of e5) t5 += "e=".concat(i4).concat(this.eol);
                return t5;
              }
              printConnection(e5) {
                return e5 ? "c=".concat(e5.nettype, " ").concat(e5.addrtype, " ").concat(e5.address).concat(this.eol) : "";
              }
              printBandwidth(e5) {
                let t5 = "";
                for (const i4 of e5) t5 += "b=".concat(i4.bwtype, ":").concat(i4.bandwidth).concat(this.eol);
                return t5;
              }
              printTimeFields(e5) {
                let t5 = "";
                for (const i4 of e5) {
                  t5 += "t=".concat(i4.time.startTime, " ").concat(i4.time.startTime).concat(this.eol);
                  for (const e6 of i4.repeats) t5 += "r=".concat(e6.repeatInterval, " ").concat(e6.typedTimes.join(" ")).concat(this.eol);
                  i4.zoneAdjustments && (t5 += "z=", t5 += "z=".concat(i4.zoneAdjustments.map((e6) => "".concat(e6.time, " ").concat(e6.back ? "-" : "", " ").concat(e6.typedTime)).join(" ")).concat(this.eol), t5 += this.eol);
                }
                return t5;
              }
              printKey(e5) {
                return e5 ? "k=".concat(e5).concat(this.eol) : "";
              }
              printAttributes(e5) {
                let t5 = "";
                for (const i4 of e5) t5 += "a=".concat(i4.attField).concat(i4.attValue ? ":".concat(i4.attValue) : "").concat(this.eol);
                return t5;
              }
              printMediaDescription(e5) {
                let t5 = "";
                for (const i4 of e5) t5 += this.printMedia(i4.media), t5 += this.printInformation(i4.information), t5 += this.printConnections(i4.connections), t5 += this.printBandwidth(i4.bandwidths), t5 += this.printKey(i4.key), t5 += this.printMediaAttributes(i4);
                return t5;
              }
              printConnections(e5) {
                let t5 = "";
                for (const i4 of e5) t5 += this.printConnection(i4);
                return t5;
              }
              printMedia(e5) {
                return "m=".concat(e5.mediaType, " ").concat(e5.port, " ").concat(e5.protos.join("/"), " ").concat(e5.fmts.join(" ")).concat(this.eol);
              }
              printSessionAttributes(e5) {
                return new O2(this.eol).print(e5);
              }
              printMediaAttributes(e5) {
                return new N2(this.eol).print(e5);
              }
            }
            class w2 {
              constructor(e5) {
                A2(this, "eol", void 0), this.eol = e5;
              }
              printIceUfrag(e5) {
                return void 0 === e5 ? "" : "a=ice-ufrag:".concat(e5).concat(this.eol);
              }
              printIcePwd(e5) {
                return void 0 === e5 ? "" : "a=ice-pwd:".concat(e5).concat(this.eol);
              }
              printIceOptions(e5) {
                return void 0 === e5 ? "" : "a=ice-options:".concat(e5.join(s2)).concat(this.eol);
              }
              printFingerprints(e5) {
                return e5.length > 0 ? e5.map((e6) => "a=fingerprint:".concat(e6.hashFunction).concat(s2).concat(e6.fingerprint)).join(this.eol) + this.eol : "";
              }
              printExtmap(e5) {
                return e5.map((e6) => "a=extmap:".concat(e6.entry).concat(e6.direction ? "/".concat(e6.direction) : "").concat(s2).concat(e6.extensionName).concat(e6.extensionAttributes ? "".concat(s2).concat(e6.extensionAttributes) : "").concat(this.eol)).join("");
              }
              printSetup(e5) {
                return void 0 === e5 ? "" : "a=setup:".concat(e5).concat(this.eol);
              }
              printUnrecognized(e5) {
                return e5.map((e6) => "a=".concat(e6.attField).concat(e6.attValue ? ":".concat(e6.attValue) : "").concat(this.eol)).join("");
              }
            }
            class O2 extends w2 {
              print(e5) {
                let t5 = "";
                return t5 += this.printGroups(e5.groups), t5 += this.printMsidSemantic(e5.msidSemantic), t5 += this.printIceLite(e5.iceLite), t5 += this.printIceUfrag(e5.iceUfrag), t5 += this.printIcePwd(e5.icePwd), t5 += this.printIceOptions(e5.iceOptions), t5 += this.printFingerprints(e5.fingerprints), t5 += this.printSetup(e5.setup), t5 += this.printTlsId(e5.tlsId), t5 += this.printIdentity(e5.identities), t5 += this.printExtmap(e5.extmaps), t5 += this.printUnrecognized(e5.unrecognized), t5;
              }
              printGroups(e5) {
                let t5 = "";
                return e5.length > 0 && (t5 += e5.map((e6) => "a=group:".concat(e6.semantic).concat(e6.identificationTag.map((e7) => "".concat(s2).concat(e7)).join("")).concat(this.eol)).join("")), t5;
              }
              printIceLite(e5) {
                return void 0 === e5 ? "" : "a=ice-lite" + this.eol;
              }
              printTlsId(e5) {
                return e5 ? "a=tls-id:".concat(e5).concat(this.eol) : "";
              }
              printIdentity(e5) {
                return 0 === e5.length ? "" : e5.map((e6) => "a=identity:".concat(e6.assertionValue).concat(e6.extensions.map((e7) => "".concat(s2).concat(e7.name).concat(e7.value ? "=".concat(e7.value) : "")))).join(this.eol) + this.eol;
              }
              printMsidSemantic(e5) {
                if (!e5) return "";
                let t5 = "a=msid-semantic:".concat(e5.semantic);
                return e5.applyForAll ? t5 += "".concat(s2, "*") : e5.identifierList.length > 0 && (t5 += e5.identifierList.map((e6) => "".concat(s2).concat(e6))), t5 + this.eol;
              }
            }
            class N2 extends w2 {
              print(e5) {
                const t5 = e5.attributes;
                let i4 = "";
                return i4 += this.printRTCP(t5.rtcp), i4 += this.printIceUfrag(t5.iceUfrag), i4 += this.printIcePwd(t5.icePwd), i4 += this.printIceOptions(t5.iceOptions), i4 += this.printCandidates(t5.candidates), i4 += this.printRemoteCandidatesList(t5.remoteCandidatesList), i4 += this.printEndOfCandidates(t5.endOfCandidates), i4 += this.printFingerprints(t5.fingerprints), i4 += this.printSetup(t5.setup), i4 += this.printMid(t5.mid), i4 += this.printExtmap(t5.extmaps), i4 += this.printRTPRelated(t5), i4 += this.printPtime(t5.ptime), i4 += this.printMaxPtime(t5.maxPtime), i4 += this.printDirection(t5.direction), i4 += this.printSSRCGroups(t5.ssrcGroups), i4 += this.printSSRC(t5.ssrcs), i4 += this.printRTCPMux(t5.rtcpMux), i4 += this.printRTCPMuxOnly(t5.rtcpMuxOnly), i4 += this.printRTCPRsize(t5.rtcpRsize), i4 += this.printMSId(t5.msids), i4 += this.printImageattr(t5.imageattr), i4 += this.printRid(t5.rids), i4 += this.printSimulcast(t5.simulcast), i4 += this.printSCTPPort(t5.sctpPort), i4 += this.printMaxMessageSize(t5.maxMessageSize), i4 += this.printUnrecognized(t5.unrecognized), i4;
              }
              printCandidates(e5) {
                return e5.map((e6) => "a=candidate:".concat(e6.foundation).concat(s2).concat(e6.componentId).concat(s2).concat(e6.transport).concat(s2).concat(e6.priority).concat(s2).concat(e6.connectionAddress).concat(s2).concat(e6.port).concat(s2, "typ").concat(s2).concat(e6.type).concat(e6.relAddr ? "".concat(s2, "raddr").concat(s2).concat(e6.relAddr) : "").concat(e6.relPort ? "".concat(s2, "rport").concat(s2).concat(e6.relPort) : "").concat(Object.keys(e6.extension).map((t5) => "".concat(s2).concat(t5).concat(s2).concat(e6.extension[t5])).join("")).concat(this.eol)).join("");
              }
              printRemoteCandidatesList(e5) {
                return e5.map((e6) => "a=remote-candidates:".concat(e6.join(s2)).concat(this.eol)).join("");
              }
              printEndOfCandidates(e5) {
                return void 0 === e5 ? "" : "a=end-of-candidates" + this.eol;
              }
              printRTPRelated(e5) {
                if (!e5.payloads) return "";
                const t5 = e5.payloads;
                let i4 = "";
                i4 += e5.rtcpFeedbackWildcards.map((e6) => this.printRTCPFeedback("*", e6)).join("");
                for (const e6 of t5) i4 += this.printRtpMap(e6.payloadType, e6.rtpMap), i4 += this.printFmtp(e6.payloadType, e6.fmtp), i4 += e6.rtcpFeedbacks.map((t6) => this.printRTCPFeedback(e6.payloadType, t6)).join("");
                return i4;
              }
              printFmtp(e5, t5) {
                if (!t5) return "";
                const i4 = Object.keys(t5.parameters);
                return 1 === i4.length && null === t5.parameters[i4[0]] ? "a=fmtp:".concat(e5).concat(s2).concat(i4[0]).concat(this.eol) : "a=fmtp:".concat(e5).concat(s2).concat(Object.keys(t5.parameters).map((e6) => "".concat(e6, "=").concat(t5.parameters[e6])).join(";")).concat(this.eol);
              }
              printRtpMap(e5, t5) {
                return t5 ? "a=rtpmap:".concat(e5).concat(s2).concat(t5.encodingName, "/").concat(t5.clockRate).concat(t5.encodingParameters ? "/".concat(t5.encodingParameters) : "").concat(this.eol) : "";
              }
              printRTCPFeedback(e5, t5) {
                let i4 = "a=rtcp-fb:".concat(e5).concat(s2), n3 = t5;
                return "trr-int" === n3.type ? i4 += "ttr-int".concat(s2).concat(n3.interval) : (i4 += "".concat(n3.type), n3.parameter && (i4 += "".concat(s2).concat(n3.parameter), n3.additional && (i4 += "".concat(s2).concat(n3.additional)))), i4 + this.eol;
              }
              printPtime(e5) {
                return void 0 === e5 ? "" : "a=ptime:".concat(e5).concat(this.eol);
              }
              printMaxPtime(e5) {
                return void 0 === e5 ? "" : "a=maxptime:".concat(e5).concat(this.eol);
              }
              printDirection(e5) {
                return void 0 === e5 ? "" : "a=".concat(e5).concat(this.eol);
              }
              printSSRC(e5) {
                return e5.map((e6) => Object.keys(e6.attributes).map((t5) => "a=ssrc:".concat(e6.ssrcId.toString(10)).concat(s2).concat(t5).concat(e6.attributes[t5] ? ":".concat(e6.attributes[t5]) : "").concat(this.eol)).join("")).join("");
              }
              printRTCPMux(e5) {
                return void 0 === e5 ? "" : "a=rtcp-mux".concat(this.eol);
              }
              printRTCPMuxOnly(e5) {
                return void 0 === e5 ? "" : "a=rtcp-mux-only".concat(this.eol);
              }
              printRTCPRsize(e5) {
                return void 0 === e5 ? "" : "a=rtcp-rsize".concat(this.eol);
              }
              printRTCP(e5) {
                if (void 0 === e5) return "";
                let t5 = "a=rtcp:".concat(e5.port);
                return e5.netType && (t5 += "".concat(s2).concat(e5.netType)), e5.addressType && (t5 += "".concat(s2).concat(e5.addressType)), e5.address && (t5 += "".concat(s2).concat(e5.address)), t5 + this.eol;
              }
              printMSId(e5) {
                return e5.map((e6) => "a=msid:".concat(e6.id).concat(e6.appdata ? "".concat(s2).concat(e6.appdata) : "").concat(this.eol)).join("");
              }
              printImageattr(e5) {
                return e5.map((e6) => "a=imageattr:".concat(e6).concat(this.eol)).join("");
              }
              printRid(e5) {
                return e5.map((e6) => {
                  let t5 = "a=rid:".concat(e6.id).concat(s2).concat(e6.direction);
                  return e6.payloads && (t5 += "".concat(s2, "pt=").concat(e6.payloads.join(","))), e6.params.length > 0 && (t5 += "".concat(s2).concat(e6.params.map((e7) => "depend" === e7.type ? "depend=".concat(e7.rids.join(",")) : "".concat(e7.type, "=").concat(e7.val)).join(";"))), t5 + this.eol;
                }).join("");
              }
              printSimulcast(e5) {
                return void 0 === e5 ? "" : "a=simulcast:".concat(e5).concat(this.eol);
              }
              printSCTPPort(e5) {
                return void 0 === e5 ? "" : "a=sctp-port:".concat(e5).concat(this.eol);
              }
              printMaxMessageSize(e5) {
                return void 0 === e5 ? "" : "a=max-message-size:".concat(e5).concat(this.eol);
              }
              printMid(e5) {
                return void 0 === e5 ? "" : "a=mid:".concat(e5).concat(this.eol);
              }
              printSSRCGroups(e5) {
                return e5.map((e6) => "a=ssrc-group:".concat(e6.semantic).concat(e6.ssrcIds.map((e7) => "".concat(s2).concat(e7.toString(10))).join("")).concat(this.eol)).join("");
              }
            }
            function D2(e5) {
              return new C2().parse(e5);
            }
            function P2(e5, t5) {
              return new b2().print(e5, t5);
            }
          } }, t3 = {};
          function i2(n2) {
            if (t3[n2]) return t3[n2].exports;
            var r2 = t3[n2] = { exports: {} };
            return e3[n2](r2, r2.exports, i2), r2.exports;
          }
          return i2.d = (e4, t4) => {
            for (var n2 in t4) i2.o(t4, n2) && !i2.o(e4, n2) && Object.defineProperty(e4, n2, { enumerable: true, get: t4[n2] });
          }, i2.o = (e4, t4) => Object.prototype.hasOwnProperty.call(e4, t4), i2.r = (e4) => {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e4, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e4, "__esModule", { value: true });
          }, i2(8);
        })();
      }(zU);
      var JU = zU.exports;
      function XU(e2) {
        if (Array.isArray(e2)) return e2.map((e3) => e3);
        if (!QU(e2)) return e2;
        const t2 = {};
        for (const i2 in e2) {
          const n2 = e2[i2];
          QU(n2) || Array.isArray(n2) ? t2[i2] = XU(n2) : t2[i2] = n2;
        }
        return t2;
      }
      function QU(e2) {
        return !("object" != typeof e2 || Array.isArray(e2) || !e2);
      }
      class ZU {
        constructor(e2) {
          sh(this, "input", []), sh(this, "size", void 0), this.size = e2;
        }
        add(e2) {
          this.input.push(e2), this.input.length > this.size && this.input.splice(0, 1);
        }
        diffMean() {
          return 0 === this.input.length ? 0 : (this.input[this.input.length - 1] - this.input[0]) / this.input.length;
        }
      }
      const $U = { address: "unknown", candidateType: "unknown", id: "unknown", port: 0, priority: 0, protocol: "unknown", type: "unknown" }, ex = { timestamp: 0, bitrate: { actualEncoded: 0, transmit: 0 }, sendPacketLossRate: 0, recvPacketLossRate: 0, videoRecv: [], videoSend: [], audioRecv: [], audioSend: [], selectedCandidatePair: { id: "unknown", localCandidate: $U, remoteCandidate: $U } }, tx = { firsCount: 0, nacksCount: 0, plisCount: 0, framesDecodeCount: 0, framesDecodeInterval: 0, framesDecodeFreezeTime: 0, decodeFrameRate: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packets: 0, ssrc: 0, qpSumPerFrame: 0 }, ix = { firsCount: 0, nacksCount: 0, plisCount: 0, frameCount: 0, bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0, jitterMs: 0, qpSumPerFrame: 0 }, nx = { bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0, jitterMs: 0 }, rx = { jitterBufferMs: 0, jitterMs: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packets: 0, ssrc: 0, receivedFrames: 0, droppedFrames: 0, concealedSamples: 0 };
      function sx(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function ox(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? sx(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : sx(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class ax {
        constructor(e2, t2) {
          sh(this, "onFirstVideoReceived", void 0), sh(this, "onFirstVideoDecoded", void 0), sh(this, "onFirstAudioReceived", void 0), sh(this, "onFirstVideoDecodedTimeout", void 0), sh(this, "onFirstAudioDecoded", void 0), sh(this, "onSelectedLocalCandidateChanged", void 0), sh(this, "onSelectedRemoteCandidateChanged", void 0), sh(this, "videoIsReady", false), sh(this, "videoIsReady2", {}), sh(this, "pc", void 0), sh(this, "options", void 0), sh(this, "intervalTimer", void 0), sh(this, "stats", XU(ex)), sh(this, "isFirstVideoReceived", {}), sh(this, "isFirstVideoDecoded", {}), sh(this, "isFirstAudioReceived", {}), sh(this, "isFirstAudioDecoded", {}), sh(this, "isFirstVideoDecodedTimeout", {}), sh(this, "lossRateWindowStats", []), this.pc = e2, this.options = t2, this.intervalTimer = window.setInterval(async () => {
            this.updateStats();
          }, this.options.updateInterval);
        }
        getStats() {
          return this.stats;
        }
        getSelectedCandidatePair() {
          return new cg((e2) => {
            e2({ local: ox({}, $U), remote: ox({}, $U) });
          });
        }
        setVideoIsReady(e2) {
          this.videoIsReady = e2;
        }
        setVideoIsReady2(e2, t2) {
          this.videoIsReady2[e2] = t2;
        }
        getVideoIsReady(e2) {
          return this.videoIsReady2[e2] || false;
        }
        setIsFirstAudioDecoded(e2) {
        }
        destroy() {
          window.clearInterval(this.intervalTimer), this.pc = void 0;
        }
        calcLossRate(e2) {
          this.lossRateWindowStats.push(e2), this.lossRateWindowStats.length > this.options.lossRateInterval && this.lossRateWindowStats.splice(0, 1);
          const t2 = this.lossRateWindowStats.length, i2 = ["videoSend", "audioSend", "videoRecv", "audioRecv"];
          let n2 = 0, r2 = 0, s2 = 0, o2 = 0;
          for (const a2 of i2) e2[a2].forEach((e3, i3) => {
            if (!this.lossRateWindowStats[t2 - 1][a2][i3] || !this.lossRateWindowStats[0][a2][i3]) return;
            const c2 = this.lossRateWindowStats[t2 - 1][a2][i3].packets - this.lossRateWindowStats[0][a2][i3].packets, d2 = this.lossRateWindowStats[t2 - 1][a2][i3].packetsLost - this.lossRateWindowStats[0][a2][i3].packetsLost;
            "videoSend" === a2 || "audioSend" === a2 ? (n2 += c2, s2 += d2) : (r2 += c2, o2 += d2), Number.isNaN(c2) || Number.isNaN(c2) ? e3.packetLostRate = 0 : e3.packetLostRate = c2 <= 0 || d2 <= 0 ? 0 : d2 / (c2 + d2);
          });
          e2.sendPacketLossRate = n2 <= 0 || s2 <= 0 ? 0 : s2 / (n2 + s2), e2.recvPacketLossRate = r2 <= 0 || o2 <= 0 ? 0 : o2 / (r2 + o2);
        }
      }
      function cx(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function dx(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? cx(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : cx(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class lx extends ax {
        constructor() {
          super(...arguments), sh(this, "_stats", ex), sh(this, "lastDecodeVideoReceiverStats", /* @__PURE__ */ new Map());
        }
        async updateStats() {
          const e2 = await this._getStats(), t2 = this.statsResponsesToObjects(e2);
          this._stats = XU(ex);
          const i2 = t2.filter((e3) => "ssrc" === e3.type);
          this.processSSRCStats(i2);
          const n2 = t2.find((e3) => "VideoBwe" === e3.type);
          n2 && this.processBandwidthStats(n2), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats;
        }
        processBandwidthStats(e2) {
          this._stats.bitrate = { actualEncoded: Number(e2.googActualEncBitrate), targetEncoded: Number(e2.googTargetEncBitrate), retransmit: Number(e2.googRetransmitBitrate), transmit: Number(e2.googTransmitBitrate) }, this._stats.sendBandwidth = Number(e2.googAvailableSendBandwidth);
        }
        processSSRCStats(e2) {
          e2.forEach((e3) => {
            var t2;
            const i2 = bn(t2 = e3.id).call(t2, "send");
            switch ("".concat(e3.mediaType, "_").concat(i2 ? "send" : "recv")) {
              case "video_send": {
                const t3 = XU(ix);
                t3.codec = e3.googCodecName, t3.adaptionChangeReason = "none", e3.googCpuLimitedResolution && (t3.adaptionChangeReason = "cpu"), e3.googBandwidthLimitedResolution && (t3.adaptionChangeReason = "bandwidth"), t3.avgEncodeMs = Number(e3.googAvgEncodeMs), t3.inputFrame = { width: Number(e3.googFrameWidthInput) || Number(e3.googFrameWidthSent), height: Number(e3.googFrameHeightInput) || Number(e3.googFrameHeightSent), frameRate: Number(e3.googFrameRateInput) }, t3.sentFrame = { width: Number(e3.googFrameWidthSent), height: Number(e3.googFrameHeightSent), frameRate: Number(e3.googFrameRateInput) }, t3.firsCount = Number(e3.googFirReceived), t3.nacksCount = Number(e3.googNacksReceived), t3.plisCount = Number(e3.googPlisReceived), t3.frameCount = Number(e3.framesEncoded), t3.bytes = Number(e3.bytesSent), t3.packets = Number(e3.packetsSent), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.rttMs = Number(e3.googRtt || 0), this._stats.videoSend.push(t3), this._stats.rtt = t3.rttMs;
                break;
              }
              case "video_recv": {
                const t3 = XU(tx), i3 = this.lastDecodeVideoReceiverStats.get(Number(e3.ssrc));
                if (t3.codec = e3.googCodecName, t3.targetDelayMs = Number(e3.googTargetDelayMs), t3.renderDelayMs = Number(e3.googRenderDelayMs), t3.currentDelayMs = Number(e3.googCurrentDelayMs), t3.minPlayoutDelayMs = Number(e3.googMinPlayoutDelayMs), t3.decodeMs = Number(e3.googDecodeMs), t3.maxDecodeMs = Number(e3.googMaxDecodeMs), t3.receivedFrame = { width: Number(e3.googFrameWidthReceived), height: Number(e3.googFrameHeightReceived), frameRate: Number(e3.googFrameRateReceived) }, t3.decodedFrame = { width: Number(e3.googFrameWidthReceived), height: Number(e3.googFrameHeightReceived), frameRate: Number(e3.googFrameRateDecoded) }, t3.decodeFrameRate = Number(e3.googFrameRateDecoded), t3.outputFrame = { width: Number(e3.googFrameWidthReceived), height: Number(e3.googFrameHeightReceived), frameRate: Number(e3.googFrameRateOutput) }, t3.jitterBufferMs = Number(e3.googJitterBufferMs), t3.firsCount = Number(e3.googFirsSent), t3.nacksCount = Number(e3.googNacksSent), t3.plisCount = Number(e3.googPlisSent), t3.framesDecodeCount = Number(e3.framesDecoded), t3.bytes = Number(e3.bytesReceived), t3.packets = Number(e3.packetsReceived), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.packets > 0 && !this.isFirstVideoReceived[t3.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t3.ssrc), this.isFirstVideoReceived[t3.ssrc] = true), t3.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t3.ssrc] && (this.onFirstVideoDecoded && this.onFirstVideoDecoded(t3.ssrc, t3.decodedFrame.width, t3.decodedFrame.height), this.isFirstVideoDecoded[t3.ssrc] = true), i3) {
                  const n2 = i3.stats, r2 = Date.now() - i3.lts;
                  t3.framesDecodeFreezeTime = n2.framesDecodeFreezeTime, t3.framesDecodeInterval = n2.framesDecodeInterval, t3.framesDecodeCount > n2.framesDecodeCount && this.isFirstVideoDecoded[t3.ssrc] ? (i3.lts = Date.now(), t3.framesDecodeInterval = r2, t3.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e3.ssrc, 10)) ? t3.framesDecodeFreezeTime += t3.framesDecodeInterval : this.setVideoIsReady2(parseInt(e3.ssrc, 10), true))) : t3.framesDecodeCount < i3.stats.framesDecodeCount && (t3.framesDecodeInterval = 0);
                }
                this.lastDecodeVideoReceiverStats.set(t3.ssrc, { stats: dx({}, t3), lts: Date.now() }), this._stats.videoRecv.push(t3);
                break;
              }
              case "audio_recv": {
                const t3 = XU(rx);
                t3.codec = e3.googCodecName, t3.outputLevel = Math.abs(Number(e3.audioOutputLevel)) / 32767, t3.decodingCNG = Number(e3.googDecodingCNG), t3.decodingCTN = Number(e3.googDecodingCTN), t3.decodingCTSG = Number(e3.googDecodingCTSG), t3.decodingNormal = Number(e3.googDecodingNormal), t3.decodingPLC = Number(e3.googDecodingPLC), t3.decodingPLCCNG = Number(e3.googDecodingPLCCNG), t3.expandRate = Number(e3.googExpandRate), t3.accelerateRate = Number(e3.googAccelerateRate), t3.preemptiveExpandRate = Number(e3.googPreemptiveExpandRate), t3.secondaryDecodedRate = Number(e3.googSecondaryDecodedRate), t3.speechExpandRate = Number(e3.googSpeechExpandRate), t3.preferredJitterBufferMs = Number(e3.googPreferredJitterBufferMs), t3.jitterBufferMs = Number(e3.googJitterBufferMs), t3.jitterMs = Number(e3.googJitterReceived), t3.bytes = Number(e3.bytesReceived), t3.packets = Number(e3.packetsReceived), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.receivedFrames = Number(e3.googDecodingCTN) || Number(e3.packetsReceived), t3.droppedFrames = Number(e3.googDecodingPLC) + Number(e3.googDecodingPLCCNG) || Number(e3.packetsLost), t3.receivedFrames > 0 && !this.isFirstAudioReceived[t3.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t3.ssrc), this.isFirstAudioReceived[t3.ssrc] = true), t3.decodingNormal > 0 && !this.isFirstAudioDecoded[t3.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t3.ssrc), this.isFirstAudioDecoded[t3.ssrc] = true), this._stats.audioRecv.push(t3);
                break;
              }
              case "audio_send": {
                const t3 = XU(nx);
                t3.codec = e3.googCodecName, t3.inputLevel = Math.abs(Number(e3.audioInputLevel)) / 32767, t3.aecReturnLoss = Number(e3.googEchoCancellationReturnLoss || 0), t3.aecReturnLossEnhancement = Number(e3.googEchoCancellationReturnLossEnhancement || 0), t3.residualEchoLikelihood = Number(e3.googResidualEchoLikelihood || 0), t3.residualEchoLikelihoodRecentMax = Number(e3.googResidualEchoLikelihoodRecentMax || 0), t3.bytes = Number(e3.bytesSent), t3.packets = Number(e3.packetsSent), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.rttMs = Number(e3.googRtt || 0), this._stats.rtt = t3.rttMs, this._stats.audioSend.push(t3);
                break;
              }
            }
          });
        }
        _getStats() {
          return new cg((e2, t2) => {
            this.pc.getStats(e2, t2);
          });
        }
        statsResponsesToObjects(e2) {
          const t2 = [];
          return e2.result().forEach((e3) => {
            const i2 = { id: e3.id, timestamp: e3.timestamp.valueOf().toString(), type: e3.type };
            e3.names().forEach((t3) => {
              i2[t3] = e3.stat(t3);
            }), t2.push(i2);
          }), t2;
        }
      }
      function ux(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function hx(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? ux(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : ux(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class px extends ax {
        constructor() {
          super(...arguments), sh(this, "_stats", ex), sh(this, "report", void 0), sh(this, "lastDecodeVideoReceiverStats", /* @__PURE__ */ new Map()), sh(this, "lastVideoFramesRecv", /* @__PURE__ */ new Map()), sh(this, "lastVideoFramesSent", /* @__PURE__ */ new Map()), sh(this, "lastVideoFramesDecode", /* @__PURE__ */ new Map()), sh(this, "lastVideoJBDelay", /* @__PURE__ */ new Map()), sh(this, "lastAudioJBDelay", /* @__PURE__ */ new Map()), sh(this, "mediaBytesSent", /* @__PURE__ */ new Map()), sh(this, "mediaBytesRetransmit", /* @__PURE__ */ new Map()), sh(this, "mediaBytesTargetEncode", /* @__PURE__ */ new Map()), sh(this, "lastEncoderMs", /* @__PURE__ */ new Map());
        }
        async updateStats() {
          this.report = await this.pc.getStats(), this._stats = XU(ex), this.report.forEach((e2) => {
            switch (e2.type) {
              case aI.OUTBOUND:
              case aI.INBOUND: {
                const t2 = e2.mediaType || e2.kind, i2 = !t2 && "frameWidth" in e2, n2 = !t2 && !("frameWidth" in e2);
                e2.type === aI.OUTBOUND ? "audio" === t2 || n2 ? this.processAudioOutboundStats(e2) : ("video" === t2 || i2) && this.processVideoOutboundStats(e2) : e2.type === aI.INBOUND && ("audio" === t2 || n2 ? this.processAudioInboundStats(e2) : ("video" === t2 || i2) && this.processVideoInboundStats(e2));
                break;
              }
              case aI.TRANSPORT: {
                const t2 = this.report.get(e2.selectedCandidatePairId);
                t2 && this.processCandidatePairStats(t2);
                break;
              }
              case aI.CANDIDATE_PAIR:
                e2.selected && this.processCandidatePairStats(e2);
            }
          }), this.updateSendBitrate(), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats;
        }
        async getSelectedCandidatePair() {
          const e2 = await this.pc.getStats(), t2 = { local: hx({}, $U), remote: hx({}, $U) };
          return e2.forEach((i2) => {
            let n2;
            if (i2.type === aI.TRANSPORT && (n2 = e2.get(i2.selectedCandidatePairId)), i2.type === aI.CANDIDATE_PAIR && i2.selected && (n2 = i2), n2) {
              const i3 = (e3, t3) => {
                e3.type = t3.type, e3.id = t3.id, t3.address && (e3.address = t3.address), t3.candidateType && (e3.candidateType = t3.candidateType), t3.port && (e3.port = t3.port), t3.priority && (e3.priority = t3.priority), t3.protocol && (e3.protocol = t3.protocol), t3.relayProtocol && (e3.relayProtocol = t3.relayProtocol);
              };
              if (n2.localCandidateId) {
                const r2 = e2.get(n2.localCandidateId);
                r2 && i3(t2.local, r2);
              }
              if (n2.remoteCandidateId) {
                const r2 = e2.get(n2.remoteCandidateId);
                r2 && i3(t2.remote, r2);
              }
            }
          }), t2;
        }
        processCandidatePairStats(e2) {
          if (this._stats.sendBandwidth = e2.availableOutgoingBitrate || 0, e2.currentRoundTripTime && (this._stats.rtt = 1e3 * e2.currentRoundTripTime), this._stats.videoSend.forEach((t2) => {
            e2.currentRoundTripTime && (t2.rttMs = 1e3 * e2.currentRoundTripTime);
          }), this._stats.audioSend.forEach((t2) => {
            e2.currentRoundTripTime && (t2.rttMs = 1e3 * e2.currentRoundTripTime);
          }), this._stats.selectedCandidatePair.id = e2.id, e2.localCandidateId) {
            const t2 = this.report.get(e2.localCandidateId);
            t2 && this.processCandidateStats(t2);
          }
          if (e2.remoteCandidateId) {
            const t2 = this.report.get(e2.remoteCandidateId);
            t2 && this.processCandidateStats(t2);
          }
        }
        processCandidateStats(e2) {
          let t2;
          e2.type === aI.LOCAL_CANDIDATE && (t2 = this._stats.selectedCandidatePair.localCandidate), e2.type === aI.REMOTE_CANDIDATE && (t2 = this._stats.selectedCandidatePair.remoteCandidate), t2 && (t2.type = e2.type, t2.id = e2.id, e2.address && (t2.address = e2.address), e2.candidateType && (t2.candidateType = e2.candidateType), e2.port && (t2.port = e2.port), e2.priority && (t2.priority = e2.priority), e2.protocol && (t2.protocol = e2.protocol), e2.relayProtocol && (t2.relayProtocol = e2.relayProtocol), e2.type === aI.LOCAL_CANDIDATE && this.stats.selectedCandidatePair.localCandidate.id !== t2.id && this.onSelectedLocalCandidateChanged && this.onSelectedLocalCandidateChanged(hx({}, t2), hx({}, this.stats.selectedCandidatePair.localCandidate)), e2.type === aI.REMOTE_CANDIDATE && this.stats.selectedCandidatePair.remoteCandidate.id !== t2.id && this.onSelectedRemoteCandidateChanged && this.onSelectedRemoteCandidateChanged(hx({}, t2), hx({}, this.stats.selectedCandidatePair.remoteCandidate)));
        }
        processAudioInboundStats(e2) {
          let t2 = this._stats.audioRecv.find((t3) => t3.ssrc === e2.ssrc);
          t2 || (t2 = XU(rx), this._stats.audioRecv.push(t2)), t2.ssrc = e2.ssrc, t2.packets = e2.packetsReceived, t2.packetsLost = e2.packetsLost, t2.bytes = e2.bytesReceived, t2.jitterMs = 1e3 * e2.jitter, this.processAudioTrackReceiverStats(e2, e2.trackId, t2), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), t2.receivedFrames || (t2.receivedFrames = e2.packetsReceived), t2.droppedFrames || (t2.droppedFrames = e2.packetsLost), t2.receivedFrames > 0 && !this.isFirstAudioReceived[t2.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t2.ssrc), this.isFirstAudioReceived[t2.ssrc] = true), t2.outputLevel && t2.outputLevel > 0 && !this.isFirstAudioDecoded[t2.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t2.ssrc), this.isFirstAudioDecoded[t2.ssrc] = true), "number" == typeof e2.concealedSamples && (t2.concealedSamples = e2.concealedSamples);
        }
        processVideoInboundStats(e2) {
          let t2 = this._stats.videoRecv.find((t3) => t3.ssrc === e2.ssrc);
          t2 || (t2 = XU(tx), this._stats.videoRecv.push(t2)), t2.ssrc = e2.ssrc, t2.packets = e2.packetsReceived, t2.packetsLost = e2.packetsLost, t2.bytes = e2.bytesReceived, t2.firsCount = e2.firCount, t2.nacksCount = e2.nackCount, t2.plisCount = e2.pliCount, t2.framesDecodeCount = e2.framesDecoded, t2.totalInterFrameDelay = e2.totalInterFrameDelay, t2.totalSquaredInterFrameDelay = e2.totalSquaredInterFrameDelay;
          const i2 = this.lastDecodeVideoReceiverStats.get(t2.ssrc), n2 = this.lastVideoFramesDecode.get(t2.ssrc), r2 = Date.now();
          if (t2.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t2.ssrc]) {
            const e3 = t2.decodedFrame ? t2.decodedFrame.width : 0, i3 = t2.decodedFrame ? t2.decodedFrame.height : 0;
            this.onFirstVideoDecoded && this.onFirstVideoDecoded(t2.ssrc, e3, i3), this.isFirstVideoDecoded[t2.ssrc] = true;
          }
          if (i2) {
            const n3 = i2.stats, s2 = r2 - i2.lts;
            t2.framesDecodeFreezeTime = n3.framesDecodeFreezeTime, t2.framesDecodeInterval = n3.framesDecodeInterval, !this.isFirstVideoDecoded[t2.ssrc] && s2 > this.options.firstVideoDecodedTimeout && !this.isFirstVideoDecodedTimeout[t2.ssrc] && (this.onFirstVideoDecodedTimeout && this.onFirstVideoDecodedTimeout(t2.ssrc), this.isFirstVideoDecodedTimeout[t2.ssrc] = true), t2.framesDecodeCount > n3.framesDecodeCount && this.isFirstVideoDecoded[t2.ssrc] ? (i2.lts = Date.now(), t2.framesDecodeInterval = s2, t2.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e2.ssrc)) ? t2.framesDecodeFreezeTime += t2.framesDecodeInterval : this.setVideoIsReady2(parseInt(e2.ssrc, 10), true))) : t2.framesDecodeCount < n3.framesDecodeCount && (t2.framesDecodeInterval = 0), e2.framesDecoded && e2.qpSum && (i2.stats.framesDecodeCount > e2.framesDecoded ? t2.qpSumPerFrame = e2.qpSum / e2.framesDecoded : t2.qpSumPerFrame = (e2.qpSum - i2.qpSum) / (e2.framesDecoded - i2.stats.framesDecodeCount));
          }
          n2 && r2 - n2.lts >= 800 ? (t2.decodeFrameRate = Math.round((t2.framesDecodeCount - n2.count) / ((r2 - n2.lts) / 1e3)), this.lastVideoFramesDecode.set(t2.ssrc, { count: t2.framesDecodeCount, lts: r2, rate: t2.decodeFrameRate })) : n2 ? t2.decodeFrameRate = n2.rate : this.lastVideoFramesDecode.set(t2.ssrc, { count: t2.framesDecodeCount, lts: r2, rate: 0 }), e2.totalDecodeTime && (t2.decodeMs = 1e3 * e2.totalDecodeTime), this.processVideoTrackReceiverStats(e2, e2.trackId, t2), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), e2.framerateMean && (t2.framesRateFirefox = e2.framerateMean), t2.packets > 0 && !this.isFirstVideoReceived[t2.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t2.ssrc), this.isFirstVideoReceived[t2.ssrc] = true), this.lastDecodeVideoReceiverStats.set(t2.ssrc, { stats: hx({}, t2), lts: i2 ? i2.lts : Date.now(), qpSum: e2.qpSum });
        }
        processVideoOutboundStats(e2) {
          let t2 = this._stats.videoSend.find((t3) => t3.ssrc === e2.ssrc);
          t2 || (t2 = XU(ix), this._stats.videoSend.push(t2));
          const i2 = this.mediaBytesSent.get(e2.ssrc);
          if (i2) i2.add(e2.bytesSent);
          else {
            const t3 = new ZU(10);
            t3.add(e2.bytesSent), this.mediaBytesSent.set(e2.ssrc, t3);
          }
          if (void 0 !== e2.retransmittedBytesSent) {
            const t3 = this.mediaBytesRetransmit.get(e2.ssrc);
            if (t3) t3.add(e2.retransmittedBytesSent);
            else {
              const t4 = new ZU(10);
              t4.add(e2.retransmittedBytesSent), this.mediaBytesRetransmit.set(e2.ssrc, t4);
            }
          }
          if (e2.totalEncodedBytesTarget) {
            const t3 = this.mediaBytesTargetEncode.get(e2.ssrc);
            if (t3) t3.add(e2.totalEncodedBytesTarget);
            else {
              const t4 = new ZU(10);
              t4.add(e2.totalEncodedBytesTarget), this.mediaBytesTargetEncode.set(e2.ssrc, t4);
            }
          }
          if (t2.ssrc = e2.ssrc, t2.bytes = e2.bytesSent, t2.packets = e2.packetsSent, t2.firsCount = e2.firCount, t2.nacksCount = e2.nackCount, t2.plisCount = e2.pliCount, t2.frameCount = e2.framesEncoded, t2.adaptionChangeReason = e2.qualityLimitationReason, t2.scalabilityMode = e2.scalabilityMode, e2.totalEncodeTime && e2.framesEncoded) {
            const i3 = this.lastEncoderMs.get(e2.ssrc);
            if (!i3 || i3.lastFrameCount > e2.framesEncoded) t2.avgEncodeMs = 1e3 * e2.totalEncodeTime / e2.framesEncoded;
            else {
              const n2 = e2.framesEncoded - i3.lastFrameCount, r2 = e2.totalEncodeTime - i3.lastEncoderTime;
              t2.avgEncodeMs = 1e3 * r2 / n2;
            }
          }
          if (e2.framesEncoded && e2.qpSum) {
            const i3 = this.lastEncoderMs.get(e2.ssrc);
            !i3 || i3.lastFrameCount > e2.framesEncoded ? t2.qpSumPerFrame = e2.qpSum / e2.framesEncoded : t2.qpSumPerFrame = (e2.qpSum - i3.lastQpSum) / (e2.framesEncoded - i3.lastFrameCount);
          }
          if (this.lastEncoderMs.set(e2.ssrc, { lastFrameCount: e2.framesEncoded, lastEncoderTime: e2.totalEncodeTime, lastQpSum: e2.qpSum, lts: Date.now() }), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), e2.mediaSourceId && this.processVideoMediaSource(e2.mediaSourceId, t2), this.processVideoTrackSenderStats(e2, e2.trackId, t2), e2.remoteId) this.processRemoteInboundStats(e2.remoteId, t2);
          else {
            const i3 = this.findRemoteStatsId(e2.ssrc, aI.REMOTE_INBOUND);
            i3 && this.processRemoteInboundStats(i3, t2);
          }
        }
        processAudioOutboundStats(e2) {
          let t2 = this._stats.audioSend.find((t3) => t3.ssrc === e2.ssrc);
          if (t2 || (t2 = XU(nx), this._stats.audioSend.push(t2)), t2.ssrc = e2.ssrc, t2.packets = e2.packetsSent, t2.bytes = e2.bytesSent, e2.mediaSourceId && this.processAudioMediaSource(e2.mediaSourceId, t2), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), this.processAudioTrackSenderStats(e2, e2.trackId, t2), e2.remoteId) this.processRemoteInboundStats(e2.remoteId, t2);
          else {
            const i2 = this.findRemoteStatsId(e2.ssrc, aI.REMOTE_INBOUND);
            i2 && this.processRemoteInboundStats(i2, t2);
          }
        }
        findRemoteStatsId(e2, t2) {
          var i2;
          const n2 = Array.from(NI(i2 = this.report).call(i2)).find((i3) => i3.type === t2 && i3.ssrc === e2);
          return n2 ? n2.id : null;
        }
        processVideoMediaSource(e2, t2) {
          const i2 = this.report.get(e2);
          i2 && i2.width && i2.height && i2.framesPerSecond && (t2.inputFrame = { width: i2.width, height: i2.height, frameRate: i2.framesPerSecond });
        }
        processAudioMediaSource(e2, t2) {
          const i2 = this.report.get(e2);
          i2 && (t2.inputLevel = i2.audioLevel);
        }
        processVideoTrackSenderStats(e2, t2, i2) {
          var n2, r2, s2, o2;
          const a2 = t2 ? this.report.get(t2) : void 0, c2 = null !== (n2 = null == a2 ? void 0 : a2.framesSent) && void 0 !== n2 ? n2 : e2.framesSent;
          if ("number" != typeof c2) return;
          let d2 = null !== (r2 = null == a2 ? void 0 : a2.frameWidth) && void 0 !== r2 ? r2 : e2.frameWidth, l2 = null !== (s2 = null == a2 ? void 0 : a2.frameHeight) && void 0 !== s2 ? s2 : e2.frameHeight, u2 = null !== (o2 = null == a2 ? void 0 : a2.framesPerSecond) && void 0 !== o2 ? o2 : e2.framesPerSecond;
          if ("number" == typeof d2 && "number" == typeof l2 || (d2 = 0, l2 = 0), null == u2) {
            const e3 = Date.now(), t3 = this.lastVideoFramesSent.get(i2.ssrc);
            t3 && e3 - t3.lts >= 800 ? (u2 = Math.round((c2 - t3.count) / ((e3 - t3.lts) / 1e3)), this.lastVideoFramesSent.set(i2.ssrc, { count: c2, lts: e3, rate: u2 })) : t3 ? u2 = t3.rate : this.lastVideoFramesSent.set(i2.ssrc, { count: c2, lts: e3, rate: 0 });
          }
          i2.sentFrame = { width: d2, height: l2, frameRate: Math.max(0, u2) };
        }
        processVideoTrackReceiverStats(e2, t2, i2) {
          var n2, r2, s2, o2, a2;
          const c2 = t2 ? this.report.get(t2) : void 0, d2 = null !== (n2 = null == c2 ? void 0 : c2.framesReceived) && void 0 !== n2 ? n2 : e2.framesReceived, l2 = null !== (r2 = null == c2 ? void 0 : c2.frameWidth) && void 0 !== r2 ? r2 : e2.frameWidth, u2 = null !== (s2 = null == c2 ? void 0 : c2.frameHeight) && void 0 !== s2 ? s2 : e2.frameHeight, h3 = null !== (o2 = null == c2 ? void 0 : c2.jitterBufferDelay) && void 0 !== o2 ? o2 : e2.jitterBufferDelay, p2 = null !== (a2 = null == c2 ? void 0 : c2.jitterBufferEmittedCount) && void 0 !== a2 ? a2 : e2.jitterBufferEmittedCount;
          if ("number" == typeof d2) {
            const e3 = this.lastVideoFramesRecv.get(i2.ssrc), t3 = Date.now();
            i2.framesReceivedCount = d2;
            let n3 = 0;
            e3 && t3 - e3.lts >= 800 ? (n3 = Math.round((d2 - e3.count) / ((t3 - e3.lts) / 1e3)), this.lastVideoFramesRecv.set(i2.ssrc, { count: d2, lts: t3, rate: n3 })) : e3 ? n3 = e3.rate : this.lastVideoFramesRecv.set(i2.ssrc, { count: d2, lts: t3, rate: 0 }), i2.receivedFrame = { width: l2 || 0, height: u2 || 0, frameRate: n3 || 0 }, i2.decodedFrame = { width: l2 || 0, height: u2 || 0, frameRate: i2.decodeFrameRate || 0 }, i2.outputFrame = { width: l2 || 0, height: u2 || 0, frameRate: i2.decodeFrameRate || 0 };
          }
          if (h3 && p2) {
            const e3 = this.lastVideoJBDelay.get(i2.ssrc) || { jitterBufferDelay: 0, jitterBufferEmittedCount: 0, jitterBufferMs: 0 };
            let t3 = e3.jitterBufferMs;
            const n3 = p2 - e3.jitterBufferEmittedCount;
            n3 > 0 && (t3 = 1e3 * (h3 - e3.jitterBufferDelay) / n3), i2.jitterBufferMs = t3, i2.currentDelayMs = Math.round(t3), this.lastVideoJBDelay.set(i2.ssrc, { jitterBufferDelay: h3, jitterBufferEmittedCount: p2, jitterBufferMs: i2.currentDelayMs });
          }
        }
        processAudioTrackSenderStats(e2, t2, i2) {
          var n2, r2, s2, o2;
          const a2 = t2 ? this.report.get(t2) : void 0, c2 = null !== (n2 = null !== (r2 = null == a2 ? void 0 : a2.echoReturnLoss) && void 0 !== r2 ? r2 : e2.echoReturnLoss) && void 0 !== n2 ? n2 : 0, d2 = null !== (s2 = null !== (o2 = null == a2 ? void 0 : a2.echoReturnLossEnhancement) && void 0 !== o2 ? o2 : e2.echoReturnLossEnhancement) && void 0 !== s2 ? s2 : 0;
          i2.aecReturnLoss = c2, i2.aecReturnLossEnhancement = d2;
        }
        processAudioTrackReceiverStats(e2, t2, i2) {
          var n2, r2, s2, o2, a2, c2, d2;
          const l2 = t2 ? this.report.get(t2) : void 0, u2 = null !== (n2 = null == l2 ? void 0 : l2.removedSamplesForAcceleration) && void 0 !== n2 ? n2 : e2.removedSamplesForAcceleration, h3 = null !== (r2 = null == l2 ? void 0 : l2.totalSamplesReceived) && void 0 !== r2 ? r2 : e2.totalSamplesReceived, p2 = null !== (s2 = null == l2 ? void 0 : l2.jitterBufferDelay) && void 0 !== s2 ? s2 : e2.jitterBufferDelay, _2 = null !== (o2 = null == l2 ? void 0 : l2.jitterBufferEmittedCount) && void 0 !== o2 ? o2 : e2.jitterBufferEmittedCount, E2 = null !== (a2 = null == l2 ? void 0 : l2.audioLevel) && void 0 !== a2 ? a2 : null == e2 ? void 0 : e2.audioLevel, m2 = null !== (c2 = null == l2 ? void 0 : l2.totalSamplesDuration) && void 0 !== c2 ? c2 : null == e2 ? void 0 : e2.totalSamplesDuration, f2 = null !== (d2 = null == l2 ? void 0 : l2.concealedSamples) && void 0 !== d2 ? d2 : e2.concealedSamples;
          if (u2 && h3 && (i2.accelerateRate = u2 / h3), p2 && _2) {
            const e3 = this.lastAudioJBDelay.get(i2.ssrc) || { jitterBufferDelay: 0, jitterBufferEmittedCount: 0, jitterBufferMs: 0 };
            let t3 = e3.jitterBufferMs;
            const n3 = _2 - e3.jitterBufferEmittedCount;
            n3 > 0 && (t3 = 1e3 * (p2 - e3.jitterBufferDelay) / n3), i2.jitterBufferMs = Math.round(t3), this.lastAudioJBDelay.set(i2.ssrc, { jitterBufferDelay: p2, jitterBufferEmittedCount: _2, jitterBufferMs: i2.jitterBufferMs });
          }
          i2.outputLevel = E2;
          let g2 = 1920;
          m2 && h3 && (g2 = h3 / m2 / 50, i2.receivedFrames = Math.round(h3 / g2)), f2 && (i2.droppedFrames = Math.round(f2 / g2));
        }
        processRemoteInboundStats(e2, t2) {
          const i2 = this.report.get(e2);
          i2 && (t2.packetsLost = i2.packetsLost, i2.roundTripTime && (t2.rttMs = 1e3 * i2.roundTripTime), i2.jitter && (t2.jitterMs = 1e3 * i2.jitter), i2.timestamp && (t2.timestamp = i2.timestamp));
        }
        getCodecFromCodecStats(e2) {
          const t2 = this.report.get(e2);
          if (!t2) return "";
          const i2 = t2.mimeType.match(/\/(.*)$/);
          return i2 && i2[1] ? i2[1] : "";
        }
        updateSendBitrate() {
          let e2 = 0, t2 = null, i2 = null;
          this.mediaBytesSent.forEach((t3) => {
            e2 += t3.diffMean();
          }), this.mediaBytesRetransmit.forEach((e3) => {
            t2 = null === t2 ? e3.diffMean() : t2 + e3.diffMean();
          }), this.mediaBytesTargetEncode.forEach((e3) => {
            i2 = null === i2 ? e3.diffMean() : i2 + e3.diffMean();
          });
          const n2 = null !== t2 ? e2 - t2 : e2;
          this._stats.bitrate = { actualEncoded: 8 * n2 / (this.options.updateInterval / 1e3), transmit: 8 * e2 / (this.options.updateInterval / 1e3) }, null !== t2 && (this._stats.bitrate.retransmit = 8 * t2 / (this.options.updateInterval / 1e3)), null !== i2 && (this._stats.bitrate.targetEncoded = 8 * i2 / (this.options.updateInterval / 1e3));
        }
      }
      class _x extends ax {
        updateStats() {
          return cg.resolve();
        }
      }
      function Ex(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 250, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 8, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 500, r2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1e4;
        const s2 = function() {
          const e3 = navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]*/i);
          return e3 && e3[0] ? Number(e3[0].split("/")[1]) : null;
        }();
        return s2 ? s2 < 76 ? new lx(e2, { updateInterval: t2, lossRateInterval: i2, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 }) : new px(e2, { updateInterval: t2, lossRateInterval: i2, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 }) : function(e3) {
          return !!window.RTCStatsReport && e3.getStats() instanceof cg;
        }(e2) ? new px(e2, { updateInterval: t2, lossRateInterval: i2, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 }) : new _x(e2, { updateInterval: t2, lossRateInterval: i2, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 });
      }
      function mx(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function fx(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? mx(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : mx(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      function gx(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n2 = arguments.length > 3 ? arguments[3] : void 0;
        const { filterRTX: r2, filterVideoFec: s2, filterAudioFec: o2, filterAudioCodec: a2, filterVideoCodec: c2 } = t2, { useXR: d2 } = i2;
        let l2 = [], u2 = [], h3 = [], p2 = [], _2 = false, E2 = false;
        if (JU.parse(e2).mediaDescriptions.forEach((e3) => {
          n2 && n2 !== e3.attributes.direction || ("video" !== e3.media.mediaType || _2 || (u2 = e3.attributes.payloads, p2 = e3.attributes.extmaps, _2 = true), "audio" !== e3.media.mediaType || E2 || (l2 = e3.attributes.payloads, h3 = e3.attributes.extmaps, E2 = true));
        }), !p2 || 0 === u2.length) throw new Error("Cannot get video capabilities from SDP.");
        if (!h3 || 0 === l2.length) throw new Error("Cannot get audio capabilities from SDP.");
        u2.forEach((e3) => {
          var t3;
          null !== (t3 = e3.rtpMap) && void 0 !== t3 && t3.clockRate && (e3.rtpMap.clockRate = parseInt(e3.rtpMap.clockRate)), d2 && e3.rtcpFeedbacks.push({ type: "rrtr" });
        }), l2.forEach((e3) => {
          var t3;
          null !== (t3 = e3.rtpMap) && void 0 !== t3 && t3.clockRate && (e3.rtpMap.clockRate = parseInt(e3.rtpMap.clockRate)), d2 && e3.rtcpFeedbacks.push({ type: "rrtr" });
        }), r2 && (l2 = l2.filter((e3) => {
          var t3;
          return "rtx" !== (null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase());
        }), u2 = u2.filter((e3) => {
          var t3;
          return "rtx" !== (null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase());
        })), s2 && (u2 = u2.filter((e3) => {
          var t3;
          return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName) || "");
        })), o2 && (l2 = l2.filter((e3) => {
          var t3;
          return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName) || "");
        })), a2 && (null == a2 ? void 0 : a2.length) > 0 && (l2 = l2.filter((e3) => {
          var t3;
          return bn(a2).call(a2, (null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "");
        })), c2 && (null == c2 ? void 0 : c2.length) > 0 && (u2 = u2.filter((e3) => {
          var t3;
          return bn(c2).call(c2, (null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "");
        }));
        const m2 = RC("UNSUPPORTED_VIDEO_CODEC");
        return m2 && m2.length > 0 && (u2 = u2.filter((e3) => !(e3.rtpMap && bn(m2).call(m2, e3.rtpMap.encodingName.toLowerCase())))), { audioCodecs: l2, videoCodecs: u2, audioExtensions: h3, videoExtensions: p2 };
      }
      function Tx(e2) {
        const t2 = JU.parse(e2);
        let i2, n2;
        for (const e3 of t2.mediaDescriptions) {
          if (!i2) {
            const t3 = e3.attributes.iceUfrag, n3 = e3.attributes.icePwd;
            if (!t3 || !n3) throw new Error("Cannot get iceUfrag or icePwd from SDP.");
            i2 = { iceUfrag: t3, icePwd: n3 };
          }
          if (!n2) {
            const t3 = e3.attributes.fingerprints;
            t3.length > 0 && (n2 = { fingerprints: t3 });
          }
        }
        if (!n2 && t2.attributes.fingerprints.length > 0 && (n2 = { fingerprints: t2.attributes.fingerprints }), !n2 || !i2) throw new Error("Cannot get iceParameters or dtlsParameters from SDP.");
        return { iceParameters: i2, dtlsParameters: n2 };
      }
      function Sx(e2, t2) {
        const i2 = [], n2 = e2.attributes.ssrcGroups.filter((e3) => "FID" === e3.semantic), r2 = e2.attributes.ssrcGroups.find((e3) => "SIM" === e3.semantic), s2 = e2.attributes.ssrcs;
        if (r2) r2.ssrcIds.forEach((e3) => {
          var r3;
          const s3 = null === (r3 = n2.find((t3) => t3.ssrcIds[0] === e3)) || void 0 === r3 ? void 0 : r3.ssrcIds[1];
          i2.push({ ssrcId: e3, rtx: t2 ? s3 : void 0 });
        });
        else if (n2.length > 0) {
          const e3 = n2[0].ssrcIds[0], r3 = n2[0].ssrcIds[1];
          i2.push({ ssrcId: e3, rtx: t2 ? r3 : void 0 });
        } else {
          if (0 === s2.length) throw new Error("No ssrcs found on local media description.");
          i2.push({ ssrcId: s2[0].ssrcId });
        }
        return i2;
      }
      function Rx(e2, t2) {
        const { cname: i2 } = e2;
        let n2;
        t2 && t2.ip && "number" == typeof t2.port ? (n2 = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t2.ip, port: t2.port.toString(), type: "host", extension: {} }], jC.debug("Using remote candidate from AP ".concat(t2.ip, ":").concat(t2.port)), t2.ip6 && (n2.push({ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t2.ip6, port: t2.port.toString(), type: "host", extension: {} }), jC.debug("Using IPV6 remote candidate from AP ".concat(t2.ip6, ":").concat(t2.port)))) : n2 = e2.iceParameters.candidates.map((e3) => ({ foundation: e3.foundation, componentId: "1", transport: e3.protocol, priority: e3.priority.toString(), connectionAddress: e3.ip, port: e3.port.toString(), type: e3.type, extension: {} }));
        const r2 = { fingerprints: e2.dtlsParameters.fingerprints.map((e3) => ({ hashFunction: e3.algorithm, fingerprint: e3.fingerprint })) }, s2 = { iceUfrag: e2.iceParameters.iceUfrag, icePwd: e2.iceParameters.icePwd };
        let o2;
        switch (e2.dtlsParameters.role) {
          case "server":
            o2 = "passive";
            break;
          case "client":
            o2 = "active";
            break;
          case "auto":
            o2 = "actpass";
        }
        return { dtlsParameters: r2, iceParameters: s2, candidates: n2, rtpCapabilities: Px(e2.rtpCapabilities), setup: o2, cname: i2 };
      }
      function Cx(e2, t2, i2) {
        const n2 = [], r2 = [];
        return e2.forEach((e3) => {
          let { ssrcId: s2, rtx: o2 } = e3;
          const a2 = nS(8, "track-"), c2 = { ssrcId: s2, attributes: fx({ label: a2, mslabel: i2 = i2 || nS(10, ""), msid: "".concat(i2, " ").concat(a2) }, t2 && { cname: t2 }) };
          if (n2.push(c2), void 0 !== o2) {
            const e4 = { ssrcId: o2, attributes: fx({ label: a2, mslabel: i2, msid: "".concat(i2, " ").concat(a2) }, t2 && { cname: t2 }) };
            n2.push(e4), r2.push({ semantic: "FID", ssrcIds: [s2, o2] });
          }
        }), e2.length > 1 && r2.push({ semantic: "SIM", ssrcIds: e2.map((e3) => {
          let { ssrcId: t3 } = e3;
          return t3;
        }) }), { ssrcs: n2, ssrcGroups: r2 };
      }
      function Ix(e2, t2) {
        t2 instanceof ew && e2.attributes.payloads.forEach((e3) => {
          var i2;
          const n2 = null === (i2 = e3.rtpMap) || void 0 === i2 ? void 0 : i2.encodingName.toLowerCase();
          if (!n2 || -1 === ["opus", "pcmu", "pcma", "g722"].indexOf(n2)) return;
          e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters.minptime = "10", e3.fmtp.parameters.useinbandfec = "1";
          const r2 = t2._encoderConfig;
          r2 && "pcmu" !== n2 && "pcma" !== n2 && "g722" !== n2 && (r2.bitrate && !wg() && (e3.fmtp.parameters.maxaveragebitrate = "".concat(Math.floor(1e3 * r2.bitrate))), r2.sampleRate && (e3.fmtp.parameters.maxplaybackrate = "".concat(r2.sampleRate), e3.fmtp.parameters["sprop-maxcapturerate"] = "".concat(r2.sampleRate)), r2.stereo && (e3.fmtp.parameters.stereo = "1", e3.fmtp.parameters["sprop-stereo"] = "1"));
        });
      }
      function vx(e2) {
        const t2 = e2.attributes.unrecognized.findIndex((e3) => "x-google-flag" === e3.attField && "conference" === e3.attValue);
        -1 !== t2 && e2.attributes.unrecognized.splice(t2, 1);
      }
      function yx(e2, t2) {
        var i2;
        if (!(t2 instanceof Rw && t2._encoderConfig && -1 === t2._hints.indexOf(jA.SCREEN_TRACK))) return;
        const n2 = t2._encoderConfig;
        IA().supportMinBitrate && n2.bitrateMin && e2.attributes.payloads.forEach((e3) => {
          var t3, i3;
          bn(t3 = ["h264", "h265", "vp8", "vp9", "av1"]).call(t3, (null === (i3 = e3.rtpMap) || void 0 === i3 ? void 0 : i3.encodingName.toLowerCase()) || "") && (e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters["x-google-min-bitrate"] = "".concat(n2.bitrateMin));
        }), IA().supportMinBitrate && !bn(i2 = t2._hints).call(i2, jA.LOW_STREAM) && n2.bitrateMax && e2.attributes.payloads.forEach((e3) => {
          var t3, i3;
          bn(t3 = ["h264", "h265", "vp8", "vp9", "av1"]).call(t3, (null === (i3 = e3.rtpMap) || void 0 === i3 ? void 0 : i3.encodingName.toLowerCase()) || "") && (e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters["x-google-start-bitrate"] = "".concat(RC("X_GOOGLE_START_BITRATE") || Math.floor(n2.bitrateMax)));
        });
      }
      function Ax(e2) {
        if ("video" !== e2.media.mediaType) return;
        const t2 = Sg();
        if (t2.name !== Eg.SAFARI && t2.os !== _g.IOS) return;
        const i2 = e2.attributes.extmaps.findIndex((e3) => /video-orientation/g.test(e3.extensionName));
        -1 !== i2 && e2.attributes.extmaps.splice(i2, 1);
      }
      function bx(e2, t2, i2) {
        if (!t2) return;
        let n2, r2;
        if ("video" === e2.media.mediaType ? (n2 = i2.videoExtensions, r2 = i2.videoCodecs) : (n2 = i2.audioExtensions, r2 = i2.audioCodecs), true === t2.twcc) {
          const t3 = n2.find((e3) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e3.extensionName);
          if (t3) {
            e2.attributes.extmaps.find((e3) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e3.extensionName) || e2.attributes.extmaps.push({ entry: t3.entry, extensionName: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" });
            const i3 = function(e3, t4) {
              return t4.filter((t5) => !!e3.find((e4) => e4.payloadType === t5.payloadType && !!e4.rtcpFeedbacks.find((e5) => "transport-cc" === e5.type)));
            }(r2, e2.attributes.payloads);
            i3.forEach((e3) => {
              e3.rtcpFeedbacks.find((e4) => "transport-cc" === e4.type) || e3.rtcpFeedbacks.push({ type: "transport-cc" });
            });
          }
        } else if (false === t2.twcc) {
          const t3 = e2.attributes.extmaps.findIndex((e3) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e3.extensionName);
          -1 !== t3 && e2.attributes.extmaps.splice(t3, 1), e2.attributes.payloads.forEach((e3) => {
            const t4 = e3.rtcpFeedbacks.findIndex((e4) => "transport-cc" === e4.type);
            -1 !== t4 && e3.rtcpFeedbacks.splice(t4, 1);
          });
        }
        if (true === t2.remb) {
          const t3 = n2.find((e3) => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e3.extensionName);
          if (t3) {
            e2.attributes.extmaps.find((e3) => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e3.extensionName) || e2.attributes.extmaps.push({ entry: t3.entry, extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" });
            const i3 = function(e3, t4) {
              return t4.filter((t5) => !!e3.find((e4) => e4.payloadType === t5.payloadType && !!e4.rtcpFeedbacks.find((e5) => "goog-remb" === e5.type)));
            }(r2, e2.attributes.payloads);
            i3.forEach((e3) => {
              e3.rtcpFeedbacks.find((e4) => "goog-remb" === e4.type) || e3.rtcpFeedbacks.push({ type: "goog-remb" });
            });
          }
        } else if (false === t2.remb) {
          const t3 = e2.attributes.extmaps.findIndex((e3) => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e3.extensionName);
          -1 !== t3 && e2.attributes.extmaps.splice(t3, 1), e2.attributes.payloads.forEach((e3) => {
            const t4 = e3.rtcpFeedbacks.findIndex((e4) => "goog-remb" === e4.type);
            -1 !== t4 && e3.rtcpFeedbacks.splice(t4, 1);
          });
        }
      }
      function wx(e2, t2, i2) {
        if (wg()) return;
        if ("video" !== e2.media.mediaType) return;
        if (!(t2 instanceof Rw)) return;
        if ("vp9" !== i2 && "vp8" !== i2) return;
        if ("vp8" === i2 && !RC("SIMULCAST")) return;
        if (void 0 === t2._scalabilityMode || t2._scalabilityMode.numSpatialLayers <= 1) return;
        const n2 = "vp8" === i2 ? 2 : t2._scalabilityMode.numSpatialLayers, r2 = e2.attributes.ssrcs[0], s2 = e2.attributes.ssrcGroups.find((e3) => "FID" === e3.semantic && e3.ssrcIds[0] === r2.ssrcId), o2 = { semantic: "SIM", ssrcIds: [r2.ssrcId] };
        for (let t3 = 1; t3 < n2; t3++) e2.attributes.ssrcs.push({ ssrcId: r2.ssrcId + t3, attributes: YT(r2.attributes) }), o2.ssrcIds.push(r2.ssrcId + t3), s2 && (e2.attributes.ssrcs.push({ ssrcId: s2.ssrcIds[1] + t3, attributes: YT(r2.attributes) }), e2.attributes.ssrcGroups.push({ semantic: "FID", ssrcIds: [r2.ssrcId + t3, s2.ssrcIds[1] + t3] }));
        e2.attributes.ssrcGroups.unshift(o2);
      }
      async function Ox() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const i2 = new RTCPeerConnection();
        i2.addTransceiver("video", { direction: "sendonly" }), i2.addTransceiver("audio", { direction: "sendonly" }), i2.addTransceiver("video", { direction: "recvonly" }), i2.addTransceiver("audio", { direction: "recvonly" });
        const n2 = (await i2.createOffer()).sdp, { send: r2, recv: s2, sendrecv: o2 } = function() {
          let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i3 = arguments.length > 2 ? arguments[2] : void 0;
          const n3 = gx(i3, e3, t3, "sendonly"), r3 = gx(i3, e3, t3, "recvonly"), s3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, o3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, a2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
          if (Dx(n3, r3, "videoExtensions", s3, o3, a2), Dx(n3, r3, "videoCodecs", s3, o3, a2), Dx(n3, r3, "audioExtensions", s3, o3, a2), Dx(n3, r3, "audioCodecs", s3, o3, a2), RC("RAISE_H264_BASELINE_PRIORITY")) {
            const e4 = a2.videoCodecs.findIndex((e5) => {
              var t4, i4;
              return "h264" === (null === (t4 = e5.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLocaleLowerCase()) && "42001f" === (null === (i4 = e5.fmtp) || void 0 === i4 ? void 0 : i4.parameters["profile-level-id"]);
            });
            if (-1 !== e4) {
              const t4 = a2.videoCodecs.findIndex((e5) => {
                var t5;
                return "h264" === (null === (t5 = e5.rtpMap) || void 0 === t5 ? void 0 : t5.encodingName.toLocaleLowerCase());
              });
              if (t4 < e4) {
                jC.debug("raising H264 baseline profile priority");
                const i4 = a2.videoCodecs[e4];
                a2.videoCodecs.splice(e4, 1), a2.videoCodecs.splice(t4, 0, i4);
              }
              -1 !== t4 && (o3.videoCodecs = o3.videoCodecs.filter((e5) => {
                var t5, i4;
                return !("h264" === (null === (t5 = e5.rtpMap) || void 0 === t5 ? void 0 : t5.encodingName.toLocaleLowerCase()) && "42001f" !== (null === (i4 = e5.fmtp) || void 0 === i4 ? void 0 : i4.parameters["profile-level-id"]));
              })), -1 !== t4 && RC("FILTER_SEND_H264_BASELINE") && (s3.videoCodecs = s3.videoCodecs.filter((e5) => {
                var t5, i4;
                return !("h264" === (null === (t5 = e5.rtpMap) || void 0 === t5 ? void 0 : t5.encodingName.toLocaleLowerCase()) && "42001f" !== (null === (i4 = e5.fmtp) || void 0 === i4 ? void 0 : i4.parameters["profile-level-id"]));
              }));
            }
          }
          return { send: s3, recv: o3, sendrecv: a2 };
        }(e2, t2, n2);
        try {
          i2.close();
        } catch (e3) {
        }
        return { send: r2, recv: s2, sendrecv: o2 };
      }
      function Nx() {
        const e2 = { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, t2 = gx(arguments.length > 2 ? arguments[2] : void 0, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, "recvonly"), i2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, n2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, r2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
        if (Dx(e2, t2, "videoExtensions", i2, n2, r2), Dx(e2, t2, "videoCodecs", i2, n2, r2), Dx(e2, t2, "audioExtensions", i2, n2, r2), Dx(e2, t2, "audioCodecs", i2, n2, r2), RC("RAISE_H264_BASELINE_PRIORITY")) {
          const e3 = r2.videoCodecs.findIndex((e4) => e4.rtpMap && "h264" === e4.rtpMap.encodingName.toLocaleLowerCase() && e4.fmtp && "42001f" === e4.fmtp.parameters["profile-level-id"]);
          if (-1 !== e3) {
            const t3 = r2.videoCodecs.findIndex((e4) => e4.rtpMap && "h264" === e4.rtpMap.encodingName.toLocaleLowerCase());
            if (t3 < e3) {
              jC.debug("raising H264 baseline profile priority");
              const i3 = r2.videoCodecs[e3];
              r2.videoCodecs.splice(e3, 1), r2.videoCodecs.splice(t3, 0, i3);
            }
            -1 !== t3 && (n2.videoCodecs = n2.videoCodecs.filter((e4) => !(e4.rtpMap && "h264" === e4.rtpMap.encodingName.toLocaleLowerCase() && e4.fmtp && "42001f" !== e4.fmtp.parameters["profile-level-id"])));
          }
        }
        return { send: i2, recv: n2, sendrecv: r2 };
      }
      function Dx(e2, t2, i2, n2, r2, s2) {
        if ("videoExtensions" === i2 || "audioExtensions" === i2) {
          const o2 = [];
          return e2[i2].forEach((e3) => {
            t2[i2].some((t3, i3) => {
              if (e3.entry === t3.entry && e3.extensionName === t3.extensionName) return o2.push(i3), true;
            }) ? s2[i2].push(e3) : n2[i2].push(e3);
          }), void t2[i2].forEach((e3, t3) => {
            -1 === o2.indexOf(t3) && r2[i2].push(e3);
          });
        }
        if ("videoCodecs" === i2 || "audioCodecs" === i2) {
          const o2 = [];
          return e2[i2].forEach((e3) => {
            t2[i2].some((t3, i3) => {
              if (e3.payloadType === t3.payloadType && JSON.stringify(e3) === JSON.stringify(t3)) return o2.push(i3), true;
            }) ? s2[i2].push(e3) : n2[i2].push(e3);
          }), void t2[i2].forEach((e3, t3) => {
            -1 === o2.indexOf(t3) && r2[i2].push(e3);
          });
        }
      }
      function Px(e2) {
        const { send: t2, recv: i2, sendrecv: n2 } = e2;
        if (!n2) {
          if (!t2 || !i2) throw new Error("cannot merge rtp capabilities because one of send or recv is empty!");
          return { send: t2, recv: i2 };
        }
        let r2, s2;
        return t2 ? (r2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, r2.audioCodecs = [...t2.audioCodecs, ...n2.audioCodecs], r2.videoCodecs = [...t2.videoCodecs, ...n2.videoCodecs], r2.audioExtensions = [...t2.audioExtensions, ...n2.audioExtensions], r2.videoExtensions = [...t2.videoExtensions, ...n2.videoExtensions]) : r2 = n2, i2 ? (s2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, s2.audioCodecs = [...i2.audioCodecs, ...n2.audioCodecs], s2.videoCodecs = [...i2.videoCodecs, ...n2.videoCodecs], s2.audioExtensions = [...i2.audioExtensions, ...n2.audioExtensions], s2.videoExtensions = [...i2.videoExtensions, ...n2.videoExtensions]) : s2 = n2, { send: r2, recv: s2 };
      }
      function Lx(e2) {
        if ("audio" !== e2.media.mediaType) return;
        e2.attributes.payloads.filter((e3) => {
          var t2;
          return "opus" === (null === (t2 = e3.rtpMap) || void 0 === t2 ? void 0 : t2.encodingName.toLowerCase());
        }).forEach((e3) => {
          e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters.stereo = "1", e3.fmtp.parameters["sprop-stereo"] = "1";
        });
      }
      function kx(e2) {
        e2.mediaDescriptions.forEach((e3) => {
          "video" !== e3.media.mediaType && "audio" !== e3.media.mediaType || e3.attributes.payloads.forEach((e4) => {
            -1 === e4.rtcpFeedbacks.findIndex((e5) => "rrtr" === e5.type) && e4.rtcpFeedbacks.push({ type: "rrtr" });
          });
        });
      }
      function Mx(e2, t2, i2, n2) {
        let r2 = [];
        if (e2 === av.VIDEO) {
          if (RC("H264_PROFILE_LEVEL_ID") && "h264" === n2 && (r2 = t2.videoCodecs.filter((e3) => {
            var t3;
            return bn(t3 = e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "").call(t3, n2) && e3 && e3.fmtp && e3.fmtp.parameters["profile-level-id"] === RC("H264_PROFILE_LEVEL_ID");
          })), !Array.isArray(r2) || 0 === r2.length) {
            let e3 = [];
            const s2 = [], o2 = [];
            i2.videoCodecs.forEach((t3) => {
              var i3, r3, a2;
              bn(i3 = t3.rtpMap && t3.rtpMap.encodingName.toLowerCase() || "").call(i3, n2) && e3.push(t3), bn(r3 = t3.rtpMap && t3.rtpMap.encodingName.toLowerCase() || "").call(r3, "vp8") && s2.push(t3), bn(a2 = t3.rtpMap && t3.rtpMap.encodingName.toLowerCase() || "").call(a2, "h264") && o2.push(t3);
            }), 0 === e3.length && (0 !== s2.length ? (e3 = s2, jC.warning("codec ".concat(n2, " not included in rtpCapabilities, fallback to default payloads: vp8"))) : 0 !== o2.length && (e3 = o2, jC.warning("codec ".concat(n2, " not included in rtpCapabilities, fallback to default payloads: h264")))), 0 !== e3.length && (r2 = t2.videoCodecs.filter((t3) => e3.some((e4) => e4.payloadType === t3.payloadType)));
          }
          if (RC("USE_PUB_RTX")) {
            const e3 = r2.map((e4) => e4.payloadType.toString()), i3 = t2.videoCodecs.filter((t3) => t3.rtpMap && "rtx" === t3.rtpMap.encodingName && bn(e3).call(e3, t3.fmtp && t3.fmtp.parameters.apt || ""));
            r2 = [...r2, ...i3];
          }
          0 === r2.length && (jC.warning("codec ".concat(n2, " not included in rtpCapabilities, fallback to default payloads: ").concat(t2.videoCodecs[0].rtpMap && t2.videoCodecs[0].rtpMap.encodingName)), r2 = t2.videoCodecs);
        } else r2 = t2.audioCodecs.filter((e3) => {
          var t3;
          return bn(t3 = e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "").call(t3, n2);
        }), 0 === r2.length && (jC.warning("codec ".concat(n2, " not included in rtpCapabilities, fallback to opus")), r2 = t2.audioCodecs.filter((e3) => {
          var t3;
          return bn(t3 = e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "").call(t3, "opus");
        }));
        return r2;
      }
      let Ux = class {
        get localCapabilities() {
          return YT(this._localCapabilities);
        }
        get rtpCapabilities() {
          return YT(this._rtpCapabilities);
        }
        get candidates() {
          return YT(this._candidates);
        }
        get iceParameters() {
          return YT(this._iceParameters);
        }
        get dtlsParameters() {
          return YT(this._dtlsParameters);
        }
        constructor(e2) {
          sh(this, "sessionDesc", void 0), sh(this, "_localCapabilities", void 0), sh(this, "_rtpCapabilities", void 0), sh(this, "_candidates", void 0), sh(this, "_iceParameters", void 0), sh(this, "_dtlsParameters", void 0), sh(this, "setup", void 0), sh(this, "currentMidIndex", void 0), sh(this, "cname", "o/i14u9pJrxRKAsu"), sh(this, "firefoxSsrcMidMap", /* @__PURE__ */ new Map()), e2 = YT(e2);
          const { remoteIceParameters: t2, remoteDtlsParameters: i2, candidates: n2, remoteRTPCapabilities: r2, localCapabilities: s2, direction: o2, setup: a2, videoCodec: c2, audioCodec: d2 } = e2;
          let l2;
          this.setup = a2, l2 = o2 === TI.RECEIVE_ONLY ? JU.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=extmap-allow-mixed\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n") : JU.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=extmap-allow-mixed\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=recvonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=recvonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n"), this._rtpCapabilities = r2, this._candidates = n2, this._iceParameters = t2, this._dtlsParameters = i2, this._localCapabilities = s2;
          const u2 = o2 === TI.RECEIVE_ONLY ? this.rtpCapabilities.send : this.rtpCapabilities.recv, h3 = o2 === TI.RECEIVE_ONLY ? this._localCapabilities.recv : this._localCapabilities.send, p2 = o2 === TI.RECEIVE_ONLY ? r2.send.videoCodecs : Mx(av.VIDEO, u2, h3, c2), _2 = o2 === TI.RECEIVE_ONLY ? r2.send.audioCodecs : Mx(av.AUDIO, u2, h3, d2);
          for (const e3 of l2.mediaDescriptions) {
            if (e3.attributes.iceUfrag = t2.iceUfrag, e3.attributes.icePwd = t2.icePwd, e3.attributes.fingerprints = i2.fingerprints, e3.attributes.candidates = n2, e3.attributes.setup = this.setup, "application" === e3.media.mediaType && (e3.attributes.sctpPort = "5000"), "video" === e3.media.mediaType && (e3.media.fmts = p2.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = p2, e3.attributes.extmaps = u2.videoExtensions, RC("PRELOAD_MEDIA_COUNT") > 0)) {
              const { ssrcs: t3, ssrcGroups: i3 } = Cx([{ ssrcId: 4e4, rtx: RC("USE_SUB_RTX") ? 40001 : void 0 }], this.cname);
              e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = i3;
            }
            if ("audio" === e3.media.mediaType && (e3.media.fmts = _2.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = _2, e3.attributes.extmaps = u2.audioExtensions, Lx(e3), RC("PRELOAD_MEDIA_COUNT") > 0)) {
              const { ssrcs: t3, ssrcGroups: i3 } = Cx([{ ssrcId: 2e4 }], this.cname);
              e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = i3;
            }
          }
          this.sessionDesc = l2, this.currentMidIndex = l2.mediaDescriptions.length - 1;
        }
        toString() {
          return JU.print(this.sessionDesc);
        }
        hasMid(e2) {
          return Array.isArray(e2) ? e2.every((e3) => this.hasMid(e3)) : this.sessionDesc.mediaDescriptions.some((t2) => t2.attributes.mid === e2);
        }
        send(e2, t2, i2, n2, r2) {
          i2 = i2.replace(/ /g, "-");
          const { ssrcs: s2, ssrcGroups: o2 } = Cx(t2, this.cname, RC("SYNC_GROUP") ? i2 : void 0), a2 = this.findPreloadMediaDesc(s2);
          if (a2) {
            if (wg() && this.firefoxSsrcMidMap.set(s2[0].ssrcId, a2.attributes.mid), r2 && (r2.twcc || r2.remb)) {
              const e3 = this.sessionDesc.mediaDescriptions.indexOf(a2);
              return this.sessionDesc.mediaDescriptions[e3] = this.mungSendMediaDesc(a2, r2), { mid: a2.attributes.mid, needExchangeSDP: true };
            }
            return { mid: a2.attributes.mid, needExchangeSDP: false };
          }
          {
            const t3 = this.findAvailableMediaIndex(e2, s2, n2);
            let i3;
            return -1 === t3 ? (i3 = this.createOrRecycleSendMedia(e2, s2, o2, "sendonly", n2, r2), this.updateBundleMids()) : (i3 = YT(this.sessionDesc.mediaDescriptions[t3]), i3.attributes.direction = "sendonly", i3.attributes.ssrcs = s2, i3.attributes.ssrcGroups = o2, this.sessionDesc.mediaDescriptions[t3] = this.mungSendMediaDesc(i3, r2)), wg() && this.firefoxSsrcMidMap.set(s2[0].ssrcId, i3.attributes.mid), { needExchangeSDP: true, mid: i3.attributes.mid };
          }
        }
        stopSending(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => t3.attributes.mid && -1 !== e2.indexOf(t3.attributes.mid));
          if (t2.length !== e2.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
          t2.forEach((e3) => {
            e3.attributes.ssrcs = [];
          }), this.updateBundleMids();
        }
        receive(e2, t2, i2) {
          const n2 = [];
          return e2.forEach((e3) => {
            const r2 = e3._mediaStreamTrack.kind, s2 = this.findAvailableRecvMediaIndex(r2);
            let o2, a2 = false;
            -1 === s2 ? (a2 = true, o2 = this.createOrRecycleRecvMedia(e3, [], "recvonly", t2, i2), this.updateBundleMids()) : (o2 = YT(this.sessionDesc.mediaDescriptions[s2]), o2.attributes.direction = "recvonly"), n2.push({ mid: o2.attributes.mid, needCreateTransceiver: a2 });
          }), n2;
        }
        stopReceiving(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => -1 !== e2.indexOf(t3.attributes.mid));
          if (t2.length !== e2.length) throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
          t2.forEach((e3) => {
            e3.media.port = "0", e3.attributes.direction = "inactive";
          }), this.updateBundleMids();
        }
        addRemoteCandidate(e2) {
          const { foundation: t2, protocol: i2, address: n2, port: r2, type: s2, relatedAddress: o2, relatedPort: a2, priority: c2 } = new RTCIceCandidate(e2), d2 = { foundation: null != t2 ? t2 : "", componentId: "1", transport: null != i2 ? i2 : "", priority: c2 ? c2 + "" : "", connectionAddress: null != n2 ? n2 : "", port: r2 ? r2 + "" : "", type: s2 ? s2 + "" : "", relAddr: null != o2 ? o2 : "", relPort: a2 ? a2 + "" : "", extension: {} };
          this.candidates.some((e3) => e3.priority === d2.priority && e3.connectionAddress === d2.connectionAddress && e3.port === d2.port) || (this._candidates.push(d2), this.sessionDesc.mediaDescriptions.forEach((e3) => {
            e3.attributes.candidates = this.candidates;
          }));
        }
        clearRemoteCandidate() {
          this._candidates = [], this.sessionDesc.mediaDescriptions[0].attributes.candidates = this._candidates;
        }
        createOrRecycleRecvMedia(e2, t2, i2, n2, r2) {
          const s2 = e2._mediaStreamTrack.kind, o2 = this.rtpCapabilities.recv, a2 = Mx(s2, o2, this.localCapabilities.send, s2 === av.AUDIO ? r2 : n2), c2 = s2 === av.VIDEO ? o2.videoExtensions : o2.audioExtensions, d2 = "".concat(++this.currentMidIndex);
          let l2 = { media: { mediaType: s2, port: "9", protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: a2.map((e3) => e3.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: [], extmaps: c2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: a2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i2, rtcpMux: true, rtcpRsize: true, mid: "".concat(d2) } };
          l2 = this.mungRecvMediaDsec(l2, e2);
          const u2 = this.findFirstClosedMedia(s2);
          if (u2) {
            const e3 = this.sessionDesc.mediaDescriptions.indexOf(u2);
            this.sessionDesc.mediaDescriptions[e3] = l2;
          } else this.sessionDesc.mediaDescriptions.push(l2);
          return l2;
        }
        muteRemote(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => bn(e2).call(e2, t3.attributes.mid || ""));
          if (t2.length !== e2.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
          t2.forEach((e3) => {
            e3.attributes.direction = "inactive";
          });
        }
        unmuteRemote(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => bn(e2).call(e2, t3.attributes.mid || ""));
          if (t2.length !== e2.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
          t2.forEach((e3) => {
            e3.attributes.direction = "recvonly";
          });
        }
        findAvailableMediaIndex(e2, t2, i2) {
          return this.sessionDesc.mediaDescriptions.findIndex((n2) => {
            const r2 = n2.media.mediaType === e2 && "0" !== n2.media.port && ("sendonly" === n2.attributes.direction || "sendrecv" === n2.attributes.direction) && 0 === n2.attributes.ssrcs.length;
            if (wg()) {
              if (r2) {
                const e3 = this.firefoxSsrcMidMap.get(t2[0].ssrcId);
                return !(e3 || "0" !== n2.attributes.mid && "1" !== n2.attributes.mid) || !(!e3 || e3 !== n2.attributes.mid);
              }
              return false;
            }
            return r2 && n2.attributes.mid === i2;
          });
        }
        findAvailableRecvMediaIndex(e2) {
          return this.sessionDesc.mediaDescriptions.findIndex((t2) => {
            const i2 = t2.media.mediaType === e2 && "0" !== t2.media.port && ("recvonly" === t2.attributes.direction || "sendrecv" === t2.attributes.direction);
            return "0" !== t2.attributes.mid && "1" !== t2.attributes.mid && i2;
          });
        }
        predictReceivingMids(e2) {
          const t2 = [];
          for (let i2 = 0; i2 < e2; i2++) t2.push((this.currentMidIndex + i2 + 1).toString(10));
          return t2;
        }
        restartICE(e2) {
          e2 = YT(e2), this._iceParameters = e2, this.sessionDesc.mediaDescriptions.forEach((t2) => {
            t2.attributes.iceUfrag = e2.iceUfrag, t2.attributes.icePwd = e2.icePwd;
          });
        }
        createOrRecycleSendMedia(e2, t2, i2, n2, r2, s2) {
          const o2 = this.rtpCapabilities.send, a2 = e2 === av.VIDEO ? o2.videoCodecs : o2.audioCodecs, c2 = e2 === av.VIDEO ? o2.videoExtensions : o2.audioExtensions;
          wg() && (r2 = "".concat(++this.currentMidIndex));
          let d2 = { media: { mediaType: e2, port: "9", protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: a2.map((e3) => e3.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: [], extmaps: c2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: i2, rtcpFeedbackWildcards: [], payloads: a2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: n2, rtcpMux: true, rtcpRsize: true, mid: r2 } };
          d2 = this.mungSendMediaDesc(d2, s2);
          const l2 = this.findFirstClosedMedia(e2);
          if (l2) {
            const e3 = this.sessionDesc.mediaDescriptions.indexOf(l2);
            this.sessionDesc.mediaDescriptions[e3] = d2;
          } else this.sessionDesc.mediaDescriptions.push(d2);
          return d2;
        }
        mungRecvMediaDsec(e2, t2, i2) {
          const n2 = YT(e2);
          return vx(n2), Ix(n2, t2), yx(n2, t2), Ax(n2), bx(n2, i2, this.localCapabilities.send), n2;
        }
        mungSendMediaDesc(e2, t2) {
          const i2 = YT(e2);
          return bx(i2, t2, this.localCapabilities.recv), Lx(i2), i2;
        }
        updateRecvMedia(e2, t2) {
          const i2 = this.sessionDesc.mediaDescriptions.findIndex((t3) => t3.attributes.mid === e2);
          if (-1 !== i2) {
            const e3 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i2], t2);
            this.sessionDesc.mediaDescriptions[i2] = e3;
          }
        }
        updateBundleMids() {
          this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter((e2) => "0" !== e2.media.port).map((e2) => e2.attributes.mid);
        }
        findPreloadMediaDesc(e2) {
          return this.sessionDesc.mediaDescriptions.find((t2) => {
            var i2;
            return (null === (i2 = t2.attributes) || void 0 === i2 || null === (i2 = i2.ssrcs[0]) || void 0 === i2 ? void 0 : i2.ssrcId) === e2[0].ssrcId;
          });
        }
        findFirstClosedMedia(e2) {
          return this.sessionDesc.mediaDescriptions.find((t2) => wg() ? "0" === t2.media.port && t2.media.mediaType === e2 : "0" === t2.media.port);
        }
      };
      const xx = ["sdp"];
      function Vx(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function Fx(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Vx(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : Vx(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      let Bx = class e2 extends Ov {
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        get dtlsTransportState() {
          var e3, t2;
          return null !== (e3 = null === (t2 = this.peerConnection.getReceivers()[0]) || void 0 === t2 || null === (t2 = t2.transport) || void 0 === t2 ? void 0 : t2.state) && void 0 !== e3 ? e3 : null;
        }
        get localCodecs() {
          return [];
        }
        set isInRestartIce(e3) {
          this._isInRestartIce = e3;
        }
        get isInRestartIce() {
          return this._isInRestartIce;
        }
        constructor(t2, i2, n2) {
          super(t2, i2), sh(this, "direction", void 0), sh(this, "name", void 0), sh(this, "store", void 0), sh(this, "spec", void 0), sh(this, "peerConnection", void 0), sh(this, "initialOffer", void 0), sh(this, "transport", void 0), sh(this, "statsFilter", void 0), sh(this, "localCandidateCount", 0), sh(this, "allCandidatesReceived", false), sh(this, "localCandidateAddress", null), sh(this, "useXR", RC("USE_XR")), sh(this, "filter", { filterRTX: !RC("USE_PUB_RTX") && !RC("USE_SUB_RTX"), filterVideoFec: RC("FILTER_VIDEO_FEC"), filterAudioFec: RC("FILTER_AUDIO_FEC") }), sh(this, "extension", { useXR: this.useXR }), sh(this, "_isInRestartIce", false), sh(this, "mutex", new pS("P2PConnection-mutex")), sh(this, "onLocalCandidate", void 0), sh(this, "remoteSDP", void 0), sh(this, "pendingCandidates", []), sh(this, "localCapabilities", void 0), sh(this, "isReady", false), sh(this, "restartCnt", 0), sh(this, "curTurnServerIndex", 0), this.store = i2, this.spec = t2, this.peerConnection = new RTCPeerConnection(e2.resolvePCConfiguration(t2, i2.p2pTransport), { optional: [{ googDscp: true }] }), this.direction = null != n2 ? n2 : TI.SEND_ONLY, this.name = this.direction === TI.SEND_ONLY ? "sendP2PConnection" : "recvP2PConnection", this.statsFilter = Ex(this.peerConnection, RC("STATS_UPDATE_INTERVAL"), void 0, wg() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1;
        }
        async establish(e3) {
          try {
            const t2 = await Ox(this.filter, this.extension);
            if (this.localCapabilities = Px(t2), e3) {
              const { sdp: t3 } = e3, i2 = qU(e3, xx), n2 = function() {
                const e4 = { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, t4 = gx(arguments.length > 2 ? arguments[2] : void 0, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, "sendonly"), i3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, n3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, r3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
                if (Dx(t4, e4, "videoExtensions", i3, n3, r3), Dx(t4, e4, "videoCodecs", i3, n3, r3), Dx(t4, e4, "audioExtensions", i3, n3, r3), Dx(t4, e4, "audioCodecs", i3, n3, r3), RC("RAISE_H264_BASELINE_PRIORITY")) {
                  const e5 = r3.videoCodecs.findIndex((e6) => e6.rtpMap && "h264" === e6.rtpMap.encodingName.toLocaleLowerCase() && e6.fmtp && "42001f" === e6.fmtp.parameters["profile-level-id"]);
                  if (-1 !== e5) {
                    const t5 = r3.videoCodecs.findIndex((e6) => e6.rtpMap && "h264" === e6.rtpMap.encodingName.toLocaleLowerCase());
                    if (t5 < e5) {
                      jC.debug("raising H264 baseline profile priority");
                      const i4 = r3.videoCodecs[e5];
                      r3.videoCodecs.splice(e5, 1), r3.videoCodecs.splice(t5, 0, i4);
                    }
                    -1 !== t5 && RC("FILTER_SEND_H264_BASELINE") && (i3.videoCodecs = i3.videoCodecs.filter((e6) => !(e6.rtpMap && "h264" === e6.rtpMap.encodingName.toLocaleLowerCase() && e6.fmtp && "42001f" !== e6.fmtp.parameters["profile-level-id"])));
                  }
                }
                return { send: i3, recv: n3, sendrecv: r3 };
              }(this.filter, this.extension, t3);
              this.remoteSDP = new Ux({ remoteIceParameters: i2.iceParameters, remoteDtlsParameters: i2.dtlsParameters, candidates: [], remoteRTPCapabilities: n2, localCapabilities: this.localCapabilities, direction: this.direction, setup: "actpass", videoCodec: this.store.codec, audioCodec: this.store.audioCodec }), await this.setRemoteDescription({ type: "offer", sdp: this.remoteSDP.toString() }), this.isReady = true;
              const r2 = await this.peerConnection.createAnswer();
              if (!r2.sdp) throw new Error("Cannot get answer sdp when trying to establish PeerConnection.");
              const s2 = Tx(r2.sdp);
              await this.peerConnection.setLocalDescription(r2);
              const o2 = await Nx(this.filter, this.extension, r2.sdp);
              this.localCapabilities = Px(o2);
              const a2 = this.peerConnection.getTransceivers()[0];
              return null != a2 && a2.receiver && a2.receiver.transport && this.tryBindTransportEvents(a2.receiver.transport), Fx(Fx({}, s2), {}, { sdp: r2.sdp });
            }
            {
              this.peerConnection.addTransceiver("video", { direction: "sendonly" }), this.peerConnection.addTransceiver("audio", { direction: "sendonly" });
              const e4 = await this.peerConnection.createOffer();
              if (!e4.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
              const t3 = Tx(e4.sdp);
              return this.initialOffer = e4, Fx(Fx({}, t3), {}, { sdp: e4.sdp });
            }
          } catch (e4) {
            throw new Kg(Hg.GET_LOCAL_CONNECTION_PARAMS_FAILED, e4.toString());
          }
        }
        async connect(e3) {
          try {
            if (!this.initialOffer) throw new Error("Cannot establish P2PConnection without initial offer.");
            await this.peerConnection.setLocalDescription(this.initialOffer);
            const { sdp: t2, iceParameters: i2, dtlsParameters: n2 } = e3, r2 = await Nx(this.filter, this.extension, t2);
            this.remoteSDP = new Ux({ remoteIceParameters: i2, remoteDtlsParameters: n2, candidates: [], remoteRTPCapabilities: r2, localCapabilities: this.localCapabilities, direction: this.direction, setup: "active", videoCodec: this.store.codec, audioCodec: this.store.audioCodec }), await this.setRemoteDescription({ type: "answer", sdp: this.remoteSDP.toString() });
            const s2 = this.peerConnection.getTransceivers()[0];
            null != s2 && s2.sender && s2.sender.transport && this.tryBindTransportEvents(s2.sender.transport);
          } catch (e4) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e4.toString()));
          }
        }
        async addRemoteCandidate(e3) {
          try {
            e3 && this.pendingCandidates.push(e3), this.peerConnection.remoteDescription && this.isReady && (this.pendingCandidates.forEach((e4) => {
              this.peerConnection.addIceCandidate(e4);
            }), this.pendingCandidates = []);
          } catch (e4) {
            throw new Kg(Hg.ADD_CANDIDATE_FAILED, "P2PConnection.addRemoteCandidate failed; ".concat(e4.toString()));
          }
        }
        send(e3, t2, i2) {
          var n2 = this;
          return PU(function* () {
            const r2 = yield IU(n2.mutex.lock("From P2PConnection.send"));
            try {
              if (!n2.remoteSDP) throw new Error("Cannot call P2PConnection.send before remote SDP created");
              const s2 = [], o2 = n2.remoteSDP.receive(e3, t2, i2);
              e3.forEach((e4, t3) => {
                if (o2[t3].needCreateTransceiver) {
                  const t4 = n2.peerConnection.addTransceiver(e4._mediaStreamTrack, { direction: "sendonly" });
                  s2.push(t4), e4._updateRtpTransceiver(t4);
                } else {
                  const i3 = n2.peerConnection.getTransceivers().find((e5) => e5.mid === o2[t3].mid);
                  if (!i3) throw new Error("cannot find transceiver when sendPeerconnection send, mid is ".concat(o2[t3].mid));
                  s2.push(i3), e4._updateRtpTransceiver(i3);
                }
              }), wg() && true === RC("SIMULCAST") && (yield IU(n2.applySimulcastForFirefox(s2, e3)));
              const a2 = o2.map((e4) => e4.mid), c2 = yield IU(n2.peerConnection.createOffer()), d2 = n2.mungSendOfferSDP(c2.sdp, e3, a2), l2 = JU.parse(d2), u2 = a2.map((e4) => {
                const t3 = l2.mediaDescriptions.find((t4) => t4.attributes.mid === e4);
                if (!t3) throw new Error("Cannot extract ssrc from mediaDescription.");
                return Sx(t3, RC("USE_PUB_RTX"));
              }), h3 = s2.map((e4, t3) => {
                const i3 = a2[t3];
                return { localSSRC: u2[t3], id: i3 };
              });
              yield IU(n2.peerConnection.setLocalDescription({ type: "offer", sdp: d2 }));
              try {
                yield h3;
              } catch (e4) {
                const t3 = n2.remoteSDP.toString();
                throw yield IU(n2.peerConnection.setLocalDescription({ type: "offer", sdp: d2 })), yield IU(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: t3 })), yield IU(n2.stopSending(a2, true)), e4;
              }
              yield IU(n2.applySimulcastEncodings(s2, e3)), yield IU(n2.applySendEncodings(s2, e3));
              const p2 = n2.remoteSDP.toString(), _2 = n2.logSDPExchange(d2, "offer", "local", "send");
              return null == _2 || _2(p2), yield IU(n2.setRemoteDescription({ type: "answer", sdp: p2 })), s2.map((e4, t3) => {
                const i3 = a2[t3];
                return { localSSRC: u2[t3], id: i3 };
              });
            } catch (e4) {
              throw e4 instanceof Kg ? e4 : new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e4.toString()));
            } finally {
              r2();
            }
          })();
        }
        async stopSending(e3, t2) {
          const i2 = t2 ? void 0 : await this.mutex.lock("From P2PConnection.stopSending");
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
            const t3 = this.peerConnection.getTransceivers().filter((t4) => -1 !== e3.indexOf(t4.mid));
            if (t3.length !== e3.length) throw new Error("Transceivers' length (".concat(t3.length, ") doesn't match mids' length (").concat(e3.length, ") when trying to call P2PConnection.stopSending."));
            t3.map((e4) => {
              var t4;
              e4.direction = "inactive", null === (t4 = e4.stop) || void 0 === t4 || t4.call(e4);
            });
            const n2 = await this.peerConnection.createOffer(), r2 = this.logSDPExchange(n2.sdp || "", "offer", "local", "stopSending");
            await this.peerConnection.setLocalDescription(n2), this.remoteSDP.stopReceiving(e3);
            const s2 = this.remoteSDP.toString();
            null == r2 || r2(s2), await this.setRemoteDescription({ type: "answer", sdp: s2 });
          } catch (e4) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e4.toString()));
          } finally {
            i2 && i2();
          }
        }
        async receive(e3, t2, i2, n2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e3, " before remoteSDP created."));
            const { mid: r2, needExchangeSDP: s2 } = this.remoteSDP.send(e3, t2, i2, n2);
            if (s2) {
              const t3 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t3, "offer", "remote", "receive");
              await this.setRemoteDescription({ type: "offer", sdp: t3 });
              const n3 = await this.peerConnection.createAnswer(), s3 = this.mungReceiveAnswerSDP(n3.sdp, r2, e3);
              null == i3 || i3(s3 || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: s3 }), jC.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " by exchanging SDP."));
            } else jC.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " no need to exchange SDP."));
            const o2 = this.peerConnection.getTransceivers().find((e4) => e4.mid === r2);
            if (!o2 || null === o2.mid) throw new Error("Cannot get transceiver after setLocalDescription.");
            return { track: o2.receiver.track, mid: o2.mid, transceiver: o2 };
          } catch (e4) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async mockReceive(e3, t2, i2, n2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e3, " before remoteSDP created."));
            const { mid: r2, needExchangeSDP: s2 } = this.remoteSDP.send(e3, t2, i2, n2);
            if (s2) {
              const t3 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t3, "offer", "remote", "receive");
              await this.setRemoteDescription({ type: "offer", sdp: t3 });
              const n3 = await this.peerConnection.createAnswer(), s3 = this.mungReceiveAnswerSDP(n3.sdp, r2, e3);
              null == i3 || i3(s3 || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: s3 }), jC.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " by exchanging SDP."));
            } else jC.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " no need to exchange SDP."));
          } catch (e4) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async stopReceiving(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
            this.remoteSDP.stopSending(e3);
            const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "stopReceiving");
            await this.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e4) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e4.toString()));
          }
        }
        async restartICE(t2) {
          try {
            if (this.store.p2pTransport === fC.Auto && (this.store.p2pTransport = fC.SdRtn, IA().supportPCSetConfiguration && this.peerConnection.setConfiguration(e2.resolvePCConfiguration(this.spec, this.store.p2pTransport))), this.restartCnt > 3 && (this.restartCnt = 0, IA().supportPCSetConfiguration && this.peerConnection.setConfiguration(e2.resolvePCConfiguration(this.spec, this.store.p2pTransport, ++this.curTurnServerIndex))), !t2) {
              this.restartCnt++, this.isReady = false;
              const e3 = await this.peerConnection.createOffer({ iceRestart: true });
              if (!e3.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist.");
              const { iceParameters: t3 } = Tx(e3.sdp);
              return this.store.descriptionStart(), this.direction === TI.SEND_ONLY && await this.peerConnection.setLocalDescription(e3), t3;
            }
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
            if (this.remoteSDP.restartICE(t2), this.store.descriptionStart(), this.direction === TI.RECEIVE_ONLY) {
              this.restartCnt++, await this.setRemoteDescription({ type: "offer", sdp: this.remoteSDP.toString() });
              const e3 = await this.peerConnection.createAnswer();
              if (!e3.sdp) throw new Error("Cannot get answer sdp when trying to iceRestart.");
              const { iceParameters: t3 } = Tx(e3.sdp);
              return await this.peerConnection.setLocalDescription(e3), t3;
            }
            await this.setRemoteDescription({ type: "answer", sdp: this.remoteSDP.toString() }), this.isReady = true;
          } catch (e3) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e3.toString()));
          }
        }
        close() {
          var e3;
          this.peerConnection.close(), this.peerConnection.onicecandidate = null, null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, "closed"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.transport = void 0, this.statsFilter.destroy();
        }
        getStats() {
          return this.statsFilter.getStats();
        }
        getRemoteVideoIsReady(e3) {
          return this.statsFilter.getVideoIsReady(e3);
        }
        async updateEncoderConfig(e3, t2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
            const i2 = await this.peerConnection.createOffer(), n2 = this.mungSendOfferSDP(i2.sdp, [t2], [e3]);
            this.remoteSDP.updateRecvMedia(e3, t2);
            const r2 = this.remoteSDP.toString(), s2 = this.logSDPExchange(n2, "offer", "local", "updateEncoderConfig");
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: n2 }), null == s2 || s2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, e4.toString());
          }
        }
        async updateSendParameters(e3, t2) {
          const i2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid === e3);
          1 === i2.length && (this.isVP8Simulcast(t2) ? wg() || await this.applySimulcastEncodings(i2, [t2]) : await this.applySendEncodings(i2, [t2]));
        }
        setStatsRemoteVideoIsReady(e3, t2) {
          this.statsFilter.setVideoIsReady2(e3, t2);
        }
        async replaceTrack(e3, t2) {
          const i2 = this.peerConnection.getTransceivers().find((e4) => e4.mid === t2);
          i2 && await i2.sender.replaceTrack(e3._mediaStreamTrack);
        }
        async getSelectedCandidatePair() {
          const e3 = this.peerConnection.getReceivers();
          if (e3.length > 0 && e3[0].transport && e3[0].transport.iceTransport && e3[0].transport.iceTransport.getSelectedCandidatePair && e3[0].transport.iceTransport.getSelectedCandidatePair()) {
            const t2 = e3[0].transport.iceTransport, { local: i2, remote: n2 } = t2.getSelectedCandidatePair();
            return { local: Fx(Fx({}, $U), {}, { candidateType: i2.type, protocol: i2.protocol, address: i2.address, port: i2.port }), remote: Fx(Fx({}, $U), {}, { candidateType: n2.type, protocol: n2.protocol, address: n2.address, port: n2.port }) };
          }
          return this.statsFilter.getSelectedCandidatePair();
        }
        bindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = () => {
            var e3, t2;
            bn(e3 = ["connected", "completed"]).call(e3, this.peerConnection.iceConnectionState) && (this.isReady = false), null === (t2 = this.onICEConnectionStateChange) || void 0 === t2 || t2.call(this, this.peerConnection.iceConnectionState);
          }, this.peerConnection.onconnectionstatechange = () => {
            var e3;
            "connected" === this.peerConnection.connectionState && (this.restartCnt = 0), null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.connectionState);
          }, this.startICECandidate();
        }
        startICECandidate() {
          this.peerConnection.onicecandidate || (this.localCandidateCount = 0, this.peerConnection.onicecandidate = (e3) => {
            if (e3.candidate) {
              var t2;
              if (e3.candidate.candidate) this.localCandidateAddress = e3.candidate.address, null === (t2 = this.onLocalCandidate) || void 0 === t2 || t2.call(this, e3.candidate.toJSON());
              this.localCandidateCount += 1;
            } else this.allCandidatesReceived = true, jC.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount);
          });
        }
        unbindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
        }
        static resolvePCConfiguration(t2, i2) {
          let n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
          const r2 = { iceServers: [] };
          var s2;
          t2.iceServers ? r2.iceServers = t2.iceServers : t2.turnServer && "off" !== t2.turnServer.mode && (RT(t2.turnServer.servers) ? r2.iceServers = t2.turnServer.servers : (r2.iceServers && r2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.servers, i2, n2)), RC("USE_TURN_SERVER_OF_GATEWAY") && r2.iceServers && t2.turnServer.serversFromGateway && r2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.serversFromGateway, i2, n2)), bn(s2 = [fC.Relay, fC.SdRtn]).call(s2, i2) && (r2.iceTransportPolicy = "relay"), RC("FORCE_TURN_TCP") ? r2.iceTransportPolicy = "relay" : t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach((e3) => {
            e3.forceturn && (r2.iceTransportPolicy = "relay");
          })));
          return RC("ENABLE_ENCODED_TRANSFORM") && IA().supportWebRTCEncodedTransform && (r2.encodedInsertableStreams = true), jC.debug("P2PConnection p2pTransport is ".concat(i2)), r2;
        }
        static turnServerConfigToIceServers(e3, t2) {
          let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
          const n2 = [], r2 = e3.filter((e4) => e4.tcpport);
          jC.debug("P2PConnection turnServers is ".concat(r2, ", current index is ").concat(i2));
          const s2 = r2.length > i2 ? r2[i2] : r2[0];
          switch (t2) {
            case fC.SdRtn:
              const t3 = e3.filter((e4) => {
                var t4;
                return bn(t4 = e4.username).call(t4, "glb:") && e4.turnServerURL == e4.turnServerURL;
              }), r3 = t3.length > i2 ? t3[i2] : t3[0];
              r3 && (n2.push({ username: r3.username, credential: r3.password, credentialType: "password", urls: "turn:".concat(gy(r3.turnServerURL), ":").concat(r3.tcpport, "?transport=udp") }), n2.push({ username: r3.username, credential: r3.password, credentialType: "password", urls: "turns:".concat(gy(r3.turnServerURL), ":").concat(r3.tcpport, "?transport=tcp") }));
              break;
            case fC.Relay:
              s2 && (n2.push({ username: s2.username, credential: s2.password, credentialType: "password", urls: "turn:".concat(s2.turnServerURL, ":").concat(s2.tcpport, "?transport=udp") }), n2.push({ username: s2.username, credential: s2.password, credentialType: "password", urls: "turns:".concat(gy(s2.turnServerURL), ":").concat(s2.tcpport, "?transport=tcp") }));
              break;
            default:
              s2 && (n2.push({ username: s2.username, credential: s2.password, credentialType: "password", urls: "turn:".concat(s2.turnServerURL, ":").concat(s2.tcpport, "?transport=udp") }), n2.push({ username: s2.username, credential: s2.password, credentialType: "password", urls: "turns:".concat(gy(s2.turnServerURL), ":").concat(s2.tcpport, "?transport=tcp") }), n2.push({ username: s2.username, credential: s2.password, credentialType: "password", urls: "stun:".concat(s2.turnServerURL, ":").concat(s2.tcpport) }));
          }
          return n2;
        }
        tryBindTransportEvents(e3) {
          if (e3) {
            this.transport = e3, e3.onstatechange = () => {
              var t3;
              null != e3 && e3.state && (null === (t3 = this.onDTLSTransportStateChange) || void 0 === t3 || t3.call(this, e3.state));
            }, e3.onerror = (e4) => {
              var t3;
              null === (t3 = this.onDTLSTransportError) || void 0 === t3 || t3.call(this, "error" in e4 ? e4.error : e4);
            };
            const t2 = e3.iceTransport;
            t2 && (t2.onstatechange = () => {
              const t3 = null == e3 ? void 0 : e3.iceTransport.state;
              var i2;
              t3 && (null === (i2 = this.onICETransportStateChange) || void 0 === i2 || i2.call(this, t3));
            }, t2.getSelectedCandidatePair && (t2.onselectedcandidatepairchange = () => {
              if (t2.getSelectedCandidatePair()) {
                const { local: e4, remote: i2 } = t2.getSelectedCandidatePair();
                jC.info("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] selectedcandidatepairchange: local ").concat(JSON.stringify({ candidateType: e4.type, protocol: e4.protocol }), ", remote ").concat(JSON.stringify({ candidateType: i2.type, protocol: i2.protocol, address: i2.address, port: i2.port }), " )"));
              }
            }));
          }
        }
        tryUnbindTransportEvents() {
          this.transport && (this.transport.onstatechange = null, this.transport.onerror = null, this.transport.iceTransport && (this.transport.iceTransport.onstatechange = null));
        }
        async updateRtpSenderEncodings(e3, t2) {
          var i2;
          if (!t2) {
            t2 = this.peerConnection.getSenders().find((t3) => t3.track === e3._mediaStreamTrack);
          }
          if (!t2) return jC.warn("[".concat(e3.getTrackId(), "] no rtpSender found}"));
          if (this.isVP8Simulcast(e3)) return jC.warn("[updateRtpSenderEncodings] Track is VP8 simulcast, please apply simulcast encodings");
          if (!IA().supportSetRtpSenderParameters) return jC.warn("[updateRtpSenderEncodings] Browser not support set rtp-sender parameters");
          const n2 = {}, r2 = {};
          switch (e3._optimizationMode) {
            case "motion":
              n2.degradationPreference = "maintain-framerate";
              break;
            case "detail":
              n2.degradationPreference = "maintain-resolution";
              break;
            default:
              n2.degradationPreference = "balanced";
          }
          if (e3._encoderConfig) {
            var s2;
            const { bitrateMax: t3, frameRate: i3, scaleResolutionDownBy: n3 } = e3._encoderConfig;
            t3 && (r2.maxBitrate = 1e3 * t3), bn(s2 = e3._hints).call(s2, jA.LOW_STREAM) && (i3 && (r2.maxFramerate = Sy(i3)), n3 && n3 >= 1 && (r2.scaleResolutionDownBy = n3));
          }
          if (RC("DSCP_TYPE") && jg()) {
            var o2;
            const e4 = RC("DSCP_TYPE");
            bn(o2 = ["very-low", "low", "medium", "high"]).call(o2, e4) && (r2.networkPriority = e4);
          }
          const a2 = t2.getParameters(), c2 = null === (i2 = a2.encodings) || void 0 === i2 ? void 0 : i2[0];
          wg() && !c2 && (n2.encodings = [r2]), c2 && Object.assign(c2, r2), Object.assign(a2, n2), jC.debug("[".concat(e3.getTrackId(), "] updateRtpSenderEncodings: ").concat(JSON.stringify(a2.encodings))), await t2.setParameters(a2);
        }
        async applySendEncodings(e3, t2) {
          try {
            if (!IA().supportSetRtpSenderParameters) return;
            if (e3.length !== t2.length) return;
            for (let i2 = 0; i2 < e3.length; i2++) {
              const n2 = e3[i2], r2 = t2[i2];
              r2 instanceof Rw && !this.isVP8Simulcast(r2) && await this.updateRtpSenderEncodings(r2, n2.sender);
            }
          } catch (e4) {
            jC.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
          }
        }
        mungSendOfferSDP(e3, t2, i2) {
          const n2 = JU.parse(e3);
          return t2.forEach((e4, t3) => {
            const r2 = i2[t3], s2 = n2.mediaDescriptions.find((e5) => e5.attributes.mid === r2);
            s2 && (Ix(s2, e4), wx(s2, e4, this.store.codec));
          }), JU.print(n2);
        }
        bindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = (e3) => {
            var t2;
            null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoReceived = (e3) => {
            var t2;
            null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstAudioDecoded = (e3) => {
            var t2;
            null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoDecoded = (e3, t2, i2) => {
            var n2;
            null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e3, t2, i2);
          }, this.statsFilter.onSelectedLocalCandidateChanged = (e3, t2) => {
            var i2;
            null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 || i2.call(this, e3, t2);
          }, this.statsFilter.onSelectedRemoteCandidateChanged = (e3, t2) => {
            var i2;
            null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 || i2.call(this, e3, t2);
          }, this.statsFilter.onFirstVideoDecodedTimeout = (e3) => {
            var t2;
            null === (t2 = this.onFirstVideoDecodedTimeout) || void 0 === t2 || t2.call(this, e3);
          };
        }
        unbindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
        }
        async applySimulcastForFirefox(e3, t2) {
          if (e3.length === t2.length) for (let a2 = 0; a2 < e3.length; a2++) {
            var i2, n2, r2, s2, o2;
            const c2 = e3[a2], d2 = t2[a2];
            if (d2 instanceof Rw && !bn(i2 = d2._hints).call(i2, jA.LOW_STREAM) && null !== (n2 = d2._encoderConfig) && void 0 !== n2 && n2.bitrateMax && (null === (r2 = d2._encoderConfig) || void 0 === r2 ? void 0 : r2.bitrateMax) > 200 && null !== (s2 = d2._scalabilityMode) && void 0 !== s2 && s2.numSpatialLayers && (null === (o2 = d2._scalabilityMode) || void 0 === o2 ? void 0 : o2.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
              const e4 = {}, t3 = { high: 1e3 * (d2._encoderConfig.bitrateMax - 50), medium: 5e4 };
              e4.encodings = [{ rid: "m", active: true, maxBitrate: t3.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: t3.high }];
              const i3 = c2.sender.getParameters();
              await c2.sender.setParameters(Object.assign(i3, e4));
            }
          }
        }
        async applySimulcastEncodings(e3, t2) {
          if (!wg() && e3.length === t2.length) for (let i2 = 0; i2 < e3.length; i2++) {
            const n2 = t2[i2];
            if (n2 instanceof Rw && this.isVP8Simulcast(n2)) {
              const t3 = e3[i2], r2 = {}, s2 = { high: 1e3 * (n2._encoderConfig.bitrateMax - 50), medium: 5e4 };
              r2.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: s2.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: s2.medium, scaleResolutionDownBy: 4 }];
              const o2 = t3.sender.getParameters();
              await t3.sender.setParameters(Object.assign(o2, r2));
            }
          }
        }
        isVP8Simulcast(e3) {
          var t2, i2, n2, r2, s2;
          return !!(e3 instanceof Rw && RC("SIMULCAST") && "vp8" === this.store.codec && !bn(t2 = e3._hints).call(t2, jA.LOW_STREAM) && null !== (i2 = e3._encoderConfig) && void 0 !== i2 && i2.bitrateMax && (null === (n2 = e3._encoderConfig) || void 0 === n2 ? void 0 : n2.bitrateMax) > 200 && null !== (r2 = e3._scalabilityMode) && void 0 !== r2 && r2.numSpatialLayers && (null === (s2 = e3._scalabilityMode) || void 0 === s2 ? void 0 : s2.numSpatialLayers) > 1);
        }
        logSDPExchange(e3, t2, i2, n2) {
          if (RC("SDP_LOGGING")) return jC.upload("[".concat(this.store.clientId, "] exchanging ").concat(i2, " ").concat(t2, " SDP during P2PConnection.").concat(n2, "\n"), e3), "offer" === t2 ? (e4) => {
            this.logSDPExchange(e4, "answer", "local" === i2 ? "remote" : "local", n2);
          } : void 0;
        }
        async muteLocal(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
            const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e3.indexOf(t3.mid));
            if (t2.length !== e3.length) throw new Error("Transceivers' length doesn't match mids' length.");
            t2.map((e4) => {
              e4.direction = "inactive";
            });
            const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "muteLocal");
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.muteRemote(e3);
            const r2 = this.remoteSDP.toString();
            null == n2 || n2(r2), await this.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e4.toString()));
          }
        }
        async unmuteLocal(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
            const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e3.indexOf(t3.mid));
            if (t2.length !== e3.length) throw new Error("Transceivers' length doesn't match mids' length.");
            t2.map(async (e4) => {
              e4.direction = "sendonly";
            });
            const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "unmuteLocal");
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.unmuteRemote(e3);
            const r2 = this.remoteSDP.toString();
            null == n2 || n2(r2), await this.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e4.toString()));
          }
        }
        async getRemoteSSRC(e3, t2) {
          var i2, n2;
          if (t2 = null !== (i2 = t2) && void 0 !== i2 ? i2 : null === (n2 = this.currentRemoteDescription) || void 0 === n2 ? void 0 : n2.sdp) {
            var r2;
            const i3 = null === (r2 = JU.parse(t2).mediaDescriptions.find((t3) => t3.attributes.mid === e3)) || void 0 === r2 ? void 0 : r2.attributes.ssrcs;
            return null == i3 ? void 0 : i3[0].ssrcId;
          }
        }
        async setRemoteDescription(e3) {
          var t2;
          await this.peerConnection.setRemoteDescription(e3), bn(t2 = ["connected", "completed"]).call(t2, this.peerConnection.iceConnectionState) || (this.isReady = true, this.addRemoteCandidate());
        }
        mungReceiveAnswerSDP(e3, t2, i2) {
          const n2 = JU.parse(e3), r2 = n2.mediaDescriptions.find((e4) => e4.attributes.mid === t2);
          return r2 && (i2 === av.AUDIO && "audio" === r2.media.mediaType && Lx(r2), this.useXR && kx(n2)), JU.print(n2);
        }
      };
      function jx(e2, t2, i2) {
        const n2 = e2[t2];
        if ("function" != typeof n2) throw new Error("Cannot use mutex on object property.");
        return i2.value = async function() {
          const e3 = this.mutex, i3 = await e3.lock("From P2PConnection.".concat(t2));
          try {
            for (var r2 = arguments.length, s2 = new Array(r2), o2 = 0; o2 < r2; o2++) s2[o2] = arguments[o2];
            return await n2.apply(this, s2);
          } finally {
            i3();
          }
        }, i2;
      }
      function Gx(e2, t2) {
        let i2 = document.createElement("video"), n2 = document.createElement("canvas");
        i2.setAttribute("style", "display:none"), n2.setAttribute("style", "display:none"), i2.setAttribute("muted", ""), i2.muted = true, i2.setAttribute("autoplay", ""), i2.autoplay = true, i2.setAttribute("playsinline", ""), n2.width = Sy(t2.width), n2.height = Sy(t2.height);
        const r2 = Sy(t2.framerate || 15);
        document.body.append(i2), document.body.append(n2);
        let s2 = e2._mediaStreamTrack;
        i2.srcObject = new MediaStream([s2]), i2.play();
        const o2 = n2.getContext("2d");
        if (!o2) throw new LI(Hg.UNEXPECTED_ERROR, "can not get canvas context");
        const a2 = IA(), c2 = n2.captureStream(a2.supportRequestFrame ? 0 : r2).getVideoTracks()[0];
        c2.canvas || (c2.canvas = n2), n2.startCapture = () => {
          if (!i2) return n2.stopCapture && n2.stopCapture();
          if (i2.paused && i2.play(), i2.videoHeight > 2 && i2.videoWidth > 2) {
            const e3 = i2.videoWidth, t3 = i2.videoHeight / e3, r3 = n2.width * t3;
            Math.abs(r3 - n2.height) >= 2 && (jC.debug("adjust low stream resolution", "".concat(n2.width, "x").concat(n2.height, " -> ").concat(n2.width, "x").concat(r3)), n2.height = r3);
          }
          o2.drawImage(i2, 0, 0, n2.width, n2.height), c2.requestFrame && c2.requestFrame(), s2 !== e2._mediaStreamTrack && (s2 = e2._mediaStreamTrack, i2.srcObject = new MediaStream([s2]));
        }, n2.stopCapture = Tb(() => n2.startCapture && n2.startCapture(), r2);
        const d2 = c2.stop;
        return c2.stop = () => {
          d2.call(c2), i2 && (i2.remove(), i2.srcObject = null, i2 = null), n2 && (n2.width = 0, n2.remove(), n2.stopCapture && n2.stopCapture(), n2.startCapture = void 0, n2.stopCapture = void 0, n2 = null), jC.debug("clean low stream renderer");
        }, c2;
      }
      var Wx, Hx, Kx, Yx, qx, zx, Jx, Xx, Qx, Zx, $x;
      DI([jx, PI("design:type", Function), PI("design:paramtypes", [Object]), PI("design:returntype", cg)], Bx.prototype, "establish", null), DI([jx, PI("design:type", Function), PI("design:paramtypes", [Object]), PI("design:returntype", cg)], Bx.prototype, "connect", null), DI([jx, PI("design:type", Function), PI("design:paramtypes", [String, Array, String, String]), PI("design:returntype", cg)], Bx.prototype, "receive", null), DI([jx, PI("design:type", Function), PI("design:paramtypes", [String, Array, String, String]), PI("design:returntype", cg)], Bx.prototype, "mockReceive", null), DI([jx, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], Bx.prototype, "stopReceiving", null), DI([jx, PI("design:type", Function), PI("design:paramtypes", [Object]), PI("design:returntype", cg)], Bx.prototype, "restartICE", null), DI([jx, PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], Bx.prototype, "close", null), DI([jx, PI("design:type", Function), PI("design:paramtypes", [String, lb]), PI("design:returntype", cg)], Bx.prototype, "updateEncoderConfig", null), DI([jx, PI("design:type", Function), PI("design:paramtypes", [String, lb]), PI("design:returntype", cg)], Bx.prototype, "updateSendParameters", null), DI([jx, PI("design:type", Function), PI("design:paramtypes", [lb, String]), PI("design:returntype", cg)], Bx.prototype, "replaceTrack", null), DI([jx, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], Bx.prototype, "muteLocal", null), DI([jx, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], Bx.prototype, "unmuteLocal", null), function(e2) {
        e2[e2.HEIGHT = 2033] = "HEIGHT", e2[e2.FRAME_RATE = 2034] = "FRAME_RATE", e2[e2.WIDTH = 2035] = "WIDTH";
      }(Wx || (Wx = {})), function(e2) {
        e2[e2.HEIGHT = 2072] = "HEIGHT", e2[e2.FRAME_RATE = 2074] = "FRAME_RATE", e2[e2.WIDTH = 2076] = "WIDTH";
      }(Hx || (Hx = {})), function(e2) {
        e2[e2.FRAME_RATE = 2002] = "FRAME_RATE", e2[e2.WIDTH = 2003] = "WIDTH", e2[e2.HEIGHT = 2004] = "HEIGHT", e2[e2.PACKAGE_LOST = 2005] = "PACKAGE_LOST", e2[e2.AVG_ENCODE = 2007] = "AVG_ENCODE", e2[e2.NACKS = 2009] = "NACKS", e2[e2.PLIS = 2010] = "PLIS", e2[e2.FIRS = 2011] = "FIRS", e2[e2.BITRATE = 2012] = "BITRATE", e2[e2.PACKAGE_RATE = 2031] = "PACKAGE_RATE", e2[e2.ADAPTATION = 2032] = "ADAPTATION", e2[e2.ACTUAL_ENCODED = 2060] = "ACTUAL_ENCODED", e2[e2.BANDWIDTH = 2061] = "BANDWIDTH", e2[e2.RETRANSMIT = 2062] = "RETRANSMIT", e2[e2.TARGET_ENCODED = 2064] = "TARGET_ENCODED", e2[e2.TRANSMIT = 2066] = "TRANSMIT", e2[e2.FREEZE = 2082] = "FREEZE", e2[e2.DISABLED = 2095] = "DISABLED", e2[e2.PLAYER_STATUS = 2128] = "PLAYER_STATUS", e2[e2.QP_SUM = 2143] = "QP_SUM";
      }(Kx || (Kx = {})), function(e2) {
        e2[e2.BITRATE = 2069] = "BITRATE", e2[e2.PACKAGE_LOST = 2070] = "PACKAGE_LOST", e2[e2.PACKAGE_RATE = 2071] = "PACKAGE_RATE", e2[e2.HEIGHT = 2073] = "HEIGHT", e2[e2.FRAME_RATE = 2075] = "FRAME_RATE", e2[e2.WIDTH = 2077] = "WIDTH";
      }(Yx || (Yx = {})), function(e2) {
        e2[e2.JITTER = -1] = "JITTER", e2[e2.PACKAGE_LOST = 2014] = "PACKAGE_LOST", e2[e2.WIDTH = 2018] = "WIDTH", e2[e2.HEIGHT = 2019] = "HEIGHT", e2[e2.FRAME_RATE = 2020] = "FRAME_RATE", e2[e2.JITTER_BUFFER = 2023] = "JITTER_BUFFER", e2[e2.CURRENT_DELAY = 2024] = "CURRENT_DELAY", e2[e2.NACKS = 2026] = "NACKS", e2[e2.PLIS = 2027] = "PLIS", e2[e2.FIRS = 2028] = "FIRS", e2[e2.BITRATE = 2029] = "BITRATE", e2[e2.PACKAGE_RATE = 2078] = "PACKAGE_RATE", e2[e2.FREEZE = 2084] = "FREEZE", e2[e2.DISABLED = 2101] = "DISABLED", e2[e2.PLAYER_STATUS = 2129] = "PLAYER_STATUS", e2[e2.QP_SUM = 2144] = "QP_SUM", e2[e2.I_FRAME_DELAY = 2149] = "I_FRAME_DELAY";
      }(qx || (qx = {})), function(e2) {
        e2[e2.FRAME_RATE_DECODE = 2021] = "FRAME_RATE_DECODE", e2[e2.FRAME_RATE_RENDER = 2022] = "FRAME_RATE_RENDER", e2[e2.FREEZE_TIME = 2109] = "FREEZE_TIME", e2[e2.FREEZE_TIME_RENDER = 2147] = "FREEZE_TIME_RENDER";
      }(zx || (zx = {})), function(e2) {
        e2[e2.PCM_LEVEL = 2104] = "PCM_LEVEL";
      }(Jx || (Jx = {})), function(e2) {
        e2[e2.PACKAGE_LOST = -1] = "PACKAGE_LOST", e2[e2.LEVEL = 2038] = "LEVEL", e2[e2.BITRATE = 2039] = "BITRATE", e2[e2.PACKAGE_RATE = 2040] = "PACKAGE_RATE", e2[e2.AEC_RETURN_LOSS = 2041] = "AEC_RETURN_LOSS", e2[e2.AEC_RETURN_LOSS_ENH = 2042] = "AEC_RETURN_LOSS_ENH", e2[e2.FREEZE = 2081] = "FREEZE", e2[e2.DISABLED = 2096] = "DISABLED";
      }(Xx || (Xx = {})), function(e2) {
        e2[e2.BITRATE = 2044] = "BITRATE", e2[e2.PACKAGE_LOST = 2045] = "PACKAGE_LOST", e2[e2.PACKAGE_RATE = 2046] = "PACKAGE_RATE", e2[e2.CURRENT_DELAY = 2047] = "CURRENT_DELAY", e2[e2.JITTER_BUFFER = 2054] = "JITTER_BUFFER", e2[e2.JITTER = 2055] = "JITTER", e2[e2.FREEZE = 2083] = "FREEZE", e2[e2.DISABLED = 2102] = "DISABLED", e2[e2.PCM_LEVEL = 2105] = "PCM_LEVEL", e2[e2.PLAYER_STATUS = 2130] = "PLAYER_STATUS", e2[e2.CONCEALED_SAMPLES = 2148] = "CONCEALED_SAMPLES";
      }(Qx || (Qx = {})), function(e2) {
        e2[e2.FREEZE_TIME = -1] = "FREEZE_TIME", e2[e2.LEVEL = 2043] = "LEVEL";
      }(Zx || (Zx = {})), function(e2) {
        e2[e2.RTT = 2006] = "RTT", e2[e2.CONN_TYPE = 801] = "CONN_TYPE";
      }($x || ($x = {}));
      const eV = 1e3, tV = 3;
      function iV(e2, t2, i2) {
        null != i2 && Number.isFinite(i2) && (e2[t2] = Math.round(Math.max(0, i2)));
      }
      function nV(e2) {
        const t2 = { [$x.CONN_TYPE]: 0, [$x.RTT]: e2.rtt };
        switch (e2.selectedCandidatePair.localCandidate.candidateType) {
          case "relay": {
            const i2 = e2.selectedCandidatePair.localCandidate.relayProtocol;
            "udp" === i2 && (t2[$x.CONN_TYPE] = 1), "tcp" === i2 && (t2[$x.CONN_TYPE] = 3), "tls" === i2 && (t2[$x.CONN_TYPE] = 4);
            break;
          }
          case "srflx":
            t2[$x.CONN_TYPE] = 2;
        }
        return t2;
      }
      class rV extends dT {
        constructor(e2) {
          super(), sh(this, "store", void 0), sh(this, "uploadWRTCStatsTimer", void 0), sh(this, "uploadOutboundDenoiserStatsTimer", void 0), sh(this, "uploadExtStatsTimer", void 0), sh(this, "uploadExtUsageStatsTimer", void 0), sh(this, "uploadInboundExtStatsTimer", void 0), sh(this, "requestStats", void 0), sh(this, "requestTransportStats", void 0), sh(this, "requestLocalMedia", void 0), sh(this, "requestRemoteMedia", void 0), sh(this, "requestAllTracks", void 0), sh(this, "requestVideoIsReady", void 0), sh(this, "requestUploadStats", void 0), sh(this, "requestUpload", void 0), sh(this, "uploadOutboundStarted", false), sh(this, "uploadInboundStarted", false), sh(this, "uploadTransportStarted", false), sh(this, "uploadExtensionUsageStarted", false), sh(this, "lastRecvStats", void 0), sh(this, "lastSendStats", void 0), sh(this, "lastFullRecvStats", void 0), sh(this, "lastFullSendStats", void 0), sh(this, "needUploadRenderFreezeTime", true), this.store = e2;
        }
        uploadWRTCStats(e2) {
          if (!this.requestStats || !this.requestUploadStats) return;
          let t2, i2;
          if (this.uploadTransportStarted && (t2 = this.requestStats(), this.store.useP2P && (i2 = this.requestStats(true))), !t2 && this.uploadOutboundStarted && (t2 = this.requestStats()), !i2 && this.uploadInboundStarted && (i2 = this.requestStats(true)), t2 || i2) {
            const n2 = {};
            if (this.uploadTransportStarted && t2) {
              const r2 = this.getTransportStats(t2, i2, e2);
              r2 && (n2.misc = [r2]);
            }
            if (this.uploadOutboundStarted && t2) {
              const i3 = this.getOutboundStats(t2, e2 ? this.lastSendStats : this.lastFullSendStats, e2);
              i3 && (n2.outbound = [i3]);
            }
            if (this.uploadInboundStarted && i2) {
              const t3 = this.getInboundStats(i2, e2 ? this.lastRecvStats : this.lastFullRecvStats, e2);
              t3 && (n2.inbound = t3);
            }
            this.requestUploadStats(n2);
          }
          this.lastRecvStats = i2, this.lastSendStats = t2, e2 || (this.lastFullRecvStats = i2, this.lastFullSendStats = t2);
        }
        startUploadWRTCStats() {
          if (this.uploadWRTCStatsTimer) return;
          let e2 = 1;
          this.uploadWRTCStatsTimer = window.setInterval(() => {
            if (!this.uploadTransportStarted && !this.uploadInboundStarted && !this.uploadOutboundStarted) return this.stopUploadWRTCStats();
            this.uploadWRTCStats(e2 !== tV), ++e2 === tV + 1 && (e2 = 1);
          }, eV);
        }
        stopUploadWRTCStats() {
          window.clearInterval(this.uploadWRTCStatsTimer), this.uploadWRTCStatsTimer = void 0, this.lastSendStats && (this.lastSendStats.videoSend = [], this.lastSendStats.audioSend = [], this.lastSendStats = void 0), this.lastRecvStats && (this.lastRecvStats.videoRecv = [], this.lastRecvStats.audioRecv = [], this.lastRecvStats = void 0);
        }
        getTransportStats(e2, t2, i2) {
          if (!this.requestStats) return;
          if (i2) return null == e2.rtt ? void 0 : { addition: { [$x.RTT]: e2.rtt, [$x.CONN_TYPE]: void 0 } };
          const n2 = nV(e2);
          if (this.store.useP2P) {
            if (t2) {
              const e3 = nV(t2);
              n2[$x.CONN_TYPE] += e3[$x.CONN_TYPE] << 3;
            }
            n2[$x.CONN_TYPE] += 110;
          } else n2[$x.CONN_TYPE] += 100;
          return { addition: n2 };
        }
        getOutboundStats(e2, t2, i2) {
          if (!this.requestUploadStats || !this.requestLocalMedia) return;
          const n2 = this.requestLocalMedia();
          if (!n2 || 0 === n2.length) return;
          let r2, s2, o2;
          return n2.forEach((n3) => {
            let [a2, { track: c2, ssrcs: d2 }] = n3;
            switch (a2) {
              case lv.LocalVideoLowTrack:
              case lv.LocalVideoTrack:
                if (a2 === lv.LocalVideoTrack) {
                  const n4 = function(e3, t3, i3, n5, r4) {
                    const s3 = t3.videoSend.find((t4) => t4.ssrc === e3);
                    if (!s3) return;
                    const o4 = {}, { sentFrame: a3, inputFrame: c3 } = s3;
                    if (c3 && a3) {
                      const e4 = c3.frameRate, t4 = a3.frameRate;
                      o4[Kx.FREEZE] = function(e5, t5) {
                        let i4 = true;
                        return i4 = !(e5 <= 5) && (e5 <= 10 ? t5 < 3 : e5 <= 20 ? t5 < 4 : t5 < 5), i4;
                      }(e4, t4) ? 1 : 0;
                    }
                    if (iV(o4, Kx.QP_SUM, s3.qpSumPerFrame), r4) return o4;
                    switch (a3 && (iV(o4, Kx.HEIGHT, a3.height), iV(o4, Kx.WIDTH, a3.width), iV(o4, Kx.FRAME_RATE, a3.frameRate)), o4[Kx.DISABLED] = n5._originMediaStreamTrack && !n5._originMediaStreamTrack.enabled || n5._mediaStreamTrack && !n5._mediaStreamTrack.enabled ? 1 : 0, s3.adaptionChangeReason) {
                      case "none":
                        o4[Kx.ADAPTATION] = 0;
                        break;
                      case "cpu":
                        o4[Kx.ADAPTATION] = 1;
                        break;
                      case "bandwidth":
                        o4[Kx.ADAPTATION] = 2;
                        break;
                      case "other":
                        o4[Kx.ADAPTATION] = 3;
                    }
                    o4[Kx.PLAYER_STATUS] = ab[n5._player ? n5._player.videoElementStatus : "uninit"], iV(o4, Kx.NACKS, s3.nacksCount), iV(o4, Kx.PLIS, s3.plisCount), iV(o4, Kx.FIRS, s3.firsCount), iV(o4, Kx.AVG_ENCODE, s3.avgEncodeMs);
                    const d3 = i3 && i3.videoSend.find((t4) => t4.ssrc === e3);
                    if (d3) {
                      let e4 = r4 ? eV : eV * tV;
                      d3.timestamp && s3.timestamp && (e4 = s3.timestamp - d3.timestamp), null != d3.packets && null != s3.packets && iV(o4, Kx.PACKAGE_RATE, 1e3 * (s3.packets - d3.packets) / e4), null != s3.packetsLost && null != d3.packetsLost && iV(o4, Kx.PACKAGE_LOST, s3.packetsLost - d3.packetsLost), null != d3.bytes && null != s3.bytes && iV(o4, Kx.BITRATE, 8 * (s3.bytes - d3.bytes) / e4);
                    }
                    return o4;
                  }(d2[0].ssrcId, e2, t2, c2, i2), r3 = i2 ? null : function(e3, t3, i3) {
                    const n5 = t3.videoSend.find((t4) => t4.ssrc === e3);
                    if (!n5) return null;
                    const r4 = {}, s3 = n5.inputFrame, o4 = s3 && s3.height || i3 && i3._videoHeight || 0, a3 = s3 && s3.width || i3 && i3._videoWidth || 0, c3 = s3 && s3.frameRate || 0;
                    return iV(r4, Wx.HEIGHT, o4), iV(r4, Wx.WIDTH, a3), iV(r4, Wx.FRAME_RATE, c3), r4;
                  }(d2[0].ssrcId, e2, c2), o3 = i2 ? null : function(e3) {
                    const t3 = {};
                    return iV(t3, Kx.RETRANSMIT, e3.bitrate.retransmit), iV(t3, Kx.TARGET_ENCODED, e3.bitrate.targetEncoded), iV(t3, Kx.ACTUAL_ENCODED, e3.bitrate.actualEncoded), iV(t3, Kx.TRANSMIT, e3.bitrate.transmit), iV(t3, Kx.BANDWIDTH, e3.sendBandwidth), t3;
                  }(e2);
                  s2 = Object.assign({}, n4, r3, o3);
                } else o2 = i2 ? void 0 : function(e3, t3, i3) {
                  const n4 = t3.videoSend.find((t4) => t4.ssrc === e3);
                  if (!n4) return;
                  const r3 = {}, s3 = n4.sentFrame;
                  if (s3 && (iV(r3, Yx.HEIGHT, s3.height), iV(r3, Yx.WIDTH, s3.width), iV(r3, Yx.FRAME_RATE, s3.frameRate)), i3) {
                    const t4 = i3.videoSend.find((t5) => t5.ssrc === e3);
                    if (t4) {
                      let e4 = eV * tV;
                      t4.timestamp && n4.timestamp && (e4 = n4.timestamp - t4.timestamp), null != t4.packets && null != n4.packets && iV(r3, Yx.PACKAGE_RATE, 1e3 * (n4.packets - t4.packets) / e4), null != n4.packetsLost && null != t4.packetsLost && iV(r3, Yx.PACKAGE_LOST, n4.packetsLost - t4.packetsLost), null != t4.bytes && null != n4.bytes && iV(r3, Yx.BITRATE, 8 * (n4.bytes - t4.bytes) / e4);
                    }
                  }
                  return r3;
                }(d2[0].ssrcId, e2, t2);
                break;
              case lv.LocalAudioTrack:
                r2 = i2 ? void 0 : function(e3, t3, i3, n4) {
                  const r3 = t3.audioSend.find((t4) => t4.ssrc === e3);
                  if (!r3) return;
                  const s3 = {};
                  s3[Xx.DISABLED] = n4._originMediaStreamTrack && !n4._originMediaStreamTrack.enabled || n4._mediaStreamTrack && !n4._mediaStreamTrack.enabled ? 1 : 0;
                  const o3 = n4._source.getAccurateVolumeLevel(), a3 = r3.inputLevel;
                  iV(s3, Xx.LEVEL, 100 * (null == a3 ? o3 : a3)), iV(s3, Jx.PCM_LEVEL, 100 * o3), iV(s3, Xx.AEC_RETURN_LOSS, r3.aecReturnLoss), iV(s3, Xx.AEC_RETURN_LOSS_ENH, r3.aecReturnLossEnhancement), s3[Xx.FREEZE] = 0;
                  const c3 = i3 && i3.audioSend.find((t4) => t4.ssrc === e3);
                  if (c3) {
                    let e4 = eV * tV;
                    c3.timestamp && r3.timestamp && (e4 = r3.timestamp - c3.timestamp), null != c3.bytes && null != r3.bytes && iV(s3, Xx.BITRATE, 8 * (r3.bytes - c3.bytes) / e4), null != c3.packets && null != r3.packets && iV(s3, Xx.PACKAGE_RATE, 1e3 * (r3.packets - c3.packets) / e4);
                  }
                  return s3;
                }(d2[0].ssrcId, e2, t2, c2);
            }
          }), { high: s2, low: o2, audio: r2 };
        }
        getInboundStats(e2, t2, i2) {
          if (!this.requestRemoteMedia) return;
          const n2 = this.requestRemoteMedia() || [], r2 = [];
          return n2.forEach((n3) => {
            let [s2, o2] = n3;
            const a2 = { peer: s2.uid };
            if (o2.has(av.VIDEO) && s2.videoTrack) {
              const n4 = s2._videoSSRC && this.requestVideoIsReady && this.requestVideoIsReady(s2._videoSSRC) || false, r3 = s2.videoTrack ? function(e3, t3, i3, n5, r4, s3, o3) {
                const a3 = t3.videoRecv.find((t4) => t4.ssrc === e3);
                if (!a3) return;
                const c2 = {}, { receivedFrame: d2, outputFrame: l2, decodeFrameRate: u2 } = a3, h3 = i3 && i3.videoRecv.find((t4) => t4.ssrc === e3);
                if (c2[qx.FREEZE] = r4 && mV.isRemoteVideoFreeze(n5, a3, h3) ? 1 : 0, iV(c2, zx.FRAME_RATE_DECODE, u2), iV(c2, qx.QP_SUM, a3.qpSumPerFrame), a3.framesRateFirefox && iV(c2, qx.FRAME_RATE, a3.framesRateFirefox), d2 && iV(c2, qx.FRAME_RATE, d2.frameRate), h3) {
                  const e4 = t3.timestamp - i3.timestamp || (o3 ? eV : tV * eV);
                  null != a3.packetsLost && null != h3.packetsLost && iV(c2, qx.PACKAGE_LOST, a3.packetsLost - h3.packetsLost), null != h3.bytes && null != a3.bytes && iV(c2, qx.BITRATE, 8 * (a3.bytes - h3.bytes) / e4), null != h3.packets && null != a3.packets && iV(c2, qx.PACKAGE_RATE, 1e3 * (a3.packets - h3.packets) / e4);
                }
                if (o3) return c2;
                if (d2 ? (iV(c2, qx.HEIGHT, d2.height), iV(c2, qx.WIDTH, d2.width)) : n5 && (iV(c2, qx.HEIGHT, n5._videoHeight || 0), iV(c2, qx.WIDTH, n5._videoWidth || 0)), l2 && iV(c2, zx.FRAME_RATE_RENDER, l2.frameRate), iV(c2, qx.JITTER_BUFFER, a3.jitterBufferMs), iV(c2, qx.CURRENT_DELAY, a3.currentDelayMs), iV(c2, qx.FIRS, a3.firsCount), iV(c2, qx.NACKS, a3.nacksCount), iV(c2, qx.PLIS, a3.plisCount), n5) {
                  c2[qx.DISABLED] = n5._originMediaStreamTrack.enabled && n5._mediaStreamTrack.enabled ? 0 : 1;
                  const e4 = n5._player;
                  if (e4) {
                    const { freezeTimeCounterList: t4, renderFreezeAccTime: i4 } = e4;
                    if (t4 && t4.length > 0 && iV(c2, zx.FREEZE_TIME, t4.splice(0, 1)[0]), s3 && "visible" === Dw.visibility) {
                      const t5 = Math.min(6e3, i4);
                      e4.renderFreezeAccTime = Math.max(0, i4 - t5), iV(c2, zx.FREEZE_TIME_RENDER, t5);
                    }
                  }
                }
                if (c2[qx.PLAYER_STATUS] = ab[n5._player ? n5._player.videoElementStatus : "uninit"], h3 && void 0 !== a3.totalInterFrameDelay && void 0 !== a3.totalSquaredInterFrameDelay && void 0 !== h3.totalInterFrameDelay && void 0 !== h3.totalSquaredInterFrameDelay) {
                  const e4 = a3.totalInterFrameDelay - h3.totalInterFrameDelay, t4 = a3.totalSquaredInterFrameDelay - h3.totalSquaredInterFrameDelay, i4 = a3.framesDecodeCount - h3.framesDecodeCount, n6 = e4 / i4 * 1e3, r5 = Math.round(1e3 * Math.sqrt((t4 - Math.pow(e4, 2) / i4) / i4));
                  !isNaN(r5) && n6 + r5 > Math.max(3 * n6, n6 + 150) && (c2[qx.I_FRAME_DELAY] = r5);
                }
                return c2;
              }(s2._videoSSRC, e2, t2, s2.videoTrack, true === n4, this.needUploadRenderFreezeTime, i2) : void 0;
              r3 && (a2.video = r3);
            }
            if (o2.has(av.AUDIO) && s2.audioTrack) {
              const n4 = s2.audioTrack ? function(e3, t3, i3, n5, r3) {
                const s3 = t3.audioRecv.find((t4) => t4.ssrc === e3);
                if (!s3) return;
                const o3 = {}, a3 = i3 && i3.audioRecv.find((t4) => t4.ssrc === e3), { receivedFrames: c2, droppedFrames: d2 } = s3;
                var l2, u2;
                if (iV(o3, Qx.JITTER, s3.jitterMs), null != c2 && null != d2 && (o3[Qx.FREEZE] = (u2 = d2, 0 === (l2 = c2) || 100 * u2 / l2 > 20 ? 1 : 0)), a3) {
                  const e4 = t3.timestamp - i3.timestamp || (r3 ? eV : eV * tV);
                  null != s3.packets && null != a3.packets && iV(o3, Qx.PACKAGE_RATE, 1e3 * (s3.packets - a3.packets) / e4), null != a3.bytes && null != s3.bytes && iV(o3, Qx.BITRATE, 8 * (s3.bytes - a3.bytes) / e4), null != s3.packetsLost && null != a3.packetsLost && iV(o3, Qx.PACKAGE_LOST, s3.packetsLost - a3.packetsLost);
                }
                if (r3) return o3;
                const h3 = n5._source.getAccurateVolumeLevel(), p2 = s3.outputLevel;
                if (iV(o3, Zx.LEVEL, 100 * (null == p2 ? h3 : p2)), iV(o3, Qx.PCM_LEVEL, 100 * h3), n5 && (o3[Qx.DISABLED] = n5._originMediaStreamTrack.enabled && n5._mediaStreamTrack.enabled ? 0 : 1), iV(o3, Qx.JITTER_BUFFER, s3.jitterBufferMs), iV(o3, Qx.CURRENT_DELAY, s3.jitterBufferMs), o3[Qx.PLAYER_STATUS] = ab[Gb.getPlayerState(n5.getTrackId())], a3) {
                  const e4 = s3.concealedSamples - a3.concealedSamples;
                  e4 > 0 && iV(o3, Qx.CONCEALED_SAMPLES, e4);
                }
                return o3;
              }(s2._audioSSRC, e2, t2, s2.audioTrack, i2) : void 0;
              n4 && (a2.audio = n4);
            }
            (a2.video || a2.audio) && r2.push(a2);
          }), this.needUploadRenderFreezeTime = !this.needUploadRenderFreezeTime, r2;
        }
        startUploadTransportStats() {
          this.uploadTransportStarted = true, this.uploadWRTCStatsTimer || this.startUploadWRTCStats();
        }
        stopUploadTransportStats() {
          this.uploadTransportStarted = false;
        }
        startUploadOutboundStats() {
          this.uploadOutboundStarted || (this.uploadOutboundStarted = true, this.uploadWRTCStatsTimer || this.startUploadWRTCStats(), this.uploadOutboundDenoiserStatsTimer && window.clearInterval(this.uploadOutboundDenoiserStatsTimer), this.uploadOutboundDenoiserStatsTimer = window.setInterval(() => {
            if (!this.requestAllTracks || !this.requestUpload) return;
            const e2 = (this.requestAllTracks() || []).find((e3) => e3 instanceof tw);
            if (e2 && e2._external.getDenoiserStats) {
              const t2 = e2._external.getDenoiserStats();
              t2 && this.requestUpload(mI.DENOISER_STATS, t2);
            }
          }, 2e3), this.uploadExtStatsTimer && window.clearInterval(this.uploadExtStatsTimer), this.uploadExtStatsTimer = window.setInterval(() => {
            if (!this.requestAllTracks || !this.requestUpload) return;
            this.requestAllTracks().forEach((e2) => {
              e2.getProcessorStats().forEach((e3) => {
                this.requestUpload && this.requestUpload(e3.type, e3.stats);
              });
            });
          }, 2e3));
        }
        stopUploadOutboundStats() {
          this.uploadOutboundStarted && (this.uploadOutboundStarted = false, this.lastSendStats && (this.lastSendStats.videoSend = [], this.lastSendStats.audioSend = [], this.lastSendStats = void 0), this.uploadOutboundDenoiserStatsTimer && window.clearInterval(this.uploadOutboundDenoiserStatsTimer), this.uploadOutboundDenoiserStatsTimer = void 0);
        }
        startUploadInboundStats() {
          this.uploadInboundStarted || (this.uploadInboundStarted = true, this.uploadWRTCStatsTimer || this.startUploadWRTCStats(), this.uploadInboundExtStatsTimer && window.clearInterval(this.uploadInboundExtStatsTimer), this.uploadInboundExtStatsTimer = window.setInterval(() => {
            if (!this.requestUpload || !this.requestRemoteMedia) return;
            (this.requestRemoteMedia() || []).forEach((e2) => {
              let [t2, i2] = e2;
              if (i2.has(av.VIDEO) && t2.videoTrack) {
                t2.videoTrack.getProcessorStats().forEach((e3) => {
                  this.requestUpload && this.requestUpload(e3.type, e3.stats);
                });
              }
              if (i2.has(av.AUDIO) && t2.audioTrack) {
                t2.audioTrack.getProcessorStats().forEach((e3) => {
                  this.requestUpload && this.requestUpload(e3.type, e3.stats);
                });
              }
            });
          }, 2e3));
        }
        stopUploadInboundStats() {
          this.uploadInboundStarted && (this.uploadInboundStarted = false, this.lastRecvStats && (this.lastRecvStats.videoRecv = [], this.lastRecvStats.audioRecv = [], this.lastRecvStats = void 0));
        }
        startUploadExtensionUsageStats() {
          if (this.uploadExtensionUsageStarted) return;
          this.uploadExtensionUsageStarted = true, this.uploadExtUsageStatsTimer && window.clearInterval(this.uploadExtUsageStatsTimer);
          const e2 = /* @__PURE__ */ new Map();
          this.uploadExtUsageStatsTimer = window.setInterval(async () => {
            const t2 = Date.now(), i2 = { connectionInterval: RC("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3, details: [], lts: t2 };
            let n2 = [];
            const r2 = this.requestAllTracks && this.requestAllTracks() || [];
            for (const e3 of r2) !e3.muted && e3.enabled && (n2 = n2.concat(await e3.getProcessorUsage()));
            const s2 = this.requestRemoteMedia && this.requestRemoteMedia() || [];
            for (const [e3, t3] of s2) t3.has(av.VIDEO) && e3.videoTrack && (n2 = n2.concat(await e3.videoTrack.getProcessorUsage())), t3.has(av.AUDIO) && e3.audioTrack && (n2 = n2.concat(await e3.audioTrack.getProcessorUsage()));
            if (0 === n2.length) return;
            i2.details = function(e3, t3) {
              const i3 = {};
              for (const { id: o3, value: a3, level: c2, direction: d2 } of e3) {
                var n3;
                const e4 = null !== (n3 = t3.get(o3)) && void 0 !== n3 ? n3 : 0, l2 = 2 === a3 ? e4 + RC("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3 : e4;
                var r3, s3;
                t3.set(o3, l2), i3[o3] ? (2 === a3 && (i3[o3].value = a3), c2 > i3[o3].level && (i3[o3].level = c2), "remote" === d2 && (i3[o3].remoteUidCount += 1), i3[o3].totalTs = null !== (r3 = t3.get(o3)) && void 0 !== r3 ? r3 : 0) : i3[o3] = { value: a3, level: c2, remoteUidCount: "local" === d2 ? 0 : 1, totalTs: null !== (s3 = t3.get(o3)) && void 0 !== s3 ? s3 : 0 };
              }
              return Object.keys(i3).map((e4) => {
                const { level: t4, value: n4, totalTs: r4 } = i3[e4];
                return { id: e4, level: t4, value: n4, totalTs: r4 };
              });
            }(n2, e2);
            const o2 = Date.now(), a2 = o2 > t2 ? o2 : t2 + 1;
            this.requestUpload && this.requestUpload(mI.EXTENSION_USAGE_STATS, { usageStats: i2, sendTs: a2 });
          }, RC("EXTENSION_USAGE_UPLOAD_INTERVAL"));
        }
        stopUploadExtensionUsageStats() {
          this.uploadExtensionUsageStarted && (this.uploadExtensionUsageStarted = false, this.uploadExtUsageStatsTimer && window.clearInterval(this.uploadExtUsageStatsTimer), this.uploadExtUsageStatsTimer = void 0);
        }
      }
      class sV {
        get hasVideo() {
          return this._video_enabled_ && !this._video_muted_ && this._video_added_;
        }
        get hasAudio() {
          return this._audio_enabled_ && !this._audio_muted_ && this._audio_added_;
        }
        get audioTrack() {
          if (this.hasAudio || this._audio_pre_subscribed) return this._audioTrack;
        }
        get videoTrack() {
          if (this.hasVideo || this._video_pre_subscribed) return this._videoTrack;
        }
        get dataChannels() {
          return this._dataChannels;
        }
        constructor(e2, t2) {
          sh(this, "uid", void 0), sh(this, "_uintid", void 0), sh(this, "_trust_in_room_", true), sh(this, "_trust_audio_enabled_state_", true), sh(this, "_trust_video_enabled_state_", true), sh(this, "_trust_audio_mute_state_", true), sh(this, "_trust_video_mute_state_", true), sh(this, "_audio_muted_", false), sh(this, "_video_muted_", false), sh(this, "_audio_enabled_", true), sh(this, "_video_enabled_", true), sh(this, "_audio_added_", false), sh(this, "_video_added_", false), sh(this, "_is_pre_created", false), sh(this, "_video_pre_subscribed", false), sh(this, "_audio_pre_subscribed", false), sh(this, "_trust_video_stream_added_state_", true), sh(this, "_trust_audio_stream_added_state_", true), sh(this, "_audioTrack", void 0), sh(this, "_videoTrack", void 0), sh(this, "_dataChannels", []), sh(this, "_audioSSRC", void 0), sh(this, "_videoSSRC", void 0), sh(this, "_audioOrtc", void 0), sh(this, "_videoOrtc", void 0), sh(this, "_cname", void 0), sh(this, "_rtxSsrcId", void 0), sh(this, "_videoMid", void 0), sh(this, "_audioMid", void 0), this.uid = e2, this._uintid = t2;
        }
      }
      var oV;
      function aV(e2, t2) {
        var i2;
        let n2;
        switch (t2) {
          case lv.LocalAudioTrack:
            n2 = JI.Audio;
            break;
          case lv.LocalVideoTrack:
            n2 = bn(i2 = e2._hints).call(i2, jA.SCREEN_TRACK) ? JI.Screen : JI.High;
            break;
          case lv.LocalVideoLowTrack:
            n2 = JI.Low;
        }
        return n2;
      }
      function cV(e2) {
        const t2 = IA();
        if (e2.some((e3) => e3._bypassWebAudio)) throw new Kg(Hg.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
        if (!t2.webAudioMediaStreamDest) throw new Kg(Hg.NOT_SUPPORTED, "cannot publish multiple tracks because your browser does not support audio mixing");
      }
      function dV(e2, t2) {
        cV(e2);
        const i2 = t2 || new nw();
        return e2.forEach((e3) => i2.addAudioTrack(e3)), i2;
      }
      function lV(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function uV(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? lV(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : lV(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      !function(e2) {
        e2.SEND_ONLY = "SEND_ONLY", e2.RECEIVE_ONLY = "RECEIVE_ONLY";
      }(oV || (oV = {}));
      class hV extends dT {
        get state() {
          return this._state;
        }
        set state(e2) {
          const t2 = this._state;
          this._state = e2, this.emit(hv.StateChange, t2, this._state);
        }
        constructor(e2, t2) {
          super(), sh(this, "store", void 0), sh(this, "statsUploader", void 0), sh(this, "sendConnection", void 0), sh(this, "recvConnection", void 0), sh(this, "localTrackMap", /* @__PURE__ */ new Map()), sh(this, "remoteUserMap", /* @__PURE__ */ new Map()), sh(this, "localDataChannels", []), sh(this, "pendingLocalTracks", []), sh(this, "pendingRemoteTracks", []), sh(this, "statsCollector", void 0), sh(this, "dtlsFailedCount", 0), sh(this, "sendMutex", new pS("P2PChannel2-send-mutex")), sh(this, "recvMutex", new pS("P2PChannel2-recv-mutex")), sh(this, "_state", uv.Disconnected), sh(this, "_restartStates", ["disconnected", "failed"]), sh(this, "reconnectInterval", void 0), sh(this, "uploadUnplinkStarted", false), sh(this, "uploadDownlinkStarted", false), sh(this, "uplinkStateUploadInterval", void 0), sh(this, "downlinkStatsUploadInterval", void 0), sh(this, "handleMuteLocalTrack", async (e3, t3, i2) => {
            const n2 = await this.sendMutex.lock("Locking from P2PChannel2.handleMuteLocalTrack");
            try {
              if (!this.sendConnection || this.state !== uv.Connected) return void i2(new Kg(Hg.INVALID_OPERATION, "Cannot call P2PChannel2.handleMuteLocalTrack before sendConnection established."));
              const o2 = this.filterTobeMutedTracks(e3);
              if (0 === o2.length) return void t3();
              const a2 = o2.find((e4) => "videoLowTrack" === e4[0]);
              if (a2) {
                a2[1].track._originMediaStreamTrack.stop();
              }
              await this.sendConnection.muteLocal(o2.map((e4) => {
                let [, { id: t4 }] = e4;
                return t4;
              }));
              let c2 = false;
              var r2, s2;
              if ("video" === e3.trackMediaType) c2 = !(null === (r2 = this.localTrackMap.get(lv.LocalAudioTrack)) || void 0 === r2 || !r2.track._muted);
              else c2 = void 0 === (null === (s2 = this.localTrackMap.get(lv.LocalVideoTrack)) || void 0 === s2 ? void 0 : s2.id);
              const d2 = this.createMuteMessage(o2);
              await yT(this, hv.RequestMuteLocal, d2);
              const l2 = "video" === e3.trackMediaType ? Av.MUTE_LOCAL_VIDEO : Av.MUTE_LOCAL_AUDIO;
              await yT(this, hv.RequestP2PMuteLocal, { action: l2, message: d2, isMuteAll: c2 }), t3();
            } catch (e4) {
              i2(e4);
            } finally {
              n2();
            }
          }), sh(this, "handleUnmuteLocalTrack", async (e3, t3, i2) => {
            const n2 = await this.sendMutex.lock("Locking from P2PChannel2.handleUnmuteLocalTrack");
            try {
              if (!this.sendConnection || this.state !== uv.Connected) return void i2(new Kg(Hg.INVALID_OPERATION, "Cannot call P2PChannel2.handleUnmuteLocalTrack before sendConnection established."));
              const r2 = this.filterTobeUnmutedTracks(e3);
              if (0 === r2.length) return void t3();
              await this.sendConnection.unmuteLocal(r2.map((e4) => {
                let [, { id: t4 }] = e4;
                return t4;
              }));
              const s2 = this.createUnmuteMessage(r2), o2 = "video" === e3.trackMediaType ? Av.UNMUTE_LOCAL_VIDEO : Av.UNMUTE_LOCAL_AUDIO;
              await yT(this, hv.RequestP2PMuteLocal, { action: o2, message: s2 }), t3();
            } catch (e4) {
              i2(e4);
            } finally {
              n2();
            }
          }), sh(this, "handleUpdateVideoEncoder", async (e3, t3, i2) => {
            const n2 = await this.sendMutex.lock("Locking from P2PChannel2.handleSetVideoEncoder");
            try {
              const i3 = this.localTrackMap.get(lv.LocalVideoTrack);
              if (!this.sendConnection || !i3 || i3.track !== e3 || this.state !== uv.Connected) return void t3();
              const { id: r2, track: s2 } = i3;
              r2 && (await this.sendConnection.updateSendParameters(r2, s2), await this.sendConnection.updateEncoderConfig(r2, s2), this.emit(hv.UpdateVideoEncoder, s2)), t3();
            } catch (e4) {
              i2(e4);
            } finally {
              n2();
            }
          }), sh(this, "handleSetOptimizationMode", async (e3, t3, i2) => {
            const n2 = await this.sendMutex.lock("Locking from P2PChannel2.handleSetOptimizationMode");
            try {
              const i3 = this.localTrackMap.get(lv.LocalVideoTrack);
              if (!this.sendConnection || !i3 || i3.track !== e3 || this.state !== uv.Connected) return;
              const { id: r2, track: s2 } = i3;
              r2 && await this.sendConnection.updateSendParameters(r2, s2), t3();
            } catch (e4) {
              i2(e4);
            } finally {
              n2();
            }
          }), sh(this, "handleReplaceTrack", async (e3, t3, i2, n2) => {
            let r2;
            jC.debug("[".concat(this.store.clientId, "] P2PChannel2 handleReplaceTrack for [track-id-").concat(e3.getTrackId(), "]")), "boolean" == typeof n2 && n2 || (r2 = await this.sendMutex.lock("From P2PChannel2.handleReplaceTrack"));
            try {
              var s2;
              const i3 = Array.from(this.localTrackMap.entries()).find((t4) => {
                let [, { track: i4 }] = t4;
                return e3 === i4;
              });
              if (!this.sendConnection || !i3 || void 0 === i3[1].id || this.state !== uv.Connected) return void t3();
              if (await (null === (s2 = this.sendConnection) || void 0 === s2 ? void 0 : s2.replaceTrack(e3, i3[1].id)), i3[0] === lv.LocalVideoTrack && IA().supportDualStreamEncoding) {
                const t4 = this.localTrackMap.get(lv.LocalVideoLowTrack);
                if (t4) {
                  const i4 = e3._mediaStreamTrack.clone();
                  t4.track._originMediaStreamTrack.stop(), t4.track._mediaStreamTrack = i4, t4.track._originMediaStreamTrack = i4, await new cg((e4, i5) => {
                    this.handleReplaceTrack(t4.track, e4, i5, true);
                  });
                }
              }
              t3();
            } catch (e4) {
              i2(e4);
            } finally {
              var o2;
              null === (o2 = r2) || void 0 === o2 || o2();
            }
          }), sh(this, "handleGetLocalVideoStats", (e3) => {
            e3(this.statsCollector.getLocalVideoTrackStats());
          }), sh(this, "handleGetLocalAudioStats", (e3) => {
            e3(this.statsCollector.getLocalAudioTrackStats());
          }), sh(this, "handleGetRemoteVideoStats", (e3) => this.statsCollector.getRemoteVideoTrackStats(e3.uid)[e3.uid]), sh(this, "handleGetRemoteAudioStats", (e3) => this.statsCollector.getRemoteAudioTrackStats(e3.uid)[e3.uid]), this.store = e2, this.statsCollector = t2, this.statsCollector.addP2PChannel(this), this.statsUploader = new rV(e2), this.bindStatsUploaderEvents(), this.reconnectInterval = window.setInterval(() => {
            [this.sendConnection, this.recvConnection].forEach((e3) => {
              e3 && ("disconnected" !== e3.iceConnectionState && "failed" !== e3.iceConnectionState || this.handleDisconnect(e3.direction));
            });
          }, RC("ICE_RESTART_INTERVAL"));
        }
        async startP2PConnection(e2, t2) {
          throw new Kg(Hg.NOT_SUPPORTED, "p2p mode does not support startP2PConnection.");
        }
        async connect(e2, t2, i2, n2, r2, s2) {
          throw new Kg(Hg.NOT_SUPPORTED, "p2p mode does not support connect.");
        }
        async startP2P(e2, t2) {
          let i2;
          try {
            if (t2) {
              this.recvConnection && (jC.warning("[".concat(this.store.clientId, "] P2PChannel.startP2P reset recvConnection.")), this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection)), i2 = await this.recvMutex.lock("From P2PChannel.startP2P"), this.recvConnection = new Bx(e2, this.store, TI.RECEIVE_ONLY), this.bindConnectionEvents(this.recvConnection);
              const n2 = await this.recvConnection.establish(t2);
              return { iceParameters: n2.iceParameters, dtlsParameters: n2.dtlsParameters, sdp: n2.sdp };
            }
            {
              this.state = uv.New, this.sendConnection && (jC.warning("[".concat(this.store.clientId, "] P2PChannel.startP2P reset sendConnection.")), this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection)), i2 = await this.sendMutex.lock("From P2PChannel.startP2P"), this.sendConnection = new Bx(e2, this.store), this.store.peerConnectionStart(), this.bindConnectionEvents(this.sendConnection);
              const t3 = await this.sendConnection.establish();
              return { iceParameters: t3.iceParameters, dtlsParameters: t3.dtlsParameters, sdp: t3.sdp };
            }
          } finally {
            i2 && i2();
          }
        }
        async p2pConnect(e2) {
          if (!this.sendConnection) throw new Kg(Hg.UNEXPECTED_ERROR, "Cannot P2PChannel2.p2pConnect before P2PChannel2.startP2PConnection .");
          this.store.peerConnectionStart(), await this.sendConnection.connect(e2), this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = uv.Connected;
        }
        async addRemoteCandidate(e2, t2) {
          if (t2 === TI.RECEIVE_ONLY) {
            if (!this.sendConnection) throw new Kg(Hg.UNEXPECTED_ERROR, "Cannot P2PChannel2.connect before P2PChannel2.addRemoteCandidate .");
            await this.sendConnection.addRemoteCandidate(e2);
          } else {
            if (!this.recvConnection) throw new Kg(Hg.UNEXPECTED_ERROR, "Cannot P2PChannel2.connect before P2PChannel2.addRemoteCandidate .");
            await this.recvConnection.addRemoteCandidate(e2);
          }
        }
        publish(e2, t2, i2) {
          var n2 = this;
          return PU(function* () {
            const r2 = yield IU(n2.sendMutex.lock("From P2PChannel.publish"));
            try {
              if (!n2.sendConnection || n2.state !== uv.Connected) {
                n2.throwIfTrackTypeNotMatch(e2);
                const t3 = e2.filter((e3) => -1 === n2.pendingLocalTracks.indexOf(e3));
                return void (n2.pendingLocalTracks = n2.pendingLocalTracks.concat(t3));
              }
              n2.store.pubId = n2.store.pubId + 1, RU.markPublishStart(n2.store.clientId, n2.store.pubId);
              const s2 = n2.filterTobePublishedTracks(e2, t2, i2);
              if (0 === s2.length) return void (yield IU(n2.tryToUnmuteAudio(e2)));
              s2.forEach((e3) => {
                let { track: t3, type: i3 } = e3;
                const r3 = Date.now();
                n2.store.publish(t3.getTrackId(), i3 === lv.LocalAudioTrack ? "audio" : "video", r3);
              }), n2.bindLocalTrackEvents(s2);
              const o2 = yield IU(n2.sendConnection.send(s2.map((e3) => {
                let { track: t3 } = e3;
                return t3;
              }), n2.store.codec, n2.store.audioCodec)), a2 = (yield IU(o2.next())).value, c2 = n2.createGatewayPublishMessage(s2, a2);
              try {
                yield c2;
              } catch (e3) {
                throw o2.throw(e3), (null == e3 ? void 0 : e3.code) === Hg.WS_ABORT && s2.forEach((e4) => {
                  let { track: t3 } = e4;
                  -1 === n2.pendingLocalTracks.indexOf(t3) && n2.pendingLocalTracks.push(t3);
                }), n2.unbindLocalTrackEvents(s2), e3;
              }
              yield IU(o2.next()), s2.forEach((e3) => {
                let { type: t3 } = e3;
                n2.statsCollector.addLocalStats(t3);
              }), n2.statsUploader.startUploadOutboundStats(), n2.assignLocalTracks(s2, a2), s2.forEach((e3) => {
                let { track: t3, type: i3 } = e3;
                const r3 = Date.now();
                n2.store.publish(t3.getTrackId(), i3 === lv.LocalAudioTrack ? "audio" : "video", void 0, r3);
              }), n2.startUploadUplinkState();
            } finally {
              r2();
            }
          })();
        }
        async unpublish(e2) {
          if (!this.sendConnection || this.state !== uv.Connected) return void (0 === e2.length ? this.pendingLocalTracks.length = 0 : this.pendingLocalTracks = this.pendingLocalTracks.filter((t3) => !bn(e2).call(e2, t3)));
          const t2 = this.filterTobeUnpublishedTracks(e2);
          if (0 === t2.length) return;
          const i2 = t2.find((e3) => "videoLowTrack" === e3[0]);
          if (i2) {
            i2[1].track.close();
          }
          const n2 = this.createGatewayUnpublishMessage(t2);
          if (await this.sendConnection.stopSending(t2.map((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          })), this.withdrawLocalTracks(t2), this.unbindLocalTrackEvents(t2.map((e3) => {
            let [t3, { track: i3 }] = e3;
            return { type: t3, track: i3 };
          })), t2.forEach((e3) => {
            let [t3] = e3;
            this.statsCollector.removeLocalStats(t3);
          }), 0 === this.localTrackMap.size && (this.statsUploader.stopUploadOutboundStats(), this.stopUploadUplinkState()), this.sendConnection && this.state === uv.Connected) {
            if (i2) {
              i2[1].track.close();
            }
            return n2;
          }
          e2.forEach((e3) => {
            const t3 = this.pendingLocalTracks.indexOf(e3);
            -1 !== t3 && this.pendingLocalTracks.splice(t3, 1);
          });
        }
        startUploadUplinkState() {
          if (this.uploadUnplinkStarted) return;
          this.uploadUnplinkStarted = true, this.uplinkStateUploadInterval && window.clearInterval(this.uplinkStateUploadInterval);
          const e2 = () => {
            const e3 = [], t2 = [];
            Array.from(this.localTrackMap.entries()).forEach((i2) => {
              let [n2, { track: r2, ssrcs: s2 }] = i2;
              const o2 = { stream_type: aV(r2, n2), ssrcs: s2 };
              r2._muted || !r2._enabled ? e3.push(o2) : t2.push(o2);
            }), e3.length > 0 && e3.forEach((e4) => {
              yT(this, hv.RequestMuteLocal, [e4]);
            }), t2.length > 0 && t2.forEach((e4) => {
              yT(this, hv.RequestUnmuteLocal, [e4]);
            });
          };
          e2(), this.uplinkStateUploadInterval = window.setInterval(() => {
            e2();
          }, 3e3);
        }
        stopUploadUplinkState() {
          this.uploadUnplinkStarted && (this.uploadUnplinkStarted = false, this.uplinkStateUploadInterval && window.clearInterval(this.uplinkStateUploadInterval));
        }
        publishLowStream(e2) {
          return PU(function* () {
            throw new Kg(Hg.NOT_SUPPORTED, "p2p mode does not support publishLowStream.");
          })();
        }
        async republish() {
          this.pendingLocalTracks.length > 0 && (jC.debug("[".concat(this.store.clientId, "] Emit P2PChannelEvents.RequestRePublish to republish tracks.")), await vT(this, hv.RequestRePublish, this.pendingLocalTracks), this.emit(hv.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = []);
        }
        async unpublishLowStream() {
          throw new Kg(Hg.NOT_SUPPORTED, "p2p mode does not support unpublishLowStream.");
        }
        async subscribe(e2, t2, i2, n2) {
          var r2;
          if (!this.recvConnection) throw new Kg(Hg.INVALID_OPERATION, "Cannot subscribe remote user when recvConnection disconnected.");
          if (null !== (r2 = this.remoteUserMap.get(e2)) && void 0 !== r2 && r2.has(t2)) return;
          const { track: s2, mid: o2, transceiver: a2 } = await this.recvConnection.receive(t2, [{ ssrcId: i2 }], String(e2.uid), n2);
          t2 === av.AUDIO ? (e2._audioTrack ? e2._audioTrack._updateOriginMediaStreamTrack(s2) : (e2._audioTrack = new Nw(s2, e2.uid, e2._uintid, this.store), jC.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(e2._audioTrack.getTrackId()))), a2 && e2._audioTrack._updateRtpTransceiver(a2), this.bindRemoteTrackEvents(e2, e2._audioTrack)) : (e2._videoSSRC = i2, e2._videoTrack ? e2._videoTrack._updateOriginMediaStreamTrack(s2) : (e2._videoTrack = new Ow(s2, e2.uid, e2._uintid, this.store), jC.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(e2._videoTrack.getTrackId()))), a2 && e2._videoTrack._updateRtpTransceiver(a2), this.bindRemoteTrackEvents(e2, e2._videoTrack));
          const c2 = this.remoteUserMap.get(e2);
          c2 ? c2.set(t2, o2) : this.remoteUserMap.set(e2, /* @__PURE__ */ new Map([[t2, o2]])), this.statsCollector.addRemoteStats(e2.uid), this.statsUploader.startUploadInboundStats(), this.startUploadDownlinkState();
          const d2 = this.pendingRemoteTracks.findIndex((i3) => {
            let { user: n3, kind: r3 } = i3;
            return n3.uid === e2.uid && t2 === r3;
          });
          -1 !== d2 && (this.pendingRemoteTracks.splice(d2, 1), this.emit(hv.MediaReconnectEnd, e2.uid));
        }
        async mockSubscribe(e2, t2, i2, n2) {
          if (!this.recvConnection) throw new Kg(Hg.INVALID_OPERATION, "Cannot subscribe remote user when recvConnection disconnected.");
          await this.recvConnection.mockReceive(t2, [{ ssrcId: i2 }], String(e2.uid), n2);
        }
        async unsubscribe(e2, t2, i2) {
          const n2 = this.pendingRemoteTracks.filter((i3) => {
            let { user: n3, kind: r3 } = i3;
            return void 0 !== t2 ? n3.uid === e2.uid && t2 === r3 : n3.uid === e2.uid;
          });
          if (n2.forEach((e3) => {
            const t3 = this.pendingRemoteTracks.indexOf(e3);
            this.pendingRemoteTracks.splice(t3, 1);
          }), this.recvConnection || i2 || n2.forEach((t3) => {
            let { kind: i3 } = t3;
            var n3;
            if (i3 === av.AUDIO) null === (n3 = e2._audioTrack) || void 0 === n3 || n3._destroy(), e2._audioTrack = void 0;
            else if (i3 === av.VIDEO) {
              var r3;
              null === (r3 = e2._videoTrack) || void 0 === r3 || r3._destroy(), e2._videoTrack = void 0;
            }
          }), !this.recvConnection) return;
          const r2 = this.filterTobeUnSubscribedTracks(e2, t2);
          0 !== r2.length && (await this.recvConnection.stopReceiving(r2.map((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          })), this.withdrawRemoteTracks(r2), 0 === this.remoteUserMap.size && (this.statsUploader.stopUploadInboundStats(), this.stopUploadDownlinkState()), r2.forEach((e3) => {
            let [t3, { kind: n3 }] = e3;
            var r3, s2;
            n3 === av.VIDEO && t3._videoSSRC && (null === (r3 = this.recvConnection) || void 0 === r3 || r3.setStatsRemoteVideoIsReady(t3._videoSSRC, false));
            if (n3 === av.VIDEO) this.unbindRemoteTrackEvents(t3._videoTrack), i2 || (null === (s2 = t3._videoTrack) || void 0 === s2 || s2._destroy(), t3._videoTrack = void 0);
            else if (n3 === av.AUDIO) {
              var o2;
              if (this.unbindRemoteTrackEvents(t3._audioTrack), !i2) null === (o2 = t3._audioTrack) || void 0 === o2 || o2._destroy(), t3._audioTrack = void 0;
            }
          }), r2.forEach((e3) => {
            let [, { kind: t3 }] = e3;
            yT(this, hv.RequestP2PMuteRemote, t3);
          }));
        }
        startUploadDownlinkState() {
          if (this.uploadDownlinkStarted) return;
          this.uploadDownlinkStarted = true, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval);
          const e2 = () => Array.from(this.remoteUserMap.entries()).forEach((e3) => {
            let [, t2] = e3;
            [av.VIDEO, av.AUDIO].forEach((e4) => {
              t2.has(e4) ? yT(this, hv.RequestP2PUnmuteRemote, e4) : yT(this, hv.RequestP2PMuteRemote, e4);
            });
          });
          e2(), this.downlinkStatsUploadInterval = window.setInterval(() => {
            e2();
          }, 3e3);
        }
        stopUploadDownlinkState() {
          this.uploadDownlinkStarted && (this.uploadDownlinkStarted = false, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval));
        }
        getAllDataChannels() {
          return this.localDataChannels;
        }
        async massSubscribe(e2) {
          throw new Kg(Hg.NOT_SUPPORTED, "p2p mode does not support massSubscribe.");
        }
        async massSubscribeNoLock(e2) {
          throw new Kg(Hg.NOT_SUPPORTED, "p2p mode does not support massSubscribeNoLock.");
        }
        async massUnsubscribe(e2) {
          throw new Kg(Hg.NOT_SUPPORTED, "p2p mode does not support massUnsubscribe.");
        }
        async massUnsubscribeNoLock(e2) {
          throw new Kg(Hg.NOT_SUPPORTED, "p2p mode does not support massUnsubscribeNoLock.");
        }
        async muteRemote(e2, t2) {
          if (!this.recvConnection) return;
          const i2 = this.remoteUserMap.get(e2);
          if (!i2) return void jC.warning("[".concat(this.store.clientId, "] P2PChannel2.muteRemote has no remote user ").concat(e2.uid, "."));
          if (!i2.get(t2)) return void jC.warning("[".concat(this.store.clientId, "] P2PChannel2.muteRemote has no remote user ").concat(e2.uid, " media type ").concat(t2, "."));
          const n2 = t2 === av.VIDEO ? e2._videoSSRC : e2._audioSSRC;
          void 0 !== n2 && this.recvConnection.setStatsRemoteVideoIsReady(n2, false);
        }
        async unmuteRemote(e2, t2) {
          return this.unmuteRemoteNoLock(e2, t2);
        }
        async unmuteRemoteNoLock(e2, t2) {
          if (!this.recvConnection) return;
          const i2 = this.remoteUserMap.get(e2);
          if (!i2) return void jC.warning("[".concat(this.store.clientId, "] P2PChannel2.unmuteRemote has no remote user ").concat(e2.uid, "."));
          i2.get(t2) || jC.warning("[".concat(this.store.clientId, "] P2PChannel2.unmuteRemote has no remote user ").concat(e2.uid, " media type ").concat(t2, "."));
        }
        getAllTracks(e2) {
          const t2 = this.localTrackMap.get(lv.LocalAudioTrack);
          if ((null == t2 ? void 0 : t2.track) instanceof nw) {
            const i2 = t2.track;
            return Array.from(this.localTrackMap.entries()).filter((e3) => {
              let [t3] = e3;
              return t3 !== lv.LocalAudioTrack;
            }).filter((t3) => {
              let [i3] = t3;
              return !(e2 && i3 === lv.LocalVideoLowTrack);
            }).map((e3) => {
              let [, { track: t3 }] = e3;
              return t3;
            }).concat(i2.trackList);
          }
          return Array.from(this.localTrackMap.entries()).filter((t3) => {
            let [i2] = t3;
            return !(e2 && i2 === lv.LocalVideoLowTrack);
          }).map((e3) => {
            let [, { track: t3 }] = e3;
            return t3;
          });
        }
        reportPublishEvent(e2, t2, i2, n2, r2) {
          if (e2) {
            const i3 = this.localTrackMap.get(lv.LocalAudioTrack), s3 = n2 ? this.localTrackMap.get(lv.LocalVideoLowTrack) : this.localTrackMap.get(lv.LocalVideoTrack);
            eI.publish(this.store.sessionId, { eventElapse: RU.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t2, audioName: null == i3 ? void 0 : i3.track.getTrackLabel(), videoName: null == s3 ? void 0 : s3.track.getTrackLabel(), screenshare: -1 !== (null == s3 ? void 0 : s3.track._hints.indexOf(jA.SCREEN_TRACK)), audio: !!i3, video: !!s3, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
          } else {
            var s2;
            i2 || (i2 = []);
            const o2 = i2.find((e3) => e3 instanceof ew), a2 = n2 ? null === (s2 = this.localTrackMap.get(lv.LocalVideoTrack)) || void 0 === s2 ? void 0 : s2.track : i2.find((e3) => e3 instanceof Rw);
            eI.publish(this.store.sessionId, { eventElapse: RU.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t2, audioName: null == o2 ? void 0 : o2.getTrackLabel(), videoName: null == a2 ? void 0 : a2.getTrackLabel(), screenshare: -1 !== (null == a2 ? void 0 : a2._hints.indexOf(jA.SCREEN_TRACK)), audio: !!o2, video: !!a2, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
          }
        }
        reportSubscribeEvent(e2, t2, i2, n2) {
          const r2 = n2 === av.VIDEO ? i2._videoSSRC : i2._audioSSRC;
          r2 && eI.subscribe(this.store.sessionId, { succ: e2, ec: t2, video: n2 === av.VIDEO, audio: n2 === av.AUDIO, peerid: i2.uid, subscribeRequestid: n2 === av.VIDEO ? i2._videoSSRC : i2._audioSSRC, p2pid: this.store.p2pId, eventElapse: RU.measureFromSubscribeStart(this.store.clientId, r2) });
        }
        reset() {
          jC.debug("[".concat(this.store.clientId, "] P2PChannel2.reset")), this.sendMutex = new pS("P2PChannel2-send-mutex"), this.sendMutex = new pS("P2PChannel2-recv-mutex"), this.sendConnection && (this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection), this.sendConnection = void 0), this.recvConnection && (this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection), this.recvConnection = void 0), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), this.statsUploader.stopUploadExtensionUsageStats(), this.stopUploadUplinkState(), this.stopUploadDownlinkState(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.unbindRtpTransceiver();
          const e2 = this.localTrackMap.get(lv.LocalAudioTrack);
          if ((null == e2 ? void 0 : e2.track) instanceof nw) {
            if (e2.track.trackList.length > 0) {
              const t2 = e2.track;
              e2.track.trackList.forEach((e3) => {
                t2.removeAudioTrack(e3);
              });
            }
            e2.track.close();
          }
          this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.reconnectInterval && (window.clearInterval(this.reconnectInterval), this.reconnectInterval = void 0), this.state = uv.Disconnected;
        }
        getStats(e2) {
          var t2, i2;
          return e2 ? null === (i2 = this.recvConnection) || void 0 === i2 ? void 0 : i2.getStats() : null === (t2 = this.sendConnection) || void 0 === t2 ? void 0 : t2.getStats();
        }
        getRemoteVideoIsReady(e2) {
          var t2;
          return (null === (t2 = this.recvConnection) || void 0 === t2 ? void 0 : t2.getRemoteVideoIsReady(e2)) || false;
        }
        getLocalAudioVolume() {
          const e2 = this.localTrackMap.get(lv.LocalAudioTrack);
          if (e2) return e2.track.getVolumeLevel();
        }
        getLocalVideoSize() {
          const e2 = this.localTrackMap.get(lv.LocalVideoTrack);
          if (e2) return { width: e2.track._videoWidth || 0, height: e2.track._videoHeight || 0 };
        }
        getEncoderConfig(e2) {
          const t2 = this.localTrackMap.get(e2);
          return t2 && t2.track instanceof Rw || t2 && t2.track instanceof ew ? t2.track._encoderConfig : void 0;
        }
        getLocalMedia(e2) {
          return this.localTrackMap.get(e2);
        }
        hasLocalMedia() {
          return this.localTrackMap.size > 0;
        }
        hasRemoteMedia(e2, t2) {
          if (!e2) return this.remoteUserMap.size > 0;
          const i2 = this.remoteUserMap.get(e2);
          return !!i2 && (!t2 || i2.has(t2));
        }
        async hasRemoteMediaWithLock(e2, t2) {
          if (!e2) return this.remoteUserMap.size > 0;
          const i2 = this.remoteUserMap.get(e2);
          return !!i2 && (!t2 || i2.has(t2));
        }
        getRemoteMedia(e2) {
          var t2;
          const i2 = Array.from(ph(t2 = this.remoteUserMap).call(t2)).find((t3) => t3.uid === e2);
          return i2 ? { audioTrack: i2.audioTrack, audioSSRC: i2._audioSSRC, videoTrack: i2.videoTrack, videoSSRC: i2._videoSSRC } : {};
        }
        getAudioLevels() {
          let e2 = Array.from(this.remoteUserMap.entries()).map((e3) => {
            let [t3] = e3;
            return { uid: t3.uid, level: t3.audioTrack ? 100 * t3.audioTrack._source.getAccurateVolumeLevel() : 0 };
          });
          const t2 = this.localTrackMap.get(lv.LocalAudioTrack);
          return t2 && e2.push({ level: 100 * t2.track._source.getAccurateVolumeLevel(), uid: this.store.uid }), e2 = ep(e2).call(e2, (e3, t3) => e3.level - t3.level), e2;
        }
        async disconnectForReconnect() {
          this.sendConnection && this.recvConnection && (jC.debug("[".concat(this.store.clientId, "] P2PChannel2.disconnectForReconnect closing P2PConnection")), this.state = uv.Reconnecting, RC("KEEP_LAST_FRAME") && 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t2] = e2;
            var i2;
            t2._videoTrack && t2._videoTrack._player && (null === (i2 = t2._videoTrack._player.getVideoElement()) || void 0 === i2 || i2.pause(), t2._videoTrack._player.isKeepLastFrame = true, t2._videoTrack._originMediaStreamTrack.stop());
          }), this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection), this.sendConnection = void 0, this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection), this.recvConnection = void 0, 0 !== this.localTrackMap.size && (Array.from(this.localTrackMap.entries()).forEach((e2) => {
            var t2;
            let [i2, { track: n2 }] = e2;
            switch (i2) {
              case lv.LocalVideoTrack:
                bn(t2 = n2._hints).call(t2, jA.LOW_STREAM) ? n2.close() : this.pendingLocalTracks.push(n2);
                break;
              case lv.LocalAudioTrack:
                n2 instanceof nw ? this.pendingLocalTracks = this.pendingLocalTracks.concat(n2.trackList) : this.pendingLocalTracks.push(n2);
              case lv.LocalVideoLowTrack:
            }
          }), this.emit(hv.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t2, i2] = e2;
            Array.from(ph(i2).call(i2)).forEach((e3) => {
              this.setPendingRemoteMedia(t2, e3);
            }), this.emit(hv.MediaReconnectStart, t2.uid);
          }), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), this.stopUploadUplinkState(), this.stopUploadDownlinkState(), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), jC.debug("[".concat(this.store.clientId, "] P2PChannel2 disconnected, waiting to reconnect.")));
        }
        hasPendingRemoteMedia(e2, t2) {
          for (const i2 of this.pendingRemoteTracks) {
            const { user: n2, kind: r2 } = i2;
            if ((e2 instanceof sV ? e2.uid : e2) === n2.uid && t2 === r2) return true;
          }
          return false;
        }
        setPendingRemoteMedia(e2, t2) {
          this.hasPendingRemoteMedia(e2, t2) || this.pendingRemoteTracks.push({ user: e2, kind: t2 });
        }
        async restartICE(e2, t2) {
          let i2, n2;
          if (e2 === TI.SEND_ONLY) {
            if (!this.sendConnection) throw new Kg(Hg.INVALID_OPERATION, "Cannot call P2PChannel2.handleMuteLocalTrack before sendConnection established.");
            i2 = await this.sendMutex.lock("From P2PChannel.restartICE"), n2 = this.sendConnection;
          } else {
            if (!this.recvConnection) throw new Kg(Hg.INVALID_OPERATION, "Cannot call P2PChannel2.handleMuteLocalTrack before recvConnection established.");
            i2 = await this.recvMutex.lock("From P2PChannel.restartICE"), n2 = this.recvConnection;
          }
          try {
            if (t2) {
              const e3 = await n2.restartICE(t2);
              return n2.isInRestartIce = false, e3;
            }
            {
              const e3 = await n2.restartICE();
              if (e3) {
                const t3 = await vT(this, hv.RequestP2PRestartICE, { direction: TI.RECEIVE_ONLY, iceParameter: e3 });
                await n2.restartICE(t3), n2.isInRestartIce = false;
              }
            }
          } finally {
            i2();
          }
        }
        getUplinkNetworkQuality() {
          if (!this.sendConnection) return 0;
          const e2 = this.sendConnection.getStats(), t2 = this.localTrackMap.get(lv.LocalVideoTrack), i2 = this.localTrackMap.get(lv.LocalAudioTrack), n2 = e2.videoSend.find((e3) => {
            var i3;
            return e3.ssrc === (null == t2 || null === (i3 = t2.ssrcs) || void 0 === i3 ? void 0 : i3[0].ssrcId);
          }), r2 = e2.audioSend.find((e3) => {
            var t3;
            return e3.ssrc === (null == i2 || null === (t3 = i2.ssrcs) || void 0 === t3 ? void 0 : t3[0].ssrcId);
          });
          if (!n2 || !r2) return 1;
          const s2 = AT(this, hv.NeedSignalRTT), o2 = n2 ? n2.rttMs : void 0, a2 = r2 ? r2.rttMs : void 0, c2 = o2 && a2 ? (o2 + a2) / 2 : o2 || a2, d2 = (c2 && s2 ? (c2 + s2) / 2 : c2 || s2) || 0, l2 = 100 * e2.sendPacketLossRate * 0.7 / 50 + 0.3 * d2 / 1500, u2 = l2 < 0.17 ? 1 : l2 < 0.36 ? 2 : l2 < 0.59 ? 3 : l2 < 0.1 ? 4 : 5, h3 = null == t2 ? void 0 : t2.track;
          if (h3 && h3._encoderConfig && -1 === h3._hints.indexOf(jA.SCREEN_TRACK)) {
            const t3 = h3._encoderConfig.bitrateMax, i3 = e2.bitrate.actualEncoded;
            if (t3 && i3) {
              const e3 = (1e3 * t3 - i3) / (1e3 * t3);
              return nI[e3 < 0.15 ? 0 : e3 < 0.3 ? 1 : e3 < 0.45 ? 2 : e3 < 0.6 ? 3 : 4][u2];
            }
          }
          return u2;
        }
        getDownlinkNetworkQuality() {
          if (!this.recvConnection) return 0;
          const e2 = this.recvConnection.getStats();
          let t2 = 0;
          return Array.from(this.remoteUserMap.entries()).forEach((i2) => {
            let [n2] = i2;
            const r2 = n2._audioSSRC, s2 = n2._videoSSRC, o2 = e2.audioRecv.find((e3) => e3.ssrc === r2), a2 = e2.videoRecv.find((e3) => e3.ssrc === s2);
            if (!o2 && !a2) return void (t2 += 1);
            const c2 = AT(this, hv.NeedSignalRTT), d2 = e2.rtt, l2 = (d2 && c2 ? (d2 + c2) / 2 : d2 || c2) || 0, u2 = o2 ? o2.jitterMs : void 0, h3 = e2.recvPacketLossRate;
            let p2 = 0.7 * h3 * 100 / 50 + 0.3 * l2 / 1500;
            u2 && (p2 = 0.6 * h3 * 100 / 50 + 0.2 * l2 / 1500 + 0.2 * u2 / 400);
            t2 += p2 < 0.1 ? 1 : p2 < 0.17 ? 2 : p2 < 0.36 ? 3 : p2 < 0.59 ? 4 : 5;
          }), this.remoteUserMap.size > 0 ? Math.round(t2 / this.remoteUserMap.size) : t2;
        }
        async muteLocalTrack(e2) {
          return new cg((t2, i2) => {
            this.handleMuteLocalTrack(e2, t2, i2);
          });
        }
        filterTobePublishedTracks(e2, t2, i2) {
          const n2 = [], r2 = IA(), s2 = this.getAllTracks();
          e2 = HT(e2 = e2.filter((e3) => -1 === s2.indexOf(e3)));
          let o2 = false, a2 = false;
          for (const s3 of e2) {
            if (s3 instanceof Rw && (this.localTrackMap.has(lv.LocalVideoTrack) || o2 ? new Kg(Hg.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (n2.push({ track: s3, type: lv.LocalVideoTrack }), o2 = true), t2)) {
              const e3 = this.getLowVideoTrack(s3, i2);
              n2.push({ track: e3, type: lv.LocalVideoLowTrack });
            }
            if (s3 instanceof ew) {
              const e3 = this.localTrackMap.get(lv.LocalAudioTrack);
              if (e3) {
                if (!(e3.track instanceof nw)) throw new Kg(Hg.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
                if (s3._bypassWebAudio) throw new Kg(Hg.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
                e3.track.addAudioTrack(s3), this.bindLocalAudioTrackEvents(s3, true);
              } else if (a2) {
                const e4 = n2.find((e5) => {
                  let { type: t3 } = e5;
                  return t3 === lv.LocalAudioTrack;
                });
                if (!(e4.track instanceof nw)) throw new Kg(Hg.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
                if (s3._bypassWebAudio) throw new Kg(Hg.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
                e4.track.addAudioTrack(s3);
              } else {
                if (!r2.webAudioMediaStreamDest || s3 instanceof nw || s3._bypassWebAudio) n2.push({ track: s3, type: lv.LocalAudioTrack });
                else {
                  const e4 = new nw();
                  e4.addAudioTrack(s3), n2.push({ track: e4, type: lv.LocalAudioTrack });
                }
                a2 = true;
              }
            }
          }
          return n2;
        }
        filterTobeUnpublishedTracks(e2) {
          const t2 = [], i2 = this.getAllTracks();
          e2 = HT(e2 = e2.filter((e3) => -1 !== i2.indexOf(e3)));
          for (const i3 of e2) {
            if (i3 instanceof ew) {
              const e3 = this.localTrackMap.get(lv.LocalAudioTrack);
              if (!e3) continue;
              e3.track instanceof nw ? (e3.track.removeAudioTrack(i3), this.unbindLocalAudioTrackEvents(i3), 0 === e3.track.trackList.length && (t2.push([lv.LocalAudioTrack, e3]), e3.track.close())) : t2.push([lv.LocalAudioTrack, e3]);
            }
            if (i3 instanceof Rw) {
              const e3 = this.localTrackMap.get(lv.LocalVideoTrack);
              if (!e3) continue;
              t2.push([lv.LocalVideoTrack, e3]);
              const i4 = this.localTrackMap.get(lv.LocalVideoLowTrack);
              i4 && t2.push([lv.LocalVideoLowTrack, i4]);
            }
          }
          return t2;
        }
        bindLocalTrackEvents(e2) {
          e2.forEach((e3) => {
            let { track: t2, type: i2 } = e3;
            switch (i2) {
              case lv.LocalVideoTrack:
                t2.addListener(BA.GET_STATS, this.handleGetLocalVideoStats), t2.addListener(BA.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.addListener(BA.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.addListener(BA.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.addListener(BA.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode), t2.addListener(BA.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.addListener(BA.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.addListener(BA.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case lv.LocalAudioTrack:
                this.bindLocalAudioTrackEvents(t2);
              case lv.LocalVideoLowTrack:
            }
          });
        }
        bindLocalAudioTrackEvents(e2, t2) {
          e2 instanceof nw ? e2.trackList.forEach((e3) => {
            e3.addListener(BA.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.addListener(BA.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.addListener(BA.GET_STATS, this.handleGetLocalAudioStats), e3.addListener(BA.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.addListener(BA.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          }) : (e2.addListener(BA.GET_STATS, this.handleGetLocalAudioStats), e2.addListener(BA.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.addListener(BA.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.addListener(BA.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.addListener(BA.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), t2 || e2.addListener(BA.NEED_REPLACE_TRACK, this.handleReplaceTrack));
        }
        unbindLocalTrackEvents(e2) {
          e2 || (e2 = Array.from(this.localTrackMap.entries()).map((e3) => {
            let [t2, { track: i2 }] = e3;
            return { track: i2, type: t2 };
          })), e2.forEach((e3) => {
            let { track: t2, type: i2 } = e3;
            switch (i2) {
              case lv.LocalVideoTrack:
                t2.off(BA.GET_STATS, this.handleGetLocalVideoStats), t2.off(BA.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.off(BA.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.off(BA.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.off(BA.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode), t2.off(BA.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.off(BA.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.off(BA.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case lv.LocalAudioTrack:
                this.unbindLocalAudioTrackEvents(t2);
              case lv.LocalVideoLowTrack:
            }
          });
        }
        unbindLocalAudioTrackEvents(e2) {
          e2 instanceof nw ? e2.trackList.forEach((e3) => {
            e3.off(BA.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.off(BA.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.off(BA.GET_STATS, this.handleGetLocalAudioStats), e3.off(BA.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.off(BA.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          }) : (e2.off(BA.GET_STATS, this.handleGetLocalAudioStats), e2.off(BA.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.off(BA.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.off(BA.NEED_REPLACE_TRACK, this.handleReplaceTrack), e2.off(BA.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.off(BA.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack));
        }
        bindRemoteTrackEvents(e2, t2) {
          t2 instanceof Ow && t2.addListener(BA.GET_STATS, (t3) => {
            t3(this.handleGetRemoteVideoStats(e2));
          }), t2 instanceof Nw && t2.addListener(BA.GET_STATS, (t3) => {
            t3(this.handleGetRemoteAudioStats(e2));
          });
        }
        unbindRemoteTrackEvents(e2) {
          e2 && e2.removeAllListeners(BA.GET_STATS);
        }
        unbindAllRemoteTrackEvents() {
          Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t2, i2] = e2;
            i2.has(av.AUDIO) && this.unbindRemoteTrackEvents(t2._audioTrack), i2.has(av.VIDEO) && this.unbindRemoteTrackEvents(t2._videoTrack);
          });
        }
        createGatewayPublishMessage(e2, t2) {
          return e2.map((e3, i2) => {
            var n2;
            let r2, { track: s2, type: o2 } = e3;
            switch (o2) {
              case lv.LocalAudioTrack:
                r2 = JI.Audio;
                break;
              case lv.LocalVideoTrack:
                r2 = bn(n2 = s2._hints).call(n2, jA.SCREEN_TRACK) ? JI.Screen : JI.High;
                break;
              case lv.LocalVideoLowTrack:
                r2 = JI.Low;
            }
            return { kind: o2 === lv.LocalAudioTrack ? av.AUDIO : av.VIDEO, stream_type: r2, mid: t2[i2].id, ssrcs: t2[i2].localSSRC, isMuted: s2.muted || !s2.enabled };
          });
        }
        createGatewayUnpublishMessage(e2) {
          return e2.map((e3) => {
            var t2;
            let i2, [n2, { track: r2, ssrcs: s2, id: o2 }] = e3;
            switch (n2) {
              case lv.LocalVideoTrack:
                i2 = bn(t2 = r2._hints).call(t2, jA.SCREEN_TRACK) ? JI.Screen : JI.High;
                break;
              case lv.LocalAudioTrack:
                i2 = JI.Audio;
                break;
              case lv.LocalVideoLowTrack:
                i2 = JI.Low;
            }
            return { stream_type: i2, ssrcs: s2, mid: o2 };
          });
        }
        assignLocalTracks(e2, t2) {
          e2.forEach((e3, i2) => {
            let { track: n2, type: r2 } = e3;
            this.localTrackMap.set(r2, { track: n2, id: t2[i2].id, ssrcs: t2[i2].localSSRC });
          });
        }
        withdrawLocalTracks(e2) {
          e2.forEach((e3) => {
            let [t2] = e3;
            this.localTrackMap.delete(t2);
          });
        }
        bindConnectionEvents(e2) {
          e2.onConnectionStateChange = async (t2) => {
            var i2;
            jC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: ").concat(e2.name, ".onConnectionStateChange(").concat(t2, ")")), this.emit(hv.PeerConnectionStateChange, t2), "connected" !== t2 || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), "connected" === t2 && (e2.isInRestartIce = false), bn(i2 = this._restartStates).call(i2, t2) && !e2.isInRestartIce && ("disconnected" === t2 && await iS(800), "disconnected" !== e2.iceConnectionState && "failed" !== e2.iceConnectionState || this.handleDisconnect(e2.direction));
          }, e2.onICEConnectionStateChange = (e3) => {
            "connected" !== e3 || this.store.keyMetrics.iceConnectionEnd || this.store.iceConnectionEnd(), jC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICEConnectionStateChange(").concat(e3, ")")), eI.reportApiInvoke(this.store.sessionId, { name: "ICEConnectionStateChange", options: e3, tag: pT.TRACER }).onSuccess(), this.emit(hv.IceConnectionStateChange, e3);
          }, e2.onICETransportStateChange = (e3) => {
            jC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICETransportStateChange(").concat(e3, ")"));
          }, e2.onDTLSTransportStateChange = (e3) => {
            jC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportStateChange(").concat(e3, ")"));
          }, e2.onDTLSTransportError = (e3) => {
            jC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportError(").concat(e3, ")"));
          }, e2.onFirstAudioDecoded = (e3) => {
            var t2;
            const i2 = Array.from(ph(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._audioSSRC === e3);
            var n2;
            i2 && (this.store.subscribe(i2.uid, "audio", void 0, void 0, void 0, Date.now()), null === (n2 = i2.audioTrack) || void 0 === n2 || n2.emit(qA.FIRST_FRAME_DECODED), eI.firstRemoteFrame(this.store.sessionId, YC.FIRST_AUDIO_DECODE, qC.FIRST_AUDIO_DECODE, { peer: i2._uintid, subscribeElapse: RU.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId }));
          }, e2.onFirstAudioReceived = (e3) => {
            var t2;
            const i2 = Array.from(ph(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._audioSSRC === e3);
            i2 && eI.firstRemoteFrame(this.store.sessionId, YC.FIRST_AUDIO_RECEIVED, qC.FIRST_AUDIO_RECEIVED, { peer: i2._uintid, subscribeElapse: RU.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
          }, e2.onFirstVideoDecoded = (e3, t2, i2) => {
            this.reportVideoFirstFrameDecoded(e3, t2, i2);
          }, e2.onFirstVideoReceived = (e3) => {
            var t2;
            const i2 = Array.from(ph(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._videoSSRC === e3);
            i2 && eI.firstRemoteFrame(this.store.sessionId, YC.FIRST_VIDEO_RECEIVED, qC.FIRST_VIDEO_RECEIVED, { peer: i2._uintid, subscribeElapse: RU.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
          }, e2.onSelectedLocalCandidateChanged = (e3, t2) => {
            const i2 = "relay" === e3.candidateType, n2 = "relay" === t2.candidateType;
            "unknown" !== t2.candidateType && i2 === n2 || this.emit(hv.ConnectionTypeChange, i2), jC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(Ay(t2)), " -> ").concat(JSON.stringify(Ay(e3)), ")"));
          }, e2.onSelectedRemoteCandidateChanged = (e3, t2) => {
            jC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(Ay(t2)), " -> ").concat(JSON.stringify(Ay(e3)), ")"));
          }, e2.onFirstVideoDecodedTimeout = (e3) => {
            this.reportVideoFirstFrameDecoded(e3, void 0, void 0, true);
          }, e2.onLocalCandidate = (t2) => {
            this.emit(hv.LocalCandidate, { candidate: t2, direction: e2.direction });
          };
        }
        unbindConnectionEvents(e2) {
          e2.onConnectionStateChange = void 0, e2.onICEConnectionStateChange = void 0, e2.onICETransportStateChange = void 0, e2.onDTLSTransportStateChange = void 0, e2.onDTLSTransportError = void 0, e2.onFirstAudioDecoded = void 0, e2.onFirstAudioReceived = void 0, e2.onFirstVideoDecoded = void 0, e2.onFirstVideoReceived = void 0, e2.onSelectedLocalCandidateChanged = void 0, e2.onSelectedRemoteCandidateChanged = void 0, e2.onFirstVideoDecodedTimeout = void 0, e2.onLocalCandidate = void 0;
        }
        async handleDisconnect(e2) {
          const t2 = e2 === TI.SEND_ONLY ? this.sendConnection : this.recvConnection;
          t2 && !t2.isInRestartIce && (t2.isInRestartIce = true, jC.debug("[".concat(this.store.clientId, "] [P2PChannel-").concat(t2.name, "] start use restartICE")), e2 === TI.SEND_ONLY ? this.restartICE(e2) : vT(this, hv.RequestP2PRestartICE, { direction: TI.SEND_ONLY }));
        }
        filterTobeMutedTracks(e2) {
          const t2 = [];
          if (-1 === this.getAllTracks().indexOf(e2)) return t2;
          const i2 = this.localTrackMap.get(lv.LocalAudioTrack);
          if (e2 instanceof ew && (null == i2 ? void 0 : i2.track) instanceof nw) return i2.track.isActive || t2.push([lv.LocalAudioTrack, i2]), t2;
          const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
            let [, { track: i3 }] = t3;
            return e2 === i3;
          });
          if (n2 && (t2.push(n2), n2[0] === lv.LocalVideoTrack)) {
            const e3 = this.localTrackMap.get(lv.LocalVideoLowTrack);
            e3 && t2.push([lv.LocalVideoLowTrack, e3]);
          }
          return t2;
        }
        filterTobeUnmutedTracks(e2) {
          const t2 = [], i2 = this.localTrackMap.get(lv.LocalAudioTrack);
          if (e2 instanceof ew && (null == i2 ? void 0 : i2.track) instanceof nw) return i2.track.isActive && t2.push([lv.LocalAudioTrack, i2]), t2;
          const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
            let [, { track: i3 }] = t3;
            return e2 === i3;
          });
          if (n2) if (n2[0] === lv.LocalVideoTrack) {
            t2.push(n2);
            const e3 = this.localTrackMap.get(lv.LocalVideoLowTrack);
            e3 && t2.push([lv.LocalVideoLowTrack, e3]);
          } else t2.push(n2);
          return t2;
        }
        createMuteMessage(e2) {
          return e2.map((e3) => {
            var t2;
            let i2, [n2, { track: r2, ssrcs: s2, id: o2 }] = e3;
            switch (n2) {
              case lv.LocalAudioTrack:
                i2 = JI.Audio;
                break;
              case lv.LocalVideoTrack:
                i2 = bn(t2 = r2._hints).call(t2, jA.SCREEN_TRACK) ? JI.Screen : JI.High;
                break;
              case lv.LocalVideoLowTrack:
                i2 = JI.Low;
            }
            return { stream_type: i2, ssrcs: s2, mid: o2 };
          });
        }
        createUnmuteMessage(e2) {
          return e2.map((e3) => {
            var t2;
            let i2, [n2, { track: r2, ssrcs: s2, id: o2 }] = e3;
            switch (n2) {
              case lv.LocalAudioTrack:
                i2 = JI.Audio;
                break;
              case lv.LocalVideoTrack:
                i2 = bn(t2 = r2._hints).call(t2, jA.SCREEN_TRACK) ? JI.Screen : JI.High;
                break;
              case lv.LocalVideoLowTrack:
                i2 = JI.Low;
            }
            return { stream_type: i2, ssrcs: s2, mid: o2 };
          });
        }
        filterTobeUnSubscribedTracks(e2, t2) {
          const i2 = [], n2 = this.remoteUserMap.get(e2);
          if (!n2) return i2;
          if (t2) {
            const r2 = n2.get(t2);
            if (!r2) return i2;
            i2.push([e2, { kind: t2, id: r2 }]);
          } else Array.from(n2.entries()).forEach((t3) => {
            let [n3, r2] = t3;
            i2.push([e2, { kind: n3, id: r2 }]);
          });
          return i2;
        }
        createUnsubscribeMessage(e2) {
          const t2 = [];
          return e2.forEach((e3) => {
            let [i2, { kind: n2, id: r2 }] = e3;
            switch (n2) {
              case av.VIDEO:
                return void (i2._videoSSRC && t2.push({ stream_type: av.VIDEO, ssrcId: i2._videoSSRC }));
              case av.AUDIO:
                return void (i2._audioSSRC && t2.push({ stream_type: av.AUDIO, ssrcId: i2._audioSSRC }));
            }
          }), t2;
        }
        withdrawRemoteTracks(e2) {
          e2.forEach((e3) => {
            let [t2, { kind: i2 }] = e3;
            const n2 = this.remoteUserMap.get(t2);
            n2 && (n2.delete(i2), 0 === Array.from(n2.entries()).length && this.remoteUserMap.delete(t2));
          });
        }
        async updateBitrateLimit(e2) {
          const t2 = this.localTrackMap.get(lv.LocalVideoTrack), i2 = this.localTrackMap.get(lv.LocalVideoLowTrack);
          t2 && await t2.track.setBitrateLimit(e2.uplink), i2 && e2.low_stream_uplink && await i2.track.setBitrateLimit({ max_bitrate: e2.low_stream_uplink.bitrate, min_bitrate: e2.low_stream_uplink.bitrate || 0 });
        }
        isP2PDisconnected() {
          if (this.sendConnection && this.recvConnection) {
            const e2 = this.sendConnection.peerConnectionState, t2 = this.recvConnection.peerConnectionState;
            return "connected" !== e2 && "connected" !== t2;
          }
          return true;
        }
        async tryToUnmuteAudio(e2) {
          for (let t2 = 0; t2 < e2.length; t2++) if (e2[t2] instanceof ew) {
            const i2 = this.filterTobeUnmutedTracks(e2[t2]);
            if (0 === i2.length) continue;
            const n2 = this.createUnmuteMessage(i2);
            return void await yT(this, hv.RequestUnmuteLocal, n2);
          }
        }
        bindStatsUploaderEvents() {
          this.statsUploader.requestStats = (e2) => this.getStats(e2), this.statsUploader.requestLocalMedia = () => Array.from(this.localTrackMap.entries()).filter((e2) => {
            let [, { ssrcs: t2 }] = e2;
            return !!t2;
          }), this.statsUploader.requestRemoteMedia = () => Array.from(this.remoteUserMap.entries()), this.statsUploader.requestVideoIsReady = (e2) => {
            var t2;
            return !(null === (t2 = this.recvConnection) || void 0 === t2 || !t2.getRemoteVideoIsReady(e2));
          }, this.statsUploader.requestUpload = (e2, t2) => this.emit(hv.RequestUpload, e2, t2), this.statsUploader.requestUploadStats = (e2) => this.emit(hv.RequestUploadStats, e2), this.statsUploader.requestAllTracks = () => this.getAllTracks();
        }
        unbindStatsUploaderEvents() {
          this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0;
        }
        async requestReconnect() {
          this.dtlsFailedCount += 1, await iS(mS(this.dtlsFailedCount, ES)), this.emit(hv.RequestReconnect);
        }
        async reconnectP2P() {
        }
        canPublishLowStream() {
          return this.localTrackMap.has(lv.LocalVideoTrack) || this.pendingLocalTracks.some((e2) => e2 instanceof Rw);
        }
        throwIfTrackTypeNotMatch(e2) {
          if (e2.filter((e3) => e3 instanceof Rw).length > 1) throw new Kg(Hg.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
          if (e2.filter((e3) => e3 instanceof ew).length > 1 && (e2.some((e3) => e3 instanceof ew && e3._bypassWebAudio) || !IA().webAudioMediaStreamDest)) throw new Kg(Hg.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
          for (const t2 of e2) {
            if (t2 instanceof Rw && this.pendingLocalTracks.some((e3) => e3 instanceof Rw)) throw new Kg(Hg.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
            if (t2 instanceof ew && this.pendingLocalTracks.some((e3) => e3 instanceof ew) && (!IA().webAudioMediaStreamDest || t2._bypassWebAudio || this.pendingLocalTracks.some((e3) => e3 instanceof ew && e3._bypassWebAudio))) throw new Kg(Hg.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
          }
        }
        getLowVideoTrack(e2, t2) {
          const i2 = !RC("DISABLE_DUAL_STREAM_USE_ENCODING") && IA().supportDualStreamEncoding, n2 = uV(uV({}, { width: 160, height: 120, framerate: 15, bitrate: 50 }), t2);
          let r2;
          r2 = i2 ? e2._mediaStreamTrack.clone() : Gx(e2, n2);
          const s2 = nS(8, "track-low-"), o2 = new Rw(r2, uV(uV({}, i2 && { scaleResolutionDownBy: yy(n2, e2) }), {}, { frameRate: n2.framerate, bitrateMax: n2.bitrate, bitrateMin: n2.bitrate }), void 0, void 0, s2);
          return o2.on(KA.TRANSCEIVER_UPDATED, (t3) => {
            e2._updateRtpTransceiver(t3, GA.LOW_STREAM);
          }), o2._hints.push(jA.LOW_STREAM), e2.addListener(BA.NEED_CLOSE, () => {
            o2.close();
          }), o2;
        }
        async globalLock() {
          return this.recvMutex.lock("From P2PChannel2.globalLock");
        }
        reportVideoFirstFrameDecoded(e2, t2, i2, n2) {
          var r2;
          const s2 = Array.from(ph(r2 = this.remoteUserMap).call(r2)).find((t3) => t3._videoSSRC === e2);
          if (s2) {
            n2 || this.store.subscribe(s2.uid, "video", void 0, void 0, void 0, void 0, Date.now());
            const r3 = this.store.keyMetrics, o2 = r3.subscribe.find((e3) => e3.userId === s2.uid && "video" === e3.type);
            eI.firstRemoteVideoDecode(this.store.sessionId, YC.FIRST_VIDEO_DECODE, qC.FIRST_VIDEO_DECODE, { peer: s2._uintid, videowidth: t2, videoheight: i2, subscribeElapse: RU.measureFromSubscribeStart(this.store.clientId, e2), subscribeRequestid: e2, p2pid: this.store.p2pId, apEnd: r3.requestAPEnd || 0, apStart: r3.requestAPStart || 0, joinGwEnd: r3.joinGatewayEnd || 0, joinGwStart: r3.joinGatewayStart || 0, pcEnd: r3.peerConnectionEnd || 0, pcStart: r3.peerConnectionStart || 0, subscriberEnd: (null == o2 ? void 0 : o2.subscribeEnd) || 0, subscriberStart: (null == o2 ? void 0 : o2.subscribeStart) || 0, videoAddNotify: (null == o2 ? void 0 : o2.streamAdded) || 0, state: n2 ? 1 : 0 });
          }
        }
        async remoteMediaSsrcChanged(e2, t2, i2) {
          if (!this.recvConnection) return false;
          const n2 = this.remoteUserMap.get(e2);
          if (!n2) return false;
          const r2 = n2.get(t2);
          if (!r2) return false;
          const s2 = await this.recvConnection.getRemoteSSRC(r2);
          return void 0 !== s2 && s2 !== i2;
        }
        resetConnection(e2) {
          jC.debug("[".concat(this.store.clientId, "] [P2PChannel2] reset connection to ").concat(e2)), this.state === uv.Connected ? (jC.debug("[".concat(this.store.clientId, "] [P2PChannel2] fallback to websocket but P2PChannel2 state still connected, disconnect first")), this.disconnectForReconnect()) : (this.sendConnection && (this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection), this.sendConnection = void 0), this.recvConnection && (this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection), this.recvConnection = void 0));
        }
        async publishDataChannel(e2) {
          throw new Kg(Hg.NOT_SUPPORTED);
        }
        async unpublishDataChannel(e2) {
          throw new Kg(Hg.NOT_SUPPORTED);
        }
        async subscribeDataChannel(e2, t2) {
          throw new Kg(Hg.NOT_SUPPORTED);
        }
        async unsubscribeDataChannel(e2, t2) {
          throw new Kg(Hg.NOT_SUPPORTED);
        }
        hasPendingRemoteDataChannel(e2, t2) {
          throw new Kg(Hg.NOT_SUPPORTED);
        }
        setPendingRemoteDataChannel(e2, t2) {
          throw new Kg(Hg.NOT_SUPPORTED);
        }
        async preConnect(e2, t2, i2, n2, r2, s2) {
          throw new Kg(Hg.NOT_SUPPORTED);
        }
        getEstablishParams() {
          throw new Kg(Hg.NOT_SUPPORTED);
        }
        async reSubscribe(e2) {
          throw new Kg(Hg.NOT_SUPPORTED);
        }
        async updateVideoStreamParameter(e2, t2) {
          throw new Kg(Hg.NOT_SUPPORTED);
        }
        unbindRtpTransceiver() {
          0 !== this.localTrackMap.size && Array.from(this.localTrackMap.entries()).forEach((e2) => {
            let [t2, { track: i2 }] = e2;
            t2 === lv.LocalVideoLowTrack ? i2._updateRtpTransceiver(void 0, GA.LOW_STREAM) : i2._updateRtpTransceiver(void 0);
          });
        }
      }
      function pV(e2) {
        return function(t2, i2, n2) {
          const r2 = t2[i2];
          if ("function" != typeof r2) throw new Error("Cannot use mutex on object property.");
          return n2.value = async function() {
            for (var t3 = arguments.length, n3 = new Array(t3), s2 = 0; s2 < t3; s2++) n3[s2] = arguments[s2];
            switch (e2) {
              case oV.SEND_ONLY: {
                const e3 = await this.sendMutex.lock("From P2PChannel2.".concat(i2));
                try {
                  return await r2.apply(this, n3);
                } finally {
                  e3();
                }
              }
              case oV.RECEIVE_ONLY: {
                const e3 = await this.recvMutex.lock("From P2PChannel2.".concat(i2));
                try {
                  return await r2.apply(this, n3);
                } finally {
                  e3();
                }
              }
              default: {
                const e3 = await this.sendMutex.lock("From P2PChannel2.".concat(i2)), t4 = await this.recvMutex.lock("From P2PChannel2.".concat(i2));
                try {
                  return await r2.apply(this, n3);
                } finally {
                  e3(), t4();
                }
              }
            }
          }, n2;
        };
      }
      function _V(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function EV(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? _V(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : _V(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      DI([pV(oV.SEND_ONLY), PI("design:type", Function), PI("design:paramtypes", [Object]), PI("design:returntype", cg)], hV.prototype, "p2pConnect", null), DI([pV(oV.SEND_ONLY), PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], hV.prototype, "unpublish", null), DI([pV(), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", cg)], hV.prototype, "unpublishLowStream", null), DI([pV(oV.RECEIVE_ONLY), PI("design:type", Function), PI("design:paramtypes", [sV, String, Number, String]), PI("design:returntype", cg)], hV.prototype, "subscribe", null), DI([pV(oV.RECEIVE_ONLY), PI("design:type", Function), PI("design:paramtypes", [sV, String, Number, String]), PI("design:returntype", cg)], hV.prototype, "mockSubscribe", null), DI([pV(oV.RECEIVE_ONLY), PI("design:type", Function), PI("design:paramtypes", [sV, String, Boolean]), PI("design:returntype", cg)], hV.prototype, "unsubscribe", null), DI([pV(oV.RECEIVE_ONLY), PI("design:type", Function), PI("design:paramtypes", [sV, String]), PI("design:returntype", cg)], hV.prototype, "muteRemote", null), DI([pV(oV.RECEIVE_ONLY), PI("design:type", Function), PI("design:paramtypes", [sV, String]), PI("design:returntype", cg)], hV.prototype, "unmuteRemote", null), DI([pV(oV.RECEIVE_ONLY), PI("design:type", Function), PI("design:paramtypes", [sV, String]), PI("design:returntype", cg)], hV.prototype, "hasRemoteMediaWithLock", null), DI([pV(), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", cg)], hV.prototype, "disconnectForReconnect", null), DI([pV(oV.RECEIVE_ONLY), PI("design:type", Function), PI("design:paramtypes", [sV, String, Number]), PI("design:returntype", cg)], hV.prototype, "remoteMediaSsrcChanged", null);
      class mV {
        constructor(e2) {
          sh(this, "store", void 0), sh(this, "onStatsException", void 0), sh(this, "onUploadPublishDuration", void 0), sh(this, "onStatsChanged", void 0), sh(this, "localStats", /* @__PURE__ */ new Map()), sh(this, "remoteStats", /* @__PURE__ */ new Map()), sh(this, "updateStatsInterval", void 0), sh(this, "trafficStats", void 0), sh(this, "trafficStatsPeerList", []), sh(this, "uplinkStats", void 0), sh(this, "exceptionMonitor", void 0), sh(this, "p2pChannel", void 0), sh(this, "scalabilityMode", oI.L1T1), sh(this, "updateStats", () => {
            this.p2pChannel && (this.updateRemoteStats(this.p2pChannel), this.updateLocalStats(this.p2pChannel));
          }), this.store = e2, this.updateStatsInterval = window.setInterval(this.updateStats, 1e3), this.exceptionMonitor = new TU(), this.exceptionMonitor.on("exception", (e3, t2, i2) => {
            this.onStatsException && this.onStatsException(e3, t2, i2);
          });
        }
        reset() {
          this.localStats = /* @__PURE__ */ new Map(), this.remoteStats = /* @__PURE__ */ new Map(), this.trafficStats = void 0, this.trafficStatsPeerList = [], this.uplinkStats = void 0;
        }
        getLocalAudioTrackStats() {
          return this.localStats.get(lv.LocalAudioTrack) || EV({}, XA);
        }
        getLocalVideoTrackStats() {
          return this.localStats.get(lv.LocalVideoTrack) || EV({}, QA);
        }
        getRemoteAudioTrackStats(e2) {
          const t2 = (e3, t3) => {
            if (!this.trafficStats) return t3;
            const i3 = this.trafficStats.peer_delay.find((t4) => t4.peer_uid === e3);
            return i3 && (t3.publishDuration = i3.B_ppad + (Date.now() - this.trafficStats.timestamp)), t3;
          }, i2 = {};
          if (e2) {
            var n2;
            const r2 = null === (n2 = this.remoteStats.get(e2)) || void 0 === n2 ? void 0 : n2.audioStats;
            r2 && (i2[e2] = t2(e2, r2));
          } else Array.from(this.remoteStats.entries()).forEach((e3) => {
            let [n3, { audioStats: r2 }] = e3;
            r2 && (i2[n3] = t2(n3, r2));
          });
          return i2;
        }
        getRemoteNetworkQualityStats(e2) {
          const t2 = {};
          if (e2) {
            var i2;
            const n2 = null === (i2 = this.remoteStats.get(e2)) || void 0 === i2 ? void 0 : i2.networkStats;
            n2 && (t2[e2] = n2);
          } else Array.from(this.remoteStats.entries()).forEach((e3) => {
            let [i3, { networkStats: n2 }] = e3;
            n2 && (t2[i3] = n2);
          });
          return t2;
        }
        getRemoteVideoTrackStats(e2) {
          const t2 = (e3, t3) => {
            if (!this.trafficStats) return t3;
            const i3 = this.trafficStats.peer_delay.find((t4) => t4.peer_uid === e3);
            return i3 && (t3.publishDuration = i3.B_ppvd + (Date.now() - this.trafficStats.timestamp)), t3;
          }, i2 = {};
          if (e2) {
            var n2;
            const r2 = null === (n2 = this.remoteStats.get(e2)) || void 0 === n2 ? void 0 : n2.videoStats;
            r2 && (i2[e2] = t2(e2, r2));
          } else Array.from(this.remoteStats.entries()).forEach((e3) => {
            let [n3, { videoStats: r2 }] = e3;
            r2 && (i2[n3] = t2(n3, r2));
          });
          return i2;
        }
        getRTCStats() {
          let e2 = 0, t2 = 0, i2 = 0, n2 = 0;
          const r2 = this.localStats.get(lv.LocalAudioTrack);
          r2 && (e2 += r2.sendBytes, t2 += r2.sendBitrate);
          const s2 = this.localStats.get(lv.LocalVideoTrack);
          s2 && (e2 += s2.sendBytes, t2 += s2.sendBitrate);
          const o2 = this.localStats.get(lv.LocalVideoLowTrack);
          o2 && (e2 += o2.sendBytes, t2 += o2.sendBitrate), this.remoteStats.forEach((e3) => {
            let { audioStats: t3, videoStats: r3 } = e3;
            t3 && (i2 += t3.receiveBytes, n2 += t3.receiveBitrate), r3 && (i2 += r3.receiveBytes, n2 += r3.receiveBitrate);
          });
          let a2 = 1;
          return this.trafficStats && (a2 += this.trafficStats.peer_delay.length), { Duration: 0, UserCount: a2, SendBitrate: t2, SendBytes: e2, RecvBytes: i2, RecvBitrate: n2, OutgoingAvailableBandwidth: this.uplinkStats ? this.uplinkStats.B_uab / 1e3 : 0, RTT: this.trafficStats ? 2 * this.trafficStats.B_acd : 0 };
        }
        addLocalStats(e2) {
          this.localStats.set(e2, void 0);
        }
        removeLocalStats(e2) {
          e2 ? this.localStats.delete(e2) : this.localStats.clear();
        }
        addRemoteStats(e2) {
          this.remoteStats.set(e2, {});
        }
        removeRemoteStats(e2) {
          e2 ? this.remoteStats.delete(e2) : this.remoteStats.clear();
        }
        addP2PChannel(e2) {
          this.p2pChannel = e2;
        }
        updateTrafficStats(e2) {
          e2.peer_delay = e2.peer_delay.filter((e3) => void 0 !== e3.B_ppad || void 0 !== e3.B_ppvd);
          e2.peer_delay.filter((e3) => -1 === this.trafficStatsPeerList.indexOf(e3.peer_uid)).forEach((e3) => {
            var t2;
            const i2 = null === (t2 = this.p2pChannel) || void 0 === t2 ? void 0 : t2.getRemoteMedia(e3.peer_uid), n2 = null != i2 && i2.videoSSRC ? RU.measureFromSubscribeStart(this.store.clientId, i2.videoSSRC) : 0, r2 = null != i2 && i2.audioSSRC ? RU.measureFromSubscribeStart(this.store.clientId, i2.audioSSRC) : 0;
            void 0 !== e3.B_ppad && void 0 !== e3.B_ppvd && (this.onUploadPublishDuration && this.onUploadPublishDuration(e3.peer_uid, e3.B_ppad, e3.B_ppvd, n2 > r2 ? n2 : r2), this.trafficStatsPeerList.push(e3.peer_uid));
          }), this.trafficStats = e2;
        }
        updateUplinkStats(e2) {
          this.uplinkStats && this.uplinkStats.B_fir !== e2.B_fir && jC.debug("[".concat(this.store.clientId, "]: Period fir changes to ").concat(e2.B_fir)), this.uplinkStats = e2;
        }
        static isRemoteVideoFreeze(e2, t2, i2) {
          if (!e2) return false;
          const n2 = !!i2 && t2.framesDecodeFreezeTime > i2.framesDecodeFreezeTime, r2 = !i2 || t2.framesDecodeCount > i2.framesDecodeCount;
          return n2 || !r2;
        }
        static isRemoteAudioFreeze(e2) {
          return !!e2 && e2._isFreeze();
        }
        isLocalVideoFreeze(e2) {
          return !(!e2.inputFrame || !e2.sentFrame) && (e2.inputFrame.frameRate > 5 && e2.sentFrame.frameRate < 3);
        }
        updateLocalStats(e2) {
          Array.from(this.localStats.entries()).forEach((t2) => {
            let [i2, n2] = t2;
            switch (i2) {
              case lv.LocalVideoTrack:
              case lv.LocalVideoLowTrack: {
                const t3 = n2, s2 = EV({}, QA), o2 = e2.getStats(), a2 = e2.getLocalMedia(i2);
                if (o2) {
                  const i3 = o2.videoSend.find((e3) => e3.ssrc === (null == a2 ? void 0 : a2.ssrcs[0].ssrcId));
                  if (i3) {
                    const n3 = e2.getLocalVideoSize(), r3 = e2.getEncoderConfig(lv.LocalVideoTrack);
                    "H264" !== i3.codec && "H265" !== i3.codec && "VP8" !== i3.codec && "VP9" !== i3.codec && "AV1X" !== i3.codec && "AV1" !== i3.codec || (s2.codecType = i3.codec), s2.sendBytes = i3.bytes, s2.sendBitrate = t3 ? 8 * Math.max(0, s2.sendBytes - t3.sendBytes) : 0, i3.inputFrame ? (s2.captureFrameRate = i3.inputFrame.frameRate, s2.captureResolutionHeight = i3.inputFrame.height, s2.captureResolutionWidth = i3.inputFrame.width) : n3 && (s2.captureResolutionWidth = n3.width, s2.captureResolutionHeight = n3.height), i3.sentFrame ? (s2.sendFrameRate = i3.sentFrame.frameRate, s2.sendResolutionHeight = i3.sentFrame.height, s2.sendResolutionWidth = i3.sentFrame.width) : n3 && (s2.sendResolutionWidth = n3.width, s2.sendResolutionHeight = n3.height), i3.avgEncodeMs && (s2.encodeDelay = i3.avgEncodeMs), r3 && r3.bitrateMax && (s2.targetSendBitrate = 1e3 * r3.bitrateMax), s2.sendPackets = i3.packets, s2.sendPacketsLost = i3.packetsLost, s2.sendJitterMs = i3.jitterMs, s2.sendRttMs = i3.rttMs, s2.totalDuration = t3 ? t3.totalDuration + 1 : 1, s2.totalFreezeTime = t3 ? t3.totalFreezeTime : 0, this.isLocalVideoFreeze(i3) && (s2.totalFreezeTime += 1), i3.scalabilityMode && this.scalabilityMode !== i3.scalabilityMode && (jC.debug("[".concat(this.store.clientId, "]: The scalabilityMode of the video sending stream is ").concat(i3.scalabilityMode)), this.scalabilityMode = i3.scalabilityMode);
                  }
                  this.trafficStats && (s2.currentPacketLossRate = (this.trafficStats.B_pvlr4 || 0) / 100);
                }
                var r2;
                if (this.localStats.set(i2, s2), (null == t3 ? void 0 : t3.sendResolutionWidth) !== s2.sendResolutionWidth || (null == t3 ? void 0 : t3.sendResolutionHeight) !== s2.sendResolutionHeight) null === (r2 = this.onStatsChanged) || void 0 === r2 || r2.call(this, "resolution", { width: s2.sendResolutionWidth, height: s2.sendResolutionHeight });
                s2 && a2 && this.exceptionMonitor.setLocalVideoStats(this.store.uid, a2.track, s2);
                break;
              }
              case lv.LocalAudioTrack: {
                const t3 = n2, r3 = EV({}, XA), s2 = e2.getStats(), o2 = e2.getLocalMedia(i2);
                if (s2) {
                  const i3 = s2.audioSend.find((e3) => e3.ssrc === (null == o2 ? void 0 : o2.ssrcs[0].ssrcId));
                  if (i3) {
                    if ("opus" !== i3.codec && "aac" !== i3.codec && "PCMU" !== i3.codec && "PCMA" !== i3.codec && "G722" !== i3.codec || (r3.codecType = i3.codec), i3.inputLevel) r3.sendVolumeLevel = Math.round(32767 * i3.inputLevel);
                    else {
                      const t4 = e2.getLocalAudioVolume();
                      t4 && (r3.sendVolumeLevel = Math.round(32767 * t4));
                    }
                    r3.sendBytes = i3.bytes, r3.sendPackets = i3.packets, r3.sendPacketsLost = i3.packetsLost, r3.sendJitterMs = i3.jitterMs, r3.sendRttMs = i3.rttMs, r3.sendBitrate = t3 ? 8 * Math.max(0, r3.sendBytes - t3.sendBytes) : 0;
                  }
                }
                this.trafficStats && (r3.currentPacketLossRate = (this.trafficStats.B_palr4 || 0) / 100), this.localStats.set(lv.LocalAudioTrack, r3), r3 && o2 && this.exceptionMonitor.setLocalAudioStats(this.store.uid, o2.track, r3);
                break;
              }
            }
          });
        }
        updateRemoteStats(e2) {
          Array.from(this.remoteStats.entries()).forEach((t2) => {
            var i2, n2;
            let [r2, { videoStats: s2, audioStats: o2, videoPcStats: a2 }] = t2;
            const c2 = o2, d2 = s2, l2 = a2, u2 = EV({}, ZA), h3 = EV({}, eb), p2 = EV({}, $A), { audioTrack: _2, videoTrack: E2, audioSSRC: m2, videoSSRC: f2 } = e2.getRemoteMedia(r2);
            let g2;
            g2 = e2 instanceof hV ? e2.getStats(true) : e2.getStats();
            const T2 = null === (i2 = g2) || void 0 === i2 ? void 0 : i2.audioRecv.find((e3) => e3.ssrc === m2), S2 = null === (n2 = g2) || void 0 === n2 ? void 0 : n2.videoRecv.find((e3) => e3.ssrc === f2), R2 = this.trafficStats && this.trafficStats.peer_delay.find((e3) => e3.peer_uid === r2);
            if (T2 && ("opus" !== T2.codec && "aac" !== T2.codec && "PCMU" !== T2.codec && "PCMA" !== T2.codec && "G722" !== T2.codec || (u2.codecType = T2.codec), T2.outputLevel ? u2.receiveLevel = Math.round(32767 * T2.outputLevel) : _2 && (u2.receiveLevel = Math.round(32767 * _2.getVolumeLevel())), u2.receiveBytes = T2.bytes, u2.receivePackets = T2.packets, u2.receivePacketsLost = T2.packetsLost, u2.packetLossRate = u2.receivePacketsLost / (u2.receivePackets + u2.receivePacketsLost), u2.receiveBitrate = c2 ? 8 * Math.max(0, u2.receiveBytes - c2.receiveBytes) : 0, u2.totalDuration = c2 ? c2.totalDuration + 1 : 1, u2.totalFreezeTime = c2 ? c2.totalFreezeTime : 0, u2.freezeRate = u2.totalFreezeTime / u2.totalDuration, u2.receiveDelay = T2.jitterBufferMs, u2.totalDuration > 10 && mV.isRemoteAudioFreeze(_2) && (u2.totalFreezeTime += 1)), S2) {
              "H264" !== S2.codec && "H265" !== S2.codec && "VP8" !== S2.codec && "VP9" !== S2.codec && "AV1X" !== S2.codec && "AV1" !== S2.codec || (h3.codecType = S2.codec), h3.receiveBytes = S2.bytes, h3.receiveBitrate = d2 ? 8 * Math.max(0, h3.receiveBytes - d2.receiveBytes) : 0, h3.decodeFrameRate = S2.decodeFrameRate < 0 ? 0 : S2.decodeFrameRate, h3.renderFrameRate = S2.decodeFrameRate < 0 ? 0 : S2.decodeFrameRate, S2.outputFrame && (h3.renderFrameRate = S2.outputFrame.frameRate), S2.receivedFrame ? (h3.receiveFrameRate = S2.receivedFrame.frameRate, h3.receiveResolutionHeight = S2.receivedFrame.height, h3.receiveResolutionWidth = S2.receivedFrame.width) : E2 && (h3.receiveResolutionHeight = E2._videoHeight || 0, h3.receiveResolutionWidth = E2._videoWidth || 0), void 0 !== S2.framesRateFirefox && (h3.receiveFrameRate = Math.round(S2.framesRateFirefox)), h3.receivePackets = S2.packets, h3.receivePacketsLost = S2.packetsLost, h3.packetLossRate = h3.receivePacketsLost / (h3.receivePackets + h3.receivePacketsLost), h3.totalDuration = d2 ? d2.totalDuration + 1 : 1, h3.totalFreezeTime = d2 ? d2.totalFreezeTime : 0, h3.receiveDelay = S2.jitterBufferMs || 0;
              const t3 = !!f2 && e2.getRemoteVideoIsReady(f2);
              E2 && t3 && mV.isRemoteVideoFreeze(E2, S2, l2) && (h3.totalFreezeTime += 1), h3.freezeRate = h3.totalFreezeTime / h3.totalDuration;
            }
            R2 && (u2.end2EndDelay = R2.B_ad, h3.end2EndDelay = R2.B_vd, u2.transportDelay = R2.B_ed, h3.transportDelay = R2.B_ed, u2.currentPacketLossRate = R2.B_ealr4 / 100, h3.currentPacketLossRate = R2.B_evlr4 / 100, p2.uplinkNetworkQuality = R2.B_punq ? R2.B_punq : 0, p2.downlinkNetworkQuality = R2.B_pdnq ? R2.B_pdnq : 0), this.remoteStats.set(r2, { audioStats: u2, videoStats: h3, videoPcStats: S2, networkStats: p2 }), _2 && this.exceptionMonitor.setRemoteAudioStats(_2, u2), E2 && this.exceptionMonitor.setRemoteVideoStats(E2, h3);
          });
        }
      }
      function fV(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function gV(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? fV(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : fV(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class TV extends dT {
        constructor(e2, t2, i2, n2) {
          super(), sh(this, "spec", void 0), sh(this, "token", void 0), sh(this, "websocket", void 0), sh(this, "pingpongTimer", void 0), sh(this, "reconnectMode", "retry"), sh(this, "serviceMode", void 0), sh(this, "reqId", 0), sh(this, "commandReqId", 0), sh(this, "handleWebSocketOpen", () => {
            this.reconnectMode = "retry", this.startPingPong();
          }), sh(this, "handleWebSocketMessage", (e3) => {
            if (!e3.data) return;
            const t3 = JSON.parse(e3.data);
            t3.requestId ? this.emit("@".concat(t3.requestId, "-").concat(t3.sid), t3) : this.serviceMode === RI.INJECT ? this.emit(jI.INJECT_STREAM_STATUS, t3) : (eI.workerEvent(this.spec.sid, { actionType: "status", serverCode: t3.code, workerType: this.serviceMode === RI.TRANSCODE ? 1 : 2 }), this.emit(jI.PUBLISH_STREAM_STATUS, t3));
          }), this.spec = t2, this.token = e2, this.serviceMode = n2, this.websocket = new zv("live-streaming", i2), this.websocket.on(SI.CONNECTED, this.handleWebSocketOpen), this.websocket.on(SI.ON_MESSAGE, this.handleWebSocketMessage), this.websocket.on(SI.REQUEST_NEW_URLS, (e3, t3) => {
            vT(this, jI.REQUEST_NEW_ADDRESS).then(e3).catch(t3);
          }), this.websocket.on(SI.RECONNECTING, () => {
            this.websocket.reconnectMode = this.reconnectMode;
          });
        }
        init(e2) {
          return this.websocket.init(e2);
        }
        async request(e2, t2, i2, n2) {
          this.reqId += 1, "request" === e2 && (this.commandReqId += 1);
          const r2 = this.commandReqId, s2 = this.reqId;
          if (!s2 || !this.websocket) throw new LI(Hg.UNEXPECTED_ERROR);
          const o2 = gV({ command: e2, sdkVersion: "4.20.2" === EC ? "0.0.1" : EC, seq: s2, requestId: s2, allocate: i2, cname: this.spec.cname, appId: this.spec.appId, sid: this.spec.sid, uid: this.spec.uid.toString(), ts: Math.floor(Date.now() / 1e3) }, t2);
          if ("closed" === this.websocket.state) throw new LI(Hg.WS_DISCONNECT);
          const a2 = () => new cg((e3, t3) => {
            this.websocket.once(SI.CLOSED, () => t3(new LI(Hg.WS_ABORT))), this.websocket.once(SI.CONNECTED, e3);
          });
          "connected" !== this.websocket.state && await a2(), o2.clientRequest && (o2.clientRequest.workerToken = this.token);
          const c2 = new cg((e3, t3) => {
            const i3 = () => {
              t3(new LI(Hg.WS_ABORT));
            };
            this.websocket.once(SI.RECONNECTING, i3), this.websocket.once(SI.CLOSED, i3), this.once("@".concat(s2, "-").concat(this.spec.sid), (t4) => {
              e3(t4);
            });
          });
          n2 && eI.workerEvent(this.spec.sid, gV(gV({}, n2), {}, { requestId: r2, actionType: "request", payload: JSON.stringify(t2.clientRequest), serverCode: 0, code: 0 }));
          const d2 = Date.now();
          this.websocket.sendMessage(o2);
          let l2 = null;
          try {
            l2 = await c2;
          } catch (n3) {
            if ("closed" === this.websocket.state) throw n3;
            return await a2(), await this.request(e2, t2, i2);
          }
          return n2 && eI.workerEvent(this.spec.sid, gV(gV({}, n2), {}, { requestId: r2, actionType: "response", payload: JSON.stringify(l2.serverResponse), serverCode: l2.code, success: 200 === l2.code, responseTime: Date.now() - d2 })), 200 !== l2.code && this.handleResponseError(l2), l2;
        }
        tryNextAddress() {
          this.reconnectMode = "tryNext", this.websocket.reconnect("tryNext");
        }
        close() {
          const e2 = "4.20.2" === EC ? "0.0.1" : EC;
          this.reqId += 1, "connected" === this.websocket.state ? (this.websocket.sendMessage({ command: "request", appId: this.spec.appId, cname: this.spec.cname, uid: this.spec.uid.toString(), sdkVersion: e2, sid: this.spec.sid, seq: this.reqId, ts: Math.floor(Date.now() / 1e3), requestId: this.reqId, clientRequest: { command: "DestroyWorker" } }), this.websocket.close(false, true)) : this.websocket.close(false), this.pingpongTimer && (window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0);
        }
        handleResponseError(e2) {
          switch (e2.code) {
            case WI.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM:
              return void jC.warning("live stream response already exists stream");
            case WI.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR:
            case WI.LIVE_STREAM_RESPONSE_BAD_STREAM:
            case WI.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR:
              return new LI(Hg.LIVE_STREAMING_INVALID_ARGUMENT, "", { code: e2.code }).throw();
            case WI.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST:
              if ("UnpublishStream" === e2.serverResponse.command || "UninjectStream" === e2.serverResponse.command) return;
              throw new LI(Hg.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: true });
            case WI.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED:
              return new LI(Hg.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED, "", { code: e2.code }).throw();
            case WI.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
              const t2 = new LI(Hg.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE);
              return this.emit(jI.WARNING, t2, e2.serverResponse.url);
            }
            case WI.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN: {
              const t2 = new LI(Hg.LIVE_STREAMING_WARN_FREQUENT_REQUEST);
              return this.emit(jI.WARNING, t2, e2.serverResponse.url);
            }
            case WI.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH:
              throw new LI(Hg.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: true });
            case WI.LIVE_STREAM_RESPONSE_NOT_SUPPORTED:
              return new LI(Hg.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED, "", { code: e2.code }).throw();
            case WI.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM: {
              const t2 = new LI(Hg.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT);
              return this.emit(jI.WARNING, t2, e2.serverResponse.url);
            }
            case WI.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR:
              return new LI(Hg.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e2.code }).throw();
            case WI.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT:
              throw new LI(Hg.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream resource limit", { retry: true, changeAddress: true });
            case WI.LIVE_STREAM_RESPONSE_WORKER_LOST:
            case WI.LIVE_STREAM_RESPONSE_WORKER_QUIT:
              if ("UnpublishStream" === e2.serverResponse.command || "UninjectStream" === e2.serverResponse.command) return;
              throw new LI(Hg.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: true, changeAddress: true });
            case WI.ERROR_FAIL_SEND_MESSAGE:
              if ("UnpublishStream" === e2.serverResponse.command || "UninjectStream" === e2.serverResponse.command) return;
              if ("UpdateTranscoding" === e2.serverResponse.command || "ControlStream" === e2.serverResponse.command) return new LI(Hg.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { code: e2.code }).throw();
              throw new LI(Hg.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: true, changeAddress: true });
            case WI.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
            case WI.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
            case WI.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
            case WI.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:
              return new LI(Hg.LIVE_STREAMING_CDN_ERROR, "", { code: e2.code }).throw();
          }
        }
        startPingPong() {
          this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(() => {
            "connected" === this.websocket.state && this.request("ping", {}).catch(sS);
          }, 6e3);
        }
      }
      function SV(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function RV(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? SV(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : SV(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class CV extends dT {
        constructor(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ES, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ES;
          super(), sh(this, "onLiveStreamWarning", void 0), sh(this, "onLiveStreamError", void 0), sh(this, "onInjectStatusChange", void 0), sh(this, "spec", void 0), sh(this, "retryTimeout", 1e4), sh(this, "connection", void 0), sh(this, "httpRetryConfig", void 0), sh(this, "wsRetryConfig", void 0), sh(this, "streamingTasks", /* @__PURE__ */ new Map()), sh(this, "isStartingStreamingTask", false), sh(this, "taskMutex", new pS("live-streaming")), sh(this, "cancelToken", sC.CancelToken.source()), sh(this, "transcodingConfig", void 0), sh(this, "injectConfig", RV({}, BI)), sh(this, "injectLoopTimes", 0), sh(this, "uapResponse", void 0), sh(this, "lastTaskId", 1), sh(this, "statusError", /* @__PURE__ */ new Map()), this.spec = e2, this.httpRetryConfig = i2, this.wsRetryConfig = t2;
        }
        async setTranscodingConfig(e2) {
          const t2 = RV(RV({}, FI), e2);
          66 !== t2.videoCodecProfile && 77 !== t2.videoCodecProfile && 100 !== t2.videoCodecProfile && (jC.debug("[".concat(this.spec.clientId, "] set transcoding config, fix video codec profile: ").concat(t2.videoCodecProfile, " -> 100")), t2.videoCodecProfile = 100), t2.transcodingUsers || (t2.transcodingUsers = t2.userConfigs), t2.transcodingUsers && (t2.transcodingUsers = t2.transcodingUsers.map((e3) => RV(RV(RV({}, UI), e3), {}, { zOrder: e3.zOrder ? e3.zOrder + 1 : 1 }))), function(e3) {
            Zg(e3.width) || zg(e3.width, "config.width", 0, 1e4), Zg(e3.height) || zg(e3.height, "config.height", 0, 1e4), Zg(e3.videoBitrate) || zg(e3.videoBitrate, "config.videoBitrate", 1, 1e6), Zg(e3.videoFrameRate) || zg(e3.videoFrameRate, "config.videoFrameRate"), Zg(e3.lowLatency) || Yg(e3.lowLatency, "config.lowLatency"), Zg(e3.audioSampleRate) || qg(e3.audioSampleRate, "config.audioSampleRate", [32e3, 44100, 48e3]), Zg(e3.audioBitrate) || zg(e3.audioBitrate, "config.audioBitrate", 1, 128), Zg(e3.audioChannels) || qg(e3.audioChannels, "config.audioChannels", [1, 2, 3, 4, 5]), Zg(e3.videoGop) || zg(e3.videoGop, "config.videoGop"), Zg(e3.videoCodecProfile) || qg(e3.videoCodecProfile, "config.videoCodecProfile", [66, 77, 100]), Zg(e3.userCount) || zg(e3.userCount, "config.userCount", 0, 17), Zg(e3.backgroundColor) || zg(e3.backgroundColor, "config.backgroundColor", 0, 16777215), Zg(e3.userConfigExtraInfo) || Xg(e3.userConfigExtraInfo, "config.userConfigExtraInfo", 0, 4096, false), e3.transcodingUsers && !Zg(e3.transcodingUsers) && (Qg(e3.transcodingUsers, "config.transcodingUsers"), e3.transcodingUsers.forEach((e4, t3) => {
              MI(e4.uid), Zg(e4.x) || zg(e4.x, "transcodingUser[".concat(t3, "].x"), 0, 1e4), Zg(e4.y) || zg(e4.y, "transcodingUser[".concat(t3, "].y"), 0, 1e4), Zg(e4.width) || zg(e4.width, "transcodingUser[".concat(t3, "].width"), 0, 1e4), Zg(e4.height) || zg(e4.height, "transcodingUser[".concat(t3, "].height"), 0, 1e4), Zg(e4.zOrder) || zg(e4.zOrder - 1, "transcodingUser[".concat(t3, "].zOrder"), 0, 100), Zg(e4.alpha) || zg(e4.alpha, "transcodingUser[".concat(t3, "].alpha"), 0, 1, false);
            })), Zg(e3.watermark) || VI(e3.watermark, "watermark"), Zg(e3.backgroundImage) || VI(e3.backgroundImage, "backgroundImage"), e3.images && !Zg(e3.images) && (Qg(e3.images, "config.images"), e3.images.forEach((e4, t3) => {
              VI(e4, "images[".concat(t3, "]"));
            }));
          }(t2);
          const i2 = [];
          t2.images && i2.push(...t2.images.map((e3) => RV(RV(RV({}, xI), e3), {}, { zOrder: 255 }))), t2.backgroundImage && (i2.push(RV(RV(RV({}, xI), t2.backgroundImage), {}, { zOrder: 0 })), delete t2.backgroundImage), t2.watermark && (i2.push(RV(RV(RV({}, xI), t2.watermark), {}, { zOrder: 255 })), delete t2.watermark), t2.images = i2, t2.transcodingUsers && (t2.userConfigs = t2.transcodingUsers.map((e3) => RV({}, e3)), t2.userCount = t2.transcodingUsers.length, delete t2.transcodingUsers);
          const n2 = (t2.userConfigs || []).map((e3) => "number" == typeof e3.uid ? cg.resolve(e3.uid) : pA(e3.uid, this.spec, this.cancelToken.token, this.httpRetryConfig));
          if ((await cg.all(n2)).forEach((e3, i3) => {
            t2.userConfigs && t2.userConfigs[i3] && (t2.userConfigs[i3].uid = e3);
          }), this.transcodingConfig = t2, this.connection) try {
            var r2;
            const e3 = await this.connection.request("request", { clientRequest: { command: "UpdateTranscoding", transcodingConfig: this.transcodingConfig } }, false, { command: "UpdateTranscoding", workerType: 1, requestByUser: true, tid: Array.from(NI(r2 = this.streamingTasks).call(r2)).map((e4) => e4.taskId).join("#") });
            jC.debug("[".concat(this.spec.clientId, "] update live transcoding config success, code: ").concat(e3.code, ", config:"), JSON.stringify(this.transcodingConfig));
          } catch (e3) {
            if (!e3.data || !e3.data.retry) throw e3;
            e3.data.changeAddress && this.connection.tryNextAddress(), this.streamingTasks.forEach((t3) => {
              jC.warning("[".concat(this.spec.clientId, "] live streaming receive error"), e3.toString(), "try to republish", t3.url), this.startLiveStreamingTask(t3.url, t3.mode, e3).then(() => {
                jC.debug("[".concat(this.spec.clientId, "] live streaming republish ").concat(t3.url, " success"));
              }).catch((e4) => {
                jC.error("[".concat(this.spec.clientId, "] live streaming republish failed"), t3.url, e4.toString()), this.onLiveStreamError && this.onLiveStreamError(t3.url, e4);
              });
            });
          }
        }
        setInjectStreamConfig(e2, t2) {
          this.injectConfig = Object.assign({}, this.injectConfig, e2), this.injectLoopTimes = t2;
        }
        async startLiveStreamingTask(e2, t2, i2) {
          var n2;
          if (Array.from(NI(n2 = this.streamingTasks).call(n2)).find((e3) => e3.mode === RI.INJECT) && t2 === RI.INJECT) return new LI(Hg.LIVE_STREAMING_TASK_CONFLICT, "inject stream over limit").throw();
          if (!this.transcodingConfig && t2 === RI.TRANSCODE) throw new LI(Hg.INVALID_OPERATION, "[LiveStreaming] no transcoding config found, can not start transcoding streaming task");
          let r2 = { command: "PublishStream", ts: Date.now(), url: e2, uid: this.spec.uid.toString(), autoDestroyTime: 100, acceptImageTimeout: true };
          jC.debug("[".concat(this.spec.clientId, "] start live streaming ").concat(e2, ", mode: ").concat(t2));
          const s2 = await this.taskMutex.lock();
          if (!this.connection && i2) return void s2();
          if (this.streamingTasks.get(e2) && !i2) return s2(), new LI(Hg.LIVE_STREAMING_TASK_CONFLICT).throw();
          try {
            this.connection || (this.connection = await this.connect(t2));
          } catch (e3) {
            throw s2(), e3;
          }
          switch (t2) {
            case RI.TRANSCODE:
              r2.transcodingConfig = RV({}, this.transcodingConfig);
              break;
            case RI.RAW:
              break;
            case RI.INJECT:
              r2 = { cname: this.spec.cname, command: "InjectStream", sid: this.spec.sid, transcodingConfig: this.injectConfig, ts: Date.now(), url: e2, loopTimes: this.injectLoopTimes };
          }
          this.uapResponse && this.uapResponse.vid && (r2.vid = this.uapResponse.vid), this.isStartingStreamingTask = true;
          const o2 = this.lastTaskId++;
          try {
            const n3 = new cg((t3, n4) => {
              iS(this.retryTimeout).then(() => {
                if (i2) return n4(i2);
                const t4 = this.statusError.get(e2);
                return t4 ? (this.statusError.delete(e2), n4(t4)) : void 0;
              });
            }), a2 = await cg.race([this.connection.request("request", { clientRequest: r2 }, true, { url: e2, command: "PublishStream", workerType: t2 === RI.TRANSCODE ? 1 : 2, requestByUser: !i2, tid: o2.toString() }), n3]);
            this.isStartingStreamingTask = false, jC.debug("[".concat(this.spec.clientId, "] live streaming started, code: ").concat(a2.code)), this.streamingTasks.set(e2, { clientRequest: r2, mode: t2, url: e2, taskId: o2 }), s2();
          } catch (n3) {
            if (s2(), this.isStartingStreamingTask = false, !n3.data || !n3.data.retry || i2) throw n3;
            return n3.data.changeAddress ? (this.connection.tryNextAddress(), await this.startLiveStreamingTask(e2, t2, n3)) : await this.startLiveStreamingTask(e2, t2, n3);
          }
        }
        stopLiveStreamingTask(e2) {
          return new cg((t2, i2) => {
            const n2 = this.streamingTasks.get(e2);
            if (!n2 || !this.connection) return new LI(Hg.UNEXPECTED_ERROR, "can not find streaming task to stop").throw();
            const r2 = n2.mode;
            n2.abortTask = () => {
              jC.debug("[".concat(this.spec.clientId, "] stop live streaming success(worker exception)")), this.streamingTasks.delete(e2), t2();
            }, this.connection.request("request", { clientRequest: { command: r2 === RI.INJECT ? "UninjectStream" : "UnpublishStream", url: n2.url } }, false, { url: e2, command: "UnPublishStream", workerType: r2 === RI.TRANSCODE ? 1 : 2, requestByUser: true, tid: (this.lastTaskId++).toString() }).then((i3) => {
              jC.debug("[".concat(this.spec.clientId, "] stop live streaming success, code: ").concat(i3.code)), this.streamingTasks.delete(e2), 0 === this.streamingTasks.size && r2 !== RI.INJECT && (this.connection && this.connection.close(), this.connection = void 0), t2(), r2 === RI.INJECT && this.onInjectStatusChange && this.onInjectStatusChange(CI.INJECT_STREAM_STATUS_STOP_SUCCESS, this.spec.uid, e2);
            }).catch(i2);
          });
        }
        async controlInjectStream(e2, t2, i2, n2) {
          const r2 = this.streamingTasks.get(e2);
          if (!r2 || !this.connection || r2.mode !== RI.INJECT) throw new LI(Hg.INVALID_OPERATION, "can not find inject stream task to control");
          return (await this.connection.request("request", { clientRequest: { command: "ControlStream", url: e2, control: t2, audioVolume: i2, position: n2 } })).serverResponse;
        }
        resetAllTask() {
          var e2;
          const t2 = Array.from(NI(e2 = this.streamingTasks).call(e2));
          this.terminate();
          for (const e3 of t2) this.startLiveStreamingTask(e3.url, e3.mode).catch((t3) => {
            this.onLiveStreamError && this.onLiveStreamError(e3.url, t3);
          });
        }
        terminate() {
          this.cancelToken && this.cancelToken.cancel(), this.streamingTasks = /* @__PURE__ */ new Map(), this.isStartingStreamingTask = false, this.statusError = /* @__PURE__ */ new Map(), this.cancelToken = sC.CancelToken.source(), this.uapResponse = void 0, this.connection && this.connection.close(), this.connection = void 0;
        }
        async connect(e2) {
          if (this.connection) throw new LI(Hg.UNEXPECTED_ERROR, "live streaming connection has already connected");
          const t2 = await vT(this, GI.REQUEST_WORKER_MANAGER_LIST, e2);
          return this.uapResponse = t2, this.connection = new TV(t2.workerToken, this.spec, this.wsRetryConfig, e2), this.connection.on(jI.WARNING, (e3, t3) => this.onLiveStreamWarning && this.onLiveStreamWarning(t3, e3)), this.connection.on(jI.PUBLISH_STREAM_STATUS, (e3) => this.handlePublishStreamServer(e3)), this.connection.on(jI.INJECT_STREAM_STATUS, (e3) => this.handleInjectStreamServerStatus(e3)), this.connection.on(jI.REQUEST_NEW_ADDRESS, (t3, i2) => {
            if (!this.connection) return i2(new LI(Hg.UNEXPECTED_ERROR, "can not get new live streaming address list"));
            vT(this, GI.REQUEST_WORKER_MANAGER_LIST, e2).then((e3) => {
              this.uapResponse = e3, t3(e3.addressList);
            }).catch(i2);
          }), await this.connection.init(t2.addressList), this.connection;
        }
        handlePublishStreamServer(e2) {
          const t2 = e2.serverStatus && e2.serverStatus.url || "empty_url", i2 = this.streamingTasks.get(t2), n2 = e2.reason;
          switch (e2.code) {
            case WI.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
            case WI.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
            case WI.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
            case WI.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH: {
              const n3 = new LI(Hg.LIVE_STREAMING_CDN_ERROR, "", { code: e2.code });
              if (i2) return jC.error(n3.toString()), this.onLiveStreamError && this.onLiveStreamError(t2, n3);
              if (!this.isStartingStreamingTask) return;
              this.statusError.set(t2, n3);
            }
            case WI.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
              const e3 = new LI(Hg.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE, n2);
              return this.onLiveStreamWarning && this.onLiveStreamWarning(t2, e3);
            }
            case WI.LIVE_STREAM_RESPONSE_WORKER_LOST:
            case WI.LIVE_STREAM_RESPONSE_WORKER_QUIT: {
              var r2;
              if (!this.connection) return;
              this.connection.tryNextAddress();
              const t3 = Array.from(NI(r2 = this.streamingTasks).call(r2));
              for (const i3 of t3) i3.abortTask ? i3.abortTask() : (jC.warning("[".concat(this.spec.clientId, "] publish stream status code"), e2.code, "try to republish", i3.url), this.startLiveStreamingTask(i3.url, i3.mode, new LI(Hg.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e2.code })).then(() => {
                jC.debug("[".concat(this.spec.clientId, "] republish live stream success"), i3.url);
              }).catch((e3) => {
                jC.error(e3.toString()), this.onLiveStreamError && this.onLiveStreamError(i3.url, e3);
              }));
              return;
            }
          }
        }
        handleInjectStreamServerStatus(e2) {
          const t2 = Number(e2.uid), i2 = e2.serverStatus && e2.serverStatus.url;
          switch (e2.code) {
            case 200:
              return void (this.onInjectStatusChange && this.onInjectStatusChange(CI.INJECT_STREAM_STATUS_START_SUCCESS, t2, i2));
            case 451:
              return this.onInjectStatusChange && this.onInjectStatusChange(CI.INJECT_STREAM_STATUS_START_ALREADY_EXISTS, t2, i2), void this.streamingTasks.delete(i2);
            case 453:
              return this.onInjectStatusChange && this.onInjectStatusChange(CI.INJECT_STREAM_STATUS_START_UNAUTHORIZED, t2, i2), void this.streamingTasks.delete(i2);
            case 470:
              return this.onInjectStatusChange && this.onInjectStatusChange(CI.INJECT_STREAM_STATUS_BROKEN, t2, i2), void this.streamingTasks.delete(i2);
            case 499:
              return this.onInjectStatusChange && this.onInjectStatusChange(CI.INJECT_STREAM_STATUS_START_TIMEOUT, t2, i2), void this.streamingTasks.delete(i2);
            default:
              return void jC.debug("inject stream server status", e2);
          }
        }
        hasUrl(e2) {
          return this.streamingTasks.has(e2);
        }
      }
      class IV {
        constructor() {
          sh(this, "destChannelMediaInfos", /* @__PURE__ */ new Map()), sh(this, "srcChannelMediaInfo", void 0);
        }
        setSrcChannelInfo(e2) {
          tv(e2), this.srcChannelMediaInfo = e2;
        }
        addDestChannelInfo(e2) {
          tv(e2), this.destChannelMediaInfos.set(e2.channelName, e2);
        }
        removeDestChannelInfo(e2) {
          kI(e2), this.destChannelMediaInfos.delete(e2);
        }
        getSrcChannelMediaInfo() {
          return this.srcChannelMediaInfo;
        }
        getDestChannelMediaInfo() {
          return this.destChannelMediaInfos;
        }
      }
      function vV(e2) {
        if (!(e2 instanceof IV)) {
          return new LI(Hg.INVALID_PARAMS, "Config should be instance of [ChannelMediaRelayConfiguration]").throw();
        }
        const t2 = e2.getSrcChannelMediaInfo(), i2 = e2.getDestChannelMediaInfo();
        if (!t2) {
          return new LI(Hg.INVALID_PARAMS, "srcChannelMediaInfo should not be empty").throw();
        }
        if (0 === i2.size) {
          return new LI(Hg.INVALID_PARAMS, "destChannelMediaInfo should not be empty").throw();
        }
      }
      class yV extends dT {
        constructor(e2, t2, i2) {
          super(), sh(this, "ws", void 0), sh(this, "requestId", 1), sh(this, "heartBeatTimer", void 0), sh(this, "joinInfo", void 0), sh(this, "clientId", void 0), sh(this, "onOpen", () => {
            this.emit("open"), this.startHeartBeatCheck();
          }), sh(this, "onClose", (e3) => {
            this.emit("close"), this.dispose();
          }), sh(this, "onMessage", (e3) => {
            const t3 = JSON.parse(e3.data);
            if (!t3 || "serverResponse" !== t3.command || !t3.requestId) return t3 && "serverStatus" === t3.command && t3.serverStatus && t3.serverStatus.command ? (this.emit("status", t3.serverStatus), void this.emit(t3.serverStatus.command, t3.serverStatus)) : void 0;
            this.emit("req_".concat(t3.requestId), t3);
          }), this.joinInfo = e2, this.clientId = t2, this.ws = new zv("cross-channel-".concat(this.clientId), i2), this.ws.on(SI.RECONNECTING, () => {
            this.ws.reconnectMode = "retry", this.emit("reconnecting");
          }), this.ws.on(SI.CONNECTED, this.onOpen), this.ws.on(SI.ON_MESSAGE, this.onMessage), this.ws.on(SI.CLOSED, this.onClose);
        }
        isConnect() {
          return "connected" === this.ws.state;
        }
        sendMessage(e2) {
          const t2 = this.requestId++;
          return e2.requestId = t2, e2.seq = t2, this.ws.sendMessage(e2), t2;
        }
        waitStatus(e2) {
          return new cg((t2, i2) => {
            const n2 = window.setTimeout(() => {
              i2(new LI(Hg.TIMEOUT, "wait status timeout, status: ".concat(e2)));
            }, 5e3);
            this.once(e2, (r2) => {
              window.clearTimeout(n2), r2.state && 0 !== r2.state ? i2(new LI(Hg.CROSS_CHANNEL_WAIT_STATUS_ERROR, "wait status error, status: ".concat(e2))) : t2(void 0);
            }), this.once("dispose", () => {
              window.clearTimeout(n2), i2(new LI(Hg.WS_ABORT));
            });
          });
        }
        async request(e2) {
          if ("closed" === this.ws.state) throw new LI(Hg.WS_DISCONNECT);
          const t2 = () => new cg((e3, t3) => {
            this.ws.once(SI.CLOSED, () => t3(new LI(Hg.WS_ABORT))), this.ws.once(SI.CONNECTED, e3);
          });
          "connected" !== this.ws.state && await t2();
          const i2 = this.sendMessage(e2), n2 = new cg((e3, t3) => {
            const n3 = () => {
              t3(new LI(Hg.WS_ABORT));
            };
            this.ws.once(SI.RECONNECTING, n3), this.ws.once(SI.CLOSED, n3), this.once("req_".concat(i2), e3), iS(3e3).then(() => {
              this.removeAllListeners("req_".concat(i2)), this.ws.off(SI.RECONNECTING, n3), this.ws.off(SI.CLOSED, n3), t3(new LI(Hg.TIMEOUT, "cross channel ws request timeout"));
            });
          }), r2 = await n2;
          if (!r2 || 200 !== r2.code) throw new LI(Hg.CROSS_CHANNEL_SERVER_ERROR_RESPONSE, "response: ".concat(JSON.stringify(r2)));
          return r2;
        }
        async connect(e2) {
          this.ws.removeAllListeners(SI.REQUEST_NEW_URLS), this.ws.on(SI.REQUEST_NEW_URLS, (t2) => {
            t2(e2);
          }), await this.ws.init(e2);
        }
        dispose() {
          this.clearHeartBeatCheck(), this.emit("dispose"), this.removeAllListeners(), this.ws.close();
        }
        sendPing(e2) {
          const t2 = this.requestId++;
          return e2.requestId = t2, this.ws.sendMessage(e2), t2;
        }
        startHeartBeatCheck() {
          this.heartBeatTimer && window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = window.setInterval(() => {
            this.sendPing({ command: "ping", appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sid: this.joinInfo.sid, ts: +/* @__PURE__ */ new Date(), requestId: 0 });
          }, 3e3);
        }
        clearHeartBeatCheck() {
          window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = void 0;
        }
      }
      class AV extends dT {
        set state(e2) {
          e2 !== this._state && (e2 !== qI.RELAY_STATE_FAILURE && (this.errorCode = zI.RELAY_OK), this.emit("state", e2, this.errorCode), this._state = e2);
        }
        get state() {
          return this._state;
        }
        constructor(e2, t2, i2, n2, r2) {
          super(), sh(this, "joinInfo", void 0), sh(this, "sid", void 0), sh(this, "clientId", void 0), sh(this, "cancelToken", sC.CancelToken.source()), sh(this, "workerToken", void 0), sh(this, "requestId", 0), sh(this, "signal", void 0), sh(this, "prevChannelMediaConfig", void 0), sh(this, "httpRetryConfig", void 0), sh(this, "_resolution", void 0), sh(this, "_state", qI.RELAY_STATE_IDLE), sh(this, "errorCode", zI.RELAY_OK), sh(this, "onStatus", (e3) => {
            jC.debug("[".concat(this.clientId, "] ChannelMediaStatus: ").concat(JSON.stringify(e3))), e3 && e3.command && ("onAudioPacketReceived" === e3.command && this.emit("event", YI.PACKET_RECEIVED_AUDIO_FROM_SRC), "onVideoPacketReceived" === e3.command && this.emit("event", YI.PACKET_RECEIVED_VIDEO_FROM_SRC), "onSrcTokenPrivilegeDidExpire" === e3.command && (this.errorCode = zI.SRC_TOKEN_EXPIRED, this.state = qI.RELAY_STATE_FAILURE), "onDestTokenPrivilegeDidExpire" === e3.command && (this.errorCode = zI.DEST_TOKEN_EXPIRED, this.state = qI.RELAY_STATE_FAILURE));
          }), sh(this, "onReconnect", async () => {
            jC.debug("[".concat(this.clientId, "] ChannelMediaSocket disconnect, reconnecting")), this.emit("event", YI.NETWORK_DISCONNECTED), this.state = qI.RELAY_STATE_IDLE, this.prevChannelMediaConfig && this.sendStartRelayMessage(this.prevChannelMediaConfig).catch((e3) => {
              this.state !== qI.RELAY_STATE_IDLE && (jC.error("auto restart channel media relay failed", e3.toString()), this.errorCode = zI.SERVER_CONNECTION_LOST, this.state = qI.RELAY_STATE_FAILURE);
            });
          }), this.joinInfo = e2, this.clientId = t2, this.sid = rS(), this.signal = new yV(this.joinInfo, this.clientId, i2), this.httpRetryConfig = n2, this._resolution = r2;
        }
        async startChannelMediaRelay(e2) {
          if (this.state !== qI.RELAY_STATE_IDLE) throw new LI(Hg.INVALID_OPERATION);
          this.state = qI.RELAY_STATE_CONNECTING, await this.connect(), jC.debug("[".concat(this.clientId, "] startChannelMediaRelay: connect success"));
          try {
            await this.sendStartRelayMessage(e2);
          } catch (e3) {
            if (e3.data && e3.data.serverResponse && "SetSourceChannel" === e3.data.serverResponse.command) throw new LI(Hg.CROSS_CHANNEL_FAILED_JOIN_SRC);
            if (e3.data && e3.data.serverResponse && "SetDestChannelStatus" === e3.serverResponse.command) throw new LI(Hg.CROSS_CHANNEL_FAILED_JOIN_DEST);
            if (e3.data && e3.data.serverResponse && "StartPacketTransfer" === e3.serverResponse.command) throw new LI(Hg.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST);
            throw e3;
          }
          this.prevChannelMediaConfig = e2;
        }
        async updateChannelMediaRelay(e2) {
          if (this.state !== qI.RELAY_STATE_RUNNING) throw new LI(Hg.INVALID_OPERATION);
          await this.sendUpdateMessage(e2), this.prevChannelMediaConfig = e2;
        }
        async setVideoProfile(e2) {
          if (this._resolution = e2, this.state !== qI.RELAY_STATE_RUNNING) throw new LI(Hg.INVALID_OPERATION);
          const t2 = this.genMessage(KI.SetVideoProfile);
          await this.signal.request(t2), jC.debug("[".concat(this.clientId, "] startChannelMediaRelay: setVideoProfile success"));
        }
        async stopChannelMediaRelay() {
          await this.sendStopRelayMessage(), jC.debug("[".concat(this.clientId, "] stopChannelMediaRelay: send stop message success")), this.state = qI.RELAY_STATE_IDLE, this.dispose();
        }
        dispose() {
          jC.debug("[".concat(this.clientId, "] disposeChannelMediaRelay")), this.cancelToken.cancel(), this.cancelToken = sC.CancelToken.source(), this.state = qI.RELAY_STATE_IDLE, this.emit("dispose"), this.signal.dispose(), this.prevChannelMediaConfig = void 0;
        }
        async connect() {
          const e2 = await fA(this.joinInfo, this.cancelToken.token, this.httpRetryConfig);
          this.workerToken = e2.workerToken, await this.signal.connect(e2.addressList), this.emit("event", YI.NETWORK_CONNECTED), this.signal.on("status", this.onStatus), this.signal.on("reconnecting", this.onReconnect);
        }
        async sendStartRelayMessage(e2) {
          const t2 = this.genMessage(KI.StopPacketTransfer);
          await this.signal.request(t2), await this.signal.waitStatus("Normal Quit"), jC.debug("[".concat(this.clientId, "] startChannelMediaRelay: StopPacketTransfer success"));
          const i2 = this.genMessage(KI.SetSdkProfile, e2);
          await this.signal.request(i2), jC.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSdkProfile success"));
          const n2 = this.genMessage(KI.SetSourceChannel, e2);
          await this.signal.request(n2), await this.signal.waitStatus("SetSourceChannelStatus"), this.emit("event", YI.PACKET_JOINED_SRC_CHANNEL), jC.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceChannel success"));
          const r2 = this.genMessage(KI.SetSourceUserId, e2);
          await this.signal.request(r2), jC.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceUserId success"));
          const s2 = this.genMessage(KI.SetDestChannel, e2);
          await this.signal.request(s2), await this.signal.waitStatus("SetDestChannelStatus"), this.emit("event", YI.PACKET_JOINED_DEST_CHANNEL), jC.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetDestChannel success"));
          const o2 = this.genMessage(KI.StartPacketTransfer, e2);
          await this.signal.request(o2), this.emit("event", YI.PACKET_SENT_TO_DEST_CHANNEL), this.state = qI.RELAY_STATE_RUNNING, jC.debug("[".concat(this.clientId, "] startChannelMediaRelay: StartPacketTransfer success")), this.setVideoProfile(this._resolution);
        }
        async sendUpdateMessage(e2) {
          const t2 = this.genMessage(KI.UpdateDestChannel, e2);
          await this.signal.request(t2), this.emit("event", YI.PACKET_UPDATE_DEST_CHANNEL), jC.debug("[".concat(this.clientId, "] sendUpdateMessage: UpdateDestChannel success"));
        }
        async sendStopRelayMessage() {
          const e2 = this.genMessage(KI.StopPacketTransfer);
          await this.signal.request(e2), jC.debug("[".concat(this.clientId, "] sendStopRelayMessage: StopPacketTransfer success"));
        }
        genMessage(e2, t2) {
          const i2 = [], n2 = [], r2 = [];
          this.requestId += 1;
          const s2 = { appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sdkVersion: EC, sid: this.sid, ts: Date.now(), requestId: this.requestId, seq: this.requestId, allocate: true, clientRequest: {} };
          "4.20.2" === s2.sdkVersion && (s2.sdkVersion = "0.0.1");
          let o2 = null, a2 = null;
          switch (e2) {
            case KI.SetSdkProfile:
              return s2.clientRequest = { command: "SetSdkProfile", type: "multi_channel" }, s2;
            case KI.SetSourceChannel:
              if (a2 = t2 && t2.getSrcChannelMediaInfo(), !a2) throw new LI(Hg.UNEXPECTED_ERROR, "can not find source config");
              return s2.clientRequest = { command: "SetSourceChannel", uid: "0", channelName: a2.channelName, token: a2.token || this.joinInfo.appId }, s2;
            case KI.SetSourceUserId:
              if (a2 = t2 && t2.getSrcChannelMediaInfo(), !a2) throw new LI(Hg.UNEXPECTED_ERROR, "can not find source config");
              return s2.clientRequest = { command: "SetSourceUserId", uid: a2.uid + "" }, s2;
            case KI.SetDestChannel:
              if (o2 = t2 && t2.getDestChannelMediaInfo(), !o2) throw new LI(Hg.UNEXPECTED_ERROR, "can not find dest config");
              return o2.forEach((e3) => {
                i2.push(e3.channelName), n2.push(e3.uid + ""), r2.push(e3.token || this.joinInfo.appId);
              }), s2.clientRequest = { command: "SetDestChannel", channelName: i2, uid: n2, token: r2 }, s2;
            case KI.StartPacketTransfer:
              return s2.clientRequest = { command: "StartPacketTransfer" }, s2;
            case KI.Reconnect:
              return s2.clientRequest = { command: "Reconnect" }, s2;
            case KI.StopPacketTransfer:
              return s2.clientRequest = { command: "StopPacketTransfer" }, s2;
            case KI.UpdateDestChannel:
              if (o2 = t2 && t2.getDestChannelMediaInfo(), !o2) throw new LI(Hg.UNEXPECTED_ERROR, "can not find dest config");
              return o2.forEach((e3) => {
                i2.push(e3.channelName), n2.push(e3.uid + ""), r2.push(e3.token || this.joinInfo.appId);
              }), s2.clientRequest = { command: "UpdateDestChannel", channelName: i2, uid: n2, token: r2 }, s2;
            case KI.SetVideoProfile:
              s2.clientRequest = { command: "SetVideoProfile", width: this._resolution.width, height: this._resolution.height };
          }
          return s2;
        }
      }
      function bV(e2) {
        var t2 = {}, i2 = false;
        function n2(t3, n3) {
          return i2 = true, { done: false, value: new CU(n3 = new wU(function(i3) {
            i3(e2[t3](n3));
          }), 1) };
        }
        return t2[void 0 !== xu && th || "@@iterator"] = function() {
          return this;
        }, t2.next = function(e3) {
          return i2 ? (i2 = false, e3) : n2("next", e3);
        }, "function" == typeof e2.throw && (t2.throw = function(e3) {
          if (i2) throw i2 = false, e3;
          return n2("throw", e3);
        }), "function" == typeof e2.return && (t2.return = function(e3) {
          return i2 ? (i2 = false, e3) : n2("return", e3);
        }), t2;
      }
      var wV = i(OU);
      function OV(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function NV(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? OV(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : OV(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      function DV(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function PV(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? DV(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : DV(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class LV extends Nv {
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get localCodecs() {
          return [...new Set(this.localCapabilities && this.localCapabilities.videoCodecs.map((e2) => e2.rtpMap && e2.rtpMap.encodingName.toLowerCase() || "").filter((e2) => {
            var t2;
            return bn(t2 = Object.keys(bC)).call(t2, e2);
          }))];
        }
        constructor(e2, t2) {
          super(e2, t2), sh(this, "store", void 0), sh(this, "peerConnection", void 0), sh(this, "remoteSDP", void 0), sh(this, "initialOffer", void 0), sh(this, "statsFilter", void 0), sh(this, "useRTX", false), sh(this, "localCapabilities", void 0), sh(this, "localCandidateCount", 0), sh(this, "allCandidatesReceived", false), sh(this, "establishPromise", void 0), sh(this, "mutex", new pS("P2PConnection-mutex")), this.store = t2, this.peerConnection = new RTCPeerConnection(LV.resolvePCConfiguration(e2), { optional: [{ googDscp: true }] }), this.statsFilter = Ex(this.peerConnection, RC("STATS_UPDATE_INTERVAL"), void 0, wg() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();
        }
        async establish() {
          try {
            const e2 = await this.peerConnection.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
            if (!e2.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
            const t2 = Tx(e2.sdp), i2 = gx(e2.sdp, { filterRTX: !this.useRTX, filterVideoFec: RC("FILTER_VIDEO_FEC"), filterAudioFec: RC("FILTER_AUDIO_FEC"), filterAudioCodec: ["opus"] });
            return this.localCapabilities = i2, this.initialOffer = e2, PV(PV({}, t2), {}, { rtpCapabilities: { send: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, recv: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, sendrecv: i2 }, offerSDP: e2.sdp });
          } catch (e2) {
            throw new Kg(Hg.GET_LOCAL_CONNECTION_PARAMS_FAILED, e2.toString());
          }
        }
        async connect(e2, t2, i2, n2, r2, s2) {
          try {
            if (!this.initialOffer) throw new Error("Cannot establish P2PConnection without initial offer.");
            this.remoteSDP = new class {
              constructor(e3) {
                sh(this, "sessionDesc", void 0), sh(this, "localCapabilities", void 0), sh(this, "rtpCapabilities", void 0), sh(this, "candidates", void 0), sh(this, "iceParameters", void 0), sh(this, "dtlsParameters", void 0), sh(this, "setup", void 0), sh(this, "currentMidIndex", void 0), sh(this, "cname", void 0), e3 = YT(e3);
                const { remoteIceParameters: t3, remoteDtlsParameters: i3, candidates: n3, remoteRTPCapabilities: r3, remoteSetup: s3, localCapabilities: o3, sdkCodec: a2, cname: c2 } = e3, d2 = JU.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE audio video\na=msid-semantic: WMS\na=ice-lite\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:audio\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:video\n");
                this.rtpCapabilities = r3, this.candidates = n3, this.iceParameters = t3, this.dtlsParameters = i3, this.setup = s3, this.localCapabilities = o3, this.cname = c2;
                for (let e4 = 0; e4 < d2.mediaDescriptions.length; e4++) {
                  const o4 = d2.mediaDescriptions[e4];
                  if (o4.attributes.iceUfrag = t3.iceUfrag, o4.attributes.icePwd = t3.icePwd, o4.attributes.fingerprints = i3.fingerprints, o4.attributes.candidates = n3, o4.attributes.setup = s3, "video" === o4.media.mediaType) {
                    o4.media.fmts = r3.videoCodecs.map((e6) => e6.payloadType.toString(10));
                    let e5 = r3.videoCodecs.filter((e6) => {
                      var t4, i4;
                      return null === (t4 = e6.rtpMap) || void 0 === t4 ? void 0 : bn(i4 = t4.encodingName.toLowerCase()).call(i4, a2);
                    });
                    0 === e5.length && (e5 = r3.videoCodecs), o4.attributes.payloads = e5, o4.attributes.extmaps = r3.videoExtensions;
                  }
                  "audio" === o4.media.mediaType && (o4.media.fmts = r3.audioCodecs.map((e5) => e5.payloadType.toString(10)), o4.attributes.payloads = r3.audioCodecs, o4.attributes.extmaps = r3.audioExtensions), d2.mediaDescriptions[e4] = this.mungMediaDesc(o4);
                }
                this.sessionDesc = d2, this.currentMidIndex = d2.mediaDescriptions.length - 1;
              }
              toString() {
                return JU.print(this.sessionDesc);
              }
              send(e3, t3, i3) {
                const { ssrcs: n3, ssrcGroups: r3 } = Cx(t3, this.cname), s3 = this.sessionDesc.mediaDescriptions.find((t4) => e3 === av.VIDEO ? "video" === t4.media.mediaType : "audio" === t4.media.mediaType), o3 = n3[0].attributes.label, a2 = n3[0].attributes.mslabel;
                return s3.attributes.ssrcs = s3.attributes.ssrcs.concat(n3), s3.attributes.ssrcGroups = s3.attributes.ssrcGroups.concat(r3), { id: o3, mslabel: a2 };
              }
              batchSend(e3) {
                return e3.map((e4) => {
                  let { kind: t3, ssrcMsg: i3 } = e4;
                  return this.send(t3, i3, void 0);
                });
              }
              stopSending(e3) {
                this.sessionDesc.mediaDescriptions.forEach((t3) => {
                  const i3 = [], n3 = [], r3 = [];
                  t3.attributes.ssrcs.forEach((t4) => {
                    bn(e3).call(e3, t4.attributes.label || "") ? r3.push(t4) : i3.push(t4);
                  }), t3.attributes.ssrcGroups.forEach((e4) => {
                    var t4;
                    bn(t4 = r3.map((e5) => e5.ssrcId)).call(t4, e4.ssrcIds[0]) || n3.push(e4);
                  }), t3.attributes.ssrcs = i3, t3.attributes.ssrcGroups = n3;
                });
              }
              mute(e3) {
                const t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e3);
                if (!t3) throw new Error("mediaDescription not found with ".concat(e3, " in remote SDP when calling RemoteSDP.mute."));
                t3.attributes.direction = "inactive";
              }
              unmute(e3) {
                const t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e3);
                if (!t3) throw new Error("mediaDescription not found with ".concat(e3, " in remote SDP when calling RemoteSDP.unmute."));
                t3.attributes.direction = "sendonly";
              }
              receive(e3, t3, i3) {
                e3.forEach((e4, t4) => {
                  const i4 = e4._mediaStreamTrack, n3 = this.sessionDesc.mediaDescriptions.findIndex((e5) => e5.attributes.mid === i4.kind), r3 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[n3], e4);
                  this.sessionDesc.mediaDescriptions[n3] = r3;
                });
              }
              stopReceiving(e3) {
              }
              updateCandidates(e3) {
                e3 === cv.TCP ? this.candidates.forEach((e4) => {
                  -1 === this.candidates.findIndex((t3) => "tcp" === t3.transport && t3.connectionAddress === e4.connectionAddress && t3.port === e4.port) && this.candidates.push(NV(NV({}, e4), {}, { foundation: "tcpcandidate", priority: Number(e4.priority) - 1 + "", transport: "tcp", port: Number(e4.port) + 90 + "" }));
                }) : this.candidates = this.candidates.filter((e4) => "tcp" !== e4.transport);
                for (const e4 of this.sessionDesc.mediaDescriptions) e4.attributes.candidates = this.candidates;
              }
              restartICE(e3) {
                e3 = YT(e3), this.iceParameters = e3, this.sessionDesc.mediaDescriptions.forEach((t3) => {
                  t3.attributes.iceUfrag = e3.iceUfrag, t3.attributes.icePwd = e3.icePwd;
                });
              }
              predictReceivingMids(e3) {
                const t3 = [];
                for (let i3 = 0; i3 < e3; i3++) t3.push((this.currentMidIndex + i3 + 1).toString(10));
                return t3;
              }
              mungRecvMediaDsec(e3, t3) {
                const i3 = YT(e3);
                return Ix(i3, t3), yx(i3, t3), i3;
              }
              updateRecvMedia(e3, t3) {
                const i3 = this.sessionDesc.mediaDescriptions.findIndex((t4) => t4.attributes.mid === e3);
                if (-1 !== i3) {
                  const e4 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i3], t3);
                  this.sessionDesc.mediaDescriptions[i3] = e4;
                }
              }
              bumpMid(e3) {
                this.currentMidIndex += e3;
              }
              updateTrackLabel(e3, t3, i3) {
                const n3 = this.sessionDesc.mediaDescriptions.find((t4) => e3 === av.VIDEO ? "video" === t4.attributes.mid : "audio" === t4.attributes.mid);
                if (n3) {
                  const e4 = n3.attributes.ssrcs.find((e5) => e5.attributes.label === t3);
                  var r3;
                  e4 && (e4.attributes.label = i3, null === (r3 = e4.attributes.msid) || void 0 === r3 || r3.replace(t3, i3));
                }
              }
              mungMediaDesc(e3) {
                const t3 = YT(e3);
                return vx(t3), function(e4) {
                  const t4 = e4.attributes.extmaps.find((e5) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e5.extensionName);
                  t4 && e4.attributes.extmaps.splice(e4.attributes.extmaps.indexOf(t4), 1), e4.attributes.payloads.forEach((e5) => {
                    const t5 = e5.rtcpFeedbacks.findIndex((e6) => "transport-cc" === e6.type);
                    -1 !== t5 && e5.rtcpFeedbacks.splice(t5, 1);
                  });
                }(t3), t3;
              }
              getSSRC(e3) {
                for (const t3 of this.sessionDesc.mediaDescriptions) for (const i3 of t3.attributes.ssrcs) if (i3.attributes.label === e3) return [i3];
              }
            }({ remoteIceParameters: e2, remoteDtlsParameters: t2, candidates: i2, remoteRTPCapabilities: n2.send, remoteSetup: r2, localCapabilities: this.localCapabilities, sdkCodec: this.store.codec, cname: s2 });
            const o2 = this.remoteSDP.toString();
            await this.peerConnection.setLocalDescription(this.initialOffer), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o2 });
          } catch (e3) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e3.toString()));
          }
        }
        async updateRemoteRTPCapabilities(e2, t2) {
          throw new Kg(Hg.NOT_SUPPORTED, "Planb mode does not support createDataChannels.");
        }
        send(e2, t2) {
          var i2 = this;
          return PU(function* () {
            const n2 = yield IU(i2.mutex.lock());
            try {
              if (!i2.remoteSDP) throw new Error("Cannot call P2PConnection.send before remote SDP created");
              const r2 = e2.map((e3) => i2.peerConnection.addTrack(e3._mediaStreamTrack)), s2 = yield IU(i2.peerConnection.createOffer()), o2 = JU.parse(s2.sdp), a2 = e2.map((e3) => {
                const t3 = e3._mediaStreamTrack, n3 = o2.mediaDescriptions.find((e4) => e4.attributes.mid === t3.kind);
                if (!n3) throw new Error("Cannot extract ssrc from mediaDescription.");
                return function(e4, t4, i3) {
                  const n4 = e4.attributes.ssrcs.filter((e5) => e5.attributes.label === t4), r3 = e4.attributes.ssrcGroups;
                  if (0 === n4.length) throw new Error("Cannot extract ssrc from plan-b SDP.");
                  if (r3 && n4.length > 1) {
                    const e5 = r3.find((e6) => -1 !== e6.ssrcIds.indexOf(n4[0].ssrcId));
                    return e5 ? [{ ssrcId: e5.ssrcIds[0], rtx: i3 ? e5.ssrcIds[1] : void 0 }] : [{ ssrcId: n4[0].ssrcId }];
                  }
                  return [{ ssrcId: n4[0].ssrcId }];
                }(n3, t3.id, i2.useRTX);
              });
              let c2;
              try {
                c2 = yield a2;
              } catch (e3) {
                throw r2.forEach((e4) => {
                  bg() && e4.replaceTrack(null), i2.peerConnection.removeTrack(e4);
                }), e3;
              }
              const d2 = i2.mungSendOfferSDP(s2.sdp, e2);
              i2.remoteSDP.receive(e2, t2, c2);
              const l2 = i2.remoteSDP.toString();
              return yield IU(i2.peerConnection.setLocalDescription({ type: "offer", sdp: d2 })), yield IU(i2.applySendEncodings(r2, e2)), yield IU(i2.peerConnection.setRemoteDescription({ type: "answer", sdp: l2 })), e2.map((e3, t3) => {
                const i3 = e3._mediaStreamTrack.id;
                return { localSSRC: a2[t3], id: i3 };
              });
            } catch (e3) {
              throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e3.toString()));
            } finally {
              n2();
            }
          })();
        }
        async stopSending(e2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
            const t2 = this.peerConnection.getSenders().filter((t3) => {
              var i3;
              return -1 !== e2.indexOf((null === (i3 = t3.track) || void 0 === i3 ? void 0 : i3.id) || "");
            });
            if (t2.length !== e2.length) throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
            t2.map((e3) => {
              bg() && e3.replaceTrack(null), this.peerConnection.removeTrack(e3);
            });
            const i2 = await this.peerConnection.createOffer();
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.stopReceiving(e2);
            const n2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
          } catch (e3) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e3.toString()));
          }
        }
        async receive(e2, t2, i2, n2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e2, " before remoteSDP created."));
            const { id: i3, mslabel: r2 } = this.remoteSDP.send(e2, t2, n2), s2 = new cg((t3, n3) => {
              const s3 = setTimeout(() => {
                n3(new Error("Cannot receive track, id: ".concat(i3)));
              }, 1e4), o3 = (n4) => {
                const a3 = Sg();
                if (("Safari" === a3.name && 11 === Number(a3.version) || Og()) && n4.track.id !== i3 && n4.streams[0].id === r2) {
                  var c2;
                  const r3 = n4.streams[0].getTracks()[0];
                  return null === (c2 = this.remoteSDP) || void 0 === c2 || c2.updateTrackLabel(e2, i3, n4.track.id), this.peerConnection.removeEventListener("track", o3), clearTimeout(s3), void t3(r3);
                }
                if (n4.track.id === i3) return this.peerConnection.removeEventListener("track", o3), clearTimeout(s3), void t3(n4.track);
              };
              this.peerConnection.addEventListener("track", o3);
            }), o2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: o2 });
            const a2 = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(a2);
            return { track: await s2, id: i3 };
          } catch (e3) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e3.toString()));
          }
        }
        async stopReceiving(e2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
            this.remoteSDP.stopSending(e2);
            const t2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const i2 = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(i2);
          } catch (e3) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e3.toString()));
          }
        }
        async muteRemote(e2) {
        }
        async unmuteRemote(e2) {
        }
        async muteLocal(e2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
            const t2 = this.peerConnection.getSenders().filter((t3) => {
              var i2;
              return -1 !== e2.indexOf((null === (i2 = t3.track) || void 0 === i2 ? void 0 : i2.id) || "");
            });
            if (t2.length !== e2.length) throw new Error("sender' length doesn't match mids' length.");
            t2.map((e3) => {
              if (bg() && e3.track) e3.track.enabled = false;
              else {
                const t3 = e3.getParameters();
                t3.encodings.forEach((e4) => e4.active = false), e3.setParameters(t3);
              }
            });
          } catch (e3) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e3.toString()));
          }
        }
        async unmuteLocal(e2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
            const t2 = this.peerConnection.getSenders().filter((t3) => {
              var i3;
              return -1 !== e2.indexOf((null === (i3 = t3.track) || void 0 === i3 ? void 0 : i3.id) || "");
            });
            if (t2.length !== e2.length) throw new Error("Senders' length doesn't match mids' length.");
            t2.map(async (e3) => {
              if (bg() && e3.track) e3.track.enabled = true;
              else {
                const t3 = e3.getParameters();
                t3.encodings.forEach((e4) => e4.active = true), await e3.setParameters(t3);
              }
            });
            const i2 = await this.peerConnection.createOffer();
            await this.peerConnection.setLocalDescription(i2);
            const n2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
          } catch (e3) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e3.toString()));
          }
        }
        restartICE(e2) {
          var t2 = this;
          return PU(function* () {
            const i2 = yield IU(t2.mutex.lock("From P2PConnection.restartICE"));
            try {
              if (!t2.remoteSDP) throw new Error("Cannot restartICE before remoteSDP created.");
              if (IA().supportPCSetConfiguration) {
                const i3 = t2.peerConnection.getConfiguration(), n3 = e2 === cv.RELAY ? "relay" : "all";
                i3.iceTransportPolicy !== n3 && (jC.debug("[".concat(t2.store.clientId, "] restartICE change iceTransportPolicy from [").concat(i3.iceTransportPolicy, "] to [").concat(n3, "]")), i3.iceTransportPolicy = n3, t2.peerConnection.setConfiguration(i3));
              } else if (e2 === cv.RELAY) return;
              e2 !== cv.RELAY && t2.remoteSDP.updateCandidates(e2);
              const n2 = yield IU(t2.peerConnection.createOffer({ iceRestart: true }));
              if (!n2.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist.");
              const r2 = Tx(n2.sdp), { remoteIceParameters: s2 } = yield r2.iceParameters;
              t2.remoteSDP.restartICE(s2);
              const o2 = t2.remoteSDP.toString();
              yield IU(t2.peerConnection.setLocalDescription(n2)), yield IU(t2.peerConnection.setRemoteDescription({ type: "answer", sdp: o2 }));
            } catch (e3) {
              jC.warning("[".concat(t2.store.clientId, "] restart ICE failed, abort operation"), e3);
            } finally {
              i2();
            }
          })();
        }
        close() {
          var e2;
          this.peerConnection.close(), null === (e2 = this.onConnectionStateChange) || void 0 === e2 || e2.call(this, "closed"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.statsFilter.destroy();
        }
        getStats() {
          return this.statsFilter.getStats();
        }
        getRemoteVideoIsReady(e2) {
          return this.statsFilter.getVideoIsReady(e2);
        }
        async updateEncoderConfig(e2, t2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
            const e3 = await this.peerConnection.createOffer(), i2 = this.mungSendOfferSDP(e3.sdp, [t2]);
            this.remoteSDP.updateRecvMedia(t2._mediaStreamTrack.kind, t2);
            const n2 = this.remoteSDP.toString();
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: i2 }), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
          } catch (e3) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, e3.toString());
          }
        }
        async updateSendParameters(e2, t2) {
          const i2 = this.peerConnection.getSenders().filter((t3) => {
            var i3;
            return (null === (i3 = t3.track) || void 0 === i3 ? void 0 : i3.id) === e2;
          });
          1 === i2.length && await this.applySendEncodings(i2, [t2]);
        }
        setStatsRemoteVideoIsReady(e2, t2) {
          this.statsFilter.setVideoIsReady2(e2, t2);
        }
        async replaceTrack(e2, t2) {
          const i2 = this.peerConnection.getSenders().find((e3) => {
            var i3;
            return (null === (i3 = e3.track) || void 0 === i3 ? void 0 : i3.id) === t2;
          });
          i2 && await i2.replaceTrack(e2._mediaStreamTrack);
        }
        createDataChannels(e2, t2) {
          throw new Kg(Hg.NOT_SUPPORTED, "Planb mode does not support createDataChannels.");
        }
        stopDataChannels(e2) {
          throw new Kg(Hg.NOT_SUPPORTED, "Planb mode does not support stopDataChannels.");
        }
        bindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = () => {
            var e2;
            null === (e2 = this.onICEConnectionStateChange) || void 0 === e2 || e2.call(this, this.peerConnection.iceConnectionState);
          }, this.peerConnection.onconnectionstatechange = () => {
            var e2;
            null === (e2 = this.onConnectionStateChange) || void 0 === e2 || e2.call(this, this.peerConnection.connectionState);
          }, this.peerConnection.onicecandidate = (e2) => {
            e2.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, jC.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
          }, setTimeout(() => {
            this.allCandidatesReceived || (this.allCandidatesReceived = true, jC.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
          }, RC("CANDIDATE_TIMEOUT"));
        }
        unbindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
        }
        static resolvePCConfiguration(e2) {
          const t2 = { iceServers: [], sdpSemantics: "plan-b" };
          return e2.iceServers ? t2.iceServers = e2.iceServers : e2.turnServer && "off" !== e2.turnServer.mode && (RT(e2.turnServer.servers) ? t2.iceServers = e2.turnServer.servers : (t2.iceServers && t2.iceServers.push(...LV.turnServerConfigToIceServers(e2.turnServer.servers)), RC("USE_TURN_SERVER_OF_GATEWAY") && t2.iceServers && e2.turnServer.serversFromGateway && t2.iceServers.push(...LV.turnServerConfigToIceServers(e2.turnServer.serversFromGateway)), e2.turnServer.servers.concat(e2.turnServer.serversFromGateway || []).forEach((e3) => {
            e3.forceturn && (t2.iceTransportPolicy = "relay");
          }))), t2;
        }
        static turnServerConfigToIceServers(e2) {
          const t2 = [];
          return e2.forEach((e3) => {
            e3.security ? e3.tcpport && t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turns:".concat(e3.turnServerURL, ":").concat(e3.tcpport, "?transport=tcp") }) : (e3.udpport && t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turn:".concat(e3.turnServerURL, ":").concat(e3.udpport, "?transport=udp") }), e3.tcpport && t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turn:".concat(e3.turnServerURL, ":").concat(e3.tcpport, "?transport=tcp") }));
          }), t2;
        }
        async updateRtpSenderEncodings(e2, t2) {
          var i2;
          if (!t2) {
            t2 = this.peerConnection.getSenders().find((t3) => {
              var i3;
              return (null === (i3 = t3.track) || void 0 === i3 ? void 0 : i3.id) === e2._mediaStreamTrack.id;
            });
          }
          if (!t2) return jC.warn("[".concat(e2.getTrackId(), "] no rtpSender found}"));
          if (!IA().supportSetRtpSenderParameters) return jC.warn("Browser not support set rtp-sender parameters");
          const n2 = {}, r2 = {};
          if (e2 instanceof Rw) switch (e2._optimizationMode) {
            case "motion":
              n2.degradationPreference = "maintain-framerate";
              break;
            case "detail":
              n2.degradationPreference = "maintain-resolution";
              break;
            default:
              n2.degradationPreference = "balanced";
          }
          if (RC("DSCP_TYPE") && jg()) {
            var s2;
            const e3 = RC("DSCP_TYPE");
            bn(s2 = ["very-low", "low", "medium", "high"]).call(s2, e3) && (r2.networkPriority = e3);
          }
          const o2 = t2.getParameters(), a2 = null === (i2 = o2.encodings) || void 0 === i2 ? void 0 : i2[0];
          a2 && Object.assign(a2, r2), Object.assign(o2, n2), jC.debug("[".concat(e2.getTrackId(), "] updateRtpSenderEncodings: ").concat(JSON.stringify(o2.encodings))), await t2.setParameters(o2);
        }
        async applySendEncodings(e2, t2) {
          try {
            if (!IA().supportSetRtpSenderParameters) return;
            if (e2.length !== t2.length) return;
            for (let i2 = 0; i2 < e2.length; i2++) {
              const n2 = e2[i2], r2 = t2[i2];
              n2 && r2 && await this.updateRtpSenderEncodings(r2, n2);
            }
          } catch (e3) {
            jC.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
          }
        }
        mungSendOfferSDP(e2, t2) {
          const i2 = JU.parse(e2);
          return t2.forEach((e3, t3) => {
            const n2 = e3._mediaStreamTrack, r2 = i2.mediaDescriptions.find((e4) => e4.attributes.mid === n2.kind);
            r2 && Ix(r2, e3);
          }), JU.print(i2);
        }
        bindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = (e2) => {
            var t2;
            null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e2);
          }, this.statsFilter.onFirstVideoReceived = (e2) => {
            var t2;
            null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e2);
          }, this.statsFilter.onFirstAudioDecoded = (e2) => {
            var t2;
            null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e2);
          }, this.statsFilter.onFirstVideoDecoded = (e2, t2, i2) => {
            var n2;
            null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e2, t2, i2);
          }, this.statsFilter.onSelectedLocalCandidateChanged = (e2, t2) => {
            var i2;
            null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 || i2.call(this, e2, t2);
          }, this.statsFilter.onSelectedRemoteCandidateChanged = (e2, t2) => {
            var i2;
            null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 || i2.call(this, e2, t2);
          };
        }
        unbindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0;
        }
        async batchReceive(e2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
            const t2 = this.remoteSDP.batchSend(e2).map((t3, i3) => {
              let { id: n3, mslabel: r2 } = t3;
              const { kind: s2 } = e2[i3];
              return new cg((e3, t4) => {
                const i4 = setTimeout(() => {
                  t4(new Error("Cannot receive track, id: ".concat(n3)));
                }, 1e4), o2 = (t5) => {
                  const a2 = Sg();
                  if ("Safari" === a2.name && 11 === Number(a2.version) && t5.track.id !== n3 && t5.streams[0].id === r2) {
                    var c2;
                    const r3 = t5.streams[0].getTracks()[0];
                    return null === (c2 = this.remoteSDP) || void 0 === c2 || c2.updateTrackLabel(s2, n3, t5.track.id), this.peerConnection.removeEventListener("track", o2), clearTimeout(i4), void e3({ track: r3, id: n3 });
                  }
                  if (t5.track.id === n3) return this.peerConnection.removeEventListener("track", o2), clearTimeout(i4), void e3({ track: t5.track, id: n3 });
                };
                this.peerConnection.addEventListener("track", o2);
              });
            }), i2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: i2 });
            const n2 = await this.peerConnection.createAnswer();
            return await this.peerConnection.setLocalDescription(n2), await cg.all(t2);
          } catch (e3) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e3.toString()));
          }
        }
        async getRemoteSSRC(e2) {
          if (!this.remoteSDP) return;
          const t2 = this.remoteSDP.getSSRC(e2);
          return null == t2 ? void 0 : t2[0].ssrcId;
        }
        setConfiguration(e2) {
          if (IA().supportPCSetConfiguration) {
            const t2 = LV.resolvePCConfiguration(e2);
            this.peerConnection.setConfiguration(t2);
          }
        }
      }
      function kV(e2, t2, i2) {
        const n2 = e2[t2];
        if ("function" != typeof n2) throw new Error("Cannot use mutex on object property.");
        return i2.value = async function() {
          const e3 = this.mutex, i3 = await e3.lock("Locking from P2PConnection.".concat(t2));
          try {
            for (var r2 = arguments.length, s2 = new Array(r2), o2 = 0; o2 < r2; o2++) s2[o2] = arguments[o2];
            return await n2.apply(this, s2);
          } finally {
            i3();
          }
        }, i2;
      }
      function MV(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function UV(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? MV(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : MV(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      DI([kV, PI("design:type", Function), PI("design:paramtypes", [Object, Object, Array, Object, String, String]), PI("design:returntype", cg)], LV.prototype, "connect", null), DI([kV, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], LV.prototype, "stopSending", null), DI([kV, PI("design:type", Function), PI("design:paramtypes", [String, Array, String, Object]), PI("design:returntype", cg)], LV.prototype, "receive", null), DI([kV, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], LV.prototype, "stopReceiving", null), DI([kV, PI("design:type", Function), PI("design:paramtypes", [String]), PI("design:returntype", cg)], LV.prototype, "muteRemote", null), DI([kV, PI("design:type", Function), PI("design:paramtypes", [String]), PI("design:returntype", cg)], LV.prototype, "unmuteRemote", null), DI([kV, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], LV.prototype, "muteLocal", null), DI([kV, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], LV.prototype, "unmuteLocal", null), DI([kV, PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], LV.prototype, "close", null), DI([kV, PI("design:type", Function), PI("design:paramtypes", [String, lb]), PI("design:returntype", cg)], LV.prototype, "updateEncoderConfig", null), DI([kV, PI("design:type", Function), PI("design:paramtypes", [String, lb]), PI("design:returntype", cg)], LV.prototype, "updateSendParameters", null), DI([kV, PI("design:type", Function), PI("design:paramtypes", [lb, String]), PI("design:returntype", cg)], LV.prototype, "replaceTrack", null), DI([kV, PI("design:type", Function), PI("design:paramtypes", [String]), PI("design:returntype", cg)], LV.prototype, "getRemoteSSRC", null);
      const xV = "9", VV = 4e4;
      function FV(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function BV(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? FV(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : FV(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class jV extends Nv {
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        get dtlsTransportState() {
          var e2, t2;
          return null !== (e2 = null === (t2 = this.peerConnection.getReceivers()[0]) || void 0 === t2 || null === (t2 = t2.transport) || void 0 === t2 ? void 0 : t2.state) && void 0 !== e2 ? e2 : null;
        }
        get localCodecs() {
          return [...new Set(this.localCapabilities && this.localCapabilities.send.videoCodecs.map((e2) => e2.rtpMap && e2.rtpMap.encodingName.toLowerCase() || "").filter((e2) => {
            var t2;
            return bn(t2 = Object.keys(bC)).call(t2, e2);
          }))];
        }
        constructor(e2, t2) {
          super(e2, t2), sh(this, "store", void 0), sh(this, "peerConnection", void 0), sh(this, "remoteSDP", void 0), sh(this, "initialOffer", void 0), sh(this, "transportEventReceiver", void 0), sh(this, "statsFilter", void 0), sh(this, "useXR", RC("USE_XR")), sh(this, "localCapabilities", void 0), sh(this, "remoteCodecs", void 0), sh(this, "localCandidateCount", 0), sh(this, "allCandidatesReceived", false), sh(this, "dataStreamChannelMap", /* @__PURE__ */ new Map()), sh(this, "establishPromise", void 0), sh(this, "recoveredDataChannelIds", []), sh(this, "currentDataChannelId", 1), sh(this, "mutex", new pS("P2PConnection-mutex")), this.store = t2, this.peerConnection = new RTCPeerConnection(jV.resolvePCConfiguration(e2), { optional: [{ googDscp: true }] }), this.statsFilter = Ex(this.peerConnection, RC("STATS_UPDATE_INTERVAL"), void 0, wg() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();
        }
        async updateRemoteRTPCapabilities(e2, t2) {
          if (this.remoteCodecs = t2, !this.remoteSDP) return void jC.debug("[P2PConnection] cannot updateRemoteRTPCapabilities before remote SDP created, local codecs: ".concat(this.localCodecs, ", codecs: ").concat(t2));
          if (this.remoteSDP.updateRemoteCodec(e2, t2, this.store.codec)) {
            const e3 = await this.peerConnection.createOffer(), t3 = this.logSDPExchange(e3.sdp || "", "offer", "local", "muteLocal");
            await this.peerConnection.setLocalDescription(e3);
            const i2 = this.remoteSDP.toString();
            null == t3 || t3(i2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: i2 });
          } else jC.debug("[P2PConnection] updateRemoteRTPCapabilities no need to exchange SDP.");
        }
        async establish() {
          try {
            this.peerConnection.addTransceiver("video", { direction: "recvonly" }), this.peerConnection.addTransceiver("audio", { direction: "recvonly" });
            const e2 = await this.peerConnection.createOffer();
            if (!e2.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
            const t2 = Tx(e2.sdp), i2 = await Ox({ filterRTX: !RC("USE_PUB_RTX") && !RC("USE_SUB_RTX"), filterVideoFec: RC("FILTER_VIDEO_FEC"), filterAudioFec: RC("FILTER_AUDIO_FEC"), filterVideoCodec: RC("FILTER_VIDEO_CODEC") }, { useXR: this.useXR });
            return this.localCapabilities = Px(i2), this.initialOffer = e2, BV(BV({}, t2), {}, { rtpCapabilities: i2, offerSDP: e2.sdp });
          } catch (e2) {
            throw new Kg(Hg.GET_LOCAL_CONNECTION_PARAMS_FAILED, e2.toString());
          }
        }
        async connect(e2, t2, i2, n2, r2, s2) {
          try {
            if (!this.initialOffer) throw new Error("Cannot establish P2PConnection without initial offer.");
            this.remoteSDP = new class {
              get localCapabilities() {
                return YT(this._localCapabilities);
              }
              get rtpCapabilities() {
                return YT(this._rtpCapabilities);
              }
              get candidates() {
                return YT(this._candidates);
              }
              get iceParameters() {
                return YT(this._iceParameters);
              }
              get dtlsParameters() {
                return YT(this._dtlsParameters);
              }
              constructor(e3) {
                sh(this, "sessionDesc", void 0), sh(this, "_localCapabilities", void 0), sh(this, "_rtpCapabilities", void 0), sh(this, "_candidates", void 0), sh(this, "_iceParameters", void 0), sh(this, "_dtlsParameters", void 0), sh(this, "setup", void 0), sh(this, "currentMidIndex", void 0), sh(this, "cname", void 0), sh(this, "firefoxSsrcMidMap", /* @__PURE__ */ new Map()), e3 = YT(e3);
                const { remoteIceParameters: t3, remoteDtlsParameters: i3, candidates: n3, remoteRTPCapabilities: r3, remoteSetup: s3, localCapabilities: o3, cname: a3 } = e3, c3 = JU.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=ice-lite\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n");
                this._rtpCapabilities = r3, this._candidates = n3, this._iceParameters = t3, this._dtlsParameters = i3, this._localCapabilities = o3, this.setup = s3, this.cname = a3;
                const d3 = this.rtpCapabilities.send;
                for (const e4 of c3.mediaDescriptions) {
                  if (e4.attributes.iceUfrag = t3.iceUfrag, e4.attributes.icePwd = t3.icePwd, e4.attributes.fingerprints = i3.fingerprints, e4.attributes.candidates = n3, e4.attributes.setup = s3, "video" === e4.media.mediaType && (e4.media.fmts = d3.videoCodecs.map((e5) => e5.payloadType.toString(10)), e4.attributes.payloads = d3.videoCodecs, e4.attributes.extmaps = d3.videoExtensions, RC("PRELOAD_MEDIA_COUNT") > 0)) {
                    const { ssrcs: t4, ssrcGroups: i4 } = Cx([{ ssrcId: VV, rtx: RC("USE_SUB_RTX") ? 40001 : void 0 }], this.cname);
                    e4.attributes.ssrcs = t4, e4.attributes.ssrcGroups = i4;
                  }
                  if ("audio" === e4.media.mediaType && (e4.media.fmts = d3.audioCodecs.map((e5) => e5.payloadType.toString(10)), e4.attributes.payloads = d3.audioCodecs, e4.attributes.extmaps = d3.audioExtensions, Lx(e4), RC("PRELOAD_MEDIA_COUNT") > 0)) {
                    const { ssrcs: t4, ssrcGroups: i4 } = Cx([{ ssrcId: 2e4 }], this.cname);
                    e4.attributes.ssrcs = t4, e4.attributes.ssrcGroups = i4;
                  }
                }
                this.sessionDesc = c3, this.currentMidIndex = c3.mediaDescriptions.length - 1;
              }
              preloadRemoteMedia() {
                const e3 = RC("PRELOAD_MEDIA_COUNT");
                this.rtpCapabilities;
                const t3 = this.candidates, i3 = this.dtlsParameters, n3 = this.iceParameters, r3 = this.rtpCapabilities.send;
                for (let s3 = 1; s3 < e3; s3++) {
                  const e4 = 2 * s3 + 2e4, o3 = 2 * s3 + VV, { ssrcs: a3, ssrcGroups: c3 } = Cx([{ ssrcId: e4 }], this.cname), { ssrcs: d3, ssrcGroups: l3 } = Cx([{ ssrcId: o3, rtx: RC("USE_SUB_RTX") ? o3 + 1 : void 0 }], this.cname);
                  this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "video", port: xV, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r3.videoCodecs.map((e5) => e5.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: n3.iceUfrag, icePwd: n3.icePwd, unrecognized: [], candidates: t3, extmaps: r3.videoExtensions, fingerprints: i3.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: d3, ssrcGroups: l3, rtcpFeedbackWildcards: [], payloads: r3.videoCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(2 * s3) } }), this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "audio", port: xV, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r3.audioCodecs.map((e5) => e5.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: n3.iceUfrag, icePwd: n3.icePwd, unrecognized: [], candidates: t3, extmaps: r3.audioExtensions, fingerprints: i3.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: a3, ssrcGroups: c3, rtcpFeedbackWildcards: [], payloads: r3.audioCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(2 * s3 + 1) } }), this.currentMidIndex += 2;
                }
                this.updateBundleMids();
              }
              toString() {
                return JU.print(this.sessionDesc);
              }
              send(e3, t3, i3, n3) {
                const { ssrcs: r3, ssrcGroups: s3 } = Cx(t3, this.cname, RC("SYNC_GROUP") ? i3 : void 0), o3 = this.findPreloadMediaDesc(r3);
                if (o3) {
                  if (wg() && this.firefoxSsrcMidMap.set(r3[0].ssrcId, o3.attributes.mid), n3 && (n3.twcc || n3.remb)) {
                    const e4 = this.sessionDesc.mediaDescriptions.indexOf(o3);
                    return this.sessionDesc.mediaDescriptions[e4] = this.mungSendMediaDesc(o3, n3), { mid: o3.attributes.mid, needExchangeSDP: true };
                  }
                  return { mid: o3.attributes.mid, needExchangeSDP: false };
                }
                {
                  const t4 = this.findAvailableMediaIndex(e3, r3);
                  let i4;
                  return -1 === t4 || 1 === t4 && (bg() || Lg()) || 0 === t4 && RC("USE_SUB_RTX") || kg() ? (i4 = this.createOrRecycleSendMedia(e3, r3, s3, "sendonly", n3), this.updateBundleMids()) : (i4 = YT(this.sessionDesc.mediaDescriptions[t4]), i4.attributes.direction = "sendonly", i4.attributes.ssrcs = r3, i4.attributes.ssrcGroups = s3, this.sessionDesc.mediaDescriptions[t4] = this.mungSendMediaDesc(i4, n3)), wg() && this.firefoxSsrcMidMap.set(r3[0].ssrcId, i4.attributes.mid), { mid: i4.attributes.mid, needExchangeSDP: true };
                }
              }
              sendDataChannel() {
                const { mediaDesc: e3, needExchangeSDP: t3 } = this.createOrRecycleDataChannel();
                return this.updateBundleMids(), { mid: e3.attributes.mid, needExchangeSDP: t3 };
              }
              batchSend(e3) {
                const t3 = e3.map((e4) => {
                  let { kind: t4, ssrcMsg: i4, mslabel: n4 } = e4;
                  return this.send(t4, i4, n4);
                }), i3 = [];
                let n3 = false;
                return t3.forEach((e4) => {
                  let { mid: t4, needExchangeSDP: r3 } = e4;
                  r3 && (n3 = true), i3.push(t4);
                }), { mids: i3, needExchangeSDP: n3 };
              }
              stopSending(e3) {
                const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => t4.attributes.mid && -1 !== e3.indexOf(t4.attributes.mid));
                if (t3.length !== e3.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
                t3.forEach((e4) => {
                  "0" === e4.attributes.mid || wg() || kg() ? e4.attributes.ssrcs = [] : (e4.attributes.ssrcs = [], e4.attributes.direction = "inactive", e4.media.port = "0");
                }), this.updateBundleMids();
              }
              mute(e3) {
                const t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e3);
                if (!t3) throw new Error("mediaDescription not found with ".concat(e3, " in remote SDP when calling RemoteSDP.mute."));
                t3.attributes.direction = "inactive";
              }
              unmute(e3) {
                const t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e3);
                if (!t3) throw new Error("mediaDescription not found with ".concat(e3, " in remote SDP when calling RemoteSDP.unmute."));
                t3.attributes.direction = "sendonly";
              }
              muteRemote(e3) {
                const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => bn(e3).call(e3, t4.attributes.mid || ""));
                if (t3.length !== e3.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
                t3.forEach((e4) => {
                  e4.attributes.direction = "inactive";
                });
              }
              unmuteRemote(e3) {
                const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => bn(e3).call(e3, t4.attributes.mid || ""));
                if (t3.length !== e3.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
                t3.forEach((e4) => {
                  e4.attributes.direction = "recvonly";
                });
              }
              receive(e3, t3, i3, n3) {
                e3.forEach((e4, r3) => {
                  this.createOrRecycleRecvMedia(e4, [], "recvonly", t3, i3, n3[r3]);
                }), this.updateBundleMids();
              }
              stopReceiving(e3) {
                const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => -1 !== e3.indexOf(t4.attributes.mid));
                if (t3.length !== e3.length) throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
                t3.forEach((e4) => {
                  e4.media.port = "0", e4.attributes.direction = "inactive";
                }), this.updateBundleMids();
              }
              updateCandidates(e3) {
                const t3 = this._candidates.filter((e4) => "udp" === e4.transport);
                if (e3 === cv.TCP) {
                  if (0 === t3.length) return;
                  if (RC("TCP_CANDIDATE_ONLY")) {
                    const e4 = this._candidates.filter((e5) => "tcp" === e5.transport);
                    t3.forEach((t4) => {
                      -1 === e4.findIndex((e5) => e5.connectionAddress === t4.connectionAddress) && e4.push(UV(UV({}, t4), {}, { foundation: "tcpcandidate", priority: Number(t4.priority) - 1 + "", transport: "tcp", port: Number(t4.port) + 90 + "" }));
                    }), this._candidates = e4;
                  } else {
                    const e4 = [];
                    t3.forEach((t4) => {
                      e4.push(UV(UV({}, t4), {}, { foundation: "tcpcandidate", priority: Number(t4.priority) - 1 + "", transport: "tcp", port: Number(t4.port) + 90 + "" }));
                    }), this._candidates = [...t3, ...e4];
                  }
                } else if (e3 === cv.RELAY) {
                  if (0 !== t3.length) return;
                  {
                    const e4 = this._candidates.filter((e5) => "tcp" === e5.transport);
                    e4.forEach((e5) => {
                      t3.push(UV(UV({}, e5), {}, { foundation: "udpcandidate", priority: Number(e5.priority) + 1 + "", transport: "udp", port: Number(e5.port) - 90 + "" }));
                    }), this._candidates = [...t3, ...e4];
                  }
                } else 0 === t3.length ? (this._candidates.filter((e4) => "tcp" === e4.transport).forEach((e4) => {
                  t3.push(UV(UV({}, e4), {}, { foundation: "udpcandidate", priority: Number(e4.priority) + 1 + "", transport: "udp", port: Number(e4.port) - 90 + "" }));
                }), this._candidates = t3) : this._candidates = this._candidates.filter((e4) => "tcp" !== e4.transport);
                for (const e4 of this.sessionDesc.mediaDescriptions) e4.attributes.candidates = this.candidates;
              }
              restartICE(e3) {
                e3 = YT(e3), this._iceParameters = e3, this.sessionDesc.mediaDescriptions.forEach((t3) => {
                  t3.attributes.iceUfrag = e3.iceUfrag, t3.attributes.icePwd = e3.icePwd;
                });
              }
              predictReceivingMids(e3) {
                const t3 = [];
                for (let i3 = 0; i3 < e3; i3++) t3.push((this.currentMidIndex + i3 + 1).toString(10));
                return t3;
              }
              findAvailableMediaIndex(e3, t3) {
                return this.sessionDesc.mediaDescriptions.findIndex((i3) => {
                  const n3 = i3.media.mediaType === e3 && "0" !== i3.media.port && ("sendonly" === i3.attributes.direction || "sendrecv" === i3.attributes.direction) && 0 === i3.attributes.ssrcs.length;
                  if (wg()) {
                    if (n3) {
                      const e4 = this.firefoxSsrcMidMap.get(t3[0].ssrcId);
                      return !(e4 || "0" !== i3.attributes.mid && "1" !== i3.attributes.mid) || !(!e4 || e4 !== i3.attributes.mid);
                    }
                    return false;
                  }
                  return n3;
                });
              }
              createOrRecycleDataChannel() {
                for (const e4 of this.sessionDesc.mediaDescriptions) if ("application" === e4.media.mediaType) return { mediaDesc: e4, needExchangeSDP: false };
                this.currentMidIndex += 1;
                const e3 = "".concat(this.currentMidIndex), t3 = { media: { mediaType: "application", port: xV, protos: ["UDP", "DTLS", "SCTP"], fmts: ["webrtc-datachannel"] }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: [], fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: [], ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: [], rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, mid: "".concat(e3), sctpPort: "5000" } };
                return this.sessionDesc.mediaDescriptions.push(t3), { mediaDesc: t3, needExchangeSDP: true };
              }
              createOrRecycleRecvMedia(e3, t3, i3, n3, r3, s3) {
                const o3 = e3._mediaStreamTrack.kind, a3 = this.rtpCapabilities.recv, c3 = Mx(o3, a3, this.localCapabilities.send, o3 === av.VIDEO ? n3 : r3), d3 = o3 === av.VIDEO ? a3.videoExtensions : a3.audioExtensions;
                this.currentMidIndex += 1;
                const l3 = "".concat(this.currentMidIndex);
                let u3 = { media: { mediaType: o3, port: xV, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: c3.map((e4) => e4.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: d3, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t3, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: c3, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i3, rtcpMux: true, rtcpRsize: true, mid: "".concat(l3) } };
                u3 = this.mungRecvMediaDsec(u3, e3, s3);
                const h3 = this.findFirstClosedMedia(o3);
                if (h3) {
                  const e4 = this.sessionDesc.mediaDescriptions.indexOf(h3);
                  this.sessionDesc.mediaDescriptions[e4] = u3;
                } else this.sessionDesc.mediaDescriptions.push(u3);
                return u3;
              }
              updateRemoteCodec(e3, t3, i3) {
                const n3 = [...new Set(this._rtpCapabilities.recv.videoCodecs.map((e4) => e4.rtpMap && e4.rtpMap.encodingName.toLowerCase() || "").filter((e4) => {
                  var t4;
                  return bn(t4 = Object.keys(bC)).call(t4, e4);
                }))], r3 = new Set(t3);
                if (n3.every((e4) => r3.has(e4))) return jC.debug("codecs has not changed, no need to updateRemoteCodec, codecs: ".concat(t3)), false;
                const s3 = this._rtpCapabilities.recv.videoCodecs.filter((e4) => t3.some((t4) => {
                  var i4;
                  return bn(i4 = e4.rtpMap && e4.rtpMap.encodingName.toLowerCase() || "").call(i4, t4);
                }));
                if (0 === s3.length) return jC.debug("updateRemoteCodec failed, because cannot find matched codec, remoteCapabilities codecs: ".concat(n3, " codecs: ").concat(t3)), false;
                const o3 = [...new Set(s3.map((e4) => e4.rtpMap && e4.rtpMap.encodingName.toLowerCase() || ""))];
                let a3;
                if (jC.debug("updateRemoteCodec, from ".concat(n3, " to ").concat(o3)), 0 === e3.length) a3 = this.sessionDesc.mediaDescriptions.filter((e4) => "video" === e4.media.mediaType && "recvonly" === e4.attributes.direction);
                else if (a3 = this.sessionDesc.mediaDescriptions.filter((t4) => t4.attributes.mid && bn(e3).call(e3, t4.attributes.mid) && "recvonly" === t4.attributes.direction), a3.length !== e3.length) return jC.debug("updateRemoteCodec failed, because cannot find mids, mids: ".concat(e3, ", codecs: ").concat(t3)), false;
                this._rtpCapabilities.recv.videoCodecs = s3;
                const c3 = this.localCapabilities.send, d3 = this.rtpCapabilities.recv, l3 = Mx(av.VIDEO, d3, c3, i3);
                return a3.forEach((e4) => {
                  const t4 = l3.map((e5) => e5.payloadType.toString(10));
                  jC.debug("updateRemoteCodec mid: ".concat(e4.attributes.mid, ", from ").concat(e4.attributes.payloads, " to ").concat(l3)), e4.attributes.payloads = l3, e4.media.fmts = t4;
                }), true;
              }
              createOrRecycleSendMedia(e3, t3, i3, n3, r3) {
                const s3 = this.rtpCapabilities.send, o3 = e3 === av.VIDEO ? s3.videoCodecs : s3.audioCodecs, a3 = e3 === av.VIDEO ? s3.videoExtensions : s3.audioExtensions;
                this.currentMidIndex += 1;
                const c3 = "".concat(this.currentMidIndex);
                let d3 = { media: { mediaType: e3, port: xV, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: o3.map((e4) => e4.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: a3, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t3, ssrcGroups: i3, rtcpFeedbackWildcards: [], payloads: o3, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: n3, rtcpMux: true, rtcpRsize: true, mid: "".concat(c3) } };
                d3 = this.mungSendMediaDesc(d3, r3);
                const l3 = this.findFirstClosedMedia(e3);
                if (l3) {
                  const e4 = this.sessionDesc.mediaDescriptions.indexOf(l3);
                  this.sessionDesc.mediaDescriptions[e4] = d3;
                } else this.sessionDesc.mediaDescriptions.push(d3);
                return d3;
              }
              updateBundleMids() {
                this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter((e3) => "0" !== e3.media.port).map((e3) => e3.attributes.mid);
              }
              mungRecvMediaDsec(e3, t3, i3) {
                const n3 = YT(e3);
                return vx(n3), Ix(n3, t3), yx(n3, t3), Ax(n3), bx(n3, i3, this.localCapabilities.send), n3;
              }
              mungSendMediaDesc(e3, t3) {
                const i3 = YT(e3);
                return bx(i3, t3, this.localCapabilities.recv), Lx(i3), i3;
              }
              updateRecvMedia(e3, t3) {
                const i3 = this.sessionDesc.mediaDescriptions.findIndex((t4) => t4.attributes.mid === e3);
                if (-1 !== i3) {
                  const e4 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i3], t3);
                  this.sessionDesc.mediaDescriptions[i3] = e4;
                }
              }
              bumpMid(e3) {
                this.currentMidIndex += e3;
              }
              findFirstClosedMedia(e3) {
                return this.sessionDesc.mediaDescriptions.find((t3) => wg() ? "0" === t3.media.port && t3.media.mediaType === e3 : "0" === t3.media.port);
              }
              findPreloadMediaDesc(e3) {
                return this.sessionDesc.mediaDescriptions.find((t3) => {
                  var i3;
                  return (null === (i3 = t3.attributes) || void 0 === i3 || null === (i3 = i3.ssrcs[0]) || void 0 === i3 ? void 0 : i3.ssrcId) === e3[0].ssrcId;
                });
              }
              getSSRC(e3) {
                var t3;
                return null === (t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e3)) || void 0 === t3 ? void 0 : t3.attributes.ssrcs;
              }
            }({ remoteIceParameters: e2, remoteDtlsParameters: t2, candidates: i2, remoteRTPCapabilities: n2, remoteSetup: r2, localCapabilities: this.localCapabilities, cname: s2 }), Array.isArray(this.remoteCodecs) && this.remoteCodecs.length > 0 && this.remoteSDP.updateRemoteCodec([], this.remoteCodecs, this.store.codec);
            const o2 = this.remoteSDP.toString(), a2 = JU.parse(this.initialOffer.sdp), c2 = a2.mediaDescriptions.find((e3) => "audio" === e3.media.mediaType);
            c2 && Lx(c2), this.useXR && kx(a2);
            const d2 = JU.print(a2), l2 = this.logSDPExchange(d2 || "", "offer", "local", "connect");
            this.store.descriptionStart(), await this.peerConnection.setLocalDescription({ type: "offer", sdp: d2 }), null == l2 || l2(o2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o2 });
            const u2 = this.peerConnection.getTransceivers()[0];
            if (null != u2 && u2.receiver && this.tryBindTransportEvents(u2.receiver), RC("PRELOAD_MEDIA_COUNT") > 0) {
              this.remoteSDP.preloadRemoteMedia();
              const e3 = this.remoteSDP.toString();
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e3 });
              const t3 = await this.peerConnection.createAnswer();
              await this.peerConnection.setLocalDescription(t3);
            }
          } catch (e3) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e3.toString()));
          }
        }
        send(e2, t2, i2) {
          var n2 = this;
          return PU(function* () {
            const r2 = yield IU(n2.mutex.lock("From P2PConnection.send"));
            try {
              if (!n2.remoteSDP) throw new Error("Cannot call P2PConnection.send before remote SDP created");
              const s2 = [];
              e2.forEach((e3) => {
                const t3 = n2.peerConnection.addTransceiver(e3._mediaStreamTrack, { direction: "sendonly" });
                s2.push(t3), e3._updateRtpTransceiver(t3);
              }), wg() && true === RC("SIMULCAST") && (yield IU(n2.applySimulcastForFirefox(s2, e2)));
              const o2 = yield IU(n2.peerConnection.createOffer()), a2 = n2.remoteSDP.predictReceivingMids(e2.length), c2 = n2.mungSendOfferSDP(o2.sdp, e2, a2), d2 = JU.parse(c2), l2 = a2.map((e3) => {
                const t3 = d2.mediaDescriptions.find((t4) => t4.attributes.mid === e3);
                if (!t3) throw new Error("Cannot extract ssrc from mediaDescription.");
                return Sx(t3, RC("USE_PUB_RTX"));
              });
              let u2;
              try {
                u2 = yield l2;
              } catch (r3) {
                u2 = [], n2.remoteSDP.receive(e2, t2, i2, u2);
                const s3 = n2.remoteSDP.toString();
                throw yield IU(n2.peerConnection.setLocalDescription({ type: "offer", sdp: c2 })), yield IU(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: s3 })), yield IU(n2.stopSending(a2, true)), r3;
              }
              n2.remoteSDP.receive(e2, t2, i2, u2);
              const h3 = n2.remoteSDP.toString(), p2 = n2.logSDPExchange(c2, "offer", "local", "send");
              return yield IU(n2.peerConnection.setLocalDescription({ type: "offer", sdp: c2 })), yield IU(n2.applySimulcastEncodings(s2, e2)), yield IU(n2.applySendEncodings(s2, e2)), null == p2 || p2(h3), yield IU(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: h3 })), s2.map((e3, t3) => {
                const i3 = a2[t3];
                return { localSSRC: l2[t3], id: i3, transceiver: e3 };
              });
            } catch (e3) {
              throw e3 instanceof Kg ? e3 : new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e3.toString()));
            } finally {
              r2();
            }
          })();
        }
        async createDataChannels(e2, t2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.createDataChannels before remote SDP created");
            let i2 = this.dataStreamChannelMap.get(e2);
            if (i2 && "open" === i2.readyState) jC.debug("[P2PConnection] Channels are already available and can be reused directly.");
            else {
              const t3 = this.currentDataChannelId < 1023 ? this.currentDataChannelId++ : this.recoveredDataChannelIds.shift();
              if ("number" != typeof t3) throw new Error("create DataChannel error, because cannot get dc id");
              i2 = this.peerConnection.createDataChannel("datastream-channel", { id: t3, negotiated: true, ordered: false, maxRetransmits: RC("DATASTREAM_MAX_RETRANSMITS") }), i2.binaryType = "arraybuffer", this.dataStreamChannelMap.set(e2, i2);
            }
            t2.forEach((e3) => {
              e3._updateOriginDataChannel(i2);
            });
            const { needExchangeSDP: n2 } = this.remoteSDP.sendDataChannel();
            if (n2) {
              const e3 = this.remoteSDP.toString();
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e3 });
              const t3 = await this.peerConnection.createAnswer();
              await this.peerConnection.setLocalDescription(t3), jC.debug("[P2PConnection] createDataChannels by exchanging SDP.");
            } else jC.debug("[P2PConnection] createDataChannels no need to exchange SDP.");
            return;
          } catch (e3) {
            throw e3 instanceof Kg ? e3 : new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.createDataChannels failed; ".concat(e3.toString()));
          }
        }
        async stopDataChannels(e2) {
          try {
            const t2 = this.dataStreamChannelMap.get(e2);
            return t2 && (t2.id && this.recoveredDataChannelIds.push(t2.id), t2.close()), void this.dataStreamChannelMap.delete(e2);
          } catch (e3) {
            throw e3 instanceof Kg ? e3 : new Kg(Hg.DATACHANNEL_FAILED, "P2PConnection.stopDataChannels failed; ".concat(e3.toString()));
          }
        }
        async stopSending(e2, t2) {
          const i2 = t2 ? void 0 : await this.mutex.lock("From P2PConnection.stopSending");
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
            const t3 = this.peerConnection.getTransceivers().filter((t4) => -1 !== e2.indexOf(t4.mid));
            if (t3.length !== e2.length) throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
            t3.map((e3) => {
              var t4;
              e3.direction = "inactive", null === (t4 = e3.stop) || void 0 === t4 || t4.call(e3);
            });
            const n2 = await this.peerConnection.createOffer(), r2 = this.logSDPExchange(n2.sdp || "", "offer", "local", "stopSending");
            await this.peerConnection.setLocalDescription(n2), this.remoteSDP.stopReceiving(e2);
            const s2 = this.remoteSDP.toString();
            null == r2 || r2(s2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: s2 });
          } catch (e3) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e3.toString()));
          } finally {
            i2 && i2();
          }
        }
        async receive(e2, t2, i2, n2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e2, " before remoteSDP created."));
            const { mid: r2, needExchangeSDP: s2 } = this.remoteSDP.send(e2, t2, i2, n2);
            if (s2) {
              const t3 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t3, "offer", "remote", "receive");
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t3 });
              const n3 = await this.peerConnection.createAnswer(), s3 = this.mungReceiveAnswerSDP(n3.sdp, r2, e2);
              null == i3 || i3(s3 || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: s3 }), jC.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e2, " by exchanging SDP."));
            } else jC.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e2, " no need to exchange SDP."));
            const o2 = this.peerConnection.getTransceivers().find((e3) => e3.mid === r2);
            if (!o2) throw new Error("Cannot get transceiver after setLocalDescription.");
            return { track: o2.receiver.track, id: r2, transceiver: o2 };
          } catch (e3) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e3.toString()));
          }
        }
        async batchReceive(e2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
            const { mids: t2, needExchangeSDP: i2 } = this.remoteSDP.batchSend(e2);
            if (i2) {
              const e3 = this.remoteSDP.toString(), t3 = this.logSDPExchange(e3, "offer", "remote", "receive");
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e3 });
              const i3 = await this.peerConnection.createAnswer();
              null == t3 || t3(i3.sdp || ""), await this.peerConnection.setLocalDescription(i3), jC.debug("[".concat(this.store.clientId, "] [P2PConnection] batchReceive by exchanging SDP."));
            } else jC.debug("[".concat(this.store.clientId, "] [P2PConnection] batchReceive no need to exchange SDP."));
            return t2.map((e3) => {
              const t3 = this.peerConnection.getTransceivers().find((t4) => t4.mid === e3);
              if (!t3) throw new Error("Cannot get transceiver after setLocalDescription.");
              return { track: t3.receiver.track, id: e3, transceiver: t3 };
            });
          } catch (e3) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e3.toString()));
          }
        }
        async stopReceiving(e2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
            this.remoteSDP.stopSending(e2);
            const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "stopReceiving");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e3) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e3.toString()));
          }
        }
        async muteRemote(e2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteRemote mid=".concat(e2, " before remote SDP created."));
            this.remoteSDP.mute(e2);
            const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "muteRemote");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e3) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.muteRemote failed; ".concat(e3.toString()));
          }
        }
        async unmuteRemote(e2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteRemote mid=".concat(e2, " before remote SDP created."));
            this.remoteSDP.unmute(e2);
            const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "unmuteRemote");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e3) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteRemote failed; ".concat(e3.toString()));
          }
        }
        async muteLocal(e2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
            const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e2.indexOf(t3.mid));
            if (t2.length !== e2.length) throw new Error("Transceivers' length doesn't match mids' length.");
            t2.map((e3) => {
              e3.direction = "inactive";
            });
            const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "muteLocal");
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.muteRemote(e2);
            const r2 = this.remoteSDP.toString();
            null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e3) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e3.toString()));
          }
        }
        async unmuteLocal(e2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
            const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e2.indexOf(t3.mid));
            if (t2.length !== e2.length) throw new Error("Transceivers' length doesn't match mids' length.");
            t2.map(async (e3, t3) => {
              e3.direction = "sendonly";
            });
            const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "unmuteLocal");
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.unmuteRemote(e2);
            const r2 = this.remoteSDP.toString();
            null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e3) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e3.toString()));
          }
        }
        restartICE(e2) {
          var t2 = this;
          return PU(function* () {
            const i2 = yield IU(t2.mutex.lock("From P2PConnection.restartICE"));
            try {
              if (!t2.remoteSDP) throw new Error("Cannot restartICE before remoteSDP created.");
              if (IA().supportPCSetConfiguration) {
                const i3 = t2.peerConnection.getConfiguration(), n3 = e2 === cv.RELAY ? "relay" : "all";
                i3.iceTransportPolicy !== n3 && (jC.debug("[".concat(t2.store.clientId, "] restartICE change iceTransportPolicy from [").concat(i3.iceTransportPolicy, "] to [").concat(n3, "]")), i3.iceTransportPolicy = n3, t2.peerConnection.setConfiguration(i3));
              } else if (e2 === cv.RELAY) return;
              t2.remoteSDP.updateCandidates(e2);
              const n2 = yield IU(t2.peerConnection.createOffer({ iceRestart: true }));
              if (!n2.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist.");
              const r2 = Tx(n2.sdp), { remoteIceParameters: s2 } = yield r2.iceParameters;
              t2.remoteSDP.restartICE(s2);
              const o2 = t2.remoteSDP.toString(), a2 = t2.logSDPExchange(n2.sdp || "", "offer", "local", "restartICE");
              t2.store.descriptionStart(), yield IU(t2.peerConnection.setLocalDescription(n2)), null == a2 || a2(o2), yield IU(t2.peerConnection.setRemoteDescription({ type: "answer", sdp: o2 }));
            } catch (e3) {
              jC.warning("[".concat(t2.store.clientId, "] restart ICE failed, abort operation"), e3);
            } finally {
              i2();
            }
          })();
        }
        close() {
          var e2;
          this.peerConnection.close(), null === (e2 = this.onConnectionStateChange) || void 0 === e2 || e2.call(this, "closed"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy(), this.dataStreamChannelMap.clear(), this.recoveredDataChannelIds = [], this.currentDataChannelId = 1;
        }
        getStats() {
          return this.statsFilter.getStats();
        }
        getRemoteVideoIsReady(e2) {
          return this.statsFilter.getVideoIsReady(e2);
        }
        async updateEncoderConfig(e2, t2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
            const i2 = await this.peerConnection.createOffer(), n2 = this.mungSendOfferSDP(i2.sdp, [t2], [e2]);
            this.remoteSDP.updateRecvMedia(e2, t2);
            const r2 = this.remoteSDP.toString(), s2 = this.logSDPExchange(n2, "offer", "local", "updateEncoderConfig");
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: n2 }), null == s2 || s2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e3) {
            throw new Kg(Hg.EXCHANGE_SDP_FAILED, e3.toString());
          }
        }
        async updateSendParameters(e2, t2) {
          const i2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid === e2);
          1 === i2.length && (this.isVP8Simulcast(t2) ? wg() || await this.applySimulcastEncodings(i2, [t2]) : await this.applySendEncodings(i2, [t2]));
        }
        setStatsRemoteVideoIsReady(e2, t2) {
          this.statsFilter.setVideoIsReady2(e2, t2);
        }
        async replaceTrack(e2, t2) {
          const i2 = this.peerConnection.getTransceivers().find((e3) => e3.mid === t2);
          i2 && await i2.sender.replaceTrack(e2._mediaStreamTrack);
        }
        async getSelectedCandidatePair() {
          const e2 = this.peerConnection.getReceivers();
          if (e2.length > 0 && e2[0].transport && e2[0].transport.iceTransport && e2[0].transport.iceTransport.getSelectedCandidatePair && e2[0].transport.iceTransport.getSelectedCandidatePair()) {
            const t2 = e2[0].transport.iceTransport, { local: i2, remote: n2 } = t2.getSelectedCandidatePair();
            return { local: BV(BV({}, $U), {}, { candidateType: i2.type, protocol: i2.protocol, address: i2.address, port: i2.port }), remote: BV(BV({}, $U), {}, { candidateType: n2.type, protocol: n2.protocol, address: n2.address, port: n2.port }) };
          }
          return this.statsFilter.getSelectedCandidatePair();
        }
        bindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = () => {
            var e2;
            null === (e2 = this.onICEConnectionStateChange) || void 0 === e2 || e2.call(this, this.peerConnection.iceConnectionState);
          }, this.peerConnection.onconnectionstatechange = () => {
            var e2;
            null === (e2 = this.onConnectionStateChange) || void 0 === e2 || e2.call(this, this.peerConnection.connectionState);
          }, this.peerConnection.onicecandidate = (e2) => {
            e2.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, jC.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
          }, setTimeout(() => {
            this.allCandidatesReceived || (this.allCandidatesReceived = true, jC.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
          }, RC("CANDIDATE_TIMEOUT"));
        }
        unbindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
        }
        static resolvePCConfiguration(e2) {
          const t2 = { iceServers: [] };
          return e2.iceServers ? t2.iceServers = e2.iceServers : e2.turnServer && "off" !== e2.turnServer.mode && (RT(e2.turnServer.servers) ? t2.iceServers = e2.turnServer.servers : (t2.iceServers && t2.iceServers.push(...jV.turnServerConfigToIceServers(e2.turnServer.servers)), RC("USE_TURN_SERVER_OF_GATEWAY") && t2.iceServers && e2.turnServer.serversFromGateway && t2.iceServers.push(...jV.turnServerConfigToIceServers(e2.turnServer.serversFromGateway)), RC("FORCE_TURN_TCP") ? t2.iceTransportPolicy = "relay" : e2.turnServer.servers.concat(e2.turnServer.serversFromGateway || []).forEach((e3) => {
            e3.forceturn && (t2.iceTransportPolicy = "relay");
          }))), RC("ENABLE_ENCODED_TRANSFORM") && IA().supportWebRTCEncodedTransform && (t2.encodedInsertableStreams = true), t2;
        }
        static turnServerConfigToIceServers(e2) {
          const t2 = [];
          return e2.forEach((e3) => {
            e3.security ? e3.tcpport && t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turns:".concat(gy(e3.turnServerURL), ":").concat(e3.tcpport, "?transport=tcp") }) : (e3.udpport && !RC("FORCE_TURN_TCP") && t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turn:".concat(e3.turnServerURL, ":").concat(e3.udpport, "?transport=udp") }), e3.tcpport && t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turn:".concat(e3.turnServerURL, ":").concat(e3.tcpport, "?transport=tcp") }));
          }), t2;
        }
        tryBindTransportEvents(e2) {
          const t2 = e2.transport;
          if (t2) {
            this.transportEventReceiver = e2, t2.onstatechange = () => {
              var e3;
              null != t2 && t2.state && (null === (e3 = this.onDTLSTransportStateChange) || void 0 === e3 || e3.call(this, t2.state));
            }, t2.onerror = (e3) => {
              var t3;
              null === (t3 = this.onDTLSTransportError) || void 0 === t3 || t3.call(this, "error" in e3 ? e3.error : e3);
            };
            const i2 = t2.iceTransport;
            i2 && (i2.onstatechange = () => {
              const e3 = null == t2 ? void 0 : t2.iceTransport.state;
              var i3;
              e3 && (null === (i3 = this.onICETransportStateChange) || void 0 === i3 || i3.call(this, e3));
            }, i2.getSelectedCandidatePair && (i2.onselectedcandidatepairchange = () => {
              if (i2.getSelectedCandidatePair()) {
                const { local: e3, remote: t3 } = i2.getSelectedCandidatePair();
                jC.info("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] selectedcandidatepairchange: local ").concat(JSON.stringify({ candidateType: e3.type, protocol: e3.protocol }), ", remote ").concat(JSON.stringify({ candidateType: t3.type, protocol: t3.protocol, address: t3.address, port: t3.port }), " )"));
              }
            }));
          }
        }
        tryUnbindTransportEvents() {
          this.transportEventReceiver && this.transportEventReceiver.transport && (this.transportEventReceiver.transport.onstatechange = null, this.transportEventReceiver.transport.onerror = null, this.transportEventReceiver.transport.iceTransport && (this.transportEventReceiver.transport.iceTransport.onstatechange = null));
        }
        async updateRtpSenderEncodings(e2, t2) {
          var i2;
          if (!t2) {
            t2 = this.peerConnection.getSenders().find((t3) => t3.track === e2._mediaStreamTrack);
          }
          if (!t2) return jC.warn("[".concat(e2.getTrackId(), "] no rtpSender found}"));
          if (this.isVP8Simulcast(e2)) return jC.warn("[updateRtpSenderEncodings] Track is VP8 simulcast, please apply simulcast encodings");
          if (!IA().supportSetRtpSenderParameters) return jC.warn("[updateRtpSenderEncodings] Browser not support set rtp-sender parameters");
          const n2 = {}, r2 = {};
          switch (e2._optimizationMode) {
            case "motion":
              n2.degradationPreference = "maintain-framerate";
              break;
            case "detail":
              n2.degradationPreference = "maintain-resolution";
              break;
            default:
              n2.degradationPreference = "balanced";
          }
          if (e2._encoderConfig) {
            var s2;
            const { bitrateMax: t3, frameRate: i3, scaleResolutionDownBy: n3 } = e2._encoderConfig;
            t3 && (r2.maxBitrate = 1e3 * t3), (bn(s2 = e2._hints).call(s2, jA.LOW_STREAM) || e2.isUseScaleResolutionDownBy) && (i3 && (r2.maxFramerate = Sy(i3)), n3 && n3 >= 1 && (r2.scaleResolutionDownBy = n3));
          }
          if (RC("DSCP_TYPE") && jg()) {
            var o2;
            const e3 = RC("DSCP_TYPE");
            bn(o2 = ["very-low", "low", "medium", "high"]).call(o2, e3) && (r2.networkPriority = e3);
          }
          const a2 = t2.getParameters(), c2 = null === (i2 = a2.encodings) || void 0 === i2 ? void 0 : i2[0];
          wg() && !c2 && (n2.encodings = [r2]), c2 && Object.assign(c2, r2), Object.assign(a2, n2), jC.debug("[".concat(e2.getTrackId(), "] updateRtpSenderEncodings: ").concat(JSON.stringify(a2.encodings))), await t2.setParameters(a2);
        }
        async applySendEncodings(e2, t2) {
          try {
            if (!IA().supportSetRtpSenderParameters) return;
            if (e2.length !== t2.length) return;
            for (let i2 = 0; i2 < e2.length; i2++) {
              const n2 = e2[i2], r2 = t2[i2];
              r2 instanceof Rw && !this.isVP8Simulcast(r2) && await this.updateRtpSenderEncodings(r2, n2.sender);
            }
          } catch (e3) {
            jC.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
          }
        }
        mungSendOfferSDP(e2, t2, i2) {
          const n2 = JU.parse(e2);
          return t2.forEach((e3, t3) => {
            const r2 = i2[t3], s2 = n2.mediaDescriptions.find((e4) => e4.attributes.mid === r2);
            s2 && (Ix(s2, e3), wx(s2, e3, this.store.codec));
          }), JU.print(n2);
        }
        mungReceiveAnswerSDP(e2, t2, i2) {
          const n2 = JU.parse(e2), r2 = n2.mediaDescriptions.find((e3) => e3.attributes.mid === t2);
          return r2 && (i2 === av.AUDIO && "audio" === r2.media.mediaType && Lx(r2), this.useXR && kx(n2)), JU.print(n2);
        }
        bindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = (e2) => {
            var t2;
            null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e2);
          }, this.statsFilter.onFirstVideoReceived = (e2) => {
            var t2;
            null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e2);
          }, this.statsFilter.onFirstAudioDecoded = (e2) => {
            var t2;
            null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e2);
          }, this.statsFilter.onFirstVideoDecoded = (e2, t2, i2) => {
            var n2;
            null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e2, t2, i2);
          }, this.statsFilter.onSelectedLocalCandidateChanged = (e2, t2) => {
            var i2;
            null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 || i2.call(this, e2, t2);
          }, this.statsFilter.onSelectedRemoteCandidateChanged = (e2, t2) => {
            var i2;
            null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 || i2.call(this, e2, t2);
          }, this.statsFilter.onFirstVideoDecodedTimeout = (e2) => {
            var t2;
            null === (t2 = this.onFirstVideoDecodedTimeout) || void 0 === t2 || t2.call(this, e2);
          };
        }
        unbindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
        }
        async applySimulcastForFirefox(e2, t2) {
          if (e2.length === t2.length) for (let a2 = 0; a2 < e2.length; a2++) {
            var i2, n2, r2, s2, o2;
            const c2 = e2[a2], d2 = t2[a2];
            if (d2 instanceof Rw && !bn(i2 = d2._hints).call(i2, jA.LOW_STREAM) && null !== (n2 = d2._encoderConfig) && void 0 !== n2 && n2.bitrateMax && (null === (r2 = d2._encoderConfig) || void 0 === r2 ? void 0 : r2.bitrateMax) > 200 && null !== (s2 = d2._scalabilityMode) && void 0 !== s2 && s2.numSpatialLayers && (null === (o2 = d2._scalabilityMode) || void 0 === o2 ? void 0 : o2.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
              const e3 = {}, t3 = { high: 1e3 * (d2._encoderConfig.bitrateMax - 50), medium: 5e4 };
              e3.encodings = [{ rid: "m", active: true, maxBitrate: t3.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: t3.high }];
              const i3 = c2.sender.getParameters();
              await c2.sender.setParameters(Object.assign(i3, e3));
            }
          }
        }
        async applySimulcastEncodings(e2, t2) {
          if (!wg() && e2.length === t2.length) for (let i2 = 0; i2 < e2.length; i2++) {
            const n2 = t2[i2];
            if (n2 instanceof Rw && this.isVP8Simulcast(n2)) {
              const t3 = e2[i2], r2 = {}, s2 = { high: 1e3 * (n2._encoderConfig.bitrateMax - 50), medium: 5e4 };
              r2.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: s2.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: s2.medium, scaleResolutionDownBy: 4 }];
              const o2 = t3.sender.getParameters();
              await t3.sender.setParameters(Object.assign(o2, r2));
            }
          }
        }
        isVP8Simulcast(e2) {
          var t2, i2, n2, r2, s2;
          return !!(e2 instanceof Rw && RC("SIMULCAST") && "vp8" === this.store.codec && !bn(t2 = e2._hints).call(t2, jA.LOW_STREAM) && null !== (i2 = e2._encoderConfig) && void 0 !== i2 && i2.bitrateMax && (null === (n2 = e2._encoderConfig) || void 0 === n2 ? void 0 : n2.bitrateMax) > 200 && null !== (r2 = e2._scalabilityMode) && void 0 !== r2 && r2.numSpatialLayers && (null === (s2 = e2._scalabilityMode) || void 0 === s2 ? void 0 : s2.numSpatialLayers) > 1);
        }
        logSDPExchange(e2, t2, i2, n2) {
          if (RC("SDP_LOGGING")) return jC.upload("[".concat(this.store.clientId, "] exchanging ").concat(i2, " ").concat(t2, " SDP during P2PConnection.").concat(n2, "\n"), e2), "offer" === t2 ? (e3) => {
            this.logSDPExchange(e3, "answer", "local" === i2 ? "remote" : "local", n2);
          } : void 0;
        }
        async getRemoteSSRC(e2) {
          if (!this.remoteSDP) return;
          const t2 = this.remoteSDP.getSSRC(e2);
          return null == t2 ? void 0 : t2[0].ssrcId;
        }
        setConfiguration(e2) {
          if (IA().supportPCSetConfiguration) {
            const t2 = jV.resolvePCConfiguration(e2);
            this.peerConnection.setConfiguration(t2);
          }
        }
      }
      function GV(e2, t2, i2) {
        const n2 = e2[t2];
        if ("function" != typeof n2) throw new Error("Cannot use mutex on object property.");
        return i2.value = async function() {
          const e3 = this.mutex, i3 = await e3.lock("From P2PConnection.".concat(t2));
          try {
            for (var r2 = arguments.length, s2 = new Array(r2), o2 = 0; o2 < r2; o2++) s2[o2] = arguments[o2];
            return await n2.apply(this, s2);
          } finally {
            i3();
          }
        }, i2;
      }
      function WV(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function HV(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? WV(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : WV(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      DI([GV, PI("design:type", Function), PI("design:paramtypes", [Array, Array]), PI("design:returntype", cg)], jV.prototype, "updateRemoteRTPCapabilities", null), DI([GV, PI("design:type", Function), PI("design:paramtypes", [Object, Object, Array, Object, String, String]), PI("design:returntype", cg)], jV.prototype, "connect", null), DI([GV, PI("design:type", Function), PI("design:paramtypes", [Object, Array]), PI("design:returntype", cg)], jV.prototype, "createDataChannels", null), DI([GV, PI("design:type", Function), PI("design:paramtypes", [String, Array, String, Object]), PI("design:returntype", cg)], jV.prototype, "receive", null), DI([GV, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], jV.prototype, "batchReceive", null), DI([GV, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], jV.prototype, "stopReceiving", null), DI([GV, PI("design:type", Function), PI("design:paramtypes", [String]), PI("design:returntype", cg)], jV.prototype, "muteRemote", null), DI([GV, PI("design:type", Function), PI("design:paramtypes", [String]), PI("design:returntype", cg)], jV.prototype, "unmuteRemote", null), DI([GV, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], jV.prototype, "muteLocal", null), DI([GV, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], jV.prototype, "unmuteLocal", null), DI([GV, PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], jV.prototype, "close", null), DI([GV, PI("design:type", Function), PI("design:paramtypes", [String, lb]), PI("design:returntype", cg)], jV.prototype, "updateEncoderConfig", null), DI([GV, PI("design:type", Function), PI("design:paramtypes", [String, lb]), PI("design:returntype", cg)], jV.prototype, "updateSendParameters", null), DI([GV, PI("design:type", Function), PI("design:paramtypes", [lb, String]), PI("design:returntype", cg)], jV.prototype, "replaceTrack", null), DI([GV, PI("design:type", Function), PI("design:paramtypes", [String]), PI("design:returntype", cg)], jV.prototype, "getRemoteSSRC", null);
      const KV = "v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0\na=msid-semantic: WMS\na=ice-lite\nm=application 9 UDP/DTLS/SCTP webrtc-datachannel\nc=IN IP4 127.0.0.1\na=mid:0\n", YV = "9", qV = 2e4, zV = 4e4;
      class JV {
        get localCapabilities() {
          return YT(this._localCapabilities);
        }
        get rtpCapabilities() {
          return YT(this._rtpCapabilities);
        }
        get candidates() {
          return YT(this._candidates);
        }
        get iceParameters() {
          return YT(this._iceParameters);
        }
        get dtlsParameters() {
          return YT(this._dtlsParameters);
        }
        constructor(e2) {
          sh(this, "sessionDesc", void 0), sh(this, "_localCapabilities", void 0), sh(this, "_rtpCapabilities", void 0), sh(this, "_candidates", void 0), sh(this, "_iceParameters", void 0), sh(this, "_dtlsParameters", void 0), sh(this, "setup", void 0), sh(this, "currentMidIndex", void 0), sh(this, "cname", void 0), sh(this, "firefoxSsrcMidMap", /* @__PURE__ */ new Map()), e2 = YT(e2);
          const { remoteIceParameters: t2, remoteDtlsParameters: i2, candidates: n2, remoteRTPCapabilities: r2, remoteSetup: s2, localCapabilities: o2, cname: a2 } = e2, c2 = JU.parse(KV);
          this._rtpCapabilities = r2, this._candidates = n2, this._iceParameters = t2, this._dtlsParameters = i2, this._localCapabilities = o2, this.setup = s2, this.cname = a2;
          const d2 = this.rtpCapabilities.send;
          for (const e3 of c2.mediaDescriptions) {
            if (e3.attributes.iceUfrag = t2.iceUfrag, e3.attributes.icePwd = t2.icePwd, e3.attributes.fingerprints = i2.fingerprints, e3.attributes.candidates = n2, e3.attributes.setup = s2, "application" === e3.media.mediaType && (e3.attributes.sctpPort = "5000"), "video" === e3.media.mediaType && (e3.media.fmts = d2.videoCodecs.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = d2.videoCodecs, e3.attributes.extmaps = d2.videoExtensions, RC("PRELOAD_MEDIA_COUNT") > 0)) {
              const { ssrcs: t3, ssrcGroups: i3 } = Cx([{ ssrcId: zV, rtx: RC("USE_SUB_RTX") ? 40001 : void 0 }], this.cname);
              e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = i3;
            }
            if ("audio" === e3.media.mediaType && (e3.media.fmts = d2.audioCodecs.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = d2.audioCodecs, e3.attributes.extmaps = d2.audioExtensions, Lx(e3), RC("PRELOAD_MEDIA_COUNT") > 0)) {
              const { ssrcs: t3, ssrcGroups: i3 } = Cx([{ ssrcId: qV }], this.cname);
              e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = i3;
            }
          }
          this.sessionDesc = c2, this.currentMidIndex = c2.mediaDescriptions.length - 1;
        }
        updateRemoteRTPCapabilities(e2) {
          const t2 = JU.parse(KV);
          this._rtpCapabilities = e2;
          const i2 = this.rtpCapabilities.send;
          for (const e3 of t2.mediaDescriptions) {
            if (e3.attributes.iceUfrag = this._iceParameters.iceUfrag, e3.attributes.icePwd = this._iceParameters.icePwd, e3.attributes.fingerprints = this._dtlsParameters.fingerprints, e3.attributes.candidates = this._candidates, e3.attributes.setup = this.setup, "application" === e3.media.mediaType && (e3.attributes.sctpPort = "5000"), "video" === e3.media.mediaType && (e3.media.fmts = i2.videoCodecs.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = i2.videoCodecs, e3.attributes.extmaps = i2.videoExtensions, RC("PRELOAD_MEDIA_COUNT") > 0)) {
              const { ssrcs: t3, ssrcGroups: i3 } = Cx([{ ssrcId: zV, rtx: RC("USE_SUB_RTX") ? 40001 : void 0 }], this.cname);
              e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = i3;
            }
            if ("audio" === e3.media.mediaType && (e3.media.fmts = i2.audioCodecs.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = i2.audioCodecs, e3.attributes.extmaps = i2.audioExtensions, RC("PRELOAD_MEDIA_COUNT") > 0)) {
              const { ssrcs: t3, ssrcGroups: i3 } = Cx([{ ssrcId: qV }], this.cname);
              e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = i3;
            }
          }
          this.sessionDesc = t2, this.currentMidIndex = t2.mediaDescriptions.length - 1;
        }
        preloadRemoteMedia(e2) {
          this.rtpCapabilities;
          const t2 = this.candidates, i2 = this.dtlsParameters, n2 = this.iceParameters, r2 = this.rtpCapabilities.send;
          for (let s2 = 1; s2 < e2; s2++) {
            const e3 = 2 * s2 + qV, o2 = 2 * s2 + zV, { ssrcs: a2, ssrcGroups: c2 } = Cx([{ ssrcId: e3 }], this.cname), { ssrcs: d2, ssrcGroups: l2 } = Cx([{ ssrcId: o2, rtx: RC("USE_SUB_RTX") ? o2 + 1 : void 0 }], this.cname);
            this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "video", port: YV, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r2.videoCodecs.map((e4) => e4.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: n2.iceUfrag, icePwd: n2.icePwd, unrecognized: [], candidates: t2, extmaps: r2.videoExtensions, fingerprints: i2.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: d2, ssrcGroups: l2, rtcpFeedbackWildcards: [], payloads: r2.videoCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(2 * s2 - 1) } }), this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "audio", port: YV, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r2.audioCodecs.map((e4) => e4.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: n2.iceUfrag, icePwd: n2.icePwd, unrecognized: [], candidates: t2, extmaps: r2.audioExtensions, fingerprints: i2.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: a2, ssrcGroups: c2, rtcpFeedbackWildcards: [], payloads: r2.audioCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(2 * s2) } }), this.currentMidIndex += 2;
          }
          this.updateBundleMids();
        }
        toString() {
          return JU.print(this.sessionDesc);
        }
        send(e2, t2, i2, n2) {
          const { ssrcs: r2, ssrcGroups: s2 } = Cx(t2, this.cname, RC("SYNC_GROUP") ? i2 : void 0), o2 = this.findPreloadMediaDesc(r2);
          if (o2) {
            if (wg() && this.firefoxSsrcMidMap.set(r2[0].ssrcId, o2.attributes.mid), n2 && (n2.twcc || n2.remb)) {
              const e3 = this.sessionDesc.mediaDescriptions.indexOf(o2);
              return this.sessionDesc.mediaDescriptions[e3] = this.mungSendMediaDesc(o2, n2), { mid: o2.attributes.mid, needExchangeSDP: true };
            }
            return { mid: o2.attributes.mid, needExchangeSDP: false };
          }
          {
            const t3 = this.findAvailableMediaIndex(e2, r2);
            let i3;
            return -1 === t3 || bg() || Og() || Lg() || 0 === t3 && RC("USE_SUB_RTX") ? (i3 = this.createOrRecycleSendMedia(e2, r2, s2, "sendonly", n2), this.updateBundleMids()) : (i3 = YT(this.sessionDesc.mediaDescriptions[t3]), i3.attributes.direction = "sendonly", i3.attributes.ssrcs = r2, i3.attributes.ssrcGroups = s2, this.sessionDesc.mediaDescriptions[t3] = this.mungSendMediaDesc(i3, n2)), wg() && this.firefoxSsrcMidMap.set(r2[0].ssrcId, i3.attributes.mid), { mid: i3.attributes.mid, needExchangeSDP: true };
          }
        }
        batchSend(e2) {
          const t2 = e2.map((e3) => {
            let { kind: t3, ssrcMsg: i3, mslabel: n3 } = e3;
            return this.send(t3, i3, n3);
          }), i2 = [];
          let n2 = false;
          return t2.forEach((e3) => {
            let { mid: t3, needExchangeSDP: r2 } = e3;
            r2 && (n2 = true), i2.push(t3);
          }), { mids: i2, needExchangeSDP: n2 };
        }
        stopSending(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => t3.attributes.mid && -1 !== e2.indexOf(t3.attributes.mid));
          if (t2.length !== e2.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
          t2.forEach((e3) => {
            "0" === e3.attributes.mid || wg() || bg() || Og() ? e3.attributes.ssrcs = [] : (e3.attributes.ssrcs = [], e3.attributes.direction = "inactive", e3.media.port = "0");
          }), this.updateBundleMids();
        }
        mute(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2);
          if (!t2) throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.mute."));
          t2.attributes.direction = "inactive";
        }
        unmute(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2);
          if (!t2) throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.unmute."));
          t2.attributes.direction = "sendonly";
        }
        muteRemote(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => bn(e2).call(e2, t3.attributes.mid || ""));
          if (t2.length !== e2.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
          t2.forEach((e3) => {
            e3.attributes.direction = "inactive";
          });
        }
        unmuteRemote(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => bn(e2).call(e2, t3.attributes.mid || ""));
          if (t2.length !== e2.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
          t2.forEach((e3) => {
            e3.attributes.direction = "recvonly";
          });
        }
        receive(e2, t2, i2, n2) {
          e2.forEach((e3, r2) => {
            this.createOrRecycleRecvMedia(e3, [], "recvonly", t2, i2, n2[r2]);
          }), this.updateBundleMids();
        }
        stopReceiving(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => -1 !== e2.indexOf(t3.attributes.mid));
          if (t2.length !== e2.length) throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
          t2.forEach((e3) => {
            e3.media.port = "0", e3.attributes.direction = "inactive";
          }), this.updateBundleMids();
        }
        updateCandidates(e2) {
          e2 === cv.TCP ? this._candidates.forEach((e3) => {
            -1 === this._candidates.findIndex((t2) => "tcp" === t2.transport && t2.connectionAddress === e3.connectionAddress && t2.port === e3.port) && this._candidates.push(HV(HV({}, e3), {}, { foundation: "tcpcandidate", priority: Number(e3.priority) - 1 + "", transport: "tcp", port: Number(e3.port) + 90 + "" }));
          }) : this._candidates = this._candidates.filter((e3) => "tcp" !== e3.transport);
          for (const e3 of this.sessionDesc.mediaDescriptions) e3.attributes.candidates = this.candidates;
        }
        restartICE(e2) {
          e2 = YT(e2), this._iceParameters = e2, this.sessionDesc.mediaDescriptions.forEach((t2) => {
            t2.attributes.iceUfrag = e2.iceUfrag, t2.attributes.icePwd = e2.icePwd;
          });
        }
        predictReceivingMids(e2) {
          const t2 = [];
          for (let i2 = 0; i2 < e2; i2++) t2.push((this.currentMidIndex + i2 + 1).toString(10));
          return t2;
        }
        findAvailableMediaIndex(e2, t2) {
          return this.sessionDesc.mediaDescriptions.findIndex((i2) => {
            const n2 = i2.media.mediaType === e2 && "0" !== i2.media.port && ("sendonly" === i2.attributes.direction || "sendrecv" === i2.attributes.direction) && 0 === i2.attributes.ssrcs.length;
            if (wg()) {
              if (n2) {
                const e3 = this.firefoxSsrcMidMap.get(t2[0].ssrcId);
                return !(e3 || "0" !== i2.attributes.mid && "1" !== i2.attributes.mid) || !(!e3 || e3 !== i2.attributes.mid);
              }
              return false;
            }
            return n2;
          });
        }
        createOrRecycleRecvMedia(e2, t2, i2, n2, r2, s2) {
          const o2 = e2._mediaStreamTrack.kind, a2 = this.rtpCapabilities.recv, c2 = Mx(o2, a2, this.localCapabilities.send, o2 === av.VIDEO ? n2 : r2), d2 = o2 === av.VIDEO ? a2.videoExtensions : a2.audioExtensions;
          this.currentMidIndex += 1;
          const l2 = "".concat(this.currentMidIndex);
          let u2 = { media: { mediaType: o2, port: YV, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: c2.map((e3) => e3.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: d2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: c2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i2, rtcpMux: true, rtcpRsize: true, mid: "".concat(l2) } };
          u2 = this.mungRecvMediaDsec(u2, e2, s2);
          const h3 = this.findFirstClosedMedia(o2);
          if (h3) {
            const e3 = this.sessionDesc.mediaDescriptions.indexOf(h3);
            this.sessionDesc.mediaDescriptions[e3] = u2;
          } else this.sessionDesc.mediaDescriptions.push(u2);
          return u2;
        }
        updateRemoteCodec(e2, t2, i2) {
          const n2 = [...new Set(this._rtpCapabilities.recv.videoCodecs.map((e3) => e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "").filter((e3) => {
            var t3;
            return bn(t3 = Object.keys(bC)).call(t3, e3);
          }))], r2 = new Set(t2);
          if (n2.every((e3) => r2.has(e3))) return jC.debug("codecs has not changed, no need to updateRemoteCodec, codecs: ".concat(t2)), false;
          const s2 = this._rtpCapabilities.recv.videoCodecs.filter((e3) => t2.some((t3) => {
            var i3;
            return bn(i3 = e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "").call(i3, t3);
          }));
          if (0 === s2.length) return jC.debug("updateRemoteCodec failed, because cannot find matched codec, remoteCapabilities codecs: ".concat(n2, " codecs: ").concat(t2)), false;
          const o2 = [...new Set(s2.map((e3) => e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || ""))];
          let a2;
          if (jC.debug("updateRemoteCodec, from ".concat(n2, " to ").concat(o2)), 0 === e2.length) a2 = this.sessionDesc.mediaDescriptions.filter((e3) => "video" === e3.media.mediaType && "recvonly" === e3.attributes.direction);
          else if (a2 = this.sessionDesc.mediaDescriptions.filter((t3) => t3.attributes.mid && bn(e2).call(e2, t3.attributes.mid) && "recvonly" === t3.attributes.direction), a2.length !== e2.length) return jC.debug("updateRemoteCodec failed, because cannot find mids, mids: ".concat(e2, ", codecs: ").concat(t2)), false;
          this._rtpCapabilities.recv.videoCodecs = s2;
          const c2 = this.localCapabilities.send, d2 = this.rtpCapabilities.recv, l2 = Mx(av.VIDEO, d2, c2, i2);
          return a2.forEach((e3) => {
            const t3 = l2.map((e4) => e4.payloadType.toString(10));
            jC.debug("updateRemoteCodec mid: ".concat(e3.attributes.mid, ", from ").concat(e3.attributes.payloads, " to ").concat(l2)), e3.attributes.payloads = l2, e3.media.fmts = t3;
          }), true;
        }
        createOrRecycleSendMedia(e2, t2, i2, n2, r2) {
          const s2 = this.rtpCapabilities.send, o2 = e2 === av.VIDEO ? s2.videoCodecs : s2.audioCodecs, a2 = e2 === av.VIDEO ? s2.videoExtensions : s2.audioExtensions;
          this.currentMidIndex += 1;
          const c2 = "".concat(this.currentMidIndex);
          let d2 = { media: { mediaType: e2, port: YV, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: o2.map((e3) => e3.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: a2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: i2, rtcpFeedbackWildcards: [], payloads: o2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: n2, rtcpMux: true, rtcpRsize: true, mid: "".concat(c2) } };
          d2 = this.mungSendMediaDesc(d2, r2);
          const l2 = this.findFirstClosedMedia(e2);
          if (l2) {
            const e3 = this.sessionDesc.mediaDescriptions.indexOf(l2);
            this.sessionDesc.mediaDescriptions[e3] = d2;
          } else this.sessionDesc.mediaDescriptions.push(d2);
          return d2;
        }
        updateBundleMids() {
          this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter((e2) => "0" !== e2.media.port).map((e2) => e2.attributes.mid);
        }
        mungRecvMediaDsec(e2, t2, i2) {
          const n2 = YT(e2);
          return vx(n2), Ix(n2, t2), yx(n2, t2), Ax(n2), bx(n2, i2, this.localCapabilities.send), n2;
        }
        mungSendMediaDesc(e2, t2) {
          const i2 = YT(e2);
          return bx(i2, t2, this.localCapabilities.recv), Lx(i2), i2;
        }
        updateRecvMedia(e2, t2) {
          const i2 = this.sessionDesc.mediaDescriptions.findIndex((t3) => t3.attributes.mid === e2);
          if (-1 !== i2) {
            const e3 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i2], t2);
            this.sessionDesc.mediaDescriptions[i2] = e3;
          }
        }
        bumpMid(e2) {
          this.currentMidIndex += e2;
        }
        findFirstClosedMedia(e2) {
          return this.sessionDesc.mediaDescriptions.find((t2) => wg() ? "0" === t2.media.port && t2.media.mediaType === e2 : "0" === t2.media.port);
        }
        findPreloadMediaDesc(e2) {
          return this.sessionDesc.mediaDescriptions.find((t2) => {
            var i2;
            return (null === (i2 = t2.attributes) || void 0 === i2 || null === (i2 = i2.ssrcs[0]) || void 0 === i2 ? void 0 : i2.ssrcId) === e2[0].ssrcId;
          });
        }
        getSSRC(e2) {
          var t2;
          return null === (t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2)) || void 0 === t2 ? void 0 : t2.attributes.ssrcs;
        }
      }
      function XV(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function QV(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? XV(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : XV(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class ZV extends Nv {
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        get localCodecs() {
          let e2;
          return this.localCapabilities && (e2 = Px(this.localCapabilities)), [...new Set(e2 && e2.send.videoCodecs.map((e3) => e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "").filter((e3) => {
            var t2;
            return bn(t2 = Object.keys(bC)).call(t2, e3);
          }))];
        }
        constructor(e2, t2, i2) {
          super(e2, t2), sh(this, "store", void 0), sh(this, "peerConnection", void 0), sh(this, "remoteSDP", void 0), sh(this, "initialOffer", void 0), sh(this, "transportEventReceiver", void 0), sh(this, "statsFilter", void 0), sh(this, "useXR", RC("USE_XR")), sh(this, "localCapabilities", void 0), sh(this, "localCandidateCount", 0), sh(this, "allCandidatesReceived", false), sh(this, "remoteCodecs", void 0), sh(this, "dataStreamChannelMap", /* @__PURE__ */ new Map()), sh(this, "establishPromise", void 0), sh(this, "mutex", new pS("NVExtentionsConnection-mutex")), sh(this, "rtcMedia", void 0), this.store = t2, this.peerConnection = i2, this.statsFilter = Ex(this.peerConnection, RC("STATS_UPDATE_INTERVAL"), void 0, wg() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();
        }
        async establish(e2) {
          try {
            const e3 = await this.peerConnection.createOffer();
            if (!e3.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
            const t2 = Tx(e3.sdp), i2 = await Ox({ filterRTX: !RC("USE_PUB_RTX") && !RC("USE_SUB_RTX"), filterVideoFec: RC("FILTER_VIDEO_FEC"), filterAudioFec: RC("FILTER_AUDIO_FEC"), filterVideoCodec: RC("FILTER_VIDEO_CODEC") }, { useXR: this.useXR });
            return this.localCapabilities = i2, this.initialOffer = e3, QV(QV({}, t2), {}, { rtpCapabilities: i2, offerSDP: e3.sdp });
          } catch (e3) {
            throw new LI(Hg.GET_LOCAL_CONNECTION_PARAMS_FAILED, e3.toString());
          }
        }
        async connect(e2, t2, i2, n2, r2, s2) {
          try {
            if (!this.initialOffer) throw new Error("Cannot establish NVConnection without initial offer.");
            this.remoteSDP = new JV({ remoteIceParameters: e2, remoteDtlsParameters: t2, candidates: i2, remoteRTPCapabilities: n2, remoteSetup: r2, localCapabilities: Px(this.localCapabilities), cname: s2 });
            const o2 = this.remoteSDP.toString(), a2 = JU.parse(this.initialOffer.sdp), c2 = a2.mediaDescriptions.find((e3) => "audio" === e3.media.mediaType);
            c2 && Lx(c2), this.useXR && kx(a2);
            const d2 = JU.print(a2), l2 = this.logSDPExchange(d2 || "", "offer", "local", "connect");
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: d2 }), null == l2 || l2(o2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o2 });
          } catch (e3) {
            throw new LI(Hg.EXCHANGE_SDP_FAILED, "NV.connect failed; ".concat(e3.toString()));
          }
        }
        async updateRemoteRTPCapabilities(e2, t2) {
          if (this.remoteCodecs = t2, !this.remoteSDP) return void jC.debug("[P2PConnection] cannot updateRemoteRTPCapabilities before remote SDP created, local codecs: ".concat(this.localCodecs, ", codecs: ").concat(t2));
          if (this.remoteSDP.updateRemoteCodec(e2, t2, this.store.codec)) {
            const e3 = await this.peerConnection.createOffer(), t3 = this.logSDPExchange(e3.sdp || "", "offer", "local", "muteLocal");
            await this.peerConnection.setLocalDescription(e3);
            const i2 = this.remoteSDP.toString();
            null == t3 || t3(i2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: i2 });
          } else jC.debug("[P2PConnection] updateRemoteRTPCapabilities no need to exchange SDP.");
        }
        async updateRemoteConnect(e2) {
          var t2, i2, n2, r2;
          (null === (t2 = this.remoteSDP) || void 0 === t2 || t2.updateRemoteRTPCapabilities(e2), Array.isArray(this.remoteCodecs) && this.remoteCodecs.length > 0) && (null === (r2 = this.remoteSDP) || void 0 === r2 || r2.updateRemoteCodec([], this.remoteCodecs, this.store.codec));
          null === (i2 = this.remoteSDP) || void 0 === i2 || i2.preloadRemoteMedia(2);
          const s2 = null === (n2 = this.remoteSDP) || void 0 === n2 ? void 0 : n2.toString();
          await this.peerConnection.setRemoteDescription({ type: "offer", sdp: s2 });
          const o2 = await this.peerConnection.createAnswer();
          await this.peerConnection.setLocalDescription(o2), jC.debug("[NVExtentionsConnection] updateRemoteRTPCapabilities by exchanging SDP.");
        }
        send(e2, t2, i2) {
          var n2 = this;
          return PU(function* () {
            const r2 = yield IU(n2.mutex.lock("From NVExtentionsConnection.send"));
            try {
              if (!n2.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.send before remote SDP created");
              const s2 = [];
              e2.forEach((e3) => {
                const t3 = n2.peerConnection.addTransceiver(e3._mediaStreamTrack, { direction: "sendonly" });
                s2.push(t3);
              }), wg() && true === RC("SIMULCAST") && (yield IU(n2.applySimulcastForFirefox(s2, e2)));
              const o2 = yield IU(n2.peerConnection.createOffer()), a2 = n2.remoteSDP.predictReceivingMids(e2.length), c2 = n2.mungSendOfferSDP(o2.sdp, e2, a2), d2 = JU.parse(c2), l2 = a2.map((e3) => {
                const t3 = d2.mediaDescriptions.find((t4) => t4.attributes.mid === e3);
                if (!t3) throw new Error("Cannot extract ssrc from mediaDescription.");
                return Sx(t3, RC("USE_PUB_RTX"));
              });
              let u2;
              try {
                u2 = yield l2;
              } catch (r3) {
                u2 = [], n2.remoteSDP.receive(e2, t2, i2, u2);
                const s3 = n2.remoteSDP.toString();
                throw yield IU(n2.peerConnection.setLocalDescription({ type: "offer", sdp: c2 })), yield IU(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: s3 })), yield IU(n2.stopSending(a2, true)), r3;
              }
              n2.remoteSDP.receive(e2, t2, i2, u2);
              const h3 = n2.remoteSDP.toString(), p2 = n2.logSDPExchange(c2, "offer", "local", "send");
              return yield IU(n2.peerConnection.setLocalDescription({ type: "offer", sdp: c2 })), yield IU(n2.applySimulcastEncodings(s2, e2)), yield IU(n2.applySendEncodings(s2, e2)), null == p2 || p2(h3), yield IU(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: h3 })), s2.map((e3, t3) => {
                const i3 = a2[t3];
                return { localSSRC: l2[t3], id: i3, transceiver: e3 };
              });
            } catch (e3) {
              throw e3 instanceof LI ? e3 : new LI(Hg.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.send failed; ".concat(e3.toString()));
            } finally {
              r2();
            }
          })();
        }
        async stopSending(e2, t2) {
          const i2 = t2 ? void 0 : await this.mutex.lock("From NVExtentionsConnection.stopSending");
          try {
            if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.stopSending before remote SDP created");
            const t3 = this.peerConnection.getTransceivers().filter((t4) => -1 !== e2.indexOf(t4.mid));
            if (t3.length !== e2.length) throw new Error("Transceivers' length doesn't match mids' length when trying to call NVExtentionsConnection.stopSending.");
            t3.map((e3) => {
              var t4;
              e3.direction = "inactive", null === (t4 = e3.stop) || void 0 === t4 || t4.call(e3);
            });
            const n2 = await this.peerConnection.createOffer(), r2 = this.logSDPExchange(n2.sdp || "", "offer", "local", "stopSending");
            await this.peerConnection.setLocalDescription(n2), this.remoteSDP.stopReceiving(e2);
            const s2 = this.remoteSDP.toString();
            null == r2 || r2(s2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: s2 });
          } catch (e3) {
            throw new LI(Hg.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.stopSending failed; ".concat(e3.toString()));
          } finally {
            i2 && i2();
          }
        }
        async createDataChannels(e2, t2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.createDataChannels before remote SDP created");
            let i2 = this.dataStreamChannelMap.get(e2);
            return i2 && "open" === i2.readyState ? jC.debug("[P2PConnection] Channels are already available and can be reused directly.") : (i2 = this.peerConnection.createDataChannel("datastream-channel", { ordered: false, maxRetransmits: RC("DATASTREAM_MAX_RETRANSMITS") }), i2.binaryType = "arraybuffer", this.dataStreamChannelMap.set(e2, i2)), void t2.forEach((e3) => {
              e3._updateOriginDataChannel(i2);
            });
          } catch (e3) {
            throw e3 instanceof LI ? e3 : new LI(Hg.DATACHANNEL_FAILED, "NVExtentionsConnection.createDataChannels failed; ".concat(e3.toString()));
          }
        }
        async stopDataChannels(e2) {
          try {
            const t2 = this.dataStreamChannelMap.get(e2);
            return null == t2 || t2.close(), void this.dataStreamChannelMap.delete(e2);
          } catch (e3) {
            throw e3 instanceof LI ? e3 : new LI(Hg.DATACHANNEL_FAILED, "NVExtentionsConnection.stopDataChannels failed; ".concat(e3.toString()));
          }
        }
        async receive(e2, t2, i2, n2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.receive ".concat(e2, " before remoteSDP created."));
            const { mid: r2, needExchangeSDP: s2 } = this.remoteSDP.send(e2, t2, i2, n2);
            if (s2) {
              const t3 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t3, "offer", "remote", "receive");
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t3 });
              const n3 = await this.peerConnection.createAnswer(), s3 = this.mungReceiveAnswerSDP(n3.sdp, r2, e2);
              null == i3 || i3(s3 || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: s3 }), jC.debug("[NVExtentionsConnection] receive ".concat(e2, " by exchanging SDP."));
            } else jC.debug("[NVExtentionsConnection] receive ".concat(e2, " no need to exchange SDP."));
            const o2 = this.peerConnection.getTransceivers().find((e3) => e3.mid === r2);
            if (!o2) throw new Error("Cannot get transceiver after setLocalDescription.");
            return { track: o2.receiver.track, id: r2 };
          } catch (e3) {
            throw new LI(Hg.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.receive failed; ".concat(e3.toString()));
          }
        }
        async batchReceive(e2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.batchReceive before remoteSDP created.");
            const { mids: t2, needExchangeSDP: i2 } = this.remoteSDP.batchSend(e2);
            if (i2) {
              const e3 = this.remoteSDP.toString(), t3 = this.logSDPExchange(e3, "offer", "remote", "receive");
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e3 });
              const i3 = await this.peerConnection.createAnswer();
              null == t3 || t3(i3.sdp || ""), await this.peerConnection.setLocalDescription(i3), jC.debug("[NVExtentionsConnection] batchReceive by exchanging SDP.");
            } else jC.debug("[NVExtentionsConnection] batchReceive no need to exchange SDP.");
            return t2.map((e3) => {
              const t3 = this.peerConnection.getTransceivers().find((t4) => t4.mid === e3);
              if (!t3) throw new Error("Cannot get transceiver after setLocalDescription.");
              return { track: t3.receiver.track, id: e3 };
            });
          } catch (e3) {
            throw new LI(Hg.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.receive failed; ".concat(e3.toString()));
          }
        }
        async stopReceiving(e2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.stopReceiving before remote SDP created.");
            this.remoteSDP.stopSending(e2);
            const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "stopReceiving");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e3) {
            throw new LI(Hg.EXCHANGE_SDP_FAILED, "NVExtentionsConnection stopReceiving failed; ".concat(e3.toString()));
          }
        }
        async muteRemote(e2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.muteRemote mid=".concat(e2, " before remote SDP created."));
            this.remoteSDP.mute(e2);
            const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "muteRemote");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e3) {
            throw new LI(Hg.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.muteRemote failed; ".concat(e3.toString()));
          }
        }
        async unmuteRemote(e2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.unmuteRemote mid=".concat(e2, " before remote SDP created."));
            this.remoteSDP.unmute(e2);
            const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "unmuteRemote");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e3) {
            throw new LI(Hg.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.unmuteRemote failed; ".concat(e3.toString()));
          }
        }
        async muteLocal(e2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.muteLocal before remote SDP created.");
            const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e2.indexOf(t3.mid));
            if (t2.length !== e2.length) throw new Error("Transceivers' length doesn't match mids' length.");
            t2.map((e3) => {
              e3.direction = "inactive";
            });
            const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "muteLocal");
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.muteRemote(e2);
            const r2 = this.remoteSDP.toString();
            null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e3) {
            throw new LI(Hg.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.muteLocal failed; ".concat(e3.toString()));
          }
        }
        async unmuteLocal(e2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.unmuteLocal before remote SDP created.");
            const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e2.indexOf(t3.mid));
            if (t2.length !== e2.length) throw new Error("Transceivers' length doesn't match mids' length.");
            t2.map(async (e3, t3) => {
              e3.direction = "sendonly";
            });
            const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "unmuteLocal");
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.unmuteRemote(e2);
            const r2 = this.remoteSDP.toString();
            null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e3) {
            throw new LI(Hg.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.unmuteLocal failed; ".concat(e3.toString()));
          }
        }
        restartICE(e2) {
          var t2 = this;
          return PU(function* () {
            const i2 = yield IU(t2.mutex.lock("From NVExtentionsConnection.restartICE"));
            try {
              if (!t2.remoteSDP) throw new Error("Cannot restartICE before remoteSDP created.");
              if (IA().supportPCSetConfiguration) {
                const i3 = t2.peerConnection.getConfiguration(), n3 = e2 === cv.RELAY ? "relay" : "all";
                i3.iceTransportPolicy !== n3 && (jC.debug("restartICE change iceTransportPolicy from [".concat(i3.iceTransportPolicy, "] to [").concat(n3, "]")), i3.iceTransportPolicy = n3, t2.peerConnection.setConfiguration(i3));
              } else if (e2 === cv.RELAY) return;
              e2 !== cv.RELAY && t2.remoteSDP.updateCandidates(e2);
              const n2 = yield IU(t2.peerConnection.createOffer({ iceRestart: true }));
              if (!n2.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist.");
              const r2 = Tx(n2.sdp), { remoteIceParameters: s2 } = yield r2.iceParameters;
              t2.remoteSDP.restartICE(s2);
              const o2 = t2.remoteSDP.toString(), a2 = t2.logSDPExchange(n2.sdp || "", "offer", "local", "restartICE");
              yield IU(t2.peerConnection.setLocalDescription(n2)), null == a2 || a2(o2), yield IU(t2.peerConnection.setRemoteDescription({ type: "answer", sdp: o2 }));
            } catch (e3) {
              jC.warning("restart ICE failed, abort operation", e3);
            } finally {
              i2();
            }
          })();
        }
        close() {
          var e2;
          null === (e2 = this.onConnectionStateChange) || void 0 === e2 || e2.call(this, "closed"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy(), this.dataStreamChannelMap.clear();
        }
        getStats() {
          return this.statsFilter.getStats();
        }
        getRemoteVideoIsReady(e2) {
          return this.statsFilter.getVideoIsReady(e2);
        }
        async updateEncoderConfig(e2, t2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.updateEncoderConfig before remote SDP created.");
            const i2 = await this.peerConnection.createOffer(), n2 = this.mungSendOfferSDP(i2.sdp, [t2], [e2]);
            this.remoteSDP.updateRecvMedia(e2, t2);
            const r2 = this.remoteSDP.toString(), s2 = this.logSDPExchange(n2, "offer", "local", "updateEncoderConfig");
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: n2 }), null == s2 || s2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e3) {
            throw new LI(Hg.EXCHANGE_SDP_FAILED, e3.toString());
          }
        }
        async updateSendParameters(e2, t2) {
          const i2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid === e2);
          1 === i2.length && (this.isVP8Simulcast(t2) ? wg() || await this.applySimulcastEncodings(i2, [t2]) : await this.applySendEncodings(i2, [t2]));
        }
        setStatsRemoteVideoIsReady(e2, t2) {
          this.statsFilter.setVideoIsReady2(e2, t2);
        }
        async replaceTrack(e2, t2) {
          const i2 = this.peerConnection.getTransceivers().find((e3) => e3.mid === t2);
          i2 && await i2.sender.replaceTrack(e2._mediaStreamTrack);
        }
        getP2PConnectionParams() {
          var e2;
          if (null === (e2 = this.peerConnection.currentLocalDescription) || void 0 === e2 || !e2.sdp || !this.localCapabilities) throw new Error();
          return QV(QV({}, Tx(this.peerConnection.currentLocalDescription.sdp)), {}, { rtpCapabilities: this.localCapabilities });
        }
        bindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = () => {
            var e2;
            null === (e2 = this.onICEConnectionStateChange) || void 0 === e2 || e2.call(this, this.peerConnection.iceConnectionState);
          }, this.peerConnection.onconnectionstatechange = () => {
            var e2;
            null === (e2 = this.onConnectionStateChange) || void 0 === e2 || e2.call(this, this.peerConnection.connectionState);
          }, this.peerConnection.onicecandidate = (e2) => {
            e2.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, jC.debug("[pc-".concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
          }, setTimeout(() => {
            this.allCandidatesReceived || (this.allCandidatesReceived = true, jC.debug("[pc-".concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
          }, RC("CANDIDATE_TIMEOUT"));
        }
        unbindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
        }
        static resolvePCConfiguration(e2) {
          const t2 = { iceServers: [] };
          return e2.iceServers ? t2.iceServers = e2.iceServers : e2.turnServer && "off" !== e2.turnServer.mode && (RT(e2.turnServer.servers) ? t2.iceServers = e2.turnServer.servers : (t2.iceServers && t2.iceServers.push(...ZV.turnServerConfigToIceServers(e2.turnServer.servers)), RC("USE_TURN_SERVER_OF_GATEWAY") && t2.iceServers && e2.turnServer.serversFromGateway && t2.iceServers.push(...ZV.turnServerConfigToIceServers(e2.turnServer.serversFromGateway)), RC("FORCE_TURN_TCP") ? t2.iceTransportPolicy = "relay" : e2.turnServer.servers.concat(e2.turnServer.serversFromGateway || []).forEach((e3) => {
            e3.forceturn && (t2.iceTransportPolicy = "relay");
          }))), t2;
        }
        static turnServerConfigToIceServers(e2) {
          const t2 = [];
          return e2.forEach((e3) => {
            e3.security ? e3.tcpport && t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turns:".concat(gy(e3.turnServerURL), ":").concat(e3.tcpport, "?transport=tcp") }) : (e3.udpport && !RC("FORCE_TURN_TCP") && t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turn:".concat(e3.turnServerURL, ":").concat(e3.udpport, "?transport=udp") }), e3.tcpport && t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turn:".concat(e3.turnServerURL, ":").concat(e3.tcpport, "?transport=tcp") }));
          }), t2;
        }
        async applySendEncodings(e2, t2) {
          try {
            if (!IA().supportSetRtpSenderParameters) return;
            if (e2.length !== t2.length) return;
            for (let l2 = 0; l2 < e2.length; l2++) {
              const u2 = e2[l2], h3 = t2[l2];
              if (h3 && h3 instanceof Rw) {
                var i2, n2, r2;
                if (this.isVP8Simulcast(h3)) continue;
                const e3 = {}, t3 = {};
                switch (h3._optimizationMode) {
                  case "motion":
                    e3.degradationPreference = "maintain-framerate";
                    break;
                  case "detail":
                    e3.degradationPreference = "maintain-resolution";
                    break;
                  default:
                    e3.degradationPreference = "balanced";
                }
                var s2, o2, a2, c2;
                if (null !== (i2 = h3._encoderConfig) && void 0 !== i2 && i2.bitrateMax) t3.maxBitrate = 1e3 * (null === (s2 = h3._encoderConfig) || void 0 === s2 ? void 0 : s2.bitrateMax);
                if (bn(n2 = h3._hints).call(n2, jA.LOW_STREAM)) null !== (o2 = h3._encoderConfig) && void 0 !== o2 && o2.frameRate && (t3.maxFramerate = Sy(h3._encoderConfig.frameRate)), null !== (a2 = h3._encoderConfig) && void 0 !== a2 && a2.scaleResolutionDownBy && (null === (c2 = h3._encoderConfig) || void 0 === c2 ? void 0 : c2.scaleResolutionDownBy) > 1 && (t3.scaleResolutionDownBy = h3._encoderConfig.scaleResolutionDownBy);
                if (RC("DSCP_TYPE") && jg()) {
                  var d2;
                  const e4 = RC("DSCP_TYPE");
                  bn(d2 = ["very-low", "low", "medium", "high"]).call(d2, e4) && (t3.networkPriority = e4);
                }
                const l3 = u2.sender.getParameters(), p2 = null === (r2 = l3.encodings) || void 0 === r2 ? void 0 : r2[0];
                wg() && !p2 && (e3.encodings = [t3]), p2 && Object.assign(p2, t3), Object.assign(l3, e3), await u2.sender.setParameters(l3);
              }
            }
          } catch (e3) {
            jC.debug("Apply RTPSendEncodings failed.");
          }
        }
        mungSendOfferSDP(e2, t2, i2) {
          const n2 = JU.parse(e2);
          return t2.forEach((e3, t3) => {
            const r2 = i2[t3], s2 = n2.mediaDescriptions.find((e4) => e4.attributes.mid === r2);
            s2 && (Ix(s2, e3), wx(s2, e3, this.store.codec));
          }), JU.print(n2);
        }
        mungReceiveAnswerSDP(e2, t2, i2) {
          const n2 = JU.parse(e2), r2 = n2.mediaDescriptions.find((e3) => e3.attributes.mid === t2);
          return r2 && i2 === av.AUDIO && "audio" === r2.media.mediaType && Lx(r2), this.useXR && kx(n2), JU.print(n2);
        }
        bindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = (e2) => {
            var t2;
            null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e2);
          }, this.statsFilter.onFirstVideoReceived = (e2) => {
            var t2;
            null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e2);
          }, this.statsFilter.onFirstAudioDecoded = (e2) => {
            var t2;
            null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e2);
          }, this.statsFilter.onFirstVideoDecoded = (e2, t2, i2) => {
            var n2;
            null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e2, t2, i2);
          }, this.statsFilter.onSelectedLocalCandidateChanged = (e2, t2) => {
            var i2;
            null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 || i2.call(this, e2, t2);
          }, this.statsFilter.onSelectedRemoteCandidateChanged = (e2, t2) => {
            var i2;
            null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 || i2.call(this, e2, t2);
          }, this.statsFilter.onFirstVideoDecodedTimeout = (e2) => {
            var t2;
            null === (t2 = this.onFirstVideoDecodedTimeout) || void 0 === t2 || t2.call(this, e2);
          };
        }
        unbindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
        }
        async applySimulcastForFirefox(e2, t2) {
          if (e2.length === t2.length) for (let a2 = 0; a2 < e2.length; a2++) {
            var i2, n2, r2, s2, o2;
            const c2 = e2[a2], d2 = t2[a2];
            if (d2 instanceof Rw && !bn(i2 = d2._hints).call(i2, jA.LOW_STREAM) && null !== (n2 = d2._encoderConfig) && void 0 !== n2 && n2.bitrateMax && (null === (r2 = d2._encoderConfig) || void 0 === r2 ? void 0 : r2.bitrateMax) > 200 && null !== (s2 = d2._scalabilityMode) && void 0 !== s2 && s2.numSpatialLayers && (null === (o2 = d2._scalabilityMode) || void 0 === o2 ? void 0 : o2.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
              const e3 = {}, t3 = { high: 1e3 * (d2._encoderConfig.bitrateMax - 50), medium: 5e4 };
              e3.encodings = [{ rid: "m", active: true, maxBitrate: t3.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: t3.high }];
              const i3 = c2.sender.getParameters();
              await c2.sender.setParameters(Object.assign(i3, e3));
            }
          }
        }
        async applySimulcastEncodings(e2, t2) {
          if (!wg() && e2.length === t2.length) for (let i2 = 0; i2 < e2.length; i2++) {
            const n2 = t2[i2];
            if (n2 instanceof Rw && this.isVP8Simulcast(n2)) {
              const t3 = e2[i2], r2 = {}, s2 = { high: 1e3 * (n2._encoderConfig.bitrateMax - 50), medium: 5e4 };
              r2.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: s2.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: s2.medium, scaleResolutionDownBy: 4 }];
              const o2 = t3.sender.getParameters();
              await t3.sender.setParameters(Object.assign(o2, r2));
            }
          }
        }
        isVP8Simulcast(e2) {
          var t2, i2, n2, r2, s2;
          return !!(e2 instanceof Rw && RC("SIMULCAST") && "vp8" === this.store.codec && !bn(t2 = e2._hints).call(t2, jA.LOW_STREAM) && null !== (i2 = e2._encoderConfig) && void 0 !== i2 && i2.bitrateMax && (null === (n2 = e2._encoderConfig) || void 0 === n2 ? void 0 : n2.bitrateMax) > 200 && null !== (r2 = e2._scalabilityMode) && void 0 !== r2 && r2.numSpatialLayers && (null === (s2 = e2._scalabilityMode) || void 0 === s2 ? void 0 : s2.numSpatialLayers) > 1);
        }
        logSDPExchange(e2, t2, i2, n2) {
          if (RC("SDP_LOGGING")) return jC.upload("exchanging ".concat(i2, " ").concat(t2, " SDP during NVExtentionsConnection.").concat(n2, "\n"), e2), "offer" === t2 ? (e3) => {
            this.logSDPExchange(e3, "answer", "local" === i2 ? "remote" : "local", n2);
          } : void 0;
        }
        async getRemoteSSRC(e2) {
          if (!this.remoteSDP) return;
          const t2 = this.remoteSDP.getSSRC(e2);
          return null == t2 ? void 0 : t2[0].ssrcId;
        }
        setConfiguration(e2) {
          if (IA().supportPCSetConfiguration) {
            const t2 = ZV.resolvePCConfiguration(e2);
            this.peerConnection.setConfiguration(t2);
          }
        }
      }
      function $V(e2, t2, i2) {
        const n2 = e2[t2];
        if ("function" != typeof n2) throw new Error("Cannot use mutex on object property.");
        return i2.value = async function() {
          const e3 = this.mutex, i3 = await e3.lock("From NVExtentionsConnection.".concat(t2));
          try {
            for (var r2 = arguments.length, s2 = new Array(r2), o2 = 0; o2 < r2; o2++) s2[o2] = arguments[o2];
            return await n2.apply(this, s2);
          } finally {
            i3();
          }
        }, i2;
      }
      function eF(e2) {
        var t2, i2, n2, r2 = 2;
        for ("undefined" != typeof Symbol && (i2 = wV, n2 = Symbol.iterator); r2--; ) {
          if (i2 && null != (t2 = e2[i2])) return t2.call(e2);
          if (n2 && null != (t2 = e2[n2])) return new tF(t2.call(e2));
          i2 = "@@asyncIterator", n2 = "@@iterator";
        }
        throw new TypeError("Object is not async iterable");
      }
      function tF(e2) {
        function t2(e3) {
          if (Object(e3) !== e3) return cg.reject(new TypeError(e3 + " is not an object."));
          var t3 = e3.done;
          return cg.resolve(e3.value).then(function(e4) {
            return { value: e4, done: t3 };
          });
        }
        return tF = function(e3) {
          this.s = e3, this.n = e3.next;
        }, tF.prototype = { s: null, n: null, next: function() {
          return t2(this.n.apply(this.s, arguments));
        }, return: function(e3) {
          var i2 = this.s.return;
          return void 0 === i2 ? cg.resolve({ value: e3, done: true }) : t2(i2.apply(this.s, arguments));
        }, throw: function(e3) {
          var i2 = this.s.return;
          return void 0 === i2 ? cg.reject(e3) : t2(i2.apply(this.s, arguments));
        } }, new tF(e2);
      }
      DI([$V, PI("design:type", Function), PI("design:paramtypes", [Object, Object, Array, Object, String, String]), PI("design:returntype", cg)], ZV.prototype, "connect", null), DI([$V, PI("design:type", Function), PI("design:paramtypes", [Array, Array]), PI("design:returntype", cg)], ZV.prototype, "updateRemoteRTPCapabilities", null), DI([$V, PI("design:type", Function), PI("design:paramtypes", [Object]), PI("design:returntype", cg)], ZV.prototype, "updateRemoteConnect", null), DI([$V, PI("design:type", Function), PI("design:paramtypes", [Object, Array]), PI("design:returntype", cg)], ZV.prototype, "createDataChannels", null), DI([$V, PI("design:type", Function), PI("design:paramtypes", [String, Array, String, Object]), PI("design:returntype", cg)], ZV.prototype, "receive", null), DI([$V, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], ZV.prototype, "batchReceive", null), DI([$V, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], ZV.prototype, "stopReceiving", null), DI([$V, PI("design:type", Function), PI("design:paramtypes", [String]), PI("design:returntype", cg)], ZV.prototype, "muteRemote", null), DI([$V, PI("design:type", Function), PI("design:paramtypes", [String]), PI("design:returntype", cg)], ZV.prototype, "unmuteRemote", null), DI([$V, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], ZV.prototype, "muteLocal", null), DI([$V, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], ZV.prototype, "unmuteLocal", null), DI([$V, PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], ZV.prototype, "close", null), DI([$V, PI("design:type", Function), PI("design:paramtypes", [String, lb]), PI("design:returntype", cg)], ZV.prototype, "updateEncoderConfig", null), DI([$V, PI("design:type", Function), PI("design:paramtypes", [String, lb]), PI("design:returntype", cg)], ZV.prototype, "updateSendParameters", null), DI([$V, PI("design:type", Function), PI("design:paramtypes", [lb, String]), PI("design:returntype", cg)], ZV.prototype, "replaceTrack", null), DI([$V, PI("design:type", Function), PI("design:paramtypes", [String]), PI("design:returntype", cg)], ZV.prototype, "getRemoteSSRC", null);
      class iF extends Nv {
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        get localCodecs() {
          return this._p2pConnection.localCodecs;
        }
        constructor(e2, t2) {
          super(e2, t2), sh(this, "store", void 0), sh(this, "peerConnection", void 0), sh(this, "cname", void 0), sh(this, "mutex", new pS("DataChannelConnection-mutex")), sh(this, "dataChannel", void 0), sh(this, "_p2pConnection", void 0), sh(this, "establishPromise", void 0), sh(this, "_nvMedia", void 0), this.store = t2, this.store.dcId = this.store.dcId + 1, this.peerConnection = new RTCPeerConnection(iF.resolvePCConfiguration(e2), { optional: [{ googDscp: true }] }), this.dataChannel = this.peerConnection.createDataChannel("agora-signal", { ordered: false, maxPacketLifeTime: 50 }), this.dataChannel.binaryType = "arraybuffer", this._p2pConnection = new ZV(e2, t2, this.peerConnection), this.bindPCEvents(), this.establishPromise = this._p2pConnection.establishPromise;
        }
        async establish() {
          var e2;
          const t2 = null === (e2 = this._nvMedia) || void 0 === e2 ? void 0 : e2.getLocalRtpCapabilities();
          return await this._p2pConnection.establish(t2);
        }
        getP2PConnectionParams() {
          return this._p2pConnection.getP2PConnectionParams();
        }
        async connect(e2, t2, i2, n2, r2, s2) {
          return this.cname = s2, await this._p2pConnection.connect(e2, t2, i2, n2, r2, s2), await new cg((e3, t3) => {
            const n3 = setTimeout(() => {
              this.closeSignal(), t3(new LI(Hg.DATACHANNEL_CONNECTION_TIMEOUT, "Datachannel connection timed out, candidates: ".concat(JSON.stringify(i2))));
            }, 2e3);
            this.dataChannel.onopen = () => {
              if ("open" === this.dataChannel.readyState) return clearTimeout(n3), void e3();
            }, this.dataChannel.onerror = (e4) => {
              this.closeSignal(), t3(e4);
            };
          }), { transmitter: this.dataChannel, close: this.closeSignal.bind(this) };
        }
        async updateRemoteRTPCapabilities(e2, t2) {
          return this._p2pConnection.updateRemoteRTPCapabilities(e2, t2);
        }
        send(e2, t2, i2) {
          var n2 = this;
          return PU(function* () {
            const r2 = yield IU(n2.mutex.lock("From DataChannelConnection.send"));
            try {
              return yield* bV(eF(n2._p2pConnection.send(e2, t2, i2)));
            } finally {
              r2();
            }
          })();
        }
        async stopSending(e2, t2) {
          return this._p2pConnection.stopSending(e2, t2);
        }
        async createDataChannels(e2, t2) {
          return this._p2pConnection.createDataChannels(e2, t2);
        }
        async stopDataChannels(e2) {
          return this._p2pConnection.stopDataChannels(e2);
        }
        async receive(e2, t2, i2, n2) {
          return this._nvMedia ? (jC.debug("[DataChannelConnection] receive ".concat(e2, " by DataChannel.")), await this._nvMedia.reveiveByRTCMedia(e2, t2, this.cname)) : (jC.debug("[DataChannelConnection] receive ".concat(e2, " by WebRTC.")), await this._p2pConnection.receive(e2, t2, i2, n2));
        }
        async batchReceive(e2) {
          return [...await this._p2pConnection.batchReceive(e2)];
        }
        async stopReceiving(e2) {
          return await this._p2pConnection.stopReceiving(e2);
        }
        async muteRemote(e2) {
          return await this._p2pConnection.muteRemote(e2);
        }
        async unmuteRemote(e2) {
          return await this._p2pConnection.unmuteRemote(e2);
        }
        async muteLocal(e2) {
          return await this._p2pConnection.muteLocal(e2);
        }
        async unmuteLocal(e2) {
          return await this._p2pConnection.unmuteLocal(e2);
        }
        restartICE(e2) {
          var t2 = this;
          return PU(function* () {
            return yield* bV(eF(t2._p2pConnection.restartICE(e2)));
          })();
        }
        close() {
          var e2;
          null === (e2 = this._nvMedia) || void 0 === e2 || e2.close(), this._p2pConnection.close(), this.unbindConnectionEvents(this._p2pConnection);
        }
        getStats() {
          return this._p2pConnection.getStats();
        }
        getRemoteVideoIsReady(e2) {
          return this._p2pConnection.getRemoteVideoIsReady(e2);
        }
        updateRemoteConnect(e2) {
          var t2;
          null === (t2 = this._nvMedia) || void 0 === t2 || t2.setRemoteRtpCapabilities(e2), this._p2pConnection.updateRemoteConnect(e2);
        }
        async updateEncoderConfig(e2, t2) {
          return await this._p2pConnection.updateEncoderConfig(e2, t2);
        }
        async updateSendParameters(e2, t2) {
          return await this._p2pConnection.updateSendParameters(e2, t2);
        }
        setStatsRemoteVideoIsReady(e2, t2) {
          this._p2pConnection.setStatsRemoteVideoIsReady(e2, t2);
        }
        async replaceTrack(e2, t2) {
          return await this._p2pConnection.replaceTrack(e2, t2);
        }
        async getRemoteSSRC(e2) {
          return this._p2pConnection.getRemoteSSRC(e2);
        }
        logSDPExchange(e2, t2, i2, n2) {
          if (RC("SDP_LOGGING")) return jC.upload("exchanging ".concat(i2, " ").concat(t2, " SDP during DataChannelConnection.").concat(n2, "\n"), e2), "offer" === t2 ? (e3) => {
            this.logSDPExchange(e3, "answer", "local" === i2 ? "remote" : "local", n2);
          } : void 0;
        }
        static resolvePCConfiguration(e2) {
          const t2 = { iceServers: [] };
          return e2.iceServers ? t2.iceServers = e2.iceServers : e2.turnServer && "off" !== e2.turnServer.mode && (RT(e2.turnServer.servers) ? t2.iceServers = e2.turnServer.servers : (t2.iceServers && t2.iceServers.push(...iF.turnServerConfigToIceServers(e2.turnServer.servers)), RC("USE_TURN_SERVER_OF_GATEWAY") && t2.iceServers && e2.turnServer.serversFromGateway && t2.iceServers.push(...iF.turnServerConfigToIceServers(e2.turnServer.serversFromGateway)), RC("FORCE_TURN_TCP") ? t2.iceTransportPolicy = "relay" : e2.turnServer.servers.concat(e2.turnServer.serversFromGateway || []).forEach((e3) => {
            e3.forceturn && (t2.iceTransportPolicy = "relay");
          }))), t2;
        }
        static turnServerConfigToIceServers(e2) {
          const t2 = [];
          return e2.forEach((e3) => {
            e3.security ? e3.tcpport && t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turns:".concat(gy(e3.turnServerURL), ":").concat(e3.tcpport, "?transport=tcp") }) : (e3.udpport && !RC("FORCE_TURN_TCP") && t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turn:".concat(e3.turnServerURL, ":").concat(e3.udpport, "?transport=udp") }), e3.tcpport && t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turn:".concat(e3.turnServerURL, ":").concat(e3.tcpport, "?transport=tcp") }));
          }), t2;
        }
        bindPCEvents() {
          this._p2pConnection.onICEConnectionStateChange = (e2) => {
            var t2;
            return null === (t2 = this.onICEConnectionStateChange) || void 0 === t2 ? void 0 : t2.call(this, e2);
          }, this._p2pConnection.onConnectionStateChange = (e2) => {
            var t2;
            return null === (t2 = this.onConnectionStateChange) || void 0 === t2 ? void 0 : t2.call(this, e2);
          }, this._p2pConnection.onDTLSTransportStateChange = (e2) => {
            var t2;
            return null === (t2 = this.onDTLSTransportStateChange) || void 0 === t2 ? void 0 : t2.call(this, e2);
          }, this._p2pConnection.onDTLSTransportError = (e2) => {
            var t2;
            return null === (t2 = this.onDTLSTransportError) || void 0 === t2 ? void 0 : t2.call(this, e2);
          }, this._p2pConnection.onICETransportStateChange = (e2) => {
            var t2;
            return null === (t2 = this.onICETransportStateChange) || void 0 === t2 ? void 0 : t2.call(this, e2);
          }, this._p2pConnection.onFirstAudioReceived = (e2) => {
            var t2;
            return null === (t2 = this.onFirstAudioReceived) || void 0 === t2 ? void 0 : t2.call(this, e2);
          }, this._p2pConnection.onFirstVideoReceived = (e2) => {
            var t2;
            return null === (t2 = this.onFirstVideoReceived) || void 0 === t2 ? void 0 : t2.call(this, e2);
          }, this._p2pConnection.onFirstAudioDecoded = (e2) => {
            var t2;
            return null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 ? void 0 : t2.call(this, e2);
          }, this._p2pConnection.onFirstVideoDecoded = (e2, t2, i2) => {
            var n2;
            return null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 ? void 0 : n2.call(this, e2, t2, i2);
          }, this._p2pConnection.onFirstVideoDecodedTimeout = (e2) => {
            var t2;
            return null === (t2 = this.onFirstVideoDecodedTimeout) || void 0 === t2 ? void 0 : t2.call(this, e2);
          }, this._p2pConnection.onSelectedLocalCandidateChanged = (e2, t2) => {
            var i2;
            return null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 ? void 0 : i2.call(this, e2, t2);
          }, this._p2pConnection.onSelectedRemoteCandidateChanged = (e2, t2) => {
            var i2;
            return null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 ? void 0 : i2.call(this, e2, t2);
          };
        }
        closeSignal() {
          this.dataChannel.close(), this.peerConnection.close();
        }
        unbindConnectionEvents(e2) {
          e2.onConnectionStateChange = void 0, e2.onICEConnectionStateChange = void 0, e2.onICETransportStateChange = void 0, e2.onDTLSTransportStateChange = void 0, e2.onDTLSTransportError = void 0, e2.onFirstAudioDecoded = void 0, e2.onFirstAudioReceived = void 0, e2.onFirstVideoDecoded = void 0, e2.onFirstVideoReceived = void 0, e2.onSelectedLocalCandidateChanged = void 0, e2.onSelectedRemoteCandidateChanged = void 0, e2.onFirstVideoDecodedTimeout = void 0;
        }
        setConfiguration(e2) {
          this._p2pConnection.setConfiguration(e2);
        }
      }
      function nF(e2, t2, i2) {
        const n2 = e2[t2];
        if ("function" != typeof n2) throw new Error("Cannot use mutex on object property.");
        return i2.value = async function() {
          const e3 = this.mutex, i3 = await e3.lock("From DataChannelConnection.".concat(t2));
          try {
            for (var r2 = arguments.length, s2 = new Array(r2), o2 = 0; o2 < r2; o2++) s2[o2] = arguments[o2];
            return await n2.apply(this, s2);
          } finally {
            i3();
          }
        }, i2;
      }
      function rF(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function sF(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? rF(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : rF(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      function oF(e2) {
        var t2, i2, n2, r2 = 2;
        for ("undefined" != typeof Symbol && (i2 = wV, n2 = Symbol.iterator); r2--; ) {
          if (i2 && null != (t2 = e2[i2])) return t2.call(e2);
          if (n2 && null != (t2 = e2[n2])) return new aF(t2.call(e2));
          i2 = "@@asyncIterator", n2 = "@@iterator";
        }
        throw new TypeError("Object is not async iterable");
      }
      function aF(e2) {
        function t2(e3) {
          if (Object(e3) !== e3) return cg.reject(new TypeError(e3 + " is not an object."));
          var t3 = e3.done;
          return cg.resolve(e3.value).then(function(e4) {
            return { value: e4, done: t3 };
          });
        }
        return aF = function(e3) {
          this.s = e3, this.n = e3.next;
        }, aF.prototype = { s: null, n: null, next: function() {
          return t2(this.n.apply(this.s, arguments));
        }, return: function(e3) {
          var i2 = this.s.return;
          return void 0 === i2 ? cg.resolve({ value: e3, done: true }) : t2(i2.apply(this.s, arguments));
        }, throw: function(e3) {
          var i2 = this.s.return;
          return void 0 === i2 ? cg.reject(e3) : t2(i2.apply(this.s, arguments));
        } }, new aF(e2);
      }
      DI([nF, PI("design:type", Function), PI("design:paramtypes", [Object, Object, Array, Object, String, String]), PI("design:returntype", cg)], iF.prototype, "connect", null), DI([nF, PI("design:type", Function), PI("design:paramtypes", [Array, Array]), PI("design:returntype", cg)], iF.prototype, "updateRemoteRTPCapabilities", null), DI([nF, PI("design:type", Function), PI("design:paramtypes", [Object, Array]), PI("design:returntype", cg)], iF.prototype, "createDataChannels", null), DI([nF, PI("design:type", Function), PI("design:paramtypes", [String, Array, String, Object]), PI("design:returntype", cg)], iF.prototype, "receive", null), DI([nF, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], iF.prototype, "stopReceiving", null), DI([nF, PI("design:type", Function), PI("design:paramtypes", [String]), PI("design:returntype", cg)], iF.prototype, "muteRemote", null), DI([nF, PI("design:type", Function), PI("design:paramtypes", [String]), PI("design:returntype", cg)], iF.prototype, "unmuteRemote", null), DI([nF, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], iF.prototype, "muteLocal", null), DI([nF, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], iF.prototype, "unmuteLocal", null), DI([nF, PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], iF.prototype, "close", null), DI([nF, PI("design:type", Function), PI("design:paramtypes", [String, lb]), PI("design:returntype", cg)], iF.prototype, "updateEncoderConfig", null), DI([nF, PI("design:type", Function), PI("design:paramtypes", [String, lb]), PI("design:returntype", cg)], iF.prototype, "updateSendParameters", null), DI([nF, PI("design:type", Function), PI("design:paramtypes", [lb, String]), PI("design:returntype", cg)], iF.prototype, "replaceTrack", null), DI([nF, PI("design:type", Function), PI("design:paramtypes", [String]), PI("design:returntype", cg)], iF.prototype, "getRemoteSSRC", null);
      class cF extends dT {
        get state() {
          return this._state;
        }
        set state(e2) {
          const t2 = this._state;
          this._state = e2, this.emit(hv.StateChange, t2, this._state);
        }
        constructor(e2, t2) {
          super(), sh(this, "store", void 0), sh(this, "statsUploader", void 0), sh(this, "connection", void 0), sh(this, "localTrackMap", /* @__PURE__ */ new Map()), sh(this, "remoteUserMap", /* @__PURE__ */ new Map()), sh(this, "localDataChannels", []), sh(this, "remoteDataChannelMap", /* @__PURE__ */ new Map()), sh(this, "pendingLocalTracks", []), sh(this, "pendingRemoteTracks", []), sh(this, "pendingLocalDataChannels", []), sh(this, "pendingRemoteDataChannels", []), sh(this, "statsCollector", void 0), sh(this, "isPlanB", false), sh(this, "shouldForwardP2PCreation", void 0), sh(this, "iceFailedCount", 0), sh(this, "dtlsFailedCount", 0), sh(this, "mutex", new pS("P2PChannel-mutex")), sh(this, "_state", uv.Disconnected), sh(this, "_pcStatsUploadType", RC("NEW_ICE_RESTART") ? dv.FIRST_CONNECTION : dv.OLD_FIRST_CONNECTION), sh(this, "_isInRestartIce", false), sh(this, "_isStartRestartIce", false), sh(this, "_restartStates", ["disconnected", "failed"]), sh(this, "_restartTimer", void 0), sh(this, "_isFirstConnected", true), sh(this, "handleMuteLocalTrack", async (e3, t3, i2) => {
            const n2 = await this.mutex.lock("Locking from P2PChannel.handleMuteLocalTrack");
            try {
              if (!this.connection || this.state !== uv.Connected) return void i2(new Kg(Hg.INVALID_OPERATION, "Cannot call P2PChannel.handleMuteLocalTrack before connection established."));
              const r2 = this.filterTobeMutedTracks(e3);
              if (0 === r2.length) return void t3();
              const s2 = r2.find((e4) => "videoLowTrack" === e4[0]);
              if (s2) {
                s2[1].track._originMediaStreamTrack.stop();
              }
              await this.connection.muteLocal(r2.map((e4) => {
                let [, { id: t4 }] = e4;
                return t4;
              }));
              const o2 = this.createMuteMessage(r2);
              await yT(this, hv.RequestMuteLocal, o2), t3();
            } catch (e4) {
              i2(e4);
            } finally {
              n2();
            }
          }), sh(this, "handleUnmuteLocalTrack", async (e3, t3, i2) => {
            const n2 = await this.mutex.lock("Locking from P2PChannel.handleUnmuteLocalTrack");
            try {
              if (!this.connection || this.state !== uv.Connected) return void i2(new Kg(Hg.INVALID_OPERATION, "Cannot call P2PChannel.handleUnmuteLocalTrack before connection established."));
              const r2 = this.filterTobeUnmutedTracks(e3);
              if (0 === r2.length) return void t3();
              const s2 = r2.find((e4) => "videoLowTrack" === e4[0]);
              if (s2) {
                const t4 = s2[1];
                if (t4.track._originMediaStreamTrack.stop(), !RC("DISABLE_DUAL_STREAM_USE_ENCODING") && IA().supportDualStreamEncoding) {
                  const i3 = e3._mediaStreamTrack.clone();
                  t4.track._mediaStreamTrack = i3, t4.track._originMediaStreamTrack = i3;
                } else {
                  const i3 = Gx(e3, bT(this, hv.RequestLowStreamParameter));
                  t4.track._mediaStreamTrack = i3, t4.track._originMediaStreamTrack = i3;
                }
                await new cg((e4, i3) => {
                  this.handleReplaceTrack(t4.track, e4, i3, true);
                });
              }
              await this.connection.unmuteLocal(r2.map((e4) => {
                let [, { id: t4 }] = e4;
                return t4;
              }));
              const o2 = this.createUnmuteMessage(r2);
              await yT(this, hv.RequestUnmuteLocal, o2), t3();
            } catch (e4) {
              i2(e4);
            } finally {
              n2();
            }
          }), sh(this, "handleUpdateVideoEncoder", async (e3, t3, i2) => {
            const n2 = await this.mutex.lock("Locking from P2PChannel.handleSetVideoEncoder");
            try {
              const i3 = this.localTrackMap.get(lv.LocalVideoTrack);
              if (!this.connection || !i3 || i3.track !== e3 || this.state !== uv.Connected) return void t3();
              const { id: r2, track: s2 } = i3;
              await this.connection.updateSendParameters(r2, s2), await this.connection.updateEncoderConfig(r2, s2), this.emit(hv.UpdateVideoEncoder, s2), t3();
            } catch (e4) {
              i2(e4);
            } finally {
              n2();
            }
          }), sh(this, "handleSetOptimizationMode", async (e3, t3, i2) => {
            const n2 = await this.mutex.lock("Locking from P2PChannel.handleSetOptimizationMode");
            try {
              const i3 = this.localTrackMap.get(lv.LocalVideoTrack);
              if (!this.connection || !i3 || i3.track !== e3 || this.state !== uv.Connected) return;
              const { id: r2, track: s2 } = i3;
              await this.connection.updateSendParameters(r2, s2), t3();
            } catch (e4) {
              i2(e4);
            } finally {
              n2();
            }
          }), sh(this, "handleReplaceMixingTrack", async (e3, t3, i2, n2) => {
            if (!this.connection || this.state !== uv.Connected) return void t3();
            const r2 = dV([e3]);
            let s2;
            jC.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection will replace audioTrack [").concat(r2.getTrackId(), "]")), "boolean" == typeof n2 && n2 || (s2 = await this.mutex.lock("From P2PChannel.handleReplaceMixingTrack"));
            try {
              await this.replaceTrack(e3, r2), t3();
            } catch (e4) {
              i2(e4);
            } finally {
              var o2;
              null === (o2 = s2) || void 0 === o2 || o2();
            }
          }), sh(this, "handleReplaceTrack", async (e3, t3, i2, n2) => {
            let r2;
            jC.debug("[".concat(this.store.clientId, "] P2PChannel handleReplaceTrack for [track-id-").concat(e3.getTrackId(), "]")), "boolean" == typeof n2 && n2 || (r2 = await this.mutex.lock("From P2PChannel.handleReplaceTrack"));
            try {
              var s2;
              const i3 = Array.from(this.localTrackMap.entries()).find((t4) => {
                let [, { track: i4 }] = t4;
                return e3 === i4;
              });
              if (!this.connection || !i3 || this.state !== uv.Connected) return void t3();
              if (await (null === (s2 = this.connection) || void 0 === s2 ? void 0 : s2.replaceTrack(e3, i3[1].id)), this.isPlanB) {
                const t4 = i3[1];
                t4.id = e3._mediaStreamTrack.id, this.localTrackMap.set(i3[0], t4);
              }
              if (i3[0] === lv.LocalVideoTrack && !RC("DISABLE_DUAL_STREAM_USE_ENCODING") && IA().supportDualStreamEncoding) {
                const t4 = this.localTrackMap.get(lv.LocalVideoLowTrack);
                if (t4) {
                  const i4 = e3._mediaStreamTrack.clone();
                  t4.track._originMediaStreamTrack.stop(), t4.track._mediaStreamTrack = i4, t4.track._originMediaStreamTrack = i4, await new cg((e4, i5) => {
                    this.handleReplaceTrack(t4.track, e4, i5, true);
                  });
                }
              }
              t3();
            } catch (e4) {
              i2(e4);
            } finally {
              var o2;
              null === (o2 = r2) || void 0 === o2 || o2();
            }
          }), sh(this, "handleGetRTCStats", (e3) => {
            e3(this.statsCollector.getRTCStats());
          }), sh(this, "handleGetLocalVideoStats", (e3) => {
            e3(this.statsCollector.getLocalVideoTrackStats());
          }), sh(this, "handleGetLocalAudioStats", (e3) => {
            e3(this.statsCollector.getLocalAudioTrackStats());
          }), sh(this, "handleGetRemoteVideoStats", (e3) => this.statsCollector.getRemoteVideoTrackStats(e3.uid)[e3.uid]), sh(this, "handleGetRemoteAudioStats", (e3) => this.statsCollector.getRemoteAudioTrackStats(e3.uid)[e3.uid]), this.store = e2, this.statsCollector = t2, this.statsCollector.addP2PChannel(this), this.statsUploader = new rV(this.store), this.bindStatsUploaderEvents(), this.isPlanB = !IA().supportUnifiedPlan || RC("CHROME_FORCE_PLAN_B") && jg(), this.shouldForwardP2PCreation = RC("FORWARD_P2P_CREATION") && IA().supportPCSetConfiguration && function() {
            const e3 = Rg();
            return e3 === _g.ANDROID || e3 === _g.IOS || e3 === _g.HARMONY_OS;
          }(), this.shouldForwardP2PCreation && (this.connection = this.store.useDataChannel ? new iF({}, this.store) : this.isPlanB ? new LV({}, this.store) : new jV({}, this.store), this.bindConnectionEvents(this.connection));
        }
        async startP2PConnection(e2, t2) {
          var i2;
          this.state = uv.New;
          const n2 = this.shouldForwardP2PCreation && "closed" === (null === (i2 = this.connection) || void 0 === i2 ? void 0 : i2.peerConnectionState);
          if (this.shouldForwardP2PCreation && !n2 || (n2 && this.connection && (jC.warning("[".concat(this.store.clientId, "] P2PChannel.startP2PConnection ForwardP2P closed.")), this.connection.close(), this.unbindConnectionEvents(this.connection)), this.connection = this.store.useDataChannel ? new iF(e2, this.store) : this.isPlanB ? new LV(e2, this.store) : new jV(e2, this.store), this.bindConnectionEvents(this.connection)), !this.connection) throw new Kg(Hg.UNEXPECTED_ERROR, "Cannot P2PChannel.startConnection before P2PConnection initialization .");
          return this._pcStatsUploadType = RC("NEW_ICE_RESTART") ? dv.FIRST_CONNECTION : dv.OLD_FIRST_CONNECTION, this._isFirstConnected = true, this._isInRestartIce = false, this._isStartRestartIce = false, this.connection.setConfiguration(e2), this.connection.establishPromise;
        }
        async connect(e2, t2, i2, n2, r2, s2) {
          if (!this.connection) throw new Kg(Hg.UNEXPECTED_ERROR, "Cannot P2PChannel.connect before P2PChannel.startP2PConnection .");
          this.connection instanceof iF ? this.connection.updateRemoteConnect(n2) : (this.store.peerConnectionStart(), await this.connection.connect(e2, t2, i2, n2, r2, s2), this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = uv.Connected);
        }
        updateRemoteRTPCapabilities(e2) {
          const t2 = Array.from(this.localTrackMap.entries()).filter((e3) => {
            var t3;
            let [i3] = e3;
            return bn(t3 = [lv.LocalVideoLowTrack, lv.LocalVideoTrack]).call(t3, i3);
          }), i2 = t2.map((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          }), n2 = t2.map((e3) => {
            let [t3] = e3;
            return t3;
          });
          if (this.connection instanceof jV) {
            if (eI.updateRemoteRTPCapabilities(this.store.sessionId, { trackTypes: JSON.stringify(n2), localCodecs: JSON.stringify(this.connection.localCodecs), remoteCodecs: JSON.stringify(e2) }), !bn(e2).call(e2, this.store.codec)) {
              const t3 = ["vp8", "h264"].find((t4) => bn(e2).call(e2, t4));
              t3 && (this.store.codec = t3, jC.debug("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, " updateRemoteRTPCapabilities] default codec is not available, hence the fallback to ").concat(t3, ".")));
            }
            this.connection.updateRemoteRTPCapabilities(i2, e2);
          }
        }
        async preConnect(e2, t2, i2, n2, r2, s2) {
          if (!this.connection) throw new Kg(Hg.UNEXPECTED_ERROR, "Cannot P2PChannel.connect before P2PChannel.startP2PConnection .");
          this.store.peerConnectionStart();
          const o2 = await this.connection.connect(e2, t2, i2, n2, r2, s2);
          return this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = uv.Connected, o2;
        }
        getEstablishParams() {
          if (this.connection instanceof iF) return this.connection.getP2PConnectionParams();
          throw new Error("Only DataChannelConnection needs to obtain establishParams");
        }
        async publishDataChannel(e2) {
          if (!this.connection || this.state !== uv.Connected) {
            if (this.state === uv.Disconnected) throw new Kg(Hg.UNEXPECTED_ERROR, "PeerConnection already disconnected.");
            return void e2.forEach((e3) => {
              var t3;
              bn(t3 = this.pendingLocalDataChannels).call(t3, e3) || this.pendingLocalDataChannels.push(e3);
            });
          }
          const t2 = this.filterTobePublishedDataChannels(e2);
          0 !== t2.length && (t2.forEach((e3) => {
            const t3 = Date.now();
            this.store.publish(e3.id.toString(), "datachannel", t3);
          }), await this.connection.createDataChannels(this.store.uid, t2), t2.forEach((e3) => {
            this.localDataChannels.push(e3);
            const t3 = Date.now();
            this.store.publish(e3.id + "", "datachannel", void 0, t3);
          }));
        }
        publish(e2, t2, i2) {
          var n2 = this;
          return PU(function* () {
            const r2 = yield IU(n2.mutex.lock("From P2PChannel.publish"));
            try {
              if (!n2.connection || n2.state !== uv.Connected) {
                if (n2.state === uv.Disconnected) throw new Kg(Hg.UNEXPECTED_ERROR, "PeerConnection already disconnected.");
                n2.throwIfTrackTypeNotMatch(e2);
                const t3 = e2.filter((e3) => -1 === n2.pendingLocalTracks.indexOf(e3));
                return void (n2.pendingLocalTracks = n2.pendingLocalTracks.concat(t3));
              }
              n2.store.pubId = n2.store.pubId + 1, RU.markPublishStart(n2.store.clientId, n2.store.pubId);
              const s2 = n2.filterTobePublishedTracks(e2, t2, i2);
              if (0 === s2.length) return void (yield IU(n2.tryToUnmuteAudio(e2)));
              yield* bV(oF(n2.doPublish(n2.connection, s2)));
            } finally {
              r2();
            }
          })();
        }
        doPublish(e2, t2) {
          var i2 = this;
          return PU(function* () {
            t2.forEach((e3) => {
              let { track: t3, type: n3 } = e3;
              const r3 = Date.now();
              i2.store.publish(t3.getTrackId(), n3 === lv.LocalAudioTrack ? "audio" : "video", r3);
            }), i2.bindLocalTrackEvents(t2);
            const n2 = t2.map((e3) => {
              let { track: t3 } = e3;
              return t3;
            }), r2 = yield IU(e2.send(t2.map((e3) => {
              let { track: t3 } = e3;
              return t3;
            }), i2.store.codec, i2.store.audioCodec)), s2 = (yield IU(r2.next())).value, o2 = i2.createGatewayPublishMessage(t2, s2);
            let a2;
            try {
              a2 = yield o2;
            } catch (e3) {
              throw r2.throw(e3), (null == e3 ? void 0 : e3.code) === Hg.WS_ABORT && t2.forEach((e4) => {
                let { track: t3 } = e4;
                -1 === i2.pendingLocalTracks.indexOf(t3) && i2.pendingLocalTracks.push(t3);
              }), i2.unbindLocalTrackEvents(t2), e3;
            }
            const c2 = i2.mapPubResToRemoteConfig(o2, a2), d2 = (yield IU(r2.next(c2))).value, l2 = RC("ENABLE_VIDEO_SEI");
            n2.forEach(async (e3) => {
              const t3 = e3.getRTCRtpTransceiver();
              t3 && l2 && (e3.trackMediaType === av.VIDEO ? await async function(e4, t4) {
                if (!IA().supportWebRTCEncodedTransform) return void jC.warning("browser not support video encoded transform");
                if (mU.has(e4)) return;
                if (!e4.track) return;
                const i3 = { track: e4.track };
                if (Ag()) {
                  if (!e4.createEncodedStreams) return void jC.warning("browser not support createEncodedStreams() API");
                  let r3 = null;
                  try {
                    r3 = e4.createEncodedStreams();
                  } catch (e5) {
                    return void jC.error("create video-encoded-streams error", e5 && e5.message);
                  }
                  let s3 = [];
                  t4.on("sei-to-send", (e5) => {
                    s3.push(e5);
                  });
                  const o3 = new TransformStream({ transform(t5, r4) {
                    i3.controller || (i3.controller = r4), e4.track && e4.track.id !== i3.track.id && (jC.debug("video track changed: ".concat(i3.track.id, " => ").concat(e4.track.id)), i3.track.removeEventListener("ended", n3), i3.track = e4.track, i3.track.addEventListener("ended", n3));
                    const o4 = s3.shift();
                    o4 && (t5.data = EU(t5.data, o4)), r4.enqueue(t5);
                  } });
                  r3.readable.pipeThrough(o3).pipeTo(r3.writable);
                } else {
                  if (!bg()) return;
                  {
                    if ("undefined" == typeof RTCRtpScriptTransform) return void jC.warning("browser not support RTCRtpScriptTransform");
                    const r3 = lU(), s3 = new MessageChannel();
                    await new cg((e5) => r3.onmessage = (t5) => {
                      "registered" === t5.data && e5(void 0);
                    });
                    const o3 = new RTCRtpScriptTransform(r3, { name: "tx", port: s3.port2 }, [s3.port2]);
                    e4.transform = o3, await new cg((e5) => r3.onmessage = (t5) => {
                      "started" === t5.data && e5(void 0);
                    }), t4.on("sei-to-send", (e5) => {
                      s3.port1.postMessage({ sei: e5 });
                    }), s3.port1.onmessage = (t5) => {
                      var r4;
                      t5.data.transformed && e4.track && (null === (r4 = e4.track) || void 0 === r4 ? void 0 : r4.id) !== i3.track.id && (jC.debug("video track changed: ".concat(i3.track.id, " => ").concat(e4.track.id)), i3.track.removeEventListener("ended", n3), i3.track = e4.track, i3.track.addEventListener("ended", n3));
                    }, i3.worker = r3;
                  }
                }
                function n3() {
                  if (e4.track) {
                    if (this.id !== e4.track.id) return;
                    e4.track.removeEventListener("ended", n3);
                  }
                  const t5 = mU.get(e4);
                  if (t5) {
                    mU.delete(e4);
                    try {
                      var i4, r3;
                      null === (i4 = t5.controller) || void 0 === i4 || i4.terminate(), null === (r3 = t5.worker) || void 0 === r3 || r3.terminate();
                    } catch (e5) {
                      jC.warning(e5 && e5.message);
                    }
                  }
                }
                mU.set(e4, i3), e4.track.addEventListener("ended", n3);
              }(t3.sender, e3) : e3.trackMediaType === av.AUDIO && await async function(e4) {
                if (!IA().supportWebRTCEncodedTransform) return void jC.warning("browser not support audio encoded transform");
                if (uU.has(e4)) return;
                if (!e4.track) return;
                const t4 = { track: e4.track };
                if (Ag()) {
                  if (!e4.createEncodedStreams) return void jC.warning("browser not support createEncodedStreams() API");
                  let n3 = null;
                  try {
                    n3 = e4.createEncodedStreams();
                  } catch (e5) {
                    return void jC.error("create audio-encoded-streams error", e5 && e5.message);
                  }
                  const r3 = new TransformStream({ transform(n4, r4) {
                    t4.controller || (t4.controller = r4), e4.track && e4.track.id !== t4.track.id && (jC.debug("audio track changed: ".concat(t4.track.id, " => ").concat(e4.track.id)), t4.track.removeEventListener("ended", i3), t4.track = e4.track, t4.track.addEventListener("ended", i3)), r4.enqueue(n4);
                  } });
                  n3.readable.pipeThrough(r3).pipeTo(n3.writable);
                } else if (bg()) {
                  if ("undefined" == typeof RTCRtpScriptTransform) return void jC.warning("browser not support RTCRtpScriptTransform");
                  const n3 = lU(), r3 = new MessageChannel();
                  await new cg((e5) => n3.onmessage = (t5) => {
                    "registered" === t5.data && e5(void 0);
                  });
                  const s3 = new RTCRtpScriptTransform(n3, { name: "tx", port: r3.port2 }, [r3.port2]);
                  e4.transform = s3, await new cg((e5) => n3.onmessage = (t5) => {
                    "started" === t5.data && e5(void 0);
                  }), r3.port1.onmessage = (n4) => {
                    var r4;
                    n4.data.transformed && e4.track && (null === (r4 = e4.track) || void 0 === r4 ? void 0 : r4.id) !== t4.track.id && (jC.debug("audio track changed: ".concat(t4.track.id, " => ").concat(e4.track.id)), t4.track.removeEventListener("ended", i3), t4.track = e4.track, t4.track.addEventListener("ended", i3));
                  }, t4.worker = n3;
                }
                function i3() {
                  if (e4.track) {
                    if (this.id !== e4.track.id) return;
                    e4.track.removeEventListener("ended", i3);
                  }
                  const t5 = uU.get(e4);
                  if (t5) {
                    uU.delete(e4);
                    try {
                      var n3, r3;
                      null === (n3 = t5.controller) || void 0 === n3 || n3.terminate(), null === (r3 = t5.worker) || void 0 === r3 || r3.terminate();
                    } catch (e5) {
                      jC.warning(e5 && e5.message);
                    }
                  }
                }
                uU.set(e4, t4), e4.track.addEventListener("ended", i3);
              }(t3.sender));
            }), t2.forEach((e3) => {
              let { type: t3 } = e3;
              i2.statsCollector.addLocalStats(t3);
            }), i2.assignLocalTracks(t2, d2), i2.statsUploader.startUploadOutboundStats(), t2.forEach((e3) => {
              let { track: t3, type: n3 } = e3;
              const r3 = Date.now();
              i2.store.publish(t3.getTrackId(), n3 === lv.LocalAudioTrack ? "audio" : "video", void 0, r3);
            });
          })();
        }
        async updateVideoStreamParameter(e2, t2) {
          const i2 = this.localTrackMap.get(t2);
          if (!i2) return;
          if (!(i2.track instanceof Rw)) return jC.warn("[updateVideoStreamParameter]: track is not an instance of LocalVideoTrack");
          if (!(this.connection instanceof jV || this.connection instanceof LV)) return jC.warn("[updateVideoStreamParameter]: connection is not P2PConnection or P2PConnectionPlanB");
          const { track: n2 } = i2, r2 = function(e3, t3) {
            const i3 = {};
            return e3.height && e3.width && (i3.scaleResolutionDownBy = yy(e3, t3)), i3.maxFramerate = e3.framerate ? Sy(e3.framerate) : void 0, i3.maxBitrate = e3.bitrate ? 1e3 * e3.bitrate : void 0, i3;
          }(e2, n2);
          if (n2._encoderConfig || (n2._encoderConfig = {}), t2 !== lv.LocalVideoLowTrack || !RC("DISABLE_DUAL_STREAM_USE_ENCODING") && IA().supportDualStreamEncoding) null != r2.scaleResolutionDownBy && (n2._encoderConfig.scaleResolutionDownBy = r2.scaleResolutionDownBy);
          else {
            const t3 = n2._originMediaStreamTrack;
            if (!t3.canvas) return jC.warn("[".concat(n2.getTrackId(), "] no canvas on track"));
            !function(e3, t4) {
              const i3 = e3.canvas;
              t4.width && (i3.width = Sy(t4.width)), t4.height && (i3.height = Sy(t4.height)), t4.framerate && (i3.stopCapture && i3.stopCapture(), i3.stopCapture = Tb(() => {
                !i3.startCapture && i3.stopCapture && i3.stopCapture(), i3.startCapture && i3.startCapture();
              }, Sy(t4.framerate)));
            }(t3, e2);
          }
          null != r2.maxBitrate && (n2._encoderConfig.bitrateMax = r2.maxBitrate / 1e3), null != r2.maxFramerate && (n2._encoderConfig.frameRate && "object" == typeof n2._encoderConfig.frameRate ? n2._encoderConfig.frameRate.max = r2.maxFramerate : n2._encoderConfig.frameRate = { max: r2.maxFramerate }), jC.debug("[".concat(n2.getTrackId(), "] LowStreamEncoderConfig: , ").concat(JSON.stringify(n2._encoderConfig))), await this.connection.updateRtpSenderEncodings(n2);
        }
        publishLowStream(e2) {
          var t2 = this;
          return PU(function* () {
            if (!t2.connection || t2.state !== uv.Connected) return;
            const i2 = yield IU(t2.mutex.lock("Locking from P2PChannel.publishLowStream"));
            try {
              const r2 = t2.localTrackMap.get(lv.LocalVideoTrack);
              if (!r2) throw new Kg(Hg.UNEXPECTED_ERROR, "Could not find high stream");
              if (t2.localTrackMap.has(lv.LocalVideoLowTrack)) throw new Kg(Hg.UNEXPECTED_ERROR, "[".concat(t2.store.clientId, "] Can't publish low stream when stream already publish"));
              const s2 = [{ track: t2.getLowVideoTrack(r2.track, e2), type: lv.LocalVideoLowTrack }];
              if (yield* bV(oF(t2.doPublish(t2.connection, s2))), r2.track.muted || !r2.track.enabled) {
                var n2;
                const e3 = null === (n2 = t2.localTrackMap.get(lv.LocalVideoLowTrack)) || void 0 === n2 ? void 0 : n2.id;
                void 0 !== e3 && (yield IU(t2.connection.muteLocal([e3])));
              }
            } finally {
              i2();
            }
          })();
        }
        async republish() {
          this.pendingLocalTracks.length > 0 && (jC.debug("[".concat(this.store.clientId, "] Emit P2PChannelEvents.RequestRePublish to republish tracks.")), await vT(this, hv.RequestRePublish, this.pendingLocalTracks), this.emit(hv.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = []), this.pendingLocalDataChannels.length > 0 && (jC.debug("Emit P2PChannelEvents.RequestRePublishDataChannel to republish datachannels."), await vT(this, hv.RequestRePublishDataChannel, this.pendingLocalDataChannels), this.pendingLocalDataChannels = []);
        }
        async reSubscribe(e2) {
          for (let e3 = this.pendingRemoteTracks.length - 1; e3 >= 0; e3--) {
            const { user: t2, kind: i2 } = this.pendingRemoteTracks[e3];
            (i2 !== av.AUDIO || t2._audio_added_ && t2._audioSSRC) && (i2 !== av.VIDEO || t2._video_added_ && t2._videoSSRC) || this.pendingRemoteTracks.splice(e3, 1);
          }
          if (e2) await vT(this, hv.RequestReSubscribe, this.pendingRemoteTracks);
          else for (const { user: e3, kind: t2 } of this.pendingRemoteTracks) await this.subscribe(e3, t2, t2 === av.VIDEO ? e3._videoSSRC : e3._audioSSRC);
          this.pendingRemoteTracks.forEach((e3) => {
            let { user: t2 } = e3;
            this.emit(hv.MediaReconnectEnd, t2.uid);
          }), this.pendingRemoteTracks = [];
        }
        async unpublish(e2) {
          if (!this.connection || this.state !== uv.Connected) return void e2.forEach((e3) => {
            const t3 = this.pendingLocalTracks.indexOf(e3);
            -1 !== t3 && this.pendingLocalTracks.splice(t3, 1);
          });
          const t2 = this.filterTobeUnpublishedTracks(e2);
          if (0 === t2.length) return;
          const i2 = t2.find((e3) => "videoLowTrack" === e3[0]);
          if (i2) {
            i2[1].track.close();
          }
          return this.doUnpublish(this.connection, t2);
        }
        async unpublishDataChannel(e2) {
          if (!this.connection || this.state !== uv.Connected) return void e2.forEach((e3) => {
            const t3 = this.pendingLocalDataChannels.indexOf(e3);
            -1 !== t3 && this.pendingLocalDataChannels.splice(t3, 1);
          });
          const t2 = this.filterTobeUnpublishedDataChannels(e2);
          return 0 !== t2.length ? (t2.forEach((e3) => {
            const t3 = this.localDataChannels.indexOf(e3);
            -1 !== t3 && this.localDataChannels.splice(t3, 1);
          }), 0 === this.localDataChannels.length && await this.connection.stopDataChannels(this.store.uid), t2.map((e3) => e3.id)) : void 0;
        }
        async unpublishLowStream() {
          if (!this.connection || this.state !== uv.Connected) return;
          const e2 = this.localTrackMap.get(lv.LocalVideoLowTrack);
          if (!e2) return;
          e2.track.close();
          const t2 = [[lv.LocalVideoLowTrack, e2]];
          return this.doUnpublish(this.connection, t2);
        }
        async doUnpublish(e2, t2) {
          const i2 = this.createGatewayUnpublishMessage(t2);
          return await e2.stopSending(t2.map((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          })), this.withdrawLocalTracks(t2), this.unbindLocalTrackEvents(t2.map((e3) => {
            let [t3, { track: i3 }] = e3;
            return { type: t3, track: i3 };
          })), t2.forEach((e3) => {
            let [t3] = e3;
            this.statsCollector.removeLocalStats(t3);
          }), 0 === this.localTrackMap.size && this.statsUploader.stopUploadOutboundStats(), i2;
        }
        async subscribeDataChannel(e2, t2) {
          if (!this.connection || this.state !== uv.Connected) throw new Kg(Hg.INVALID_OPERATION, "Cannot subscribe remote user when peerConnection disconnected.");
          const i2 = t2.filter((t3) => {
            var i3;
            return !(null !== (i3 = this.remoteDataChannelMap.get(e2)) && void 0 !== i3 && i3.get(t3.id));
          });
          if (0 !== i2.length) return await this.connection.createDataChannels(e2.uid, i2), i2.forEach((t3) => {
            var i3;
            this.remoteDataChannelMap.has(e2) ? null === (i3 = this.remoteDataChannelMap.get(e2)) || void 0 === i3 || i3.set(t3.id, t3) : this.remoteDataChannelMap.set(e2, /* @__PURE__ */ new Map([[t3.id, t3]]));
            const n2 = this.pendingRemoteDataChannels.findIndex((i4) => {
              let { user: n3, id: r2 } = i4;
              return n3.uid === e2.uid && r2 === t3.id;
            });
            -1 !== n2 && this.pendingRemoteDataChannels.splice(n2, 1);
          }), i2.map((e3) => e3.id);
        }
        async subscribe(e2, t2, i2, n2, r2) {
          var s2;
          if (!this.connection || this.state !== uv.Connected) throw new Kg(Hg.INVALID_OPERATION, "Cannot subscribe remote user when peerConnection disconnected.");
          if (null !== (s2 = this.remoteUserMap.get(e2)) && void 0 !== s2 && s2.has(t2)) return;
          let o2, a2, c2;
          if (r2) {
            const i3 = r2.find((e3) => {
              let { stream_type: i4 } = e3;
              return i4 === t2;
            });
            if (!i3) throw new Kg(Hg.UNEXPECTED_ERROR, "Cannot subscribe to remote ".concat(t2, " for user: ").concat(e2.uid, " because subscribe answer from gateway does not contain stream_type: ").concat(t2, "."));
            const n3 = await this.connection.receive(t2, i3.ssrcs, String(e2._uintid), i3.attributes);
            this.connection instanceof jV && (c2 = n3.transceiver), o2 = n3.track, a2 = n3.id;
          } else {
            const r3 = await this.connection.receive(t2, [{ ssrcId: i2, rtx: n2 }], String(e2._uintid), void 0);
            this.connection instanceof jV && (c2 = r3.transceiver), o2 = r3.track, a2 = r3.id;
          }
          t2 === av.AUDIO ? (e2._audioTrack ? e2._audioTrack._updateOriginMediaStreamTrack(o2) : (e2._audioTrack = new Nw(o2, e2.uid, e2._uintid, this.store), jC.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(e2._audioTrack.getTrackId()))), c2 && e2._audioTrack._updateRtpTransceiver(c2), this.bindRemoteTrackEvents(e2, e2._audioTrack)) : (e2._videoTrack ? e2._videoTrack._updateOriginMediaStreamTrack(o2) : (e2._videoTrack = new Ow(o2, e2.uid, e2._uintid, this.store), jC.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(e2._videoTrack.getTrackId()))), c2 && e2._videoTrack._updateRtpTransceiver(c2), this.bindRemoteTrackEvents(e2, e2._videoTrack)), RC("ENABLE_VIDEO_SEI") && c2 && (t2 == av.VIDEO ? await gU(c2.receiver, { onSei: (t3) => {
            var i3;
            null === (i3 = e2._videoTrack) || void 0 === i3 || i3._onSei(t3);
          } }) : t2 == av.AUDIO && await pU(c2.receiver));
          const d2 = this.remoteUserMap.get(e2);
          d2 ? d2.set(t2, a2) : this.remoteUserMap.set(e2, /* @__PURE__ */ new Map([[t2, a2]])), this.statsCollector.addRemoteStats(e2.uid), this.statsUploader.startUploadInboundStats();
          const l2 = this.pendingRemoteTracks.findIndex((i3) => {
            let { user: n3, kind: r3 } = i3;
            return n3.uid === e2.uid && t2 === r3;
          });
          -1 !== l2 && (this.pendingRemoteTracks.splice(l2, 1), this.emit(hv.MediaReconnectEnd, e2.uid));
        }
        async massSubscribe(e2) {
          return this.massSubscribeNoLock(e2);
        }
        async massSubscribeNoLock(e2) {
          if (!this.connection || this.state !== uv.Connected) throw new Kg(Hg.INVALID_OPERATION, "Cannot subscribeAll remote users when peerConnection disconnected.");
          e2 = e2.filter((e3) => {
            var t3;
            let { user: i2, mediaType: n2 } = e3;
            return !(null !== (t3 = this.remoteUserMap.get(i2)) && void 0 !== t3 && t3.has(n2));
          });
          const t2 = await this.connection.batchReceive(e2.map((e3) => {
            let { user: t3, mediaType: i2, ssrcId: n2, rtxSsrcId: r2 } = e3;
            return { kind: i2, ssrcMsg: [{ ssrcId: n2, rtx: r2 }], mslabel: String(t3._uintid) };
          }));
          e2.forEach((e3, i2) => {
            let { user: n2, mediaType: r2 } = e3;
            const { track: s2, id: o2, transceiver: a2 } = t2[i2];
            r2 === av.AUDIO ? (n2._audioTrack ? n2._audioTrack._updateOriginMediaStreamTrack(s2) : (n2._audioTrack = new Nw(s2, n2.uid, n2._uintid, this.store), jC.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(n2._audioTrack.getTrackId()))), a2 && n2._audioTrack._updateRtpTransceiver(a2), this.bindRemoteTrackEvents(n2, n2._audioTrack)) : (n2._videoTrack ? n2._videoTrack._updateOriginMediaStreamTrack(s2) : (n2._videoTrack = new Ow(s2, n2.uid, n2._uintid, this.store), jC.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(n2._videoTrack.getTrackId()))), a2 && n2._videoTrack._updateRtpTransceiver(a2), this.bindRemoteTrackEvents(n2, n2._videoTrack));
            const c2 = this.remoteUserMap.get(n2);
            c2 ? c2.set(r2, o2) : this.remoteUserMap.set(n2, /* @__PURE__ */ new Map([[r2, o2]])), this.statsCollector.addRemoteStats(n2.uid), this.statsUploader.startUploadInboundStats();
            const d2 = this.pendingRemoteTracks.findIndex((e4) => {
              let { user: t3, kind: i3 } = e4;
              return t3.uid === n2.uid && r2 === i3;
            });
            -1 !== d2 && (this.pendingRemoteTracks.splice(d2, 1), this.emit(hv.MediaReconnectEnd, n2.uid));
          });
        }
        async unsubscribe(e2, t2, i2) {
          const n2 = this.pendingRemoteTracks.filter((i3) => {
            let { user: n3, kind: r3 } = i3;
            return void 0 !== t2 ? n3.uid === e2.uid && t2 === r3 : n3.uid === e2.uid;
          });
          if (n2.forEach((e3) => {
            const t3 = this.pendingRemoteTracks.indexOf(e3);
            this.pendingRemoteTracks.splice(t3, 1);
          }), this.connection && this.state === uv.Connected || i2 || n2.forEach((t3) => {
            let { kind: i3 } = t3;
            var n3;
            if (i3 === av.AUDIO) null === (n3 = e2._audioTrack) || void 0 === n3 || n3._destroy(), e2._audioTrack = void 0;
            else if (i3 === av.VIDEO) {
              var r3;
              null === (r3 = e2._videoTrack) || void 0 === r3 || r3._destroy(), e2._videoTrack = void 0;
            }
          }), !this.connection || this.state !== uv.Connected) return;
          const r2 = this.filterTobeUnSubscribedTracks(e2, t2);
          if (0 === r2.length) return;
          await this.connection.stopReceiving(r2.map((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          }));
          const s2 = this.createUnsubscribeMessage(r2);
          return this.withdrawRemoteTracks(r2), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadInboundStats(), r2.forEach((e3) => {
            let [t3, { kind: n3 }] = e3;
            var r3, s3;
            n3 === av.VIDEO && t3._videoSSRC && (null === (r3 = this.connection) || void 0 === r3 || r3.setStatsRemoteVideoIsReady(t3._videoSSRC, false));
            if (n3 === av.VIDEO) this.unbindRemoteTrackEvents(t3._videoTrack), i2 || (null === (s3 = t3._videoTrack) || void 0 === s3 || s3._destroy(), t3._videoTrack = void 0);
            else if (n3 === av.AUDIO) {
              var o2;
              if (this.unbindRemoteTrackEvents(t3._audioTrack), !i2) null === (o2 = t3._audioTrack) || void 0 === o2 || o2._destroy(), t3._audioTrack = void 0;
            }
          }), s2;
        }
        async unsubscribeDataChannel(e2, t2) {
          if (t2.forEach((e3) => {
            const t3 = this.pendingRemoteDataChannels.findIndex((t4) => t4.id === e3.id);
            -1 !== t3 && this.pendingRemoteDataChannels.splice(t3, 1);
          }), !this.connection) return;
          const i2 = this.filterTobeUnSubscribedDataChannels(e2, t2);
          if (0 === i2.length) return;
          t2.forEach((e3) => {
            e3._close();
          });
          const n2 = this.remoteDataChannelMap.get(e2);
          return i2.forEach((e3) => {
            n2 && n2.delete(e3.id);
          }), n2 && 0 === n2.size && (this.remoteDataChannelMap.delete(e2), await this.connection.stopDataChannels(e2.uid)), i2.map((e3) => e3.id);
        }
        async massUnsubscribe(e2) {
          return this.massUnsubscribeNoLock(e2);
        }
        async massUnsubscribeNoLock(e2) {
          let t2 = [];
          for (const { user: i3, mediaType: n3 } of e2) {
            const e3 = this.pendingRemoteTracks.filter((e4) => {
              let { user: t3, kind: r2 } = e4;
              return void 0 !== n3 ? t3.uid === i3.uid && n3 === r2 : t3.uid === i3.uid;
            });
            e3.forEach((e4) => {
              const t3 = this.pendingRemoteTracks.indexOf(e4);
              this.pendingRemoteTracks.splice(t3, 1);
            }), t2 = t2.concat(e3);
          }
          if (!this.connection || this.state !== uv.Connected) return void t2.forEach((e3) => {
            let { user: t3, kind: i3 } = e3;
            var n3;
            if (i3 === av.AUDIO) null === (n3 = t3._audioTrack) || void 0 === n3 || n3._destroy(), t3._audioTrack = void 0;
            else if (i3 === av.VIDEO) {
              var r2;
              null === (r2 = t3._videoTrack) || void 0 === r2 || r2._destroy(), t3._videoTrack = void 0;
            }
          });
          const i2 = BT(e2).call(e2, (e3, t3) => {
            let { user: i3, mediaType: n3 } = t3;
            const r2 = this.filterTobeUnSubscribedTracks(i3, n3);
            return e3.concat(r2);
          }, []);
          if (0 === i2.length) return;
          await this.connection.stopReceiving(i2.map((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          }));
          const n2 = this.createUnsubscribeAllMessage(i2);
          return this.withdrawRemoteTracks(i2), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadInboundStats(), i2.forEach((e3) => {
            let [t3, { kind: i3 }] = e3;
            var n3, r2;
            i3 === av.VIDEO && t3._videoSSRC && (null === (n3 = this.connection) || void 0 === n3 || n3.setStatsRemoteVideoIsReady(t3._videoSSRC, false));
            if (i3 === av.VIDEO) this.unbindRemoteTrackEvents(t3._videoTrack), null === (r2 = t3._videoTrack) || void 0 === r2 || r2._destroy(), t3._videoTrack = void 0;
            else if (i3 === av.AUDIO) {
              var s2;
              this.unbindRemoteTrackEvents(t3._audioTrack), null === (s2 = t3._audioTrack) || void 0 === s2 || s2._destroy(), t3._audioTrack = void 0;
            }
          }), n2;
        }
        async muteRemote(e2, t2) {
          if (!this.connection) return;
          const i2 = this.remoteUserMap.get(e2);
          if (!i2) return void jC.warning("[".concat(this.store.clientId, "] P2PChannel.muteRemote has no remote user ").concat(e2.uid, "."));
          if (!i2.get(t2)) return void jC.warning("[".concat(this.store.clientId, "] P2PChannel.muteRemote has no remote user ").concat(e2.uid, " media type ").concat(t2, "."));
          const n2 = t2 === av.VIDEO ? e2._videoSSRC : e2._audioSSRC;
          void 0 !== n2 && this.connection.setStatsRemoteVideoIsReady(n2, false);
        }
        async unmuteRemote(e2, t2) {
          return this.unmuteRemoteNoLock(e2, t2);
        }
        async unmuteRemoteNoLock(e2, t2) {
          if (!this.connection) return;
          const i2 = this.remoteUserMap.get(e2);
          if (!i2) return void jC.warning("[".concat(this.store.clientId, "] P2PChannel.unmuteRemote has no remote user ").concat(e2.uid, "."));
          i2.get(t2) || jC.warning("[".concat(this.store.clientId, "] P2PChannel.unmuteRemote has no remote user ").concat(e2.uid, " media type ").concat(t2, "."));
        }
        getAllTracks(e2) {
          const t2 = this.localTrackMap.get(lv.LocalAudioTrack);
          if ((null == t2 ? void 0 : t2.track) instanceof nw) {
            const i2 = t2.track;
            return Array.from(this.localTrackMap.entries()).filter((e3) => {
              let [t3] = e3;
              return t3 !== lv.LocalAudioTrack;
            }).filter((t3) => {
              let [i3] = t3;
              return !(e2 && i3 === lv.LocalVideoLowTrack);
            }).map((e3) => {
              let [, { track: t3 }] = e3;
              return t3;
            }).concat(i2.trackList);
          }
          return Array.from(this.localTrackMap.entries()).filter((t3) => {
            let [i2] = t3;
            return !(e2 && i2 === lv.LocalVideoLowTrack);
          }).map((e3) => {
            let [, { track: t3 }] = e3;
            return t3;
          });
        }
        getAllDataChannels() {
          return this.localDataChannels;
        }
        reportPublishEvent(e2, t2, i2, n2, r2) {
          if (e2) {
            const i3 = this.localTrackMap.get(lv.LocalAudioTrack), s3 = n2 ? this.localTrackMap.get(lv.LocalVideoLowTrack) : this.localTrackMap.get(lv.LocalVideoTrack);
            eI.publish(this.store.sessionId, { eventElapse: RU.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t2, audioName: null == i3 ? void 0 : i3.track.getTrackLabel(), videoName: null == s3 ? void 0 : s3.track.getTrackLabel(), screenshare: -1 !== (null == s3 ? void 0 : s3.track._hints.indexOf(jA.SCREEN_TRACK)), audio: !!i3, video: !!s3, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
          } else {
            var s2;
            i2 || (i2 = []);
            const o2 = i2.find((e3) => e3 instanceof ew), a2 = n2 ? null === (s2 = this.localTrackMap.get(lv.LocalVideoTrack)) || void 0 === s2 ? void 0 : s2.track : i2.find((e3) => e3 instanceof Rw);
            eI.publish(this.store.sessionId, { eventElapse: RU.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t2, audioName: null == o2 ? void 0 : o2.getTrackLabel(), videoName: null == a2 ? void 0 : a2.getTrackLabel(), screenshare: -1 !== (null == a2 ? void 0 : a2._hints.indexOf(jA.SCREEN_TRACK)), audio: !!o2, video: !!a2, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
          }
        }
        reportSubscribeEvent(e2, t2, i2, n2) {
          const r2 = n2 === av.VIDEO ? i2._videoSSRC : i2._audioSSRC;
          r2 && eI.subscribe(this.store.sessionId, { succ: e2, ec: t2, video: n2 === av.VIDEO, audio: n2 === av.AUDIO, peerid: i2.uid, subscribeRequestid: n2 === av.VIDEO ? i2._videoSSRC : i2._audioSSRC, p2pid: this.store.p2pId, eventElapse: RU.measureFromSubscribeStart(this.store.clientId, r2) });
        }
        reset() {
          jC.debug("[".concat(this.store.clientId, "] P2PChannel.reset")), this.mutex = new pS("P2PChannel-mutex"), this.connection && (this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0), this.shouldForwardP2PCreation && (this.connection = this.store.useDataChannel ? new iF({}, this.store) : this.isPlanB ? new LV({}, this.store) : new jV({}, this.store), this.bindConnectionEvents(this.connection)), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), this.statsUploader.stopUploadExtensionUsageStats(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.unbindRtpTransceiver();
          const e2 = this.localTrackMap.get(lv.LocalAudioTrack);
          if ((null == e2 ? void 0 : e2.track) instanceof nw) {
            if (e2.track.trackList.length > 0) {
              const t2 = e2.track;
              e2.track.trackList.forEach((e3) => {
                t2.removeAudioTrack(e3);
              });
            }
            e2.track.close();
          }
          this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.iceFailedCount = 0, this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.localDataChannels = [], this.remoteDataChannelMap.clear(), this.pendingLocalDataChannels = [], this.pendingRemoteDataChannels = [], this.state = uv.Disconnected;
        }
        getStats() {
          var e2;
          return null === (e2 = this.connection) || void 0 === e2 ? void 0 : e2.getStats();
        }
        getRemoteVideoIsReady(e2) {
          var t2;
          return (null === (t2 = this.connection) || void 0 === t2 ? void 0 : t2.getRemoteVideoIsReady(e2)) || false;
        }
        getLocalAudioVolume() {
          const e2 = this.localTrackMap.get(lv.LocalAudioTrack);
          if (e2) return e2.track.getVolumeLevel();
        }
        getLocalVideoSize() {
          const e2 = this.localTrackMap.get(lv.LocalVideoTrack);
          if (e2) return { width: e2.track._videoWidth || 0, height: e2.track._videoHeight || 0 };
        }
        getEncoderConfig(e2) {
          const t2 = this.localTrackMap.get(e2);
          return t2 && t2.track instanceof Rw || t2 && t2.track instanceof ew ? t2.track._encoderConfig : void 0;
        }
        getLocalMedia(e2) {
          return this.localTrackMap.get(e2);
        }
        hasLocalMedia() {
          return this.localTrackMap.size > 0;
        }
        hasRemoteMedia(e2, t2) {
          if (!e2) return this.remoteUserMap.size > 0;
          const i2 = this.remoteUserMap.get(e2);
          return !!i2 && (!t2 || i2.has(t2));
        }
        async hasRemoteMediaWithLock(e2, t2) {
          if (!e2) return this.remoteUserMap.size > 0;
          const i2 = this.remoteUserMap.get(e2);
          return !!i2 && (!t2 || i2.has(t2));
        }
        getRemoteMedia(e2) {
          var t2;
          const i2 = Array.from(ph(t2 = this.remoteUserMap).call(t2)).find((t3) => t3.uid === e2);
          return i2 ? { audioTrack: i2.audioTrack, audioSSRC: i2._audioSSRC, videoTrack: i2.videoTrack, videoSSRC: i2._videoSSRC } : {};
        }
        getAudioLevels() {
          let e2 = Array.from(this.remoteUserMap.entries()).map((e3) => {
            let [t3] = e3;
            return { uid: t3.uid, level: t3.audioTrack ? 100 * t3.audioTrack._source.getAccurateVolumeLevel() : 0 };
          });
          const t2 = this.localTrackMap.get(lv.LocalAudioTrack);
          return t2 && e2.push({ level: 100 * t2.track._source.getAccurateVolumeLevel(), uid: this.store.uid }), e2 = ep(e2).call(e2, (e3, t3) => e3.level - t3.level), e2;
        }
        async disconnectForReconnect() {
          this.connection && (jC.debug("[".concat(this.store.clientId, "] P2PChannel.disconnectForReconnect closing P2PConnection")), this.state = uv.Reconnecting, RC("KEEP_LAST_FRAME") && 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t2] = e2;
            var i2;
            t2._videoTrack && t2._videoTrack._player && (null === (i2 = t2._videoTrack._player.getVideoElement()) || void 0 === i2 || i2.pause(), t2._videoTrack._player.isKeepLastFrame = true, t2._videoTrack._originMediaStreamTrack.stop());
          }), this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0, this.shouldForwardP2PCreation && (this.connection = this.store.useDataChannel ? new iF({}, this.store) : this.isPlanB ? new LV({}, this.store) : new jV({}, this.store), this.bindConnectionEvents(this.connection)), 0 !== this.localTrackMap.size && (Array.from(this.localTrackMap.entries()).forEach((e2) => {
            var t2;
            let [i2, { track: n2 }] = e2;
            switch (i2) {
              case lv.LocalVideoTrack:
                bn(t2 = n2._hints).call(t2, jA.LOW_STREAM) ? n2.close() : this.pendingLocalTracks.push(n2);
                break;
              case lv.LocalAudioTrack:
                n2 instanceof nw ? this.pendingLocalTracks = this.pendingLocalTracks.concat(n2.trackList) : this.pendingLocalTracks.push(n2);
              case lv.LocalVideoLowTrack:
            }
          }), this.emit(hv.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t2, i2] = e2;
            Array.from(ph(i2).call(i2)).forEach((e3) => {
              this.setPendingRemoteMedia(t2, e3);
            }), this.emit(hv.MediaReconnectStart, t2.uid);
          }), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), 0 !== this.localDataChannels.length && (this.localDataChannels.forEach((e2) => {
            this.pendingLocalDataChannels.push(e2);
          }), this.localDataChannels.length = 0), 0 !== this.remoteDataChannelMap.size && (Array.from(this.remoteDataChannelMap.entries()).forEach((e2) => {
            let [t2, i2] = e2;
            Array.from(ph(i2).call(i2)).forEach((e3) => {
              this.setPendingRemoteDataChannel(t2, e3);
            });
          }), this.remoteDataChannelMap.clear()), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), jC.debug("[".concat(this.store.clientId, "] P2PChannel disconnected, waiting to reconnect.")));
        }
        hasPendingRemoteDataChannel(e2, t2) {
          for (const i2 of this.pendingRemoteDataChannels) {
            const { user: n2, id: r2 } = i2;
            if ((e2 instanceof sV ? e2.uid : e2) === n2.uid && r2 === t2) return true;
          }
          return false;
        }
        setPendingRemoteDataChannel(e2, t2) {
          this.hasPendingRemoteDataChannel(e2, t2) || this.pendingRemoteDataChannels.push({ user: e2, id: t2 });
        }
        hasPendingRemoteMedia(e2, t2) {
          for (const i2 of this.pendingRemoteTracks) {
            const { user: n2, kind: r2 } = i2;
            if ((e2 instanceof sV ? e2.uid : e2) === n2.uid && t2 === r2) return true;
          }
          return false;
        }
        setPendingRemoteMedia(e2, t2) {
          this.hasPendingRemoteMedia(e2, t2) || this.pendingRemoteTracks.push({ user: e2, kind: t2 });
        }
        restartICE(e2) {
          var t2 = this;
          return PU(function* () {
            if (!t2.connection || t2.state !== uv.Connected || t2.connection instanceof iF) return;
            const i2 = yield IU(t2.mutex.lock("From P2PChannel.restartICE"));
            let n2;
            try {
              n2 = yield IU(t2.connection.restartICE(e2));
              const r3 = yield IU(n2.next());
              if (r3.done) return;
              const s2 = r3.value, o2 = yield s2;
              switch (t2.reportPCDisconnectedOrFailed(e2), e2) {
                case cv.TCP:
                  t2._pcStatsUploadType = dv.TCP_RESTART;
                  break;
                case cv.RELAY:
                  t2._pcStatsUploadType = dv.RELAY_RESTART;
                  break;
                default:
                  t2._pcStatsUploadType = dv.OLD_RESTART;
              }
              t2._isInRestartIce = true, n2.next(o2);
            } catch (e3) {
              var r2;
              null === (r2 = n2) || void 0 === r2 || r2.throw(e3);
            } finally {
              i2();
            }
          })();
        }
        getUplinkNetworkQuality() {
          if (!this.connection) return 0;
          const e2 = this.connection.getStats(), t2 = this.localTrackMap.get(lv.LocalVideoTrack), i2 = this.localTrackMap.get(lv.LocalAudioTrack), n2 = e2.videoSend.find((e3) => e3.ssrc === (null == t2 ? void 0 : t2.ssrcs[0].ssrcId)), r2 = e2.audioSend.find((e3) => e3.ssrc === (null == i2 ? void 0 : i2.ssrcs[0].ssrcId));
          if (!n2 || !r2) return 1;
          const s2 = AT(this, hv.NeedSignalRTT), o2 = n2 ? n2.rttMs : void 0, a2 = r2 ? r2.rttMs : void 0, c2 = o2 && a2 ? (o2 + a2) / 2 : o2 || a2, d2 = (c2 && s2 ? (c2 + s2) / 2 : c2 || s2) || 0, l2 = 100 * e2.sendPacketLossRate * 0.7 / 50 + 0.3 * d2 / 1500, u2 = l2 < 0.17 ? 1 : l2 < 0.36 ? 2 : l2 < 0.59 ? 3 : l2 < 0.1 ? 4 : 5, h3 = null == t2 ? void 0 : t2.track;
          if (h3 && h3._encoderConfig && -1 === h3._hints.indexOf(jA.SCREEN_TRACK)) {
            const t3 = h3._encoderConfig.bitrateMax, i3 = e2.bitrate.actualEncoded;
            if (t3 && i3) {
              const e3 = (1e3 * t3 - i3) / (1e3 * t3);
              return nI[e3 < 0.15 ? 0 : e3 < 0.3 ? 1 : e3 < 0.45 ? 2 : e3 < 0.6 ? 3 : 4][u2];
            }
          }
          return u2;
        }
        getDownlinkNetworkQuality() {
          if (!this.connection) return 0;
          const e2 = this.connection.getStats();
          let t2 = 0;
          return Array.from(this.remoteUserMap.entries()).forEach((i2) => {
            let [n2] = i2;
            const r2 = n2._audioSSRC, s2 = n2._videoSSRC, o2 = e2.audioRecv.find((e3) => e3.ssrc === r2), a2 = e2.videoRecv.find((e3) => e3.ssrc === s2);
            if (!o2 && !a2) return void (t2 += 1);
            const c2 = AT(this, hv.NeedSignalRTT), d2 = e2.rtt, l2 = (d2 && c2 ? (d2 + c2) / 2 : d2 || c2) || 0, u2 = o2 ? o2.jitterMs : void 0, h3 = e2.recvPacketLossRate;
            let p2 = 0.7 * h3 * 100 / 50 + 0.3 * l2 / 1500;
            u2 && (p2 = 0.6 * h3 * 100 / 50 + 0.2 * l2 / 1500 + 0.2 * u2 / 400);
            t2 += p2 < 0.1 ? 1 : p2 < 0.17 ? 2 : p2 < 0.36 ? 3 : p2 < 0.59 ? 4 : 5;
          }), this.remoteUserMap.size > 0 ? Math.round(t2 / this.remoteUserMap.size) : t2;
        }
        async muteLocalTrack(e2) {
          return new cg((t2, i2) => {
            this.handleMuteLocalTrack(e2, t2, i2);
          });
        }
        async replaceTrack(e2, t2) {
          var i2;
          if (jC.debug("[".concat(this.store.clientId, "] P2PChannel replaceTrack from [").concat(e2.getTrackId(), "] to [").concat(t2.getTrackId(), "]")), !this.connection || this.state !== uv.Connected) return;
          const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
            let [, { track: i3 }] = t3;
            return e2 === i3;
          });
          if (!n2) return;
          const r2 = n2[0];
          if (e2 !== t2 && (this.unbindLocalTrackEvents([{ track: e2, type: r2 }]), this.bindLocalTrackEvents([{ track: t2, type: r2 }]), n2[1].track = t2), await (null === (i2 = this.connection) || void 0 === i2 ? void 0 : i2.replaceTrack(t2, n2[1].id)), this.isPlanB) {
            const e3 = n2[1];
            e3.id = t2._mediaStreamTrack.id, this.localTrackMap.set(r2, e3);
          }
          if (r2 === lv.LocalVideoTrack && !RC("DISABLE_DUAL_STREAM_USE_ENCODING") && IA().supportDualStreamEncoding) {
            const t3 = this.localTrackMap.get(lv.LocalVideoLowTrack);
            if (t3) {
              const i3 = e2._mediaStreamTrack.clone();
              t3.track._originMediaStreamTrack.stop(), t3.track._mediaStreamTrack = i3, t3.track._originMediaStreamTrack = i3, await new cg((e3, i4) => {
                this.handleReplaceTrack(t3.track, e3, i4, true);
              });
            }
          }
        }
        filterTobePublishedTracks(e2, t2, i2) {
          const n2 = [], r2 = this.getAllTracks();
          e2 = HT(e2 = e2.filter((e3) => -1 === r2.indexOf(e3)));
          let s2, o2 = false;
          const a2 = this.localTrackMap.get(lv.LocalAudioTrack);
          for (const r3 of e2) {
            if (r3 instanceof Rw && (this.localTrackMap.has(lv.LocalVideoTrack) || o2 ? new Kg(Hg.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (n2.push({ track: r3, type: lv.LocalVideoTrack }), o2 = true), t2)) {
              const e3 = this.getLowVideoTrack(r3, i2);
              n2.push({ track: e3, type: lv.LocalVideoLowTrack });
            }
            if (r3 instanceof ew) if (a2) {
              const e3 = a2.track;
              if (e3 instanceof nw) cV([r3]), e3.addAudioTrack(r3), this.bindLocalAudioTrackEvents(r3, true);
              else {
                const t3 = dV([e3, r3]);
                jC.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection will replace audioTrack [").concat(t3.getTrackId(), "]")), this.replaceTrack(e3, t3);
              }
            } else if (s2 instanceof nw) cV([r3]), s2.addAudioTrack(r3);
            else if (s2 || !r3._useAudioElement && IA().webAudioMediaStreamDest && !r3._bypassWebAudio) {
              s2 = dV(s2 ? [r3, s2] : [r3]);
            } else s2 = r3;
          }
          return s2 && (jC.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection will send audioTrack [").concat(s2.getTrackId(), "]")), n2.push({ track: s2, type: lv.LocalAudioTrack })), n2;
        }
        filterTobeUnpublishedTracks(e2) {
          const t2 = [], i2 = this.getAllTracks();
          e2 = HT(e2 = e2.filter((e3) => -1 !== i2.indexOf(e3)));
          for (const i3 of e2) {
            if (i3 instanceof ew) {
              const e3 = this.localTrackMap.get(lv.LocalAudioTrack);
              if (!e3) continue;
              e3.track instanceof nw ? (e3.track.removeAudioTrack(i3), this.unbindLocalAudioTrackEvents(i3), 0 === e3.track.trackList.length && (t2.push([lv.LocalAudioTrack, e3]), e3.track.close())) : t2.push([lv.LocalAudioTrack, e3]);
            }
            if (i3 instanceof Rw) {
              const e3 = this.localTrackMap.get(lv.LocalVideoTrack);
              if (!e3) continue;
              t2.push([lv.LocalVideoTrack, e3]);
              const i4 = this.localTrackMap.get(lv.LocalVideoLowTrack);
              i4 && t2.push([lv.LocalVideoLowTrack, i4]);
            }
          }
          return t2;
        }
        filterTobePublishedDataChannels(e2) {
          return e2 = (e2 = HT(e2)).filter((e3) => -1 === this.localDataChannels.findIndex((t2) => t2.id === e3.id));
        }
        filterTobeUnpublishedDataChannels(e2) {
          return e2 = (e2 = (e2 = HT(e2)).filter((e3) => -1 !== this.localDataChannels.indexOf(e3))).filter((e3) => e3._originDataChannel);
        }
        bindLocalTrackEvents(e2) {
          e2.forEach((e3) => {
            let { track: t2, type: i2 } = e3;
            switch (i2) {
              case lv.LocalVideoTrack:
                t2.addListener(BA.GET_STATS, this.handleGetLocalVideoStats), t2.addListener(BA.GET_RTC_STATS, this.handleGetRTCStats), t2.addListener(BA.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.addListener(BA.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.addListener(BA.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.addListener(BA.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode), t2.addListener(BA.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.addListener(BA.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.addListener(BA.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case lv.LocalAudioTrack:
                this.bindLocalAudioTrackEvents(t2);
              case lv.LocalVideoLowTrack:
            }
          });
        }
        bindLocalAudioTrackEvents(e2, t2) {
          e2 instanceof nw ? e2.trackList.forEach((e3) => {
            e3.addListener(BA.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.addListener(BA.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.addListener(BA.GET_STATS, this.handleGetLocalAudioStats), e3.addListener(BA.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.addListener(BA.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          }) : (e2.addListener(BA.GET_STATS, this.handleGetLocalAudioStats), e2.addListener(BA.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.addListener(BA.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.addListener(BA.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.addListener(BA.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), t2 || (e2.addListener(BA.NEED_REPLACE_TRACK, this.handleReplaceTrack), e2.addListener(BA.NEED_REPLACE_MIXING_TRACK, this.handleReplaceMixingTrack)));
        }
        unbindLocalTrackEvents(e2) {
          e2 || (e2 = Array.from(this.localTrackMap.entries()).map((e3) => {
            let [t2, { track: i2 }] = e3;
            return { track: i2, type: t2 };
          })), e2.forEach((e3) => {
            let { track: t2, type: i2 } = e3;
            switch (i2) {
              case lv.LocalVideoTrack:
                t2.off(BA.GET_STATS, this.handleGetLocalVideoStats), t2.off(BA.GET_RTC_STATS, this.handleGetRTCStats), t2.off(BA.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.off(BA.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.off(BA.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.off(BA.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode), t2.off(BA.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.off(BA.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.off(BA.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case lv.LocalAudioTrack:
                this.unbindLocalAudioTrackEvents(t2);
              case lv.LocalVideoLowTrack:
            }
          });
        }
        unbindLocalAudioTrackEvents(e2) {
          e2 instanceof nw ? e2.trackList.forEach((e3) => {
            e3.off(BA.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.off(BA.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.off(BA.GET_STATS, this.handleGetLocalAudioStats), e3.off(BA.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.off(BA.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          }) : (e2.off(BA.GET_STATS, this.handleGetLocalAudioStats), e2.off(BA.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.off(BA.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.off(BA.NEED_REPLACE_TRACK, this.handleReplaceTrack), e2.off(BA.NEED_REPLACE_MIXING_TRACK, this.handleReplaceMixingTrack), e2.off(BA.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.off(BA.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack));
        }
        bindRemoteTrackEvents(e2, t2) {
          t2 instanceof Ow && t2.addListener(BA.GET_STATS, (t3) => {
            t3(this.handleGetRemoteVideoStats(e2));
          }), t2 instanceof Nw && t2.addListener(BA.GET_STATS, (t3) => {
            t3(this.handleGetRemoteAudioStats(e2));
          });
        }
        unbindRemoteTrackEvents(e2) {
          e2 && e2.removeAllListeners(BA.GET_STATS);
        }
        unbindAllRemoteTrackEvents() {
          Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t2, i2] = e2;
            i2.has(av.AUDIO) && this.unbindRemoteTrackEvents(t2._audioTrack), i2.has(av.VIDEO) && this.unbindRemoteTrackEvents(t2._videoTrack);
          });
        }
        createGatewayPublishMessage(e2, t2) {
          return e2.map((e3, i2) => {
            var n2;
            let r2, s2, { track: o2, type: a2 } = e3;
            switch (a2) {
              case lv.LocalAudioTrack:
                r2 = JI.Audio, s2 = { dtx: o2 instanceof tw && o2._config.DTX, hq: false, lq: false, stereo: false, speech: false };
                break;
              case lv.LocalVideoTrack:
                r2 = bn(n2 = o2._hints).call(n2, jA.SCREEN_TRACK) ? JI.Screen : JI.High, s2 = sF(sF({}, Ry(o2)), {}, { codec: this.store.codec });
                break;
              case lv.LocalVideoLowTrack:
                r2 = JI.Low, s2 = sF(sF({}, Ry(o2)), {}, { codec: this.store.codec });
            }
            return { stream_type: r2, attributes: s2, ssrcs: t2[i2] };
          });
        }
        createGatewayUnpublishMessage(e2) {
          return e2.map((e3) => {
            var t2;
            let i2, [n2, { track: r2, ssrcs: s2, id: o2 }] = e3;
            switch (n2) {
              case lv.LocalVideoTrack:
                i2 = bn(t2 = r2._hints).call(t2, jA.SCREEN_TRACK) ? JI.Screen : JI.High;
                break;
              case lv.LocalAudioTrack:
                i2 = JI.Audio;
                break;
              case lv.LocalVideoLowTrack:
                i2 = JI.Low;
            }
            return { stream_type: i2, ssrcs: s2, mid: o2 };
          });
        }
        assignLocalTracks(e2, t2) {
          e2.forEach((e3, i2) => {
            let { track: n2, type: r2 } = e3;
            this.localTrackMap.set(r2, { track: n2, id: t2[i2].id, ssrcs: t2[i2].localSSRC });
          });
        }
        withdrawLocalTracks(e2) {
          e2.forEach((e3) => {
            let [t2] = e3;
            this.localTrackMap.delete(t2);
          });
        }
        bindConnectionEvents(e2) {
          e2.onConnectionStateChange = async (t2) => {
            if (jC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onConnectionStateChange(").concat(t2, ")")), this.emit(hv.PeerConnectionStateChange, t2), "connected" !== t2 || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), "connected" === t2 && (this._restartTimer && (clearTimeout(this._restartTimer), this._restartTimer = void 0), (this._isFirstConnected || this._isInRestartIce) && this.reportPCStats(Date.now(), true, this._pcStatsUploadType), this._isInRestartIce = false, this._isFirstConnected = false, this._isStartRestartIce = false), RC("NEW_ICE_RESTART")) {
              var i2;
              if (bn(i2 = this._restartStates).call(i2, t2)) {
                if (this._isStartRestartIce) return;
                this._isStartRestartIce = true;
                const t3 = (t4) => {
                  if ("disconnected" === e2.iceConnectionState || "checking" === e2.iceConnectionState || "failed" === e2.iceConnectionState) {
                    jC.debug("[".concat(this.store.clientId, "] [P2PChannel] start use restartICE, type is ").concat(t4));
                    "CONNECTED" === AT(this, hv.QueryClientConnectionState) && this.emit(hv.RequestRestartICE, t4);
                  }
                }, i3 = () => {
                  "disconnected" !== e2.iceConnectionState && "checking" !== e2.iceConnectionState && "failed" !== e2.iceConnectionState || (this.reportPCStats(Date.now(), false, this._pcStatsUploadType), jC.debug("[".concat(this.store.clientId, "] P2PConnection disconnected timeout, force reconnect")), setTimeout(() => this.emit(hv.P2PLost), 0), this.iceFailedCount += 1, this.requestReconnect());
                }, n2 = RC("ICE_RESTART_INTERVAL");
                return void (this._restartTimer = window.setTimeout(() => {
                  if (RC("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE") && IA().supportPCSetConfiguration) t3(cv.RELAY), this._restartTimer = window.setTimeout(i3, n2);
                  else if (wg()) t3(cv.UDP), this._restartTimer = window.setTimeout(i3, 4e3);
                  else {
                    if (t3(cv.TCP), IA().supportPCSetConfiguration) return void (this._restartTimer = window.setTimeout(() => {
                      t3(cv.RELAY), this._restartTimer = window.setTimeout(i3, n2);
                    }, n2));
                    this._restartTimer = window.setTimeout(i3, n2);
                  }
                }, 800));
              }
            } else {
              if ("disconnected" === t2 && "disconnected" === e2.iceConnectionState) return setTimeout(() => {
                if ("disconnected" === e2.iceConnectionState && RC("ICE_RESTART")) {
                  "CONNECTED" === AT(this, hv.QueryClientConnectionState) && this.emit(hv.RequestRestartICE);
                }
              }, 800), void setTimeout(() => {
                "disconnected" === e2.peerConnectionState && (jC.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection disconnected timeout 4000ms, force reconnect")), this.reportPCStats(Date.now(), false, this._pcStatsUploadType), this._isInRestartIce = false, setTimeout(() => this.emit(hv.P2PLost), 0), this.iceFailedCount += 1, this.requestReconnect());
              }, 4e3);
              "failed" === t2 && (jC.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection state failed, force reconnect")), this.reportPCDisconnectedOrFailed(), setTimeout(() => this.emit(hv.P2PLost), 0), this.iceFailedCount += 1, await this.requestReconnect());
            }
          }, e2.onICEConnectionStateChange = (e3) => {
            "connected" !== e3 || this.store.keyMetrics.iceConnectionEnd || this.store.iceConnectionEnd(), jC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICEConnectionStateChange(").concat(e3, ")")), eI.reportApiInvoke(this.store.sessionId, { name: "ICEConnectionStateChange", options: e3, tag: pT.TRACER }).onSuccess(), this.emit(hv.IceConnectionStateChange, e3);
          }, e2.onICETransportStateChange = (e3) => {
            jC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICETransportStateChange(").concat(e3, ")"));
          }, e2.onDTLSTransportStateChange = (e3) => {
            jC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportStateChange(").concat(e3, ")"));
          }, e2.onDTLSTransportError = (e3) => {
            jC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportError(").concat(e3, ")"));
          }, e2.onFirstAudioDecoded = (e3) => {
            var t2;
            const i2 = Array.from(ph(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._audioSSRC === e3);
            var n2;
            i2 && (this.store.subscribe(i2.uid, "audio", void 0, void 0, void 0, Date.now()), null === (n2 = i2.audioTrack) || void 0 === n2 || n2.emit(qA.FIRST_FRAME_DECODED), eI.firstRemoteFrame(this.store.sessionId, YC.FIRST_AUDIO_DECODE, qC.FIRST_AUDIO_DECODE, { peer: i2._uintid, subscribeElapse: RU.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId }));
          }, e2.onFirstAudioReceived = (e3) => {
            var t2;
            const i2 = Array.from(ph(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._audioSSRC === e3);
            i2 && eI.firstRemoteFrame(this.store.sessionId, YC.FIRST_AUDIO_RECEIVED, qC.FIRST_AUDIO_RECEIVED, { peer: i2._uintid, subscribeElapse: RU.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
          }, e2.onFirstVideoDecoded = (e3, t2, i2) => {
            this.reportVideoFirstFrameDecoded(e3, t2, i2);
          }, e2.onFirstVideoReceived = (e3) => {
            var t2;
            const i2 = Array.from(ph(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._videoSSRC === e3);
            i2 && eI.firstRemoteFrame(this.store.sessionId, YC.FIRST_VIDEO_RECEIVED, qC.FIRST_VIDEO_RECEIVED, { peer: i2._uintid, subscribeElapse: RU.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
          }, e2.onSelectedLocalCandidateChanged = (e3, t2) => {
            const i2 = "relay" === e3.candidateType, n2 = "relay" === t2.candidateType;
            "unknown" !== t2.candidateType && i2 === n2 || this.emit(hv.ConnectionTypeChange, i2), jC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(Ay(t2)), " -> ").concat(JSON.stringify(Ay(e3)), ")"));
          }, e2.onSelectedRemoteCandidateChanged = (e3, t2) => {
            jC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(Ay(t2)), " -> ").concat(JSON.stringify(Ay(e3)), ")"));
          }, e2.onFirstVideoDecodedTimeout = (e3) => {
            this.reportVideoFirstFrameDecoded(e3, void 0, void 0, true);
          };
        }
        unbindConnectionEvents(e2) {
          e2.onConnectionStateChange = void 0, e2.onICEConnectionStateChange = void 0, e2.onICETransportStateChange = void 0, e2.onDTLSTransportStateChange = void 0, e2.onDTLSTransportError = void 0, e2.onFirstAudioDecoded = void 0, e2.onFirstAudioReceived = void 0, e2.onFirstVideoDecoded = void 0, e2.onFirstVideoReceived = void 0, e2.onSelectedLocalCandidateChanged = void 0, e2.onSelectedRemoteCandidateChanged = void 0, e2.onFirstVideoDecodedTimeout = void 0;
        }
        filterTobeMutedTracks(e2) {
          const t2 = [];
          if (-1 === this.getAllTracks().indexOf(e2)) return t2;
          const i2 = this.localTrackMap.get(lv.LocalAudioTrack);
          if (e2 instanceof ew && (null == i2 ? void 0 : i2.track) instanceof nw) return i2.track.isActive || t2.push([lv.LocalAudioTrack, i2]), t2;
          const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
            let [, { track: i3 }] = t3;
            return e2 === i3;
          });
          if (n2 && (t2.push(n2), n2[0] === lv.LocalVideoTrack)) {
            const e3 = this.localTrackMap.get(lv.LocalVideoLowTrack);
            e3 && t2.push([lv.LocalVideoLowTrack, e3]);
          }
          return t2;
        }
        filterTobeUnmutedTracks(e2) {
          const t2 = [], i2 = this.localTrackMap.get(lv.LocalAudioTrack);
          if (e2 instanceof ew && (null == i2 ? void 0 : i2.track) instanceof nw) return i2.track.isActive && t2.push([lv.LocalAudioTrack, i2]), t2;
          const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
            let [, { track: i3 }] = t3;
            return e2 === i3;
          });
          if (n2) if (n2[0] === lv.LocalVideoTrack) {
            t2.push(n2);
            const e3 = this.localTrackMap.get(lv.LocalVideoLowTrack);
            e3 && t2.push([lv.LocalVideoLowTrack, e3]);
          } else t2.push(n2);
          return t2;
        }
        createMuteMessage(e2) {
          return e2.map((e3) => {
            var t2;
            let i2, [n2, { track: r2, ssrcs: s2, id: o2 }] = e3;
            switch (n2) {
              case lv.LocalAudioTrack:
                i2 = JI.Audio;
                break;
              case lv.LocalVideoTrack:
                i2 = bn(t2 = r2._hints).call(t2, jA.SCREEN_TRACK) ? JI.Screen : JI.High;
                break;
              case lv.LocalVideoLowTrack:
                i2 = JI.Low;
            }
            return { stream_type: i2, ssrcs: s2, mid: o2 };
          });
        }
        createUnmuteMessage(e2) {
          return e2.map((e3) => {
            var t2;
            let i2, [n2, { track: r2, ssrcs: s2, id: o2 }] = e3;
            switch (n2) {
              case lv.LocalAudioTrack:
                i2 = JI.Audio;
                break;
              case lv.LocalVideoTrack:
                i2 = bn(t2 = r2._hints).call(t2, jA.SCREEN_TRACK) ? JI.Screen : JI.High;
                break;
              case lv.LocalVideoLowTrack:
                i2 = JI.Low;
            }
            return { stream_type: i2, ssrcs: s2, mid: o2 };
          });
        }
        filterTobeUnSubscribedTracks(e2, t2) {
          const i2 = [], n2 = this.remoteUserMap.get(e2);
          if (!n2) return i2;
          if (t2) {
            const r2 = n2.get(t2);
            if (!r2) return i2;
            i2.push([e2, { kind: t2, id: r2 }]);
          } else Array.from(n2.entries()).forEach((t3) => {
            let [n3, r2] = t3;
            i2.push([e2, { kind: n3, id: r2 }]);
          });
          return i2;
        }
        filterTobeUnSubscribedDataChannels(e2, t2) {
          const i2 = [];
          return t2.forEach((t3) => {
            var n2;
            null !== (n2 = this.remoteDataChannelMap.get(e2)) && void 0 !== n2 && n2.has(t3.id) && i2.push(t3);
          }), i2;
        }
        createUnsubscribeMessage(e2) {
          const t2 = [];
          return e2.forEach((e3) => {
            let [i2, { kind: n2, id: r2 }] = e3;
            switch (n2) {
              case av.VIDEO:
                return void (i2._videoSSRC && t2.push({ stream_type: av.VIDEO, ssrcId: i2._videoSSRC }));
              case av.AUDIO:
                return void (i2._audioSSRC && t2.push({ stream_type: av.AUDIO, ssrcId: i2._audioSSRC }));
            }
          }), t2;
        }
        createUnsubscribeAllMessage(e2) {
          const t2 = /* @__PURE__ */ new Map();
          return e2.forEach((e3) => {
            let [i2, { kind: n2 }] = e3;
            if (t2.has(i2)) {
              let e4 = t2.get(i2);
              n2 === av.VIDEO ? e4 |= ZI.Video : e4 |= ZI.Audio, t2.set(i2, e4);
            } else n2 === av.VIDEO ? t2.set(i2, ZI.Video) : t2.set(i2, ZI.Audio);
          }), { users: Array.from(t2.entries()).map((e3) => {
            let [t3, i2] = e3;
            return { stream_id: t3.uid, stream_type: i2 };
          }) };
        }
        withdrawRemoteTracks(e2) {
          e2.forEach((e3) => {
            let [t2, { kind: i2 }] = e3;
            const n2 = this.remoteUserMap.get(t2);
            n2 && (n2.delete(i2), 0 === Array.from(n2.entries()).length && this.remoteUserMap.delete(t2));
          });
        }
        async updateBitrateLimit(e2) {
          const t2 = this.localTrackMap.get(lv.LocalVideoTrack), i2 = this.localTrackMap.get(lv.LocalVideoLowTrack);
          t2 && await t2.track.setBitrateLimit(e2.uplink), i2 && e2.low_stream_uplink && await i2.track.setBitrateLimit({ max_bitrate: e2.low_stream_uplink.bitrate, min_bitrate: e2.low_stream_uplink.bitrate || 0 });
        }
        isP2PDisconnected() {
          if (this.connection) {
            return "connected" !== this.connection.peerConnectionState;
          }
          return true;
        }
        mapPubResToRemoteConfig(e2, t2) {
          return e2.map((e3, i2) => {
            var n2;
            let { stream_type: r2 } = e3;
            return null === (n2 = t2.find((e4) => {
              let { stream_type: t3 } = e4;
              return r2 === t3;
            })) || void 0 === n2 ? void 0 : n2.attributes;
          });
        }
        async tryToUnmuteAudio(e2) {
          for (let i2 = 0; i2 < e2.length; i2++) if (e2[i2] instanceof ew) {
            var t2;
            const n2 = this.filterTobeUnmutedTracks(e2[i2]);
            if (0 === n2.length) continue;
            await (null === (t2 = this.connection) || void 0 === t2 ? void 0 : t2.unmuteLocal(n2.map((e3) => {
              let [, { id: t3 }] = e3;
              return t3;
            })));
            const r2 = this.createUnmuteMessage(n2);
            return void await yT(this, hv.RequestUnmuteLocal, r2);
          }
        }
        bindStatsUploaderEvents() {
          this.statsUploader.requestStats = () => this.getStats(), this.statsUploader.requestLocalMedia = () => Array.from(this.localTrackMap.entries()), this.statsUploader.requestRemoteMedia = () => Array.from(this.remoteUserMap.entries()), this.statsUploader.requestVideoIsReady = (e2) => {
            var t2;
            return !(null === (t2 = this.connection) || void 0 === t2 || !t2.getRemoteVideoIsReady(e2));
          }, this.statsUploader.requestUpload = (e2, t2) => this.emit(hv.RequestUpload, e2, t2), this.statsUploader.requestUploadStats = (e2) => this.emit(hv.RequestUploadStats, e2), this.statsUploader.requestAllTracks = () => this.getAllTracks();
        }
        unbindStatsUploaderEvents() {
          this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0;
        }
        async requestReconnect() {
          this.dtlsFailedCount += 1, await iS(mS(this.dtlsFailedCount, ES)), this.emit(hv.RequestReconnect);
        }
        async reconnectP2P() {
          const e2 = Array.from(this.localTrackMap.entries()), t2 = this.createGatewayUnpublishMessage(e2);
          Array.from(this.remoteUserMap.entries()), t2.length > 0 && await vT(this, hv.RequestUnpublishForReconnectPC, t2), this.disconnectForReconnect(), this.emit(hv.RequestReconnectPC);
        }
        canPublishLowStream() {
          return this.localTrackMap.has(lv.LocalVideoTrack) || this.pendingLocalTracks.some((e2) => e2 instanceof Rw);
        }
        throwIfTrackTypeNotMatch(e2) {
          if (e2.filter((e3) => e3 instanceof Rw).length > 1) throw new Kg(Hg.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
          if (e2.filter((e3) => e3 instanceof ew).length > 1 && (e2.some((e3) => e3 instanceof ew && e3._bypassWebAudio) || !IA().webAudioMediaStreamDest)) throw new Kg(Hg.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
          for (const t2 of e2) {
            if (t2 instanceof Rw && this.pendingLocalTracks.some((e3) => e3 instanceof Rw)) throw new Kg(Hg.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
            if (t2 instanceof ew && this.pendingLocalTracks.some((e3) => e3 instanceof ew) && (!IA().webAudioMediaStreamDest || t2._bypassWebAudio || this.pendingLocalTracks.some((e3) => e3 instanceof ew && e3._bypassWebAudio))) throw new Kg(Hg.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
          }
        }
        getLowVideoTrack(e2, t2) {
          const i2 = !RC("DISABLE_DUAL_STREAM_USE_ENCODING") && IA().supportDualStreamEncoding, n2 = sF(sF({}, { width: 160, height: 120, framerate: 15, bitrate: 50 }), t2);
          let r2;
          r2 = i2 ? e2._mediaStreamTrack.clone() : Gx(e2, n2);
          const s2 = nS(8, "track-low-"), o2 = new Rw(r2, sF(sF({}, i2 && { scaleResolutionDownBy: yy(n2, e2) }), {}, { frameRate: n2.framerate, bitrateMax: n2.bitrate, bitrateMin: n2.bitrate }), void 0, void 0, s2);
          return o2.on(KA.TRANSCEIVER_UPDATED, (t3) => {
            e2._updateRtpTransceiver(t3, GA.LOW_STREAM);
          }), o2._hints.push(jA.LOW_STREAM), e2.on("sei-to-send", (e3) => {
            o2.emit("sei-to-send", e3);
          }), e2.addListener(BA.NEED_CLOSE, () => {
            o2.close();
          }), o2;
        }
        async globalLock() {
          return this.mutex.lock("From P2PChannel.globalLock");
        }
        async reportPCStats(e2, t2, i2) {
          let n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
          if (this.connection && this.connection instanceof jV) {
            var r2, s2, o2, a2;
            const c2 = this.store.keyMetrics.descriptionStart || 0, { iceConnectionState: d2, dtlsTransportState: l2, peerConnectionState: u2 } = this.connection, { local: h3, remote: p2 } = await this.connection.getSelectedCandidatePair();
            eI.pcStats(this.store.sessionId, { startTime: c2, eventElapse: e2 - c2 || 0, iceconnectionsate: d2, dtlsstate: l2, connectionstate: u2, intSucc: t2 ? 1 : 2, error: n2, selectedLocalCandidateProtocol: null !== (r2 = null == h3 ? void 0 : h3.protocol) && void 0 !== r2 ? r2 : "", selectedLocalCandidateType: null !== (s2 = h3.candidateType) && void 0 !== s2 ? s2 : "", selectedLocalCandidateAddress: "".concat(h3.address, ":").concat(h3.port), selectedRemoteCandidateProtocol: null !== (o2 = p2.protocol) && void 0 !== o2 ? o2 : "", selectedRemoteCandidateType: null !== (a2 = p2.candidateType) && void 0 !== a2 ? a2 : "", selectedRemoteCandidateAddress: "".concat(p2.address, ":").concat(p2.port), restartCnt: i2 });
          }
        }
        reportVideoFirstFrameDecoded(e2, t2, i2, n2) {
          var r2;
          const s2 = Array.from(ph(r2 = this.remoteUserMap).call(r2)).find((t3) => t3._videoSSRC === e2);
          if (s2) {
            n2 || this.store.subscribe(s2.uid, "video", void 0, void 0, void 0, void 0, Date.now());
            const r3 = this.store.keyMetrics, o2 = r3.subscribe.find((e3) => e3.userId === s2.uid && "video" === e3.type);
            eI.firstRemoteVideoDecode(this.store.sessionId, YC.FIRST_VIDEO_DECODE, qC.FIRST_VIDEO_DECODE, { peer: s2._uintid, videowidth: t2, videoheight: i2, subscribeElapse: RU.measureFromSubscribeStart(this.store.clientId, e2), subscribeRequestid: e2, p2pid: this.store.p2pId, apEnd: r3.requestAPEnd || 0, apStart: r3.requestAPStart || 0, joinGwEnd: r3.joinGatewayEnd || 0, joinGwStart: r3.joinGatewayStart || 0, pcEnd: r3.peerConnectionEnd || 0, pcStart: r3.peerConnectionStart || 0, subscriberEnd: (null == o2 ? void 0 : o2.subscribeEnd) || 0, subscriberStart: (null == o2 ? void 0 : o2.subscribeStart) || 0, videoAddNotify: (null == o2 ? void 0 : o2.streamAdded) || 0, state: n2 ? 1 : 0 });
          }
        }
        async remoteMediaSsrcChanged(e2, t2, i2) {
          if (!this.connection) return false;
          const n2 = this.remoteUserMap.get(e2);
          if (!n2) return false;
          const r2 = n2.get(t2);
          if (!r2) return false;
          const s2 = await this.connection.getRemoteSSRC(r2);
          return void 0 !== s2 && s2 !== i2;
        }
        resetConnection(e2) {
          jC.debug("[".concat(this.store.clientId, "] [P2PChannel] reset connection to ").concat(e2)), this.state === uv.Connected ? (jC.debug("[".concat(this.store.clientId, "] [P2PChannel] fallback to websocket but P2PChannel state still connected, disconnect first")), this.disconnectForReconnect()) : (this.connection && (this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0), this.shouldForwardP2PCreation && (this.connection = e2 === $I.datachannel ? new iF({}, this.store) : this.isPlanB ? new LV({}, this.store) : new jV({}, this.store), this.bindConnectionEvents(this.connection)));
        }
        unbindRtpTransceiver() {
          0 !== this.localTrackMap.size && Array.from(this.localTrackMap.entries()).forEach((e2) => {
            let [t2, { track: i2 }] = e2;
            t2 === lv.LocalVideoLowTrack ? i2._updateRtpTransceiver(void 0, GA.LOW_STREAM) : i2._updateRtpTransceiver(void 0);
          });
        }
        reportPCDisconnectedOrFailed(e2) {
          this.connection && this.connection instanceof jV && ("disconnected" !== this.connection.iceConnectionState && "checking" !== this.connection.iceConnectionState && "failed" !== this.connection.iceConnectionState || (this._isFirstConnected ? (this.reportPCStats(Date.now(), false, this._pcStatsUploadType), this._isFirstConnected = false) : this._pcStatsUploadType === dv.TCP_RESTART && e2 === cv.RELAY ? this.reportPCStats(Date.now(), false, this._pcStatsUploadType) : this.reportPCStats(Date.now(), false, dv.DISCONNECTED_OR_FAILED)));
        }
      }
      function dF(e2, t2, i2) {
        const n2 = e2[t2];
        if ("function" != typeof n2) throw new Error("Cannot use mutex on object property.");
        return i2.value = async function() {
          const e3 = this.mutex, i3 = await e3.lock("From P2PChannel.".concat(t2));
          try {
            for (var r2 = arguments.length, s2 = new Array(r2), o2 = 0; o2 < r2; o2++) s2[o2] = arguments[o2];
            return await n2.apply(this, s2);
          } finally {
            i3();
          }
        }, i2;
      }
      function lF(e2) {
        let t2 = RF();
        return function(e3, t3) {
          let i2 = e3.appId;
          void 0 !== i2 && (MF(t3, 10), wF(t3, i2));
          let n2 = e3.cid;
          void 0 !== n2 && (MF(t3, 16), MF(t3, n2));
          let r2 = e3.cname;
          void 0 !== r2 && (MF(t3, 26), wF(t3, r2));
          let s2 = e3.deviceId;
          void 0 !== s2 && (MF(t3, 34), wF(t3, s2));
          let o2 = e3.elapse;
          void 0 !== o2 && (MF(t3, 40), UF(t3, o2));
          let a2 = e3.fileSize;
          void 0 !== a2 && (MF(t3, 48), UF(t3, TF(a2)));
          let c2 = e3.height;
          void 0 !== c2 && (MF(t3, 56), UF(t3, TF(c2)));
          let d2 = e3.jpg;
          void 0 !== d2 && (MF(t3, 66), MF(t3, d2.length), function(e4, t4) {
            let i3 = yF(e4, t4.length);
            e4.bytes.set(t4, i3);
          }(t3, d2));
          let l2 = e3.networkType;
          void 0 !== l2 && (MF(t3, 72), UF(t3, TF(l2)));
          let u2 = e3.osType;
          void 0 !== u2 && (MF(t3, 80), UF(t3, TF(u2)));
          let h3 = e3.requestId;
          void 0 !== h3 && (MF(t3, 90), wF(t3, h3));
          let p2 = e3.sdkVersion;
          void 0 !== p2 && (MF(t3, 98), wF(t3, p2));
          let _2 = e3.sequence;
          void 0 !== _2 && (MF(t3, 104), UF(t3, TF(_2)));
          let E2 = e3.sid;
          void 0 !== E2 && (MF(t3, 114), wF(t3, E2));
          let m2 = e3.timestamp;
          void 0 !== m2 && (MF(t3, 120), UF(t3, m2));
          let f2 = e3.uid;
          void 0 !== f2 && (MF(t3, 128), MF(t3, f2));
          let g2 = e3.vid;
          void 0 !== g2 && (MF(t3, 136), MF(t3, g2));
          let T2 = e3.width;
          void 0 !== T2 && (MF(t3, 144), UF(t3, TF(T2)));
          let S2 = e3.service;
          void 0 !== S2 && (MF(t3, 152), MF(t3, S2));
          let R2 = e3.callbackData;
          void 0 !== R2 && (MF(t3, 162), wF(t3, R2));
          let C2 = e3.jpgEncryption;
          void 0 !== C2 && (MF(t3, 168), MF(t3, C2));
          let I2 = e3.requestType;
          void 0 !== I2 && (MF(t3, 176), MF(t3, I2));
          let v2 = e3.scorePorn;
          void 0 !== v2 && (MF(t3, 185), LF(t3, v2));
          let y2 = e3.scoreSexy;
          void 0 !== y2 && (MF(t3, 193), LF(t3, y2));
          let A2 = e3.scoreNeutral;
          void 0 !== A2 && (MF(t3, 201), LF(t3, A2));
          let b2 = e3.scene;
          void 0 !== b2 && (MF(t3, 208), MF(t3, b2));
          let w2 = e3.ossFilePrefix;
          void 0 !== w2 && (MF(t3, 218), wF(t3, w2));
          let O2 = e3.serviceVendor;
          if (void 0 !== O2) for (let e4 of O2) {
            MF(t3, 226);
            let i3 = RF();
            pF(e4, i3), MF(t3, i3.limit), OF(t3, i3), CF(i3);
          }
        }(e2, t2), function(e3) {
          let t3 = e3.bytes, i2 = e3.limit;
          return t3.length === i2 ? t3 : t3.subarray(0, i2);
        }(t2);
      }
      function uF(e2) {
        return function(e3) {
          let t3 = {};
          e: for (; !vF(e3); ) {
            let i2 = kF(e3);
            switch (i2 >>> 3) {
              case 0:
                break e;
              case 1:
                t3.code = kF(e3);
                break;
              case 2:
                t3.msg = bF(e3, kF(e3));
                break;
              case 3: {
                let i3 = _F(e3);
                t3.data = hF(e3), e3.limit = i3;
                break;
              }
              default:
                EF(e3, 7 & i2);
            }
          }
          return t3;
        }({ bytes: t2 = e2, offset: 0, limit: t2.length });
        var t2;
      }
      function hF(e2) {
        let t2 = {};
        e: for (; !vF(e2); ) {
          let i2 = kF(e2);
          switch (i2 >>> 3) {
            case 0:
              break e;
            case 1:
              t2.requestId = bF(e2, kF(e2));
              break;
            case 2:
              t2.requestType = kF(e2) >>> 0;
              break;
            case 3:
              t2.scorePorn = PF(e2);
              break;
            case 4:
              t2.scoreSexy = PF(e2);
              break;
            case 5:
              t2.scoreNeutral = PF(e2);
              break;
            case 6:
              t2.requestScene = kF(e2) >>> 0;
              break;
            case 7:
              t2.scene = kF(e2) >>> 0;
              break;
            default:
              EF(e2, 7 & i2);
          }
        }
        return t2;
      }
      function pF(e2, t2) {
        let i2 = e2.service;
        void 0 !== i2 && (MF(t2, 8), MF(t2, i2));
        let n2 = e2.vendor;
        void 0 !== n2 && (MF(t2, 16), MF(t2, n2));
        let r2 = e2.token;
        void 0 !== r2 && (MF(t2, 26), wF(t2, r2));
        let s2 = e2.callbackUrl;
        void 0 !== s2 && (MF(t2, 34), wF(t2, s2));
      }
      function _F(e2) {
        let t2 = kF(e2), i2 = e2.limit;
        return e2.limit = e2.offset + t2, i2;
      }
      function EF(e2, t2) {
        switch (t2) {
          case 0:
            for (; 128 & NF(e2); ) ;
            break;
          case 2:
            IF(e2, kF(e2));
            break;
          case 5:
            IF(e2, 4);
            break;
          case 1:
            IF(e2, 8);
            break;
          default:
            throw new Error("Unimplemented type: " + t2);
        }
      }
      DI([dF, PI("design:type", Function), PI("design:paramtypes", [Object, Boolean]), PI("design:returntype", cg)], cF.prototype, "startP2PConnection", null), DI([dF, PI("design:type", Function), PI("design:paramtypes", [Object, Object, Array, Object, String, String]), PI("design:returntype", cg)], cF.prototype, "connect", null), DI([dF, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", void 0)], cF.prototype, "updateRemoteRTPCapabilities", null), DI([dF, PI("design:type", Function), PI("design:paramtypes", [Object, Object, Array, Object, String, String]), PI("design:returntype", cg)], cF.prototype, "preConnect", null), DI([dF, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], cF.prototype, "publishDataChannel", null), DI([dF, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], cF.prototype, "unpublish", null), DI([dF, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], cF.prototype, "unpublishDataChannel", null), DI([dF, PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", cg)], cF.prototype, "unpublishLowStream", null), DI([dF, PI("design:type", Function), PI("design:paramtypes", [sV, Array]), PI("design:returntype", cg)], cF.prototype, "subscribeDataChannel", null), DI([dF, PI("design:type", Function), PI("design:paramtypes", [sV, String, Number, Number, Array]), PI("design:returntype", cg)], cF.prototype, "subscribe", null), DI([dF, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], cF.prototype, "massSubscribe", null), DI([dF, PI("design:type", Function), PI("design:paramtypes", [sV, String, Boolean]), PI("design:returntype", cg)], cF.prototype, "unsubscribe", null), DI([dF, PI("design:type", Function), PI("design:paramtypes", [sV, Array]), PI("design:returntype", cg)], cF.prototype, "unsubscribeDataChannel", null), DI([dF, PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], cF.prototype, "massUnsubscribe", null), DI([dF, PI("design:type", Function), PI("design:paramtypes", [sV, String]), PI("design:returntype", cg)], cF.prototype, "muteRemote", null), DI([dF, PI("design:type", Function), PI("design:paramtypes", [sV, String]), PI("design:returntype", cg)], cF.prototype, "unmuteRemote", null), DI([dF, PI("design:type", Function), PI("design:paramtypes", [sV, String]), PI("design:returntype", cg)], cF.prototype, "hasRemoteMediaWithLock", null), DI([dF, PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", cg)], cF.prototype, "disconnectForReconnect", null), DI([dF, PI("design:type", Function), PI("design:paramtypes", [Object]), PI("design:returntype", cg)], cF.prototype, "updateBitrateLimit", null), DI([dF, PI("design:type", Function), PI("design:paramtypes", [sV, String, Number]), PI("design:returntype", cg)], cF.prototype, "remoteMediaSsrcChanged", null);
      let mF = new Float32Array(1);
      new Uint8Array(mF.buffer);
      let fF = new Float64Array(1), gF = new Uint8Array(fF.buffer);
      function TF(e2) {
        return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
      }
      let SF = [];
      function RF() {
        const e2 = SF.pop();
        return e2 ? (e2.offset = e2.limit = 0, e2) : { bytes: new Uint8Array(64), offset: 0, limit: 0 };
      }
      function CF(e2) {
        SF.push(e2);
      }
      function IF(e2, t2) {
        if (e2.offset + t2 > e2.limit) throw new Error("Skip past limit");
        e2.offset += t2;
      }
      function vF(e2) {
        return e2.offset >= e2.limit;
      }
      function yF(e2, t2) {
        let i2 = e2.bytes, n2 = e2.offset, r2 = e2.limit, s2 = n2 + t2;
        if (s2 > i2.length) {
          let t3 = new Uint8Array(2 * s2);
          t3.set(i2), e2.bytes = t3;
        }
        return e2.offset = s2, s2 > r2 && (e2.limit = s2), n2;
      }
      function AF(e2, t2) {
        let i2 = e2.offset;
        if (i2 + t2 > e2.limit) throw new Error("Read past limit");
        return e2.offset += t2, i2;
      }
      function bF(e2, t2) {
        let i2 = AF(e2, t2), n2 = String.fromCharCode, r2 = e2.bytes, s2 = "ï¿½", o2 = "";
        for (let e3 = 0; e3 < t2; e3++) {
          let a2, c2, d2, l2, u2 = r2[e3 + i2];
          0 == (128 & u2) ? o2 += n2(u2) : 192 == (224 & u2) ? e3 + 1 >= t2 ? o2 += s2 : (a2 = r2[e3 + i2 + 1], 128 != (192 & a2) ? o2 += s2 : (l2 = (31 & u2) << 6 | 63 & a2, l2 < 128 ? o2 += s2 : (o2 += n2(l2), e3++))) : 224 == (240 & u2) ? e3 + 2 >= t2 ? o2 += s2 : (a2 = r2[e3 + i2 + 1], c2 = r2[e3 + i2 + 2], 32896 != (49344 & (a2 | c2 << 8)) ? o2 += s2 : (l2 = (15 & u2) << 12 | (63 & a2) << 6 | 63 & c2, l2 < 2048 || l2 >= 55296 && l2 <= 57343 ? o2 += s2 : (o2 += n2(l2), e3 += 2))) : 240 == (248 & u2) ? e3 + 3 >= t2 ? o2 += s2 : (a2 = r2[e3 + i2 + 1], c2 = r2[e3 + i2 + 2], d2 = r2[e3 + i2 + 3], 8421504 != (12632256 & (a2 | c2 << 8 | d2 << 16)) ? o2 += s2 : (l2 = (7 & u2) << 18 | (63 & a2) << 12 | (63 & c2) << 6 | 63 & d2, l2 < 65536 || l2 > 1114111 ? o2 += s2 : (l2 -= 65536, o2 += n2(55296 + (l2 >> 10), 56320 + (1023 & l2)), e3 += 3))) : o2 += s2;
        }
        return o2;
      }
      function wF(e2, t2) {
        let i2 = t2.length, n2 = 0;
        for (let e3 = 0; e3 < i2; e3++) {
          let r3 = t2.charCodeAt(e3);
          r3 >= 55296 && r3 <= 56319 && e3 + 1 < i2 && (r3 = (r3 << 10) + t2.charCodeAt(++e3) - 56613888), n2 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
        }
        MF(e2, n2);
        let r2 = yF(e2, n2), s2 = e2.bytes;
        for (let e3 = 0; e3 < i2; e3++) {
          let n3 = t2.charCodeAt(e3);
          n3 >= 55296 && n3 <= 56319 && e3 + 1 < i2 && (n3 = (n3 << 10) + t2.charCodeAt(++e3) - 56613888), n3 < 128 ? s2[r2++] = n3 : (n3 < 2048 ? s2[r2++] = n3 >> 6 & 31 | 192 : (n3 < 65536 ? s2[r2++] = n3 >> 12 & 15 | 224 : (s2[r2++] = n3 >> 18 & 7 | 240, s2[r2++] = n3 >> 12 & 63 | 128), s2[r2++] = n3 >> 6 & 63 | 128), s2[r2++] = 63 & n3 | 128);
        }
      }
      function OF(e2, t2) {
        let i2 = yF(e2, t2.limit), n2 = e2.bytes, r2 = t2.bytes;
        for (let e3 = 0, s2 = t2.limit; e3 < s2; e3++) n2[e3 + i2] = r2[e3];
      }
      function NF(e2) {
        return e2.bytes[AF(e2, 1)];
      }
      function DF(e2, t2) {
        let i2 = yF(e2, 1);
        e2.bytes[i2] = t2;
      }
      function PF(e2) {
        let t2 = AF(e2, 8), i2 = e2.bytes;
        return gF[0] = i2[t2++], gF[1] = i2[t2++], gF[2] = i2[t2++], gF[3] = i2[t2++], gF[4] = i2[t2++], gF[5] = i2[t2++], gF[6] = i2[t2++], gF[7] = i2[t2++], fF[0];
      }
      function LF(e2, t2) {
        let i2 = yF(e2, 8), n2 = e2.bytes;
        fF[0] = t2, n2[i2++] = gF[0], n2[i2++] = gF[1], n2[i2++] = gF[2], n2[i2++] = gF[3], n2[i2++] = gF[4], n2[i2++] = gF[5], n2[i2++] = gF[6], n2[i2++] = gF[7];
      }
      function kF(e2) {
        let t2, i2 = 0, n2 = 0;
        do {
          t2 = NF(e2), i2 < 32 && (n2 |= (127 & t2) << i2), i2 += 7;
        } while (128 & t2);
        return n2;
      }
      function MF(e2, t2) {
        for (t2 >>>= 0; t2 >= 128; ) DF(e2, 127 & t2 | 128), t2 >>>= 7;
        DF(e2, t2);
      }
      function UF(e2, t2) {
        let i2 = t2.low >>> 0, n2 = (t2.low >>> 28 | t2.high << 4) >>> 0, r2 = t2.high >>> 24, s2 = 0 === r2 ? 0 === n2 ? i2 < 16384 ? i2 < 128 ? 1 : 2 : i2 < 1 << 21 ? 3 : 4 : n2 < 16384 ? n2 < 128 ? 5 : 6 : n2 < 1 << 21 ? 7 : 8 : r2 < 128 ? 9 : 10, o2 = yF(e2, s2), a2 = e2.bytes;
        switch (s2) {
          case 10:
            a2[o2 + 9] = r2 >>> 7 & 1;
          case 9:
            a2[o2 + 8] = 9 !== s2 ? 128 | r2 : 127 & r2;
          case 8:
            a2[o2 + 7] = 8 !== s2 ? n2 >>> 21 | 128 : n2 >>> 21 & 127;
          case 7:
            a2[o2 + 6] = 7 !== s2 ? n2 >>> 14 | 128 : n2 >>> 14 & 127;
          case 6:
            a2[o2 + 5] = 6 !== s2 ? n2 >>> 7 | 128 : n2 >>> 7 & 127;
          case 5:
            a2[o2 + 4] = 5 !== s2 ? 128 | n2 : 127 & n2;
          case 4:
            a2[o2 + 3] = 4 !== s2 ? i2 >>> 21 | 128 : i2 >>> 21 & 127;
          case 3:
            a2[o2 + 2] = 3 !== s2 ? i2 >>> 14 | 128 : i2 >>> 14 & 127;
          case 2:
            a2[o2 + 1] = 2 !== s2 ? i2 >>> 7 | 128 : i2 >>> 7 & 127;
          case 1:
            a2[o2] = 1 !== s2 ? 128 | i2 : 127 & i2;
        }
      }
      function xF(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      const VF = /* @__PURE__ */ new Map([["moderation", 1], ["supervise", 2]]);
      class FF extends dT {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          if (this._connectionState === e2) return;
          const t2 = this._connectionState;
          this._connectionState = e2, this.emit(mv.CONNECTION_STATE_CHANGE, t2, e2);
        }
        get inspectType() {
          return this._inspectType;
        }
        set inspectType(e2) {
          var t2;
          this._inspectMode = BT(t2 = e2.map((e3) => VF.get(e3) || 0)).call(t2, (e3, t3) => e3 + t3), this._inspectType = e2;
        }
        get quality() {
          return this._quality;
        }
        set quality(e2) {
          this._quality = e2 > 1 ? 1 : e2 < 0.1 ? 0.1 : e2, this.qualityTimer && (window.clearTimeout(this.qualityTimer), this.qualityTimer = null), this._quality >= 1 || (this.qualityTimer = window.setTimeout(() => {
            this.quality = this._quality / this.qualityRatio;
          }, 6e4));
        }
        constructor(e2) {
          super(), sh(this, "name", "AgoraRTCVideoContentInspect"), sh(this, "_connectionState", _v.CONNECTING), sh(this, "_innerConnectionState", void 0), sh(this, "sequence", 0), sh(this, "inspectStartTime", void 0), sh(this, "workerManagerConnection", void 0), sh(this, "workerConnection", void 0), sh(this, "workerMessageLengthLimit", void 0), sh(this, "inspectIntervalMinimum", void 0), sh(this, "qualityRatio", void 0), sh(this, "_connectInfo", void 0), sh(this, "_cancelTokenSource", sC.CancelToken.source()), sh(this, "_retryConfig", void 0), sh(this, "wmSequence", 0), sh(this, "inspectInterval", void 0), sh(this, "inspectTimer", null), sh(this, "ossFilePrefix", void 0), sh(this, "extraInfo", void 0), sh(this, "_inspectType", void 0), sh(this, "_inspectMode", void 0), sh(this, "_quality", 1), sh(this, "qualityTimer", null), sh(this, "_inspectId", void 0), sh(this, "_needWorkUrlOnly", false), sh(this, "inspectImage", () => {
            if (this.connectionState !== _v.CONNECTED) throw new LI(Hg.OPERATION_ABORTED, "content inspect service connection status is ".concat(this.connectionState));
            this.inspectTimer && (window.clearInterval(this.inspectTimer), this.inspectTimer = null), this.inspectTimer = window.setInterval(() => {
              this.connectionState === _v.CONNECTED ? this.requestToInspectImage() : jC.debug("[".concat(this._inspectId, "] Inspect State is not connected , "), this.connectionState);
            }, this.inspectInterval < this.inspectIntervalMinimum ? this.inspectIntervalMinimum : this.inspectInterval), this.requestToInspectImage();
          }), this._inspectId = nS(5, "inspect-"), this.workerMessageLengthLimit = RC("VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT"), this.inspectIntervalMinimum = RC("VIDEO_INSPECT_INTERVAL_MINIMUM"), this.qualityRatio = RC("VIDEO_INSPECT_QUALITY_RATIO"), this.inspectInterval = e2.interval, this.ossFilePrefix = e2.ossFilePrefix, this.extraInfo = e2.extraInfo, this.inspectType = e2.inspectType, this.inspectStartTime = Number(Date.now()), this.workerManagerConnection = new zv("worker-manager-" + this._inspectId, ES), this.on(mv.STATE_CHANGE, (e3, t2) => {
            this._innerConnectionState = e3, jC.debug("[".concat(this._inspectId, "] Inspect operation :").concat(Ev[e3], " ").concat(t2 || ""));
          }), this.handleWorkerManagerEvents(), this.workerConnection = new zv("worker-" + this._inspectId, ES), this.handleWorkerEvents();
        }
        async init(e2, t2) {
          this.emit(mv.STATE_CHANGE, Ev.CONNECT_AP), this._connectInfo = e2;
          const i2 = this._cancelTokenSource.token;
          return this._retryConfig = t2, new cg((n2, r2) => {
            this.on(mv.CONNECTION_STATE_CHANGE, (e3, t3) => {
              t3 === _v.CONNECTED && n2();
            }), this.requestAP(e2, i2, t2).then((e3) => {
              this.connectWorkerManager(e3);
            }).catch((e3) => {
              r2(e3);
            });
          });
        }
        async requestAP(e2, t2, i2) {
          const n2 = RC("WEBCS_DOMAIN").map((e3) => "https://".concat(e3, "/api/v1")), r2 = await function(e3, t3, i3, n3) {
            let { appId: r3, areaCode: s3, cname: o2, sid: a2, token: c2, uid: d2 } = t3;
            cA++;
            const l2 = "image_moderation_api", u2 = { service_name: l2, json_body: JSON.stringify({ appId: r3, areaCode: s3, cname: o2, command: "allocateEdge", requestId: cA, seq: cA, sid: a2, token: c2, ts: Date.now(), uid: d2 + "" }) };
            let h3, p2, _2 = e3[0];
            return fS(async () => {
              h3 = Date.now();
              const e4 = await By(_2, { data: u2, cancelToken: i3, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" }, params: { action: "wrtc_gateway" } });
              if (p2 = Date.now() - h3, 0 !== e4.code) {
                const t5 = new LI(Hg.UNEXPECTED_RESPONSE, "image inspect ap error, code" + e4.code, { retry: true, responseTime: p2 });
                throw jC.error(t5.toString()), t5;
              }
              const t4 = JSON.parse(e4.json_body);
              if (200 !== t4.code) {
                const e5 = new LI(Hg.UNEXPECTED_RESPONSE, "image inspect ap error, code: ".concat(t4.code, ", reason: ").concat(t4.reason), { code: t4.code, responseTime: p2 });
                throw jC.error(e5.toString()), e5;
              }
              if (!t4.servers || !Array.isArray(t4.servers) || 0 === t4.servers.length) {
                const e5 = new LI(Hg.UNEXPECTED_RESPONSE, "image inspect ap empty server", { code: t4.code, responseTime: p2 });
                throw jC.error(e5.toString()), e5;
              }
              const n4 = RC("VIDEO_INSPECT_WORKER_MANAGER_HOST"), r4 = RC("VIDEO_INSPECT_WORKER_MANAGER_PORT");
              return { addressList: t4.servers.map((e5) => {
                let { address: t5, wss: i4 } = e5;
                if (t5 && i4) return "wss://".concat(t5.replace(/\./g, "-"), ".").concat(n4, ":").concat(r4 || i4);
              }).filter((e5) => !!e5), workerToken: t4.workerToken, vid: t4.vid, responseTime: p2 };
            }, (t4, i4) => (eI.apworkerEvent(a2, { success: true, sc: 200, serviceName: l2, responseDetail: JSON.stringify(t4.addressList), firstSuccess: 0 === i4, responseTime: p2, serverIp: e3[i4 % e3.length] }), false), (t4, i4) => (eI.apworkerEvent(a2, { success: false, sc: t4.data && t4.data.code || 200, serviceName: l2, responseTime: p2, serverIp: e3[i4 % e3.length] }), !!(t4.code !== Hg.OPERATION_ABORTED && t4.code !== Hg.UNEXPECTED_RESPONSE || t4.data && t4.data.retry) && (_2 = e3[(i4 + 1) % e3.length], true)), n3);
          }(n2, e2, t2, i2);
          this.emit(mv.STATE_CHANGE, Ev.AP_CONNECTED);
          const { addressList: s2 } = r2;
          return this.wmSequence++, s2;
        }
        async connectWorkerManager(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          this._needWorkUrlOnly = t2, this.emit(mv.STATE_CHANGE, Ev.CONNECT_WORKER_MANAGER), await this.workerManagerConnection.init(e2, 1e4);
        }
        async connectWorker(e2) {
          await this.workerConnection.init([e2]);
        }
        handleWorkerManagerEvents() {
          this.workerManagerConnection.on(SI.CONNECTED, async () => {
            this.emit(mv.STATE_CHANGE, Ev.WORKER_MANAGER_CONNECTED, this.workerManagerConnection.url), this.workerManagerConnection.sendMessage({ appId: this._connectInfo.appId, cname: this._connectInfo.cname, uid: this._connectInfo.uid + "", sdkVersion: "4.20.2", sid: this._connectInfo.sid, seq: this.wmSequence, ts: Number(Date.now()), requestId: Math.floor(1e12 * Math.random()), allocate: true, clientRequest: { command: "join" } }, true);
          }), this.workerManagerConnection.on(SI.CLOSED, () => {
            this._innerConnectionState < Ev.GET_WORKER_MANAGER_RESPONSE && jC.debug("[".concat(this._inspectId, "] Inspect worker manager is closed before connecting worker"));
          }), this.workerManagerConnection.on(SI.FAILED, () => {
            this._innerConnectionState < Ev.GET_WORKER_MANAGER_RESPONSE && jC.debug("[".concat(this._inspectId, "] Connecting inspect worker manager is failed before connecting worker"));
          }), this.workerManagerConnection.on(SI.RECONNECTING, () => {
            this._innerConnectionState < Ev.GET_WORKER_MANAGER_RESPONSE && jC.debug("[".concat(this._inspectId, "] Inspect worker manager is reconnecting before connecting worker"));
          }), this.workerManagerConnection.on(SI.ON_MESSAGE, async (e2) => {
            this.emit(mv.STATE_CHANGE, Ev.GET_WORKER_MANAGER_RESPONSE);
            const t2 = this.workerManagerConnection.url;
            this.workerManagerConnection.close();
            const i2 = JSON.parse(e2.data);
            if (200 !== i2.code) throw jC.error("[".concat(this._inspectId, "] Unexpected code ").concat(i2.code, " from worker manager")), new LI(Hg.UNEXPECTED_RESPONSE, "response code of worker is unexpected", i2);
            if (!(i2.serverResponse && i2.serverResponse.portWss && t2)) throw jC.error("[".concat(this._inspectId, "] Unexpected content from worker manager : ").concat(JSON.stringify(i2))), new LI(Hg.UNEXPECTED_RESPONSE, "response content of worker is unexpected", i2);
            {
              const e3 = RC("VIDEO_INSPECT_WORKER_PORT") || i2.serverResponse.portWss, n2 = t2.replace(/:\d+\/?$/, ":".concat(e3));
              this.emit(mv.STATE_CHANGE, Ev.CONNECT_WORKER, n2), this._needWorkUrlOnly ? this.emit(mv.REQUEST_NEW_WORKER_URL, n2) : await this.connectWorker(n2);
            }
          }), this.workerManagerConnection.on(SI.WILL_RECONNECT, (e2, t2, i2) => {
            i2(e2);
          }), this.workerManagerConnection.on(SI.REQUEST_NEW_URLS, (e2, t2) => {
            this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e2).catch(t2);
          });
        }
        handleWorkerEvents() {
          this.workerConnection.on(SI.CONNECTED, async () => {
            this.emit(mv.STATE_CHANGE, Ev.WORKER_CONNECTED, this.workerConnection.url), this.connectionState = _v.CONNECTED;
          }), this.workerConnection.on(SI.ON_MESSAGE, async (e2) => {
            if (e2.data instanceof ArrayBuffer) {
              const i2 = uF(new Uint8Array(e2.data));
              if (RC("SHOW_VIDEO_INSPECT_WORKER_MESSAGE") && jC.debug("[".concat(this._inspectId, "] Response message for worker of inspect content "), JSON.stringify(i2)), 200 === i2.code) {
                if (Array.isArray(this.inspectType) && 1 === this.inspectType.length && "supervise" === this.inspectType[0]) return void this.emit(mv.INSPECT_RESULT, void 0, void 0);
                if (i2.data && i2.data.scorePorn && i2.data.scoreSexy && i2.data.scoreNeutral) {
                  var t2;
                  const e3 = { porn: i2.data.scorePorn, sexy: i2.data.scoreSexy, neutral: i2.data.scoreNeutral }, n2 = BT(t2 = Object.keys(e3)).call(t2, (t3, i3) => e3[t3] > e3[i3] ? t3 : i3, "porn"), r2 = Object.keys(e3).find((e4) => e4 === n2);
                  this.emit(mv.INSPECT_RESULT, r2);
                } else this.emit(mv.INSPECT_RESULT, void 0, new LI(Hg.UNEXPECTED_RESPONSE, i2.code + "", "There is an unexpected data on message"));
              } else this.emit(mv.INSPECT_RESULT, void 0, new LI(Hg.UNEXPECTED_RESPONSE, i2.code + "", i2.msg));
            } else jC.error("[".concat(this._inspectId, "] Unexpected message type from worker")), this.emit(mv.INSPECT_RESULT, void 0, new LI(Hg.UNEXPECTED_RESPONSE, "invalid worker message type"));
          }), this.workerConnection.on(SI.CLOSED, () => {
            this.connectionState = _v.CLOSED;
          }), this.workerConnection.on(SI.FAILED, () => {
            this.connectionState = _v.CLOSED;
          }), this.workerConnection.on(SI.RECONNECTING, () => {
            this.connectionState = this.connectionState === _v.CONNECTED ? _v.RECONNECTING : _v.CONNECTING;
          }), this.workerConnection.on(SI.WILL_RECONNECT, (e2, t2, i2) => {
            "recover" === e2 && i2(e2), i2("tryNext");
          }), this.workerConnection.on(SI.REQUEST_NEW_URLS, (e2, t2) => {
            this.workerManagerConnection.close(), this.once(mv.REQUEST_NEW_WORKER_URL, (t3) => {
              e2([t3]);
            }), this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then((e3) => {
              this.connectWorkerManager(e3, true);
            }).catch((e3) => {
              t2(e3);
            });
          });
        }
        static intToLong(e2) {
          return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
        }
        async requestToInspectImage() {
          this.sequence++;
          const e2 = AT(this, mv.CLIENT_LOCAL_VIDEO_TRACK), t2 = { appId: this._connectInfo.appId, cname: this._connectInfo.cname, cid: this._connectInfo.cid, sid: this._connectInfo.sid, uid: this._connectInfo.uid, vid: this._connectInfo.vid };
          if (e2) {
            if (!e2.isPlaying) return void this.emit(mv.INSPECT_RESULT, void 0, new LI(Hg.INVALID_OPERATION, "Only the track being played can be inspected"));
            const i2 = await this.generateRequestData(e2, t2);
            this.workerConnection.sendMessage(i2, true, true);
          } else this.emit(mv.INSPECT_RESULT, void 0, new LI(Hg.INVALID_OPERATION, "Only the track being published can be inspected"));
        }
        async generateRequestData(e2, t2) {
          let { appId: i2, cname: n2, cid: r2, vid: s2, sid: o2, uid: a2 } = t2;
          const c2 = Date.now(), d2 = await e2.getCurrentFrameImage("image/jpeg", this.quality), l2 = await gw(d2, i2, n2), u2 = this.sequence + "-" + r2 + "-" + a2 + "-" + c2 + "-" + nS(12, ""), h3 = { appId: i2, cid: r2, cname: n2, deviceId: "", elapse: FF.intToLong(Number(c2 - this.inspectStartTime)), fileSize: l2.byteLength, jpgEncryption: 2, height: d2.height, width: d2.width, jpg: l2, networkType: 6, osType: 7, requestId: u2, sdkVersion: "4.20.2", sequence: this.sequence, sid: o2, timestamp: FF.intToLong(c2), uid: a2, vid: s2, service: this._inspectMode, callbackData: this.extraInfo, ossFilePrefix: this.ossFilePrefix };
          void 0 === this.extraInfo && delete h3.callbackData, void 0 === this.ossFilePrefix && delete h3.ossFilePrefix;
          const p2 = lF(h3);
          if (p2.byteLength < this.workerMessageLengthLimit) {
            if (RC("SHOW_VIDEO_INSPECT_WORKER_MESSAGE")) {
              const e3 = function(e4) {
                for (var t3 = 1; t3 < arguments.length; t3++) {
                  var i3 = null != arguments[t3] ? arguments[t3] : {};
                  t3 % 2 ? xF(Object(i3), true).forEach(function(t4) {
                    sh(e4, t4, i3[t4]);
                  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(i3)) : xF(Object(i3)).forEach(function(t4) {
                    Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(i3, t4));
                  });
                }
                return e4;
              }({}, h3);
              delete e3.jpg, jC.debug("[".concat(this._inspectId, "] Request message for worker of inspect content "), JSON.stringify(e3));
            }
            return p2;
          }
          {
            const t3 = this.quality * this.qualityRatio;
            return this.quality = t3, await this.generateRequestData(e2, { appId: i2, cname: n2, cid: r2, vid: s2, sid: o2, uid: a2 });
          }
        }
        close() {
          this._cancelTokenSource.cancel(), this._cancelTokenSource = sC.CancelToken.source(), this.workerManagerConnection && this.workerManagerConnection.close(), this.workerConnection && this.workerConnection.close(), this.inspectTimer && window.clearInterval(this.inspectTimer), this.inspectTimer = null, this.connectionState = _v.CLOSED, this.emit(mv.STATE_CHANGE, Ev.CLOSED);
        }
      }
      function BF(e2) {
        let t2 = function() {
          const e3 = HF.pop();
          return e3 ? (e3.offset = e3.limit = 0, e3) : { bytes: new Uint8Array(64), offset: 0, limit: 0 };
        }();
        return function(e3, t3) {
          let i2 = e3.appId;
          void 0 !== i2 && (tB(t3, 10), QF(t3, i2));
          let n2 = e3.cid;
          void 0 !== n2 && (tB(t3, 16), tB(t3, n2));
          let r2 = e3.cname;
          void 0 !== r2 && (tB(t3, 26), QF(t3, r2));
          let s2 = e3.deviceId;
          void 0 !== s2 && (tB(t3, 34), QF(t3, s2));
          let o2 = e3.elapse;
          void 0 !== o2 && (tB(t3, 40), nB(t3, o2));
          let a2 = e3.fileSize;
          void 0 !== a2 && (tB(t3, 48), nB(t3, WF(a2)));
          let c2 = e3.height;
          void 0 !== c2 && (tB(t3, 56), nB(t3, WF(c2)));
          let d2 = e3.jpg;
          void 0 !== d2 && (tB(t3, 66), tB(t3, d2.length), JF(t3, d2));
          let l2 = e3.networkType;
          void 0 !== l2 && (tB(t3, 72), nB(t3, WF(l2)));
          let u2 = e3.osType;
          void 0 !== u2 && (tB(t3, 80), nB(t3, WF(u2)));
          let h3 = e3.requestId;
          void 0 !== h3 && (tB(t3, 90), QF(t3, h3));
          let p2 = e3.sdkVersion;
          void 0 !== p2 && (tB(t3, 98), QF(t3, p2));
          let _2 = e3.sequence;
          void 0 !== _2 && (tB(t3, 104), nB(t3, WF(_2)));
          let E2 = e3.sid;
          void 0 !== E2 && (tB(t3, 114), QF(t3, E2));
          let m2 = e3.timestamp;
          void 0 !== m2 && (tB(t3, 120), nB(t3, m2));
          let f2 = e3.uid;
          void 0 !== f2 && (tB(t3, 128), tB(t3, f2));
          let g2 = e3.vid;
          void 0 !== g2 && (tB(t3, 136), tB(t3, g2));
          let T2 = e3.width;
          void 0 !== T2 && (tB(t3, 144), nB(t3, WF(T2)));
          let S2 = e3.service;
          void 0 !== S2 && (tB(t3, 152), tB(t3, S2));
          let R2 = e3.callbackData;
          void 0 !== R2 && (tB(t3, 162), tB(t3, R2.length), JF(t3, R2));
          let C2 = e3.ticket;
          void 0 !== C2 && (tB(t3, 170), QF(t3, C2));
          let I2 = e3.vendorConfigs;
          void 0 !== I2 && (tB(t3, 178), QF(t3, I2));
        }(e2, t2), function(e3) {
          let t3 = e3.bytes, i2 = e3.limit;
          return t3.length === i2 ? t3 : t3.subarray(0, i2);
        }(t2);
      }
      function jF(e2) {
        return function(e3) {
          let t3 = {};
          e: for (; !YF(e3); ) {
            let i2 = eB(e3);
            switch (i2 >>> 3) {
              case 0:
                break e;
              case 1:
                t3.code = eB(e3);
                break;
              case 2:
                t3.msg = XF(e3, eB(e3));
                break;
              case 3:
                t3.requestId = XF(e3, eB(e3));
                break;
              case 4:
                t3.timestamp = iB(e3, false);
                break;
              default:
                GF(e3, 7 & i2);
            }
          }
          return t3;
        }({ bytes: t2 = e2, offset: 0, limit: t2.length });
        var t2;
      }
      function GF(e2, t2) {
        switch (t2) {
          case 0:
            for (; 128 & ZF(e2); ) ;
            break;
          case 2:
            KF(e2, eB(e2));
            break;
          case 5:
            KF(e2, 4);
            break;
          case 1:
            KF(e2, 8);
            break;
          default:
            throw new Error("Unimplemented type: " + t2);
        }
      }
      function WF(e2) {
        return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
      }
      let HF = [];
      function KF(e2, t2) {
        if (e2.offset + t2 > e2.limit) throw new Error("Skip past limit");
        e2.offset += t2;
      }
      function YF(e2) {
        return e2.offset >= e2.limit;
      }
      function qF(e2, t2) {
        let i2 = e2.bytes, n2 = e2.offset, r2 = e2.limit, s2 = n2 + t2;
        if (s2 > i2.length) {
          let t3 = new Uint8Array(2 * s2);
          t3.set(i2), e2.bytes = t3;
        }
        return e2.offset = s2, s2 > r2 && (e2.limit = s2), n2;
      }
      function zF(e2, t2) {
        let i2 = e2.offset;
        if (i2 + t2 > e2.limit) throw new Error("Read past limit");
        return e2.offset += t2, i2;
      }
      function JF(e2, t2) {
        let i2 = qF(e2, t2.length);
        e2.bytes.set(t2, i2);
      }
      function XF(e2, t2) {
        let i2 = zF(e2, t2), n2 = String.fromCharCode, r2 = e2.bytes, s2 = "ï¿½", o2 = "";
        for (let e3 = 0; e3 < t2; e3++) {
          let a2, c2, d2, l2, u2 = r2[e3 + i2];
          0 == (128 & u2) ? o2 += n2(u2) : 192 == (224 & u2) ? e3 + 1 >= t2 ? o2 += s2 : (a2 = r2[e3 + i2 + 1], 128 != (192 & a2) ? o2 += s2 : (l2 = (31 & u2) << 6 | 63 & a2, l2 < 128 ? o2 += s2 : (o2 += n2(l2), e3++))) : 224 == (240 & u2) ? e3 + 2 >= t2 ? o2 += s2 : (a2 = r2[e3 + i2 + 1], c2 = r2[e3 + i2 + 2], 32896 != (49344 & (a2 | c2 << 8)) ? o2 += s2 : (l2 = (15 & u2) << 12 | (63 & a2) << 6 | 63 & c2, l2 < 2048 || l2 >= 55296 && l2 <= 57343 ? o2 += s2 : (o2 += n2(l2), e3 += 2))) : 240 == (248 & u2) ? e3 + 3 >= t2 ? o2 += s2 : (a2 = r2[e3 + i2 + 1], c2 = r2[e3 + i2 + 2], d2 = r2[e3 + i2 + 3], 8421504 != (12632256 & (a2 | c2 << 8 | d2 << 16)) ? o2 += s2 : (l2 = (7 & u2) << 18 | (63 & a2) << 12 | (63 & c2) << 6 | 63 & d2, l2 < 65536 || l2 > 1114111 ? o2 += s2 : (l2 -= 65536, o2 += n2(55296 + (l2 >> 10), 56320 + (1023 & l2)), e3 += 3))) : o2 += s2;
        }
        return o2;
      }
      function QF(e2, t2) {
        let i2 = t2.length, n2 = 0;
        for (let e3 = 0; e3 < i2; e3++) {
          let r3 = t2.charCodeAt(e3);
          r3 >= 55296 && r3 <= 56319 && e3 + 1 < i2 && (r3 = (r3 << 10) + t2.charCodeAt(++e3) - 56613888), n2 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
        }
        tB(e2, n2);
        let r2 = qF(e2, n2), s2 = e2.bytes;
        for (let e3 = 0; e3 < i2; e3++) {
          let n3 = t2.charCodeAt(e3);
          n3 >= 55296 && n3 <= 56319 && e3 + 1 < i2 && (n3 = (n3 << 10) + t2.charCodeAt(++e3) - 56613888), n3 < 128 ? s2[r2++] = n3 : (n3 < 2048 ? s2[r2++] = n3 >> 6 & 31 | 192 : (n3 < 65536 ? s2[r2++] = n3 >> 12 & 15 | 224 : (s2[r2++] = n3 >> 18 & 7 | 240, s2[r2++] = n3 >> 12 & 63 | 128), s2[r2++] = n3 >> 6 & 63 | 128), s2[r2++] = 63 & n3 | 128);
        }
      }
      function ZF(e2) {
        return e2.bytes[zF(e2, 1)];
      }
      function $F(e2, t2) {
        let i2 = qF(e2, 1);
        e2.bytes[i2] = t2;
      }
      function eB(e2) {
        let t2, i2 = 0, n2 = 0;
        do {
          t2 = ZF(e2), i2 < 32 && (n2 |= (127 & t2) << i2), i2 += 7;
        } while (128 & t2);
        return n2;
      }
      function tB(e2, t2) {
        for (t2 >>>= 0; t2 >= 128; ) $F(e2, 127 & t2 | 128), t2 >>>= 7;
        $F(e2, t2);
      }
      function iB(e2, t2) {
        let i2, n2 = 0, r2 = 0, s2 = 0;
        return i2 = ZF(e2), n2 = 127 & i2, 128 & i2 && (i2 = ZF(e2), n2 |= (127 & i2) << 7, 128 & i2 && (i2 = ZF(e2), n2 |= (127 & i2) << 14, 128 & i2 && (i2 = ZF(e2), n2 |= (127 & i2) << 21, 128 & i2 && (i2 = ZF(e2), r2 = 127 & i2, 128 & i2 && (i2 = ZF(e2), r2 |= (127 & i2) << 7, 128 & i2 && (i2 = ZF(e2), r2 |= (127 & i2) << 14, 128 & i2 && (i2 = ZF(e2), r2 |= (127 & i2) << 21, 128 & i2 && (i2 = ZF(e2), s2 = 127 & i2, 128 & i2 && (i2 = ZF(e2), s2 |= (127 & i2) << 7))))))))), { low: n2 | r2 << 28, high: r2 >>> 4 | s2 << 24, unsigned: t2 };
      }
      function nB(e2, t2) {
        let i2 = t2.low >>> 0, n2 = (t2.low >>> 28 | t2.high << 4) >>> 0, r2 = t2.high >>> 24, s2 = 0 === r2 ? 0 === n2 ? i2 < 16384 ? i2 < 128 ? 1 : 2 : i2 < 1 << 21 ? 3 : 4 : n2 < 16384 ? n2 < 128 ? 5 : 6 : n2 < 1 << 21 ? 7 : 8 : r2 < 128 ? 9 : 10, o2 = qF(e2, s2), a2 = e2.bytes;
        switch (s2) {
          case 10:
            a2[o2 + 9] = r2 >>> 7 & 1;
          case 9:
            a2[o2 + 8] = 9 !== s2 ? 128 | r2 : 127 & r2;
          case 8:
            a2[o2 + 7] = 8 !== s2 ? n2 >>> 21 | 128 : n2 >>> 21 & 127;
          case 7:
            a2[o2 + 6] = 7 !== s2 ? n2 >>> 14 | 128 : n2 >>> 14 & 127;
          case 6:
            a2[o2 + 5] = 6 !== s2 ? n2 >>> 7 | 128 : n2 >>> 7 & 127;
          case 5:
            a2[o2 + 4] = 5 !== s2 ? 128 | n2 : 127 & n2;
          case 4:
            a2[o2 + 3] = 4 !== s2 ? i2 >>> 21 | 128 : i2 >>> 21 & 127;
          case 3:
            a2[o2 + 2] = 3 !== s2 ? i2 >>> 14 | 128 : i2 >>> 14 & 127;
          case 2:
            a2[o2 + 1] = 2 !== s2 ? i2 >>> 7 | 128 : i2 >>> 7 & 127;
          case 1:
            a2[o2] = 1 !== s2 ? 128 | i2 : 127 & i2;
        }
      }
      const rB = {}, sB = {}, oB = 4294967296, aB = oB * oB, cB = aB / 2, dB = _B(0, true), lB = _B(0), uB = EB(0, -2147483648, false), hB = EB(-1, 2147483647, false), pB = EB(-1, -1, true);
      function _B(e2, t2) {
        let i2, n2, r2;
        return t2 ? (r2 = 0 <= (e2 >>>= 0) && e2 < 256) && (n2 = sB[e2], n2) ? n2 : (i2 = EB(e2, 0, true), r2 && (sB[e2] = i2), i2) : (r2 = -128 <= (e2 |= 0) && e2 < 128) && (n2 = rB[e2], n2) ? n2 : (i2 = EB(e2, e2 < 0 ? -1 : 0, false), r2 && (rB[e2] = i2), i2);
      }
      function EB(e2, t2, i2) {
        return { low: 0 | e2, high: 0 | t2, unsigned: !!i2 };
      }
      function mB(e2, t2) {
        if (isNaN(e2)) return t2 ? dB : lB;
        if (t2) {
          if (e2 < 0) return dB;
          if (e2 >= aB) return pB;
        } else {
          if (e2 <= -cB) return uB;
          if (e2 + 1 >= cB) return hB;
        }
        return e2 < 0 ? t2 ? dB : lB : EB(e2 % oB | 0, e2 / oB | 0, t2);
      }
      function fB(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      class gB extends dT {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          if (this._connectionState === e2) return;
          const t2 = this._connectionState;
          this._connectionState = e2, this.emit(Cv.CONNECTION_STATE_CHANGE, e2, t2);
        }
        get quality() {
          return this._quality;
        }
        set quality(e2) {
          this._quality = e2 > 1 ? 1 : e2 < 0.1 ? 0.1 : e2, this._qualityTimer && (window.clearTimeout(this._qualityTimer), this._qualityTimer = null), this._quality >= 1 || (this._qualityTimer = window.setTimeout(() => {
            this.quality = this._quality / this._qualityRatio;
          }, 6e4));
        }
        constructor(e2) {
          var t2;
          super(), sh(this, "name", "AgoraRTCImageModeration"), sh(this, "_connectionState", Rv.CONNECTING), sh(this, "_sequence", 0), sh(this, "_moderationStartTime", void 0), sh(this, "_workerConnection", void 0), sh(this, "_workerMessageLengthLimit", void 0), sh(this, "_qualityRatio", void 0), sh(this, "_connectInfo", void 0), sh(this, "_cancelTokenSource", sC.CancelToken.source()), sh(this, "_retryConfig", void 0), sh(this, "_moderationInterval", void 0), sh(this, "_moderationTimer", null), sh(this, "_moderationMode", 1), sh(this, "_quality", 1), sh(this, "_qualityTimer", null), sh(this, "_ticket", void 0), sh(this, "_moderationIntervalMinimum", void 0), sh(this, "_uploadFailedNum", 0), sh(this, "_uploadNum", 0), sh(this, "_uploadTimer", null), sh(this, "_extraInfo", void 0), sh(this, "_vendor", ""), sh(this, "_encoder", new TextEncoder()), sh(this, "_moderationId", void 0), sh(this, "inspectImage", () => {
            if (this.connectionState !== Rv.CONNECTED) throw new LI(Hg.OPERATION_ABORTED, "image moderation service connection status is ".concat(this.connectionState));
            this._moderationTimer && (window.clearInterval(this._moderationTimer), this._moderationTimer = null), this._moderationTimer = window.setInterval(() => {
              this.connectionState === Rv.CONNECTED ? this.requestToInspectImage() : jC.debug("[".concat(this._moderationId, "] Moderation State is not connected , "), this.connectionState);
            }, this._moderationInterval < this._moderationIntervalMinimum ? this._moderationIntervalMinimum : this._moderationInterval), this.requestToInspectImage();
          }), this._moderationId = nS(5, "image-moderation-"), this._workerMessageLengthLimit = RC("IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT"), this._moderationIntervalMinimum = RC("IMAGE_MODERATION_INTERVAL_MINIMUM"), this._moderationInterval = null !== (t2 = e2.interval) && void 0 !== t2 ? t2 : 1e3, e2.extraInfo && (this._extraInfo = this._encoder.encode(e2.extraInfo)), e2.vendor && (this._vendor = e2.vendor), this._qualityRatio = RC("IMAGE_MODERATION_QUALITY_RATIO"), this._moderationStartTime = Number(Date.now()), this._workerConnection = new zv("worker-" + this._moderationId, ES), this.on(Cv.STATE_CHANGE, (e3, t3) => {
            jC.debug("[".concat(this._moderationId, "] Moderation operation :").concat(Iv[e3], " ").concat(t3 || ""));
          }), this.handleWorkerEvents();
        }
        async init(e2, t2) {
          this.emit(Cv.STATE_CHANGE, Iv.CONNECT_AP), this._connectInfo = e2;
          const i2 = this._cancelTokenSource.token;
          return this._retryConfig = t2, new cg((n2, r2) => {
            this.on(Cv.CONNECTION_STATE_CHANGE, (e3, t3) => {
              e3 === Rv.CONNECTED && n2();
            }), this.requestAP(e2, i2, t2).then((e3) => {
              this.connectWorker(e3);
            }).catch((e3) => {
              r2(e3);
            });
          });
        }
        updateConfig(e2) {
          var t2;
          this._moderationInterval = null !== (t2 = e2.interval) && void 0 !== t2 ? t2 : 1e3, e2.extraInfo && (this._extraInfo = this._encoder.encode(e2.extraInfo)), e2.vendor && (this._vendor = e2.vendor), jC.debug("[".concat(this._moderationId, "] updateConfig: ").concat(JSON.stringify(e2))), this.connectionState === Rv.CONNECTED && this.inspectImage();
        }
        async requestAP(e2, t2, i2) {
          const n2 = RC("WEBCS_DOMAIN").map((e3) => "https://".concat(e3, "/api/v1")), r2 = await function(e3, t3, i3, n3) {
            let { appId: r3, areaCode: s3, cname: o3, sid: a2, token: c2, uid: d2 } = t3;
            cA++;
            const l2 = "moderation_plugin", u2 = { service_name: l2, json_body: JSON.stringify({ appId: r3, areaCode: s3, cname: o3, command: "allocateEdge", requestId: cA, seq: cA, sid: a2, appToken: c2, ts: Date.now(), uid: d2 + "" }) };
            let h3, p2, _2 = e3[0];
            return fS(async () => {
              h3 = Date.now();
              const e4 = await By(_2, { data: u2, cancelToken: i3, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" }, params: { action: "wrtc_gateway" } });
              if (p2 = Date.now() - h3, 0 !== e4.code) {
                const t5 = new LI(Hg.UNEXPECTED_RESPONSE, "moderation plugin ap error, code" + e4.code, { retry: true, responseTime: p2 });
                throw jC.error(t5.toString()), t5;
              }
              const t4 = JSON.parse(e4.json_body);
              if (200 !== t4.code) {
                const e5 = new LI(Hg.UNEXPECTED_RESPONSE, "moderation plugin ap error, code: ".concat(t4.code, ", reason: ").concat(t4.reason), { code: t4.code, responseTime: p2 });
                throw jC.error(e5.toString()), e5;
              }
              if (!t4.servers || !Array.isArray(t4.servers) || 0 === t4.servers.length) {
                const e5 = new LI(Hg.UNEXPECTED_RESPONSE, "moderation plugin ap empty server", { code: t4.code, responseTime: p2 });
                throw jC.error(e5.toString()), e5;
              }
              if (!t4.servers.some((e5) => !!e5.wss)) {
                const e5 = new LI(Hg.UNEXPECTED_RESPONSE, "moderation plugin ap empty port", { code: t4.code, responseTime: p2 });
                throw jC.error(e5.toString()), e5;
              }
              const n4 = RC("IMAGE_MODERATION_WORKER_HOST");
              return { addressList: t4.servers.map((e5) => {
                let { address: t5, wss: i4 } = e5;
                if (t5 && i4) return "wss://".concat(t5.replace(/\./g, "-"), ".").concat(n4, ":").concat(i4, "/moderation");
              }).filter((e5) => !!e5), workerToken: t4.workerToken, vid: t4.vid, ticket: t4.appTicket, responseTime: p2 };
            }, (t4, i4) => (eI.apworkerEvent(a2, { success: true, sc: 200, serviceName: l2, responseDetail: JSON.stringify(t4.addressList), firstSuccess: 0 === i4, responseTime: p2, serverIp: e3[i4 % e3.length] }), false), (t4, i4) => (eI.apworkerEvent(a2, { success: false, sc: t4.data && t4.data.code || 200, serviceName: l2, responseTime: p2, serverIp: e3[i4 % e3.length] }), !!(t4.code !== Hg.OPERATION_ABORTED && t4.code !== Hg.UNEXPECTED_RESPONSE || t4.data && t4.data.retry) && (_2 = e3[(i4 + 1) % e3.length], true)), n3);
          }(n2, e2, t2, i2);
          this.emit(Cv.STATE_CHANGE, Iv.AP_CONNECTED);
          const { addressList: s2, ticket: o2 } = r2;
          return this._ticket = o2, s2;
        }
        async connectWorker(e2) {
          this.emit(Cv.STATE_CHANGE, Iv.CONNECT_WORKER), await this._workerConnection.init(e2, 1e4);
        }
        handleWorkerEvents() {
          this._workerConnection.on(SI.CONNECTED, async () => {
            this.emit(Cv.STATE_CHANGE, Iv.WORKER_CONNECTED, this._workerConnection.url), this.connectionState = Rv.CONNECTED;
          }), this._workerConnection.on(SI.CLOSED, () => {
            this.connectionState = Rv.CLOSED;
          }), this._workerConnection.on(SI.FAILED, () => {
            this.connectionState = Rv.CLOSED;
          }), this._workerConnection.on(SI.RECONNECTING, () => {
            this.connectionState = this.connectionState === Rv.CONNECTED ? Rv.RECONNECTING : Rv.CONNECTING;
          }), this._workerConnection.on(SI.ON_MESSAGE, async (e2) => {
            if (e2.data instanceof ArrayBuffer) {
              const t2 = jF(new Uint8Array(e2.data));
              RC("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && jC.debug("[".concat(this._moderationId, "] Response message for worker of image moderation "), JSON.stringify(t2)), this._uploadNum++, void 0 === t2.code || 0 === t2.code || (this._uploadFailedNum++, jC.error("[".concat(this._moderationId, "] Error response from worke, code is ").concat(t2.code, ", msg is ").concat(t2.msg)), this._uploadTimer || (this._uploadTimer = window.setTimeout(() => {
                eI.reportApiInvoke(this._connectInfo.sid || null, { name: hT.IMAGE_MODERATION_UPLOAD, options: [this._uploadFailedNum, this._uploadNum, t2.code], tag: pT.TRACER }).onError(new LI(Hg.IMAGE_MODERATION_UPLOAD_FAILED, t2.msg)), this._uploadTimer = null;
              }, RC("IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL"))));
            } else jC.error("[".concat(this._moderationId, "] Unexpected message type from worker"));
          }), this._workerConnection.on(SI.WILL_RECONNECT, (e2, t2, i2) => {
            "recover" === e2 && i2(e2), i2("tryNext");
          }), this._workerConnection.on(SI.REQUEST_NEW_URLS, (e2, t2) => {
            this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e2).catch(t2);
          });
        }
        static intToLong(e2) {
          return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
        }
        async requestToInspectImage() {
          const e2 = AT(this, Cv.CLIENT_LOCAL_VIDEO_TRACK), t2 = { appId: this._connectInfo.appId, cname: this._connectInfo.cname, cid: this._connectInfo.cid, sid: this._connectInfo.sid, uid: this._connectInfo.uid, vid: this._connectInfo.vid };
          if (e2) {
            if (!e2.isPlaying) return void (RC("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && jC.debug("Only the track being played can be inspected"));
            this._sequence++;
            const i2 = await this.generateRequestData(e2, t2);
            this._workerConnection.sendMessage(i2, true, true);
          } else RC("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && jC.debug("Only the track being published can be inspected");
        }
        async generateRequestData(e2, t2) {
          let { appId: i2, cname: n2, cid: r2, vid: s2, sid: o2, uid: a2 } = t2;
          const c2 = Date.now(), d2 = await e2.getCurrentFrameImage("image/jpeg", this.quality), l2 = await gw(d2, i2, n2), u2 = this._sequence + "-" + r2 + "-" + a2 + "-" + c2 + "-" + nS(12, ""), h3 = { appId: i2, cid: r2, cname: n2, deviceId: "", elapse: gB.intToLong(Number(c2 - this._moderationStartTime)), fileSize: d2.buffer.byteLength, height: d2.height, width: d2.width, jpg: l2, networkType: 6, osType: 7, requestId: u2, sdkVersion: "4.20.2", sequence: this._sequence, sid: o2, timestamp: mB(c2), uid: a2, vid: s2, service: this._moderationMode, ticket: this._ticket, callbackData: this._extraInfo, vendorConfigs: this._vendor };
          void 0 === this._extraInfo && delete h3.callbackData;
          const p2 = BF(h3);
          if (p2.byteLength < this._workerMessageLengthLimit) {
            if (RC("SHOW_IMAGE_MODERATION_WORKER_MESSAGE")) {
              const e3 = function(e4) {
                for (var t3 = 1; t3 < arguments.length; t3++) {
                  var i3 = null != arguments[t3] ? arguments[t3] : {};
                  t3 % 2 ? fB(Object(i3), true).forEach(function(t4) {
                    sh(e4, t4, i3[t4]);
                  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(i3)) : fB(Object(i3)).forEach(function(t4) {
                    Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(i3, t4));
                  });
                }
                return e4;
              }({}, h3);
              delete e3.jpg, jC.debug("[".concat(this._moderationId, "] Request message for worker of image moderation service: "), JSON.stringify(e3));
            }
            return p2;
          }
          {
            const t3 = this.quality * this._qualityRatio;
            return this.quality = t3, await this.generateRequestData(e2, { appId: i2, cname: n2, cid: r2, vid: s2, sid: o2, uid: a2 });
          }
        }
        close() {
          this._cancelTokenSource.cancel(), this._cancelTokenSource = sC.CancelToken.source(), this._workerConnection && this._workerConnection.close(), this._moderationTimer && window.clearInterval(this._moderationTimer), this._moderationTimer = null, this._uploadTimer && window.clearTimeout(this._uploadTimer), this._uploadTimer = null, this.connectionState = Rv.CLOSED, this.emit(Cv.STATE_CHANGE, Iv.CLOSED);
        }
      }
      function TB(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function SB(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? TB(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : TB(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      const RB = Date.now(), CB = 20, IB = /* @__PURE__ */ new Map(), vB = /* @__PURE__ */ new Map();
      async function yB(e2) {
        const t2 = IB.get(e2), i2 = Array.isArray(t2) && t2[t2.length - 1], n2 = vB.get(e2);
        if (!i2) return void (n2.isSyncing = false);
        const r2 = { uid: i2.uid, payload: i2.payload };
        0 === n2.firstRecvTs && (n2.firstRecvTs = i2.recvTs, n2.firstSendTs = i2.sendTs);
        const s2 = i2.sendTs - n2.firstSendTs, o2 = s2 - (Date.now() - n2.firstRecvTs);
        o2 > 0 && (n2.firstRecvTs = Date.now() - s2);
        let a2 = i2.mediaDelay + o2;
        a2 <= 0 ? (t2.pop(), AB(i2.context, r2), a2 = 0) : a2 = Math.min(a2, CB), setTimeout(() => t2.length && yB(e2), a2);
      }
      function AB(e2, t2) {
        e2.safeEmit(mT.STREAM_MESSAGE, t2.uid, t2.payload), e2.onStreamMessage && e2.onStreamMessage(t2);
      }
      function bB(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i2 = arguments.length > 2 ? arguments[2] : void 0;
        if (!e2.syncWithAudio) return AB(i2, { uid: e2.uid, payload: e2.payload });
        const n2 = "".concat(i2.id, "-").concat(e2.uid), r2 = IB.get(n2) || [], s2 = r2.findIndex((t3) => e2.sendTs >= t3.sendTs), o2 = SB(SB({}, e2), {}, { context: i2, mediaDelay: t2, recvTs: Date.now() });
        -1 === s2 ? r2.push(o2) : r2.splice(s2, 0, o2), IB.set(n2, r2);
        let a2 = false;
        var c2;
        vB.has(n2) ? a2 = !(null === (c2 = vB.get(n2)) || void 0 === c2 || !c2.isSyncing) : vB.set(n2, { isSyncing: a2, firstRecvTs: 0, firstSendTs: 0 });
        a2 || yB(n2);
      }
      const wB = Sg().name;
      function OB() {
        return !function(e2, t2, i2) {
          const n2 = Sg();
          if (n2.os !== _g.IOS || !n2.osVersion) return false;
          const r2 = n2.osVersion.split(".");
          return i2 ? t2 && Number(r2[0]) === e2 && Number(r2[1]) < t2 || Number(r2[0]) < e2 : t2 ? Number(r2[0]) === e2 && Number(r2[1]) <= t2 || Number(r2[0]) < e2 : Number(r2[0]) <= e2;
        }(16, 0, true) && !function(e2, t2, i2) {
          const n2 = Sg();
          if (n2.name !== Eg.SAFARI || !n2.osVersion) return false;
          const r2 = n2.version.split(".");
          return i2 ? t2 && Number(r2[0]) === e2 && Number(r2[1]) < t2 || Number(r2[0]) < e2 : t2 ? Number(r2[0]) === e2 && Number(r2[1]) <= t2 || Number(r2[0]) < e2 : Number(r2[0]) <= e2;
        }(16, 0, true);
      }
      function NB(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function DB(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? NB(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : NB(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      pS.setLogger(jC);
      class PB extends dT {
        get connectionState() {
          return this._gateway.state;
        }
        get remoteUsers() {
          return this._users;
        }
        get localTracks() {
          return this._p2pChannel.getAllTracks(true);
        }
        get uid() {
          return this._uid;
        }
        get channelName() {
          return this._channelName;
        }
        get localDataChannels() {
          return this._p2pChannel.getAllDataChannels();
        }
        get mode() {
          return this._config.mode;
        }
        get role() {
          var e2;
          return (null === (e2 = this._config) || void 0 === e2 ? void 0 : e2.role) || "audience";
        }
        get codec() {
          return this._config.codec;
        }
        get audioCodec() {
          return this._config.audioCodec || "opus";
        }
        get isStringUID() {
          return !!this._joinInfo && !!this._joinInfo.stringUid;
        }
        get __className__() {
          return "Client";
        }
        constructor(e2) {
          let t2;
          if (super(), sh(this, "store", void 0), sh(this, "_uid", void 0), sh(this, "_channelName", void 0), sh(this, "_uintUid", void 0), sh(this, "_users", []), sh(this, "_config", void 0), sh(this, "_clientId", void 0), sh(this, "_appId", void 0), sh(this, "_sessionId", null), sh(this, "_key", void 0), sh(this, "_rtmConfig", {}), sh(this, "_joinInfo", void 0), sh(this, "_gateway", void 0), sh(this, "_statsCollector", void 0), sh(this, "_configDistribute", void 0), sh(this, "_leaveMutex", new pS("client-leave")), sh(this, "_publishMutex", new pS("client-publish")), sh(this, "_renewTokenMutex", new pS("client-renewtoken")), sh(this, "_subscribeMutex", new pS("client-subscribe")), sh(this, "_encryptionMode", "none"), sh(this, "_encryptionSecret", null), sh(this, "_encryptionSalt", null), sh(this, "_encryptDataStream", false), sh(this, "_encryptDataStreamKey", null), sh(this, "_encryptDataStreamIv", null), sh(this, "_proxyServer", void 0), sh(this, "_turnServer", { servers: [], mode: "auto" }), sh(this, "_cloudProxyServerMode", "disabled"), sh(this, "_isDualStreamEnabled", false), sh(this, "_defaultStreamFallbackType", void 0), sh(this, "_lowStreamParameter", void 0), sh(this, "_streamFallbackTypeCacheMap", /* @__PURE__ */ new Map()), sh(this, "_remoteStreamTypeCacheMap", /* @__PURE__ */ new Map()), sh(this, "_axiosCancelSource", sC.CancelToken.source()), sh(this, "_audioVolumeIndicationInterval", void 0), sh(this, "_networkQualityInterval", void 0), sh(this, "_userOfflineTimeout", void 0), sh(this, "_streamRemovedTimeout", void 0), sh(this, "_injectStreamingClient", void 0), sh(this, "_liveTranscodeStreamingClient", void 0), sh(this, "_liveRawStreamingClient", void 0), sh(this, "_channelMediaRelayClient", void 0), sh(this, "_networkQualitySensitivity", "normal"), sh(this, "_p2pChannel", void 0), sh(this, "_useLocalAccessPoint", false), sh(this, "_setLocalAPVersion", void 0), sh(this, "_joinAndNotLeaveYet", false), sh(this, "_numberOfJoinCount", 0), sh(this, "_remoteDefaultVideoStreamType", void 0), sh(this, "_inspect", void 0), sh(this, "_moderation", void 0), sh(this, "_license", void 0), sh(this, "_pendingPublishedUsers", []), sh(this, "ntpAlignErrorCount", 0), sh(this, "remoteInboundOffset", 0), sh(this, "_handleLocalTrackEnable", (e3, t3, i2) => {
            this.publish(e3, false).then(t3).catch(i2);
          }), sh(this, "_handleLocalTrackDisable", (e3, t3, i2) => {
            this.unpublish(e3).then(t3).catch(i2);
          }), sh(this, "_handleUserOnline", (e3) => {
            if (RC("BLOCK_LOCAL_CLIENT") && sI(e3.uid, this.channelName)) return void jC.debug("[".concat(e3.uid, "] will be ignored in local"));
            this.isStringUID && "string" != typeof e3.uid && jC.error("[".concat(this._clientId, "] StringUID is Mixed with UintUID"));
            const t3 = this._users.find((t4) => t4.uid === e3.uid);
            if (t3) t3._trust_in_room_ = true, t3._is_pre_created && (t3._is_pre_created = false, this.safeEmit(mT.USER_JOINED, t3));
            else {
              const t4 = new sV(e3.uid, e3.uint_id || e3.uid);
              this._users.push(t4), jC.debug("[".concat(this._clientId, "] user online"), e3.uid), this.safeEmit(mT.USER_JOINED, t4);
            }
          }), sh(this, "_handleUserOffline", (e3) => {
            if (RC("BLOCK_LOCAL_CLIENT") && sI(e3.uid, this.channelName)) return;
            const t3 = this._users.find((t4) => t4.uid === e3.uid);
            t3 && (this._handleRemoveStream(e3), this._handleRemoveDataChannels(e3), t3._audio_pre_subscribed || t3._video_pre_subscribed ? t3._is_pre_created = true : WT(this._users, t3), this._remoteStreamTypeCacheMap.delete(t3.uid), this._streamFallbackTypeCacheMap.delete(t3.uid), jC.debug("[".concat(this._clientId, "] user offline"), e3.uid, "reason:", e3.reason), this.safeEmit(mT.USER_LEAVED, t3, e3.reason));
          }), sh(this, "_handleAddAudioOrVideoStream", (e3, t3, i2, n2, r2, s2, o2) => {
            if (RC("BLOCK_LOCAL_CLIENT") && sI(t3, this.channelName)) return;
            const a2 = this._users.find((e4) => e4.uid === t3);
            if (!a2) return void jC.error("[".concat(this._clientId, "] can not find target user!(on_add_stream)"));
            jC.debug("[".concat(this._clientId, "] stream added with uid ").concat(t3, ", type ").concat(e3)), this.store.subscribe(a2.uid, e3, void 0, void 0, void 0, Date.now());
            const c2 = "audio" === e3 ? a2.hasAudio : a2.hasVideo;
            a2._uintid || (a2._uintid = r2 || t3), "audio" === e3 ? a2._trust_audio_stream_added_state_ = true : a2._trust_video_stream_added_state_ = true, "audio" === e3 ? (a2._audio_added_ = true, void 0 !== i2 && (a2._audioSSRC = i2), void 0 !== n2 && (a2._cname = n2), s2 && (a2._audioOrtc = s2)) : (a2._video_added_ = true, void 0 !== i2 && (a2._videoSSRC = i2), void 0 !== n2 && (a2._cname = n2), void 0 !== o2 && (a2._rtxSsrcId = o2), s2 && (a2._videoOrtc = s2)), ("audio" === e3 ? a2.hasAudio : a2.hasVideo) && !c2 && (jC.info("[".concat(this._clientId, "] remote user ").concat(a2.uid, " published ").concat(e3)), this.safeEmit(mT.USER_PUBLISHED, a2, e3)), "video" === e3 ? eI.onGatewayStream(this._sessionId, YC.ON_ADD_VIDEO_STREAM, qC.ON_ADD_VIDEO_STREAM, { peer: r2 || t3, ssrc: a2._videoSSRC }) : eI.onGatewayStream(this._sessionId, YC.ON_ADD_AUDIO_STREAM, qC.ON_ADD_AUDIO_STREAM, { peer: r2 || t3, ssrc: a2._audioSSRC }), this._p2pChannel.remoteMediaSsrcChanged(a2, e3, i2).then((t4) => {
              if (t4 && (jC.debug("[".concat(this._clientId, "] resubscribe ").concat(e3, " for user ").concat(a2.uid, " after rejoin because SSRC id changed.")), this._p2pChannel instanceof cF)) return this._p2pChannel.unsubscribe(a2, e3, true).then(() => this._subscribe(a2, e3, true).catch((e4) => {
                jC.error("[".concat(this._clientId, "] resubscribe error"), e4.toString());
              }));
            }), this._p2pChannel.hasPendingRemoteMedia(a2, e3) && (jC.debug("[".concat(this._clientId, "] resubscribe ").concat(e3, " for user ").concat(a2.uid, " after reconnect.")), this._subscribe(a2, e3, true).catch((e4) => {
              jC.error("[".concat(this._clientId, "] resubscribe error"), e4.toString());
            }));
          }), sh(this, "_handleRemoveStream", (e3) => {
            if (RC("BLOCK_LOCAL_CLIENT") && sI(e3.uid, this.channelName)) return;
            const t3 = this._users.find((t4) => t4.uid === e3.uid);
            if (!t3) return void jC.warning("[".concat(this._clientId, "] can not find target user!(on_remove_stream)"));
            jC.debug("[".concat(this._clientId, "] stream removed with uid ").concat(e3.uid));
            let i2 = () => {
            };
            t3.hasAudio && t3.hasVideo ? i2 = () => {
              jC.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished audio track")), this.safeEmit(mT.USER_UNPUBLISHED, t3, "audio"), jC.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished video track")), this.safeEmit(mT.USER_UNPUBLISHED, t3, "video");
            } : t3.hasVideo ? i2 = () => {
              jC.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished video track")), this.safeEmit(mT.USER_UNPUBLISHED, t3, "video");
            } : t3.hasAudio && (i2 = () => {
              jC.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished audio track")), this.safeEmit(mT.USER_UNPUBLISHED, t3, "audio");
            }), t3._video_pre_subscribed || t3._audio_pre_subscribed || (t3._trust_audio_stream_added_state_ = true, t3._trust_video_stream_added_state_ = true, t3._audio_added_ = false, t3._video_added_ = false, this._p2pChannel instanceof cF && this._p2pChannel.unsubscribe(t3).then((e4) => {
              if (e4) return this._gateway.unsubscribe(e4, t3.uid);
            }), t3._audioSSRC = void 0, t3._videoSSRC = void 0, t3._audioOrtc = void 0, t3._videoOrtc = void 0, t3._rtxSsrcId = void 0), eI.onGatewayStream(this._sessionId, YC.ON_REMOVE_STREAM, qC.ON_REMOVE_STREAM, { peer: e3.uint_id || e3.uid }), i2();
          }), sh(this, "_handleSetStreamLocalEnable", (e3, t3, i2) => {
            if (RC("BLOCK_LOCAL_CLIENT") && sI(t3, this.channelName)) return;
            const n2 = this._users.find((e4) => e4.uid === t3);
            if (!n2) return void jC.error("[".concat(this._clientId, "] can not find target user!(disable_local)"));
            jC.debug("[".concat(this._clientId, "] local ").concat(e3, " ").concat(i2 ? "enabled" : "disabled", " with uid ").concat(t3));
            const r2 = "audio" === e3 ? n2.hasAudio : n2.hasVideo;
            if ("audio" === e3) {
              n2._trust_audio_enabled_state_ = true;
              const e4 = n2._audio_enabled_;
              if (n2._audio_enabled_ = i2, n2._audio_enabled_ === e4) return;
              {
                const e5 = n2._audio_enabled_ ? "enable-local-audio" : "disable-local-audio";
                jC.debug("[".concat(this._clientId, "] user-info-updated, uid: ").concat(t3, ", msg: ").concat(e5)), this.safeEmit(mT.USER_INFO_UPDATED, t3, e5);
              }
            } else {
              n2._trust_video_enabled_state_ = true;
              const e4 = n2._video_enabled_;
              if (n2._video_enabled_ = i2, n2._video_enabled_ === e4) return;
              {
                const e5 = n2._video_enabled_ ? "enable-local-video" : "disable-local-video";
                jC.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(t3, ", msg: ").concat(e5)), this.safeEmit(mT.USER_INFO_UPDATED, t3, e5);
              }
            }
            const s2 = "audio" === e3 ? n2.hasAudio : n2.hasVideo;
            return r2 !== s2 ? !r2 && s2 ? (jC.info("[".concat(this._clientId, "] remote user ").concat(t3, " published ").concat(e3)), void this.safeEmit(mT.USER_PUBLISHED, n2, e3)) : ("video" === e3 && n2._videoTrack && n2._videoTrack._destroy(), "audio" === e3 && n2._audioTrack, this._p2pChannel.muteRemote(n2, e3), jC.info("[".concat(this._clientId, "] remote user ").concat(t3, " unpublished ").concat(e3)), void this.safeEmit(mT.USER_UNPUBLISHED, n2, e3)) : void 0;
          }), sh(this, "_handleMuteStream", (e3, t3, i2) => {
            if (RC("BLOCK_LOCAL_CLIENT") && sI(e3, this.channelName)) return;
            jC.debug("[".concat(this._clientId, "] receive mute message"), e3, t3, i2);
            const n2 = this._users.find((t4) => t4.uid === e3);
            if (!n2) return void jC.warning("[".concat(this._clientId, "] can not find remote user, ignore mute event, uid: ").concat(e3));
            const r2 = "audio" === t3 ? n2.hasAudio : n2.hasVideo;
            if ("audio" === t3) {
              n2._trust_audio_mute_state_ = true;
              const t4 = n2._audio_muted_;
              if (n2._audio_muted_ = i2, n2._audio_muted_ === t4) return;
              {
                const t5 = n2._audio_muted_ ? "mute-audio" : "unmute-audio";
                jC.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e3, ", msg: ").concat(t5)), this.safeEmit(mT.USER_INFO_UPDATED, e3, t5);
              }
            } else {
              n2._trust_video_mute_state_ = true;
              const t4 = n2._video_muted_;
              if (n2._video_muted_ = i2, n2._video_muted_ === t4) return;
              {
                const t5 = n2._video_muted_ ? "mute-video" : "unmute-video";
                jC.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e3, ", msg: ").concat(t5)), this.safeEmit(mT.USER_INFO_UPDATED, e3, t5);
              }
            }
            const s2 = "audio" === t3 ? n2.hasAudio : n2.hasVideo;
            if (r2 !== s2) {
              if (!r2 && s2) {
                return ("audio" === t3 ? n2._audioSSRC : n2._videoSSRC) ? (jC.info("[".concat(this._clientId, "] remote user ").concat(e3, " published ").concat(t3)), void this.safeEmit(mT.USER_PUBLISHED, n2, t3)) : void jC.warning("[".concat(this._clientId, "] remote user ").concat(e3, " receive ").concat(t3, " unmute message  before add stream message, ").concat(t3, " SSRC doesn't exist yet."));
              }
              "video" === t3 && n2._videoTrack && !n2._video_pre_subscribed && n2._videoTrack._destroy(), "audio" === t3 && n2._audioTrack, this._p2pChannel.muteRemote(n2, t3), jC.info("[".concat(this._clientId, "] remote user ").concat(e3, " unpublished ").concat(t3)), this.safeEmit(mT.USER_UNPUBLISHED, n2, t3);
            }
          }), sh(this, "_handleP2PLost", async (e3) => {
            jC.debug("[".concat(this._clientId, "] receive p2p lost"), e3), parseInt(e3.p2pid, 10) === this.store.p2pId ? await this._p2pChannel.requestReconnect() : jC.warning("[".concat(this._clientId, "] P2PLost stream not found"), e3);
          }), sh(this, "_handleTokenWillExpire", () => {
            jC.debug("[".concat(this._clientId, "] received message onTokenPrivilegeWillExpire")), this.safeEmit(mT.ON_TOKEN_PRIVILEGE_WILL_EXPIRE);
          }), sh(this, "_handleBeforeUnload", (e3) => {
            "beforeunload" === e3.type && void 0 !== e3.returnValue && "" !== e3.returnValue || (this.leave(), jC.info("[".concat(this._clientId, "] auto leave onbeforeunload or pagehide")));
          }), sh(this, "_handleUpdateNetworkQuality", () => {
            if ("normal" === this._networkQualitySensitivity) return;
            if (navigator && void 0 !== navigator.onLine && !navigator.onLine) return void this.safeEmit(mT.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 });
            const e3 = { downlinkNetworkQuality: 0, uplinkNetworkQuality: 0 };
            e3.uplinkNetworkQuality = this._p2pChannel.getUplinkNetworkQuality(), e3.downlinkNetworkQuality = this._p2pChannel.getDownlinkNetworkQuality(), this.safeEmit(mT.NETWORK_QUALITY, e3);
          }), sh(this, "_handleP2PAddAudioOrVideoStream", (e3, t3, i2, n2) => {
            const r2 = this._users.find((e4) => e4.uid === t3);
            if (!r2) return void jC.error("[".concat(this._clientId, "] can not find target user!(on_add_stream)"));
            jC.debug("[".concat(this._clientId, "] stream added with uid ").concat(t3, ", type ").concat(e3)), this.store.subscribe(r2.uid, e3, void 0, void 0, void 0, Date.now());
            const s2 = "audio" === e3 ? r2.hasAudio : r2.hasVideo;
            "audio" === e3 ? r2._trust_audio_stream_added_state_ = true : r2._trust_video_stream_added_state_ = true, "audio" === e3 ? (r2._audio_added_ = true, void 0 !== i2 && (r2._audioSSRC = i2), void 0 !== n2 && (r2._audioMid = n2)) : (r2._video_added_ = true, void 0 !== i2 && (r2._videoSSRC = i2), void 0 !== n2 && (r2._videoMid = n2)), ("audio" === e3 ? r2.hasAudio : r2.hasVideo) && !s2 && (jC.info("[".concat(this._clientId, "] remote user ").concat(r2.uid, " published ").concat(e3)), this.safeEmit(mT.USER_PUBLISHED, r2, e3)), this._p2pChannel.hasPendingRemoteMedia(r2, e3) && (jC.debug("[".concat(this._clientId, "] resubscribe ").concat(e3, " for user ").concat(r2.uid, " after reconnect.")), this._subscribe(r2, e3, true).catch((e4) => {
              jC.error("[".concat(this._clientId, "] resubscribe error"), e4.toString());
            }));
          }), this._config = e2, this._clientId = nS(5, "client-"), this.store = new AC(e2.codec, e2.audioCodec, e2.mode, this._clientId), this.store.clientCreated(), e2.proxyServer && this.setProxyServer(e2.proxyServer, true), e2.turnServer && this.setTurnServer(e2.turnServer, true), jC.info("[".concat(this._clientId, "] Initializing AgoraRTC client v").concat(EC, " build: ").concat(gC, ", mode: ").concat(this.mode, ", codec: ").concat(this.codec)), e2.clientRoleOptions) try {
            IT(e2.clientRoleOptions), t2 = Object.assign({}, e2.clientRoleOptions);
          } catch (e3) {
            jC.warning("[".concat(this._clientId, "] ").concat(e3.toString()));
          }
          this._statsCollector = new mV(this.store), this._statsCollector.onStatsException = (e3, t3, i2) => {
            jC.debug("[".concat(this._clientId, "] receive exception msg, code: ").concat(e3, ", msg: ").concat(t3, ", uid: ").concat(i2)), this.safeEmit(mT.EXCEPTION, { code: e3, msg: t3, uid: i2 });
          }, this._statsCollector.onUploadPublishDuration = (e3, t3, i2, n2) => {
            const r2 = this._users.find((t4) => t4.uid === e3);
            r2 && eI.peerPublishStatus(this._sessionId, { subscribeElapse: n2, audioPublishDuration: t3, videoPublishDuration: i2, peer: r2._uintid });
          }, this.store.useDataChannel = IA().supportDataChannel && RC("SIGNAL_CHANNEL"), this.store.useP2P = "p2p" === e2.mode, this._gateway = new xy(this.store, { clientId: this._clientId, mode: this.mode, codec: this.codec, websocketRetryConfig: e2.websocketRetryConfig || ES, httpRetryConfig: e2.httpRetryConfig || ES, forceWaitGatewayResponse: void 0 === e2.forceWaitGatewayResponse || e2.forceWaitGatewayResponse, statsCollector: this._statsCollector, role: e2.role, clientRoleOptions: t2 }), this._configDistribute = new RA(), this.store.useP2P ? (this._p2pChannel = new hV(this.store, this._statsCollector), this._handleP2PEvents()) : this._p2pChannel = new cF(this.store, this._statsCollector), this._handleP2PChannelEvents(), this._handleGatewayEvents(), this._handleGatewaySignalEvents();
        }
        async joinMeta(e2, t2, i2, n2, r2) {
          let s2 = !(arguments.length > 5 && void 0 !== arguments[5]) || arguments[5], o2 = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
          SC("JOIN_GATEWAY_USE_443PORT_ONLY", s2), SC("JOIN_GATEWAY_USE_DUAL_DOMAIN", o2);
          const a2 = this._gateway.signal.websocket;
          return a2 instanceof qv && (a2.use443PortOnly = s2, a2.tryDoubleDomain = o2), async function(e3, t3, i3) {
            ug.get(e3) || ug.set(e3, []), hg.get(e3) || hg.set(e3, t3), pg.get(e3) || pg.set(e3, 0);
            const n3 = ug.get(e3), r3 = hg.get(e3);
            if (!n3 || !r3) throw new Error("concurrent: deferQueue or maxConcurrency is null");
            if (pg.get(e3) === r3) {
              const e4 = lg();
              n3.push(e4), await e4.promise;
            }
            pg.set(e3, pg.get(e3) + 1);
            for (var s3 = arguments.length, o3 = new Array(s3 > 3 ? s3 - 3 : 0), a3 = 3; a3 < s3; a3++) o3[a3 - 3] = arguments[a3];
            const c2 = await i3(...o3);
            return pg.set(e3, pg.get(e3) - 1), pg.get(e3) === r3 - 1 && n3.length > 0 && (n3[0].resolve(), n3.shift()), 0 === pg.get(e3) && (ug.set(e3, []), hg.set(e3, 0), pg.set(e3, 0)), c2;
          }("client.join", RC("JOIN_MAX_CONCURRENCY"), this.join.bind(this), e2, t2, i2, n2, r2);
        }
        async join(e2, t2, i2, n2, r2) {
          const s2 = ++this._numberOfJoinCount;
          this.store.joinStart(), n2 && (this.store.uid = n2);
          const o2 = pC(), a2 = _C() ? window.isSecureContext : "Browser Not Support";
          if (!_C() && !o2 || !window.isSecureContext) {
            const e3 = "The website must be running in a secure context (About secure context: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts ), otherwise the media collection will be restricted by the browser";
            jC.warning(e3);
          }
          const c2 = rS();
          "DISCONNECTED" === this.connectionState && (this.store.avoidJoinStart = Math.round(Date.now()), jC.debug("[".concat(this._clientId, "] set avoidJoinStart to ").concat(this.store.avoidJoinStart)));
          const d2 = eI.reportApiInvoke(c2, { name: hT.JOIN, options: [e2, t2, i2, n2], states: { isHttps: o2, isSecureContext: a2 }, tag: pT.TRACER });
          eI.setAppId(e2);
          try {
            if (!i2 && null !== i2) throw new LI(Hg.INVALID_PARAMS, "Invalid token: ".concat(i2, ". If you don not use token, set it to null"));
            i2 && Xg(i2, "token", 1, 2047), Xg(e2, "appid", 1, 2047), kI(t2), n2 && MI(n2), r2 && Xg(r2, "optionalInfo", 1, 2047);
          } catch (e3) {
            throw d2.onError(e3), e3;
          }
          if (jC.info("[".concat(this._clientId, "] start join channel ").concat(t2, ", join number: ").concat(s2)), this._leaveMutex.isLocked) {
            jC.debug("[".concat(this._clientId, "] join: waiting leave operation"));
            (await this._leaveMutex.lock())(), jC.debug("[".concat(this._clientId, "] join: continue"));
          }
          if (this._joinAndNotLeaveYet = true, "DISCONNECTED" !== this.connectionState) {
            const e3 = new LI(Hg.INVALID_OPERATION, "[".concat(this._clientId, "] Client already in connecting/connected state"));
            throw d2.onError(e3), e3;
          }
          this._sessionId || (this._sessionId = c2, this.store.sessionId = this._sessionId), this._gateway.state = "CONNECTING";
          const l2 = DB(DB({}, this._rtmConfig), {}, { clientId: this._clientId, appId: e2, sid: this._sessionId, cname: t2, uid: "string" != typeof n2 ? n2 : null, turnServer: this._turnServer, proxyServer: this._proxyServer, token: i2 || e2, cloudProxyServer: this._cloudProxyServerMode, optionalInfo: r2, license: this._license, useLocalAccessPoint: this._useLocalAccessPoint }, void 0 !== this._remoteDefaultVideoStreamType && { defaultVideoStream: this._remoteDefaultVideoStreamType });
          if (this._useLocalAccessPoint && (l2.setLocalAPVersion = this._setLocalAPVersion), "string" == typeof n2 && (l2.stringUid = n2, this._uintUid ? (l2.uid = this._uintUid, this._uintUid = void 0) : l2.uid = 0), "none" !== this._encryptionMode && this._encryptionSecret) {
            if (l2.aesmode = this._encryptionMode, l2.aespassword = await aT(this._encryptionSecret), !this._joinAndNotLeaveYet) throw new LI(Hg.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
            this._encryptionSalt && (l2.aessalt = this._encryptionSalt);
          }
          if (this._encryptDataStream && ("aes-128-gcm2" === this._encryptionMode || "aes-256-gcm2" === this._encryptionMode)) if (this._encryptionSalt && this._encryptionSecret) if (window.crypto.subtle) {
            const e3 = new TextEncoder(), t3 = RC("USE_PURE_ENCRYPTION_MASTER_KEY") ? e3.encode(l2.appId + this._encryptionSecret + this._encryptionSecret) : e3.encode(l2.appId + l2.cname + this._encryptionSecret);
            this._encryptDataStreamIv = await async function(e4, t4, i3) {
              const n3 = await window.crypto.subtle.importKey("raw", t4, "PBKDF2", false, ["deriveBits", "deriveKey"]), r3 = "aes-128-gcm2" === e4 ? 128 : 256, s3 = await window.crypto.subtle.deriveBits({ name: "PBKDF2", iterations: DC, hash: "SHA-256", salt: i3 }, n3, r3 + NC);
              return new Uint8Array(s3).subarray(r3 / 8);
            }(this._encryptionMode, t3, XT(this._encryptionSalt)), this._encryptDataStreamKey = await async function(e4, t4, i3) {
              const n3 = await window.crypto.subtle.importKey("raw", t4, "PBKDF2", false, ["deriveBits", "deriveKey"]), r3 = "aes-128-gcm2" === e4 ? 128 : 256;
              return await window.crypto.subtle.deriveKey({ name: "PBKDF2", iterations: DC, hash: "SHA-256", salt: i3 }, n3, { name: "AES-GCM", length: r3 }, true, ["encrypt", "decrypt"]);
            }(this._encryptionMode, t3, XT(this._encryptionSalt));
          } else a2 ? jC.warning("[".concat(this._clientId, "] encrypt datastream must be running in a secure context, fallback to plain data stream")) : jC.warning("[".concat(this._clientId, "] current browser do not support WebCrypto ,fallback to plain data stream")), this._encryptDataStream = false;
          else this._encryptDataStream = false, jC.debug("[".concat(this._clientId, "] no salt / secret, cannot support encrypt data stream, fallback to plain data stream"));
          this._startSession(this._sessionId, { channel: t2, appId: e2, stringUid: l2.stringUid });
          const u2 = this._sessionId;
          setTimeout(() => {
            "CONNECTING" === this.connectionState && u2 === this._sessionId && eI.joinChannelTimeout(this._sessionId, 5);
          }, 5e3);
          try {
            var h3;
            let n3;
            const r3 = l2.cloudProxyServer;
            if (bn(h3 = ["proxy3", "proxy4", "proxy5"]).call(h3, r3)) {
              const e3 = RC("PROXY_SERVER_TYPE3");
              Array.isArray(e3) ? l2.proxyServer = e3[0] : l2.proxyServer = e3;
            }
            if (eI.setProxyServer(l2.proxyServer), jC.setProxyServer(l2.proxyServer), this.store.requestAPStart(), l2.stringUid && !l2.uid) {
              let e3;
              [e3, n3] = await cg.all([pA(l2.stringUid, l2, this._axiosCancelSource.token, this._config.httpRetryConfig || ES, this.store), hA(l2, this._axiosCancelSource.token, this._config.httpRetryConfig || ES, true, this.store)]), jC.debug("[".concat(this._clientId, "] getUserAccount Success ").concat(l2.stringUid, " => ").concat(e3)), l2.uid = e3, n3.gatewayInfo.uid = e3, n3.gatewayInfo.res.uid = e3;
            } else n3 = await hA(l2, this._axiosCancelSource.token, this._config.httpRetryConfig || ES, true, this.store);
            if (!this._joinAndNotLeaveYet) throw new LI(Hg.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
            this.store.requestAPEnd(), setTimeout(() => {
              this._configDistribute.startGetConfigDistribute(l2, this._axiosCancelSource.token), this._configDistribute.on(sv.UPDATE_BITRATE_LIMIT, (e3) => {
                this._p2pChannel.updateBitrateLimit(e3);
              });
            }, 0), this._key = i2 || e2;
            const s3 = n3.gatewayInfo, o3 = l2.uid ? l2.uid : s3.uid;
            this._joinInfo = DB(DB({}, l2), {}, { cid: s3.cid, uid: o3, vid: s3.vid, apResponse: s3.res, uni_lbs_ip: s3.uni_lbs_ip, gatewayAddrs: s3.gatewayAddrs }), this.store.intUid = o3;
            const a3 = await this._joinGateway();
            if (!this._joinAndNotLeaveYet) throw new LI(Hg.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
            d2.onSuccess(a3), this._appId = e2, this._channelName = l2.cname, this._uid = a3, this.store.uid = a3, setTimeout(() => {
              this._networkQualityInterval && window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = window.setInterval(this._handleUpdateNetworkQuality, 2e3), window.addEventListener(bg() ? "beforeunload" : "pagehide", this._handleBeforeUnload);
            }, 0);
            const c3 = l2.stringUid ? "string uid: ".concat(l2.stringUid, ",uid: ").concat(l2.uid) : "uid: ".concat(this._uid);
            return jC.info("[".concat(this._clientId, "] Joining channel success: channel: ").concat(t2, ",").concat(c3)), setTimeout(() => {
              jC.startUpload();
            }, 5e3), this.store.joinEnd(), p2 = this, bn(rI).call(rI, p2) || rI.push(p2), a3;
          } catch (e3) {
            const t3 = Array.isArray(e3) ? e3[0] : e3;
            throw t3 && t3.code === Hg.OPERATION_ABORTED ? jC.warning("[".concat(this._clientId, "] join number: ").concat(s2, ", Joining channel failed, rollback"), t3) : jC.error("[".concat(this._clientId, "] join number: ").concat(s2, ", Joining channel failed, rollback"), t3), t3.code !== Hg.OPERATION_ABORTED && this._numberOfJoinCount === s2 && (this._gateway.state = "DISCONNECTED", this._reset()), d2.onError(t3), t3;
          }
          var p2;
        }
        _joinGateway() {
          if (!this._joinInfo || !this._key) throw new LI(Hg.INVALID_OPERATION);
          return this._gateway.join(this._joinInfo, this._key, !("disabled" !== this._joinInfo.cloudProxyServer || this._joinInfo.proxyServer || !RC("JOIN_WITH_FALLBACK_SIGNAL_PROXY"))).then((e2) => e2).catch((e2) => {
            if (e2.code === Hg.INIT_WEBSOCKET_TIMEOUT) return this._gateway.leave(true, ET.FALLBACK), e2;
            if (e2.code === Hg.INIT_DATACHANNEL_TIMEOUT) return this._gateway.leave(true, ET.FALLBACK), e2;
            throw e2;
          }).then((e2) => {
            if (e2 instanceof LI) {
              if (e2.code === Hg.INIT_WEBSOCKET_TIMEOUT) {
                if (jC.info("[".concat(this._clientId, "] join timeout, fallback to proxy")), !this._joinInfo || !this._key) throw new LI(Hg.INVALID_OPERATION);
                this._joinInfo.cloudProxyServer = "fallback", this._cloudProxyServerMode = "fallback", this.store.cloudProxyServerMode = "fallback";
                const e3 = RC("PROXY_SERVER_TYPE3");
                if (Array.isArray(e3)) if (this._joinInfo.apUrl) {
                  const t3 = /^https?:\/\/(.+?)(\/.*)?$/.exec(this._joinInfo.apUrl)[1].split("."), i2 = t3.slice(t3.length - 2).join(".");
                  e3.forEach((e4) => {
                    this._joinInfo && bn(e4).call(e4, i2) && (this._joinInfo.proxyServer = e4);
                  }), this._joinInfo.proxyServer || (this._joinInfo.proxyServer = e3[0]);
                } else this._joinInfo.proxyServer = e3[0];
                else this._joinInfo.proxyServer = e3;
                const t2 = RC("LOG_UPLOAD_SERVER").match(/.+:(\d{1,5})$/);
                t2 && t2[1] && "443" !== t2[1] && jC.setProxyServer(this._joinInfo.proxyServer), "443" !== RC("STATS_COLLECTOR_PORT").toString() && eI.setProxyServer(this._joinInfo.proxyServer);
                return eI.reportApiInvoke(this._sessionId, { name: hT.JOIN_FALLBACK_TO_PROXY, options: [this._joinInfo.proxyServer], tag: pT.TRACER }).onSuccess(), this.safeEmit(mT.JOIN_FALLBACK_TO_PROXY, this._joinInfo.proxyServer), RC("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE") && this._joinInfo.turnServer.servers.forEach((e4) => {
                  "forceturn" in e4 && (e4.forceturn = true);
                }), this._gateway.join(this._joinInfo, this._key);
              }
              if (jC.info("[".concat(this._clientId, "] join by datachannel timeout, fallback to websocket")), !this._joinInfo || !this._key) throw new LI(Hg.INVALID_OPERATION);
              return eI.reportApiInvoke(this._sessionId, { name: hT.DATACHANNEL_FAILBACK, options: [this.store.clientId], tag: pT.TRACER }).onSuccess(), this._joinGateway();
            }
            return e2;
          }).then((e2) => e2);
        }
        async leave() {
          jC.info("[".concat(this._clientId, "] Leaving channel")), window.removeEventListener(bg() ? "beforeunload" : "pagehide", this._handleBeforeUnload), this._reset(), function(e3) {
            const t2 = rI.indexOf(e3);
            -1 !== t2 && rI.splice(t2, 1);
          }(this);
          const e2 = await this._leaveMutex.lock();
          if ("DISCONNECTED" === this.connectionState) return jC.info("[".concat(this._clientId, "] Leaving channel repeated, success")), void e2();
          await this._gateway.leave("CONNECTED" !== this.connectionState), jC.info("[".concat(this._clientId, "] Leaving channel success")), this._joinAndNotLeaveYet = false, this.store.resetJoinChannelServiceRecords(), e2();
        }
        async publish(e2) {
          let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (!Array.isArray(e2)) {
            if (!(e2 instanceof lb)) return this._publishDataChannel(e2);
            e2 = [e2];
          }
          if (0 === e2.length) throw new LI(Hg.INVALID_PARAMS, "param list is empty");
          const i2 = e2;
          if ("audience" === this._gateway.role) throw new LI(Hg.INVALID_OPERATION, "audience can not publish stream");
          for (const e3 of i2) {
            if (!(e3 instanceof lb)) throw new LI(Hg.INVALID_PARAMS, "parameter is not local track");
            if (!e3._enabled && t2) throw new LI(Hg.TRACK_IS_DISABLED, "can not publish a disabled track: ".concat(e3.getTrackId()));
          }
          jC.info("[".concat(this._clientId, "] Publishing tracks, id ").concat(i2.map((e3) => "".concat(e3.getTrackId(), " "))));
          const n2 = await this._publishMutex.lock();
          await this._configDistribute.awaitConfigDistributeComplete(), t2 && i2.forEach((e3) => {
            const t3 = this._configDistribute.getBitrateLimit();
            e3 instanceof Rw && t3 && e3.setBitrateLimit(t3.uplink);
          });
          try {
            await this._publishHighStream(i2), jC.info("[".concat(this._clientId, "] Publish success, id ").concat(i2.map((e3) => "".concat(e3.getTrackId(), " "))));
          } catch (e3) {
            throw jC.error("[".concat(this._clientId, "] publish error"), e3.toString()), e3;
          } finally {
            n2();
          }
        }
        async _publishDataChannel(e2) {
          zg(e2.id, "id", 0, 65535, true), Yg(e2.ordered, "ordered"), Xg(e2.metadata, "metadata", 0, 512), jC.info("[".concat(this._clientId, "] Publishing datachannels, id ").concat(e2.id));
          const t2 = await this._publishMutex.lock();
          try {
            if (-1 !== this._p2pChannel.getAllDataChannels().findIndex((t3) => t3.id === e2.id)) throw new LI(Hg.INVALID_PARAMS, "Invalid id: ".concat(e2.id, ". If you want to republish the datachannel, unpublish first"));
            if (!this._joinInfo || void 0 === this._uid) throw new LI(Hg.INVALID_OPERATION, "Can't publish datachannel, haven't joined yet!");
            if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new LI(Hg.INVALID_OPERATION, "can not publish datachannel in ".concat(this.connectionState, " state"));
            if ("auto" === this._turnServer.mode && RC("FORCE_TURN") && !RC("TURN_ENABLE_TCP") && !RC("TURN_ENABLE_UDP")) throw new LI(Hg.UNEXPECTED_ERROR, "force TURN With No TURN Configuration");
            const i2 = new aP(e2);
            if (await this._p2pChannel.publishDataChannel([i2]), !this._p2pChannel.isP2PDisconnected()) {
              if ("number" != typeof i2._originDataChannelId) throw jC.error("[".concat(this._clientId, "] can not publish with mediaType datachannel, cannot get RTCDatachannel id")), new LI(Hg.CREATE_DATACHANNEL_ERROR);
              try {
                const t3 = { streamId: e2.id, ordered: e2.ordered, maxRetransmits: RC("DATASTREAM_MAX_RETRANSMITS"), metadata: e2.metadata, channelId: i2._originDataChannelId };
                await this._gateway.publishDataChannel(this._uid, t3, true), await i2._waitTillOpen();
              } catch (e3) {
                if (e3.code !== Hg.DISCONNECT_P2P) throw e3;
              }
            }
            return jC.info("[".concat(this._clientId, "] Publish dataChannels success, id ").concat(i2.id)), i2;
          } catch (e3) {
            throw jC.error("[".concat(this._clientId, "] publish datachannels error"), e3.toString()), e3;
          } finally {
            t2();
          }
        }
        async unpublish(e2) {
          if (!this._joinInfo || void 0 === this._uid) throw new LI(Hg.INVALID_OPERATION, "Can't unpublish stream, haven't joined yet!");
          let t2 = [];
          if (e2) if (Array.isArray(e2)) t2 = e2;
          else {
            if (!(e2 instanceof lb)) return this._unpublishDataChannel([e2]);
            t2 = [e2];
          }
          else this.store.useP2P || await this._unpublishDataChannel(), t2 = this._p2pChannel.getAllTracks(true);
          jC.info("[".concat(this._clientId, "] Unpublish tracks, tracks ").concat(t2.map((e3) => "".concat(e3.getTrackId(), " ")), " "));
          const i2 = await this._publishMutex.lock();
          try {
            if (this._p2pChannel instanceof hV) {
              const e3 = await this._p2pChannel.unpublish(t2);
              e3 && await this._gateway.sendExtensionMessage(vv.UNPUBLISH, { unpubMsg: e3 }, true);
            } else {
              const e3 = await this._p2pChannel.unpublish(t2);
              e3 && await this._gateway.unpublish(e3, this._uid), jC.info("[".concat(this._clientId, "] Unpublish success,tracks ").concat(t2.map((e4) => "".concat(e4.getTrackId()))));
            }
          } catch (e3) {
            throw jC.error("[".concat(this._clientId, "] unpublish error"), e3.toString()), e3;
          } finally {
            i2 && i2();
          }
        }
        async _unpublishDataChannel(e2) {
          void 0 !== e2 && 0 !== e2.length || (e2 = this._p2pChannel.getAllDataChannels()), jC.info("[".concat(this._clientId, "] Unpublish datachannels, datachannels ").concat(e2.map((e3) => "".concat(e3.id, " ")), " "));
          const t2 = await this._publishMutex.lock();
          try {
            const i2 = await this._p2pChannel.unpublishDataChannel(e2);
            i2 && await this._gateway.unpublishDataChannel(i2), jC.info("[".concat(this._clientId, "] Unpublish dataChannel success,dataChannel ").concat(e2.map((e3) => "".concat(e3.id))));
          } catch (e3) {
            throw jC.error("[".concat(this._clientId, "] unpublish dataChannel error"), e3.toString()), e3;
          } finally {
            t2 && t2();
          }
        }
        async subscribe(e2, t2, i2) {
          return "datachannel" === t2 ? this._subscribeDataChannel(e2, i2) : this._subscribe(e2, t2);
        }
        async presubscribe(e2, t2) {
          if (qg(t2, "mediaType", ["audio", "video"]), this._p2pChannel instanceof hV) throw new LI(Hg.INVALID_OPERATION, "can't presub at p2p mode");
          if (!this._joinInfo) throw new LI(Hg.INVALID_OPERATION, "can't presub when not join");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new LI(Hg.INVALID_OPERATION, "can't presub in ".concat(this.connectionState, " state"));
          const i2 = t2 === av.AUDIO, n2 = t2 === av.VIDEO, r2 = await this._subscribeMutex.lock();
          try {
            const { ssrcId: s2, ortc: o2, rtxSsrcId: a2, cname: c2, uint_id: d2 } = await this._gateway.presubscribe(e2, t2, true);
            if (null == s2) throw new LI(Hg.UNEXPECTED_RESPONSE, "no ssrc id");
            let l2 = this._users.find((t3) => t3.uid === e2);
            l2 || (l2 = new sV(e2, d2 || e2), l2._is_pre_created = true, this._users.push(l2)), c2 && (l2._cname = c2), l2._uintid || (l2._uintid = d2 || e2), i2 && (l2._audioSSRC = s2, l2._audio_pre_subscribed = true, o2 && (l2._audioOrtc = o2)), n2 && (l2._videoSSRC = s2, l2._video_pre_subscribed = true, o2 && (l2._videoOrtc = o2), null != a2 && (l2._rtxSsrcId = a2)), jC.info("[".concat(this._clientId, "] presub succeed ssrc: ").concat(s2)), await this._p2pChannel.subscribe(l2, t2, s2, a2, o2);
            const u2 = i2 ? l2._audioTrack : l2._videoTrack;
            if (!u2) throw new LI(Hg.UNEXPECTED_ERROR, "can not find remote track in user");
            return i2 && (l2._trust_audio_stream_added_state_ = true, l2._audio_added_ = true), n2 && (l2._trust_video_stream_added_state_ = true, l2._video_added_ = true), u2;
          } catch (t3) {
            throw jC.error("[".concat(this._clientId, "] presub user ").concat(e2, " error"), t3), t3;
          } finally {
            r2();
          }
        }
        async _subscribeDataChannel(e2, t2) {
          var i2;
          if (zg(t2, "channelId", 0, 65535, true), !this._joinInfo) throw new LI(Hg.INVALID_OPERATION, "Can't subscribe datachannel, not joined");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new LI(Hg.INVALID_OPERATION, "Can't subscribe datachannel in ".concat(this.connectionState, " state"));
          if (!this._users.find((t3) => t3 === e2)) throw jC.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", this user is not in the channel")), new LI(Hg.INVALID_REMOTE_USER, "user is not in the channel");
          if (!e2.hasAudio && !e2.hasVideo && 0 === e2._dataChannels.length) throw jC.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", user is not published")), new LI(Hg.INVALID_REMOTE_USER, "user is not published");
          const n2 = null === (i2 = e2._dataChannels) || void 0 === i2 ? void 0 : i2.find((e3) => e3.id === t2);
          if (!n2) throw jC.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType datachannel, remote datachannel is not published")), new LI(Hg.REMOTE_USER_IS_NOT_PUBLISHED);
          const r2 = await this._subscribeMutex.lock();
          jC.info("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, ", mediaType: datachannel"));
          try {
            const t3 = await this._p2pChannel.subscribeDataChannel(e2, [n2]);
            if (t3 && bn(t3).call(t3, n2.id)) try {
              var s2;
              if ("number" != typeof n2._originDataChannelId) throw jC.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType datachannel, cannot get RTCDatachannel")), new LI(Hg.CREATE_DATACHANNEL_ERROR);
              const t4 = { id: n2.id, datachannelId: n2._originDataChannelId, ordered: n2.ordered, maxRetransmits: n2.maxRetransmits, metadata: null !== (s2 = n2.metadata) && void 0 !== s2 ? s2 : "" };
              await this._gateway.subscribeDataChannel(e2.uid, t4, true), await n2._waitTillOpen();
            } catch (t4) {
              if ((null == t4 ? void 0 : t4.code) !== Hg.WS_ABORT) throw await this._p2pChannel.unsubscribeDataChannel(e2, [n2]), t4;
              await this._p2pChannel.unsubscribeDataChannel(e2, [n2]), this._p2pChannel.setPendingRemoteDataChannel(e2, n2.id);
            }
            return jC.info("[".concat(this._clientId, "] subscribe success user ").concat(e2.uid, ", mediaType: datachannel")), n2;
          } finally {
            r2();
          }
        }
        async _p2pSubscribe(e2, t2, i2) {
          if (qg(t2, "mediaType", ["audio", "video"]), !this._joinInfo) throw new LI(Hg.INVALID_OPERATION, "Can't subscribe stream, not joined");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new LI(Hg.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
          if (!this._users.find((t3) => t3 === e2)) {
            const t3 = new LI(Hg.INVALID_REMOTE_USER, "user is not in the channel");
            throw jC.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", this user is not in the channel")), t3;
          }
          if (!e2.hasAudio && !e2.hasVideo) {
            const t3 = new LI(Hg.INVALID_REMOTE_USER, "user is not published");
            throw jC.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", user is not published")), t3;
          }
          if (!i2 && ("audio" === t2 && !e2.hasAudio || "video" === t2 && !e2.hasVideo)) {
            const i3 = new LI(Hg.REMOTE_USER_IS_NOT_PUBLISHED);
            throw jC.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType ").concat(t2, ", remote track is not published")), i3;
          }
          const n2 = await this._subscribeMutex.lock();
          jC.info("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, ", mediaType: ").concat(t2));
          try {
            if (await this._p2pChannel.hasRemoteMediaWithLock(e2, t2)) await this._p2pChannel.unmuteRemote(e2, t2);
            else try {
              const i4 = "audio" === t2 ? e2._audioSSRC : e2._videoSSRC, n3 = "audio" === t2 ? e2._audioMid : e2._videoMid;
              this.store.subscribe(e2.uid, t2, Date.now()), this._p2pChannel instanceof hV && await this._p2pChannel.subscribe(e2, t2, i4, n3);
            } catch (e3) {
              throw e3;
            }
            jC.info("[".concat(this._clientId, "] subscribe success user ").concat(e2.uid, ", mediaType: ").concat(t2)), this._defaultStreamFallbackType && this.setStreamFallbackOption(e2.uid, this._defaultStreamFallbackType).catch((e3) => {
              jC.warning("[".concat(this._clientId, "] auto set fallback failed"), e3);
            });
            const i3 = "audio" === t2 ? e2._audioTrack : e2._videoTrack;
            if (!i3) throw new LI(Hg.UNEXPECTED_ERROR, "can not find remote track in user object");
            return i3;
          } catch (t3) {
            throw jC.error("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, " error"), t3), t3;
          } finally {
            n2();
          }
        }
        async _subscribe(e2, t2, i2) {
          if (this._p2pChannel instanceof hV) return this._p2pSubscribe(e2, t2);
          if (qg(t2, "mediaType", ["audio", "video"]), !this._joinInfo) throw new LI(Hg.INVALID_OPERATION, "Can't subscribe stream, not joined");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new LI(Hg.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
          if (!this._users.find((t3) => t3 === e2)) {
            const t3 = new LI(Hg.INVALID_REMOTE_USER, "user is not in the channel");
            throw jC.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", this user is not in the channel")), t3;
          }
          if (!e2.hasAudio && !e2.hasVideo) {
            const t3 = new LI(Hg.INVALID_REMOTE_USER, "user is not published");
            throw jC.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", user is not published")), t3;
          }
          if (!(i2 || ("audio" !== t2 || e2.hasAudio && void 0 !== e2._audioSSRC) && ("video" !== t2 || e2.hasVideo && void 0 !== e2._videoSSRC))) {
            const i3 = new LI(Hg.REMOTE_USER_IS_NOT_PUBLISHED);
            throw jC.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType ").concat(t2, ", remote track is not published")), i3;
          }
          let n2 = "audio" === t2 ? e2._audioSSRC : e2._videoSSRC, r2 = "audio" === t2 ? e2._audioOrtc : e2._videoOrtc, s2 = "video" === t2 ? e2._rtxSsrcId : void 0, o2 = { stream_type: "audio" === t2 ? av.AUDIO : av.VIDEO, ssrcId: n2 };
          const a2 = await this._subscribeMutex.lock();
          jC.info("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, ", mediaType: ").concat(t2));
          try {
            if (await this._p2pChannel.hasRemoteMediaWithLock(e2, t2)) await this._p2pChannel.unmuteRemote(e2, t2);
            else try {
              const i4 = "audio" === t2 ? e2._audioSSRC : e2._videoSSRC;
              void 0 !== i4 && i4 !== n2 && (n2 = i4, r2 = "audio" === t2 ? e2._audioOrtc : e2._videoOrtc, s2 = "video" === t2 ? e2._rtxSsrcId : void 0, o2 = { stream_type: "audio" === t2 ? av.AUDIO : av.VIDEO, ssrcId: n2 }), RU.markSubscribeStart(this.store.clientId, n2), this.store.subscribe(e2.uid, t2, Date.now()), await this._p2pChannel.subscribe(e2, t2, n2, s2, r2);
              try {
                await this._gateway.subscribe(e2.uid, o2, true);
              } catch (i5) {
                if ((null == i5 ? void 0 : i5.code) !== Hg.WS_ABORT) throw await this._p2pChannel.unsubscribe(e2, t2), i5;
                await this._p2pChannel.unsubscribe(e2, t2, true), this._p2pChannel.setPendingRemoteMedia(e2, t2);
              }
              this.store.subscribe(e2.uid, t2, void 0, Date.now()), this._p2pChannel.reportSubscribeEvent(true, null, e2, t2);
            } catch (i4) {
              throw this._p2pChannel.reportSubscribeEvent(false, null == i4 ? void 0 : i4.code, e2, t2), i4;
            }
            jC.info("[".concat(this._clientId, "] subscribe success user ").concat(e2.uid, ", mediaType: ").concat(t2)), this._defaultStreamFallbackType && this.setStreamFallbackOption(e2.uid, this._defaultStreamFallbackType).catch((e3) => {
              jC.warning("[".concat(this._clientId, "] auto set fallback failed"), e3);
            });
            const i3 = "audio" === t2 ? e2._audioTrack : e2._videoTrack;
            if (!i3) throw new LI(Hg.UNEXPECTED_ERROR, "can not find remote track in user object");
            return i3;
          } catch (t3) {
            throw jC.error("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, " error"), t3), t3;
          } finally {
            a2();
          }
        }
        async massSubscribe(e2) {
          if (Qg(e2, "subscribeList"), !this._joinInfo) throw new LI(Hg.INVALID_OPERATION, "Can't subscribe stream, not joined");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new LI(Hg.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
          const t2 = Date.now(), i2 = /* @__PURE__ */ new Map(), n2 = await this._subscribeMutex.lock();
          jC.info("[".concat(this._clientId, "]start massSubscribe user ").concat(e2.map((e3) => {
            let { user: t3, mediaType: i3 } = e3;
            return "user: ".concat(null == t3 ? void 0 : t3.uid, ", mediaType: ").concat(i3);
          }).join("; ")));
          const r2 = (e2 = [...e2]).map((e3) => {
            let { user: t3, mediaType: i3 } = e3;
            return { user: t3, mediaType: i3 };
          }), s2 = await this._p2pChannel.globalLock();
          try {
            var o2;
            for (let t3 = e2.length - 1; t3 >= 0; t3--) {
              const n3 = e2[t3], { user: s3, mediaType: o3 } = n3;
              if (qg(o3, "mediaType", ["audio", "video"]), !s3) {
                const e3 = new LI(Hg.INVALID_PARAMS, "user property does not exist in subscribeList item");
                throw jC.error("[".concat(this._clientId, "] user property does not exist in subscribeList item")), e3;
              }
              if (!this._users.find((e3) => e3 === s3)) {
                const i3 = new LI(Hg.INVALID_REMOTE_USER, "user is not in the channel");
                jC.error("[".concat(this._clientId, "] can not massSubscribe ").concat(s3.uid, ", this user is not in the channel")), r2[t3].error = i3, e2.splice(t3, 1);
                continue;
              }
              if ("audio" === o3 && (!s3.hasAudio || void 0 === s3._audioSSRC) || "video" === o3 && (!s3.hasVideo || void 0 === s3._videoSSRC)) {
                const i3 = new LI(Hg.REMOTE_USER_IS_NOT_PUBLISHED);
                jC.error("[".concat(this._clientId, "] can not subscribe ").concat(s3.uid, " with mediaType ").concat(o3, ", remote user is not published")), r2[t3].error = i3, e2.splice(t3, 1);
                continue;
              }
              const a3 = ZI.Video | ZI.LwoVideo, c2 = i2.get(s3);
              if (c2) {
                if ("video" === o3 ? c2 & a3 : c2 & ZI.Audio) {
                  e2.splice(t3, 1), jC.warning("[".concat(this._clientId, "] repeat massSubscribe user:").concat(s3.uid, ", mediaType:").concat(o3, " twice"));
                  continue;
                }
                i2.set(s3, c2 | ("video" === o3 ? a3 : ZI.Audio));
              } else i2.set(s3, "video" === o3 ? a3 : ZI.Audio);
            }
            for (let t3 = e2.length - 1; t3 >= 0; t3--) {
              const n3 = e2[t3], { user: r3, mediaType: s3 } = n3, o3 = ZI.Video | ZI.LwoVideo;
              if (this._p2pChannel.hasRemoteMedia(r3, s3)) {
                await this._p2pChannel.unmuteRemoteNoLock(r3, s3);
                const n4 = i2.get(r3);
                i2.set(r3, "video" === s3 ? n4 ^ o3 : n4 ^ ZI.Audio), e2.splice(t3, 1);
              }
            }
            this.store.massSubscribe(e2.map((e3) => ({ userId: e3.user.uid, type: e3.mediaType })), t2);
            const a2 = BT(o2 = Array.from(i2.entries())).call(o2, (e3, t3) => {
              let [i3, n3] = t3;
              if (0 === n3) return e3;
              const r3 = { stream_id: i3.uid, stream_type: n3 };
              return n3 & ZI.Audio && (r3.audio_ssrc = i3._audioSSRC), n3 & ZI.Video && (r3.video_ssrc = i3._videoSSRC), e3.push(r3), e3;
            }, []);
            try {
              e2.length > 0 && await this._p2pChannel.massSubscribeNoLock(e2.map((e3) => {
                let { user: t3, mediaType: i4 } = e3;
                return { user: t3, mediaType: i4, ssrcId: i4 === av.VIDEO ? t3._videoSSRC : t3._audioSSRC, rtxSsrcId: i4 === av.VIDEO ? t3._rtxSsrcId : void 0 };
              }));
              const i3 = /* @__PURE__ */ new Map();
              if (a2.length > 0) {
                const e3 = await this._gateway.subscribeAll(a2, true);
                ((null == e3 ? void 0 : e3.users) || []).forEach((e4) => {
                  let { stream_id: t3, video_error_code: n3, audio_error_code: r3, error_code: s3 } = e4;
                  (n3 || r3 || s3) && i3.set(t3, { video_error_code: n3, audio_error_code: r3, error_code: s3 });
                });
              }
              if (Array.from(i3.entries()).length > 0) {
                const e3 = [];
                Array.from(i3.entries()).forEach((t3) => {
                  let [i4, n3] = t3;
                  const r3 = this.remoteUsers.find((e4) => e4.uid === i4);
                  if (r3) {
                    let t4;
                    n3.error_code || n3.video_error_code && n3.audio_error_code ? t4 = void 0 : n3.video_error_code ? t4 = av.VIDEO : n3.audio_error_code && (t4 = av.AUDIO), e3.push({ user: r3, mediaType: t4 });
                  }
                }), e3.length > 0 && await this._p2pChannel.massUnsubscribeNoLock(e3);
              }
              for (const e3 of r2) {
                const t3 = i3.get(e3.user.uid);
                if (t3) {
                  const i4 = t3.error_code || "audio" === e3.mediaType && t3.audio_error_code || "video" === e3.mediaType && t3.video_error_code;
                  if (i4) {
                    const t4 = kv(i4);
                    jC.error("user:".concat(e3.user.uid, " mediaType:").concat(e3.mediaType, " has massSubscribe error ").concat(t4.desc)), e3.error = new LI(Hg.SUBSCRIBE_FAILED, "code ".concat(i4, ": ").concat(t4.desc));
                  }
                }
                e3.error || ("video" === e3.mediaType ? e3.track = e3.user.videoTrack : e3.track = e3.user.audioTrack);
              }
              return this.store.massSubscribe(r2.filter((e3) => !e3.error).map((e3) => ({ userId: e3.user.uid, type: e3.mediaType })), void 0, Date.now()), r2.forEach((e3) => {
                var i4;
                eI.subscribe(this.store.sessionId, { succ: !!e3.error, ec: (null === (i4 = e3.error) || void 0 === i4 ? void 0 : i4.code) || null, video: e3.mediaType === av.VIDEO, audio: e3.mediaType === av.AUDIO, peerid: e3.user.uid, subscribeRequestid: e3.mediaType === av.VIDEO ? e3.user._videoSSRC : e3.user._audioSSRC, p2pid: this.store.p2pId, eventElapse: Math.floor(performance.now() - t2) }, true);
              }), jC.info("[".concat(this._clientId, "] massSubscribe success ").concat(e2.map((e3) => {
                let { user: t3, mediaType: i4 } = e3;
                return "user: ".concat(null == t3 ? void 0 : t3.uid, ", mediaType: ").concat(i4);
              }).join("; "))), r2;
            } catch (t3) {
              throw await this._p2pChannel.massUnsubscribeNoLock(e2), t3;
            }
          } finally {
            s2(), n2();
          }
        }
        async unsubscribe(e2, t2, i2) {
          if (t2 || this.store.useP2P) {
            if ("datachannel" === t2) return this._unsubscribeDataChannel(e2, i2);
          } else await this._unsubscribeDataChannel(e2, i2);
          if (t2 && qg(t2, "mediaType", ["audio", "video"]), !this._joinInfo) throw new LI(Hg.INVALID_OPERATION, "Can't unsubscribe stream, haven't joined yet!");
          if (!this._users.find((t3) => t3 === e2)) {
            const t3 = new LI(Hg.INVALID_REMOTE_USER, "user is not in the channel");
            throw jC.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e2.uid, ", user is not in the channel")), t3;
          }
          jC.info("[".concat(this._clientId, "] unsubscribe uid: ").concat(e2.uid, ", mediaType: ").concat(t2));
          const n2 = await this._subscribeMutex.lock();
          try {
            if (this._p2pChannel instanceof hV) await this._p2pChannel.unsubscribe(e2, t2);
            else {
              const i3 = await this._p2pChannel.unsubscribe(e2, t2);
              i3 && await this._gateway.unsubscribe(i3, e2.uid), t2 && "audio" !== t2 || (e2._audio_pre_subscribed = false), t2 && "video" !== t2 || (e2._video_pre_subscribed = false), e2._is_pre_created && WT(this._users, e2), jC.info("[".concat(this._clientId, "] unsubscribe success uid: ").concat(e2.uid, ", mediaType: ").concat(t2));
            }
          } catch (t3) {
            if (t3.code === Hg.DISCONNECT_P2P) return void jC.warning("disconnecting p2p, abort unsubscribe request.");
            throw jC.error("[".concat(this._clientId, "] unsubscribe user ").concat(e2.uid, " error"), t3.toString()), t3;
          } finally {
            n2();
          }
        }
        async _unsubscribeDataChannel(e2, t2) {
          if (t2 && zg(t2, "id", 0, 65535, true), !this._joinInfo) throw new LI(Hg.INVALID_OPERATION, "Can't unsubscribe datachannel, haven't joined yet!");
          if (!this._users.find((t3) => t3 === e2)) {
            const t3 = new LI(Hg.INVALID_REMOTE_USER, "user is not in the channel");
            throw jC.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e2.uid, ", user is not in the channel")), t3;
          }
          let i2;
          if ("number" == typeof t2) {
            const n2 = e2._dataChannels.find((e3) => e3.id === t2);
            n2 && (i2 = [n2]);
          } else i2 = e2._dataChannels;
          if (void 0 === i2) {
            const i3 = new LI(Hg.REMOTE_USER_IS_NOT_PUBLISHED);
            throw jC.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e2.uid, " with channelId ").concat(t2, ", remote datachannel is not published")), i3;
          }
          jC.info("[".concat(this._clientId, "] unsubscribe uid: ").concat(e2.uid, ", mediaType: datachannel, ids: ").concat(i2.map((e3) => e3.id)));
          try {
            const t3 = await this._p2pChannel.unsubscribeDataChannel(e2, i2);
            t3 && await this._gateway.unsubscribeDataChannel(t3, e2.uid), jC.info("[".concat(this._clientId, "] unsubscribe datachannel success uid: ").concat(e2.uid, ", mediaType: datachannel, ids: ").concat(t3));
          } catch (t3) {
            if (t3.code === Hg.DISCONNECT_P2P) return void jC.warning("disconnecting p2p, abort unsubscribe request.");
            throw jC.error("[".concat(this._clientId, "] unsubscribe user ").concat(e2.uid, " error"), t3.toString()), t3;
          }
        }
        async massUnsubscribe(e2) {
          if (Qg(e2, "unsubscribeList"), !this._joinInfo) throw new LI(Hg.INVALID_OPERATION, "Can't unsubscribeAll stream, haven't joined yet!");
          jC.info("[".concat(this._clientId, "] start massUnsubscribe ").concat(e2.map((e3) => {
            let { user: t3, mediaType: i2 } = e3;
            return "user: ".concat(null == t3 ? void 0 : t3.uid, ", mediaType: ").concat(i2, ";");
          }).join())), e2 = [...e2];
          const t2 = /* @__PURE__ */ new Map();
          for (let i2 = e2.length - 1; i2 >= 0; i2--) {
            const { user: n2, mediaType: r2 } = e2[i2];
            if (!n2) {
              const e3 = new LI(Hg.INVALID_PARAMS, "user property does not exist in unsubscribeList item");
              throw jC.error("[".concat(this._clientId, "] user property does not exist in unsubscribeList item")), e3;
            }
            qg(r2, "mediaType", ["video", "audio", void 0]);
            if (!this._users.find((e3) => e3 === n2)) {
              jC.warning("[".concat(this._clientId, "] can not unsubscribe ").concat(n2.uid, ", user is not in the channel")), e2.splice(i2, 1);
              continue;
            }
            const s2 = ZI.Video | ZI.LwoVideo;
            if (t2.has(n2)) {
              const o2 = t2.get(n2);
              let a2;
              switch (r2) {
                case "video":
                  a2 = o2 & s2;
                  break;
                case "audio":
                  a2 = o2 & ZI.Audio;
                  break;
                default:
                  a2 = o2 & (ZI.Audio | s2);
              }
              if (a2) {
                jC.warning("[".concat(this._clientId, "] repeat massUnsubscribe user:").concat(n2.uid, ",mediaType:").concat(r2, " twice.")), e2.splice(i2, 1);
                continue;
              }
              r2 ? "audio" === r2 ? t2.set(n2, o2 | ZI.Audio) : "video" === r2 && t2.set(n2, o2 | s2) : t2.set(n2, o2 | ZI.Audio | s2);
            } else r2 ? "audio" === r2 ? t2.set(n2, ZI.Audio) : "video" === r2 && t2.set(n2, s2) : t2.set(n2, ZI.Audio | s2);
          }
          try {
            const t3 = await this._p2pChannel.massUnsubscribe(e2);
            t3 && await this._gateway.massUnsubscribe(t3), jC.info("[".concat(this._clientId, "] massUnsubscribe success ").concat(e2.map((e3) => {
              let { user: t4, mediaType: i2 } = e3;
              return "user: ".concat(null == t4 ? void 0 : t4.uid, ", mediaType: ").concat(i2, ";");
            }).join()));
          } catch (e3) {
            if (e3.code === Hg.DISCONNECT_P2P) return void jC.warning("[".concat(this._clientId, "] disconnecting p2p, abort unsubscribe request."));
            throw jC.error("[".concat(this._clientId, "] massUnsubscribe error"), e3.toString()), e3;
          }
        }
        async setLowStreamParameter(e2) {
          !function(e3) {
            if (!e3) throw new Kg(Hg.INVALID_PARAMS);
            Zg(e3.width) || Jg(e3.width, "streamParameter.width"), Zg(e3.height) || Jg(e3.height, "streamParameter.height"), Zg(e3.framerate) || Jg(e3.framerate, "streamParameter.framerate"), Zg(e3.bitrate) || zg(e3.bitrate, "streamParameter.bitrate");
          }(e2), (!e2.width && e2.height || e2.width && !e2.height) && jC.warning("[".concat(this._clientId, "] The width and height parameters take effect only when both are set")), jC.info("[".concat(this._clientId, "] set low stream parameter to"), JSON.stringify(e2));
          const t2 = this._configDistribute.getLowStreamConfigDistribute();
          if (t2 && t2.bitrate && e2.bitrate && t2.bitrate < e2.bitrate && (e2.bitrate = t2.bitrate), this._lowStreamParameter = e2, this._isDualStreamEnabled) return this._p2pChannel.updateVideoStreamParameter(e2, lv.LocalVideoLowTrack);
        }
        async enableDualStream() {
          if (!IA().supportDualStream) throw eI.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: false }), new LI(Hg.NOT_SUPPORTED, "Your browser is not support dual stream");
          if (this._isDualStreamEnabled) throw new LI(Hg.INVALID_OPERATION, "Dual stream is already enabled");
          if (this._p2pChannel.canPublishLowStream()) try {
            await this._publishLowStream();
          } catch (e2) {
            throw eI.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: false }), e2;
          }
          this._isDualStreamEnabled = true, eI.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: true }), jC.info("[".concat(this._clientId, "] enable dual stream"));
        }
        async disableDualStream() {
          if (this._isDualStreamEnabled) {
            if (!this._joinInfo) throw new LI(Hg.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
            if (this._p2pChannel.getLocalMedia(lv.LocalVideoLowTrack)) try {
              const e2 = await this._p2pChannel.unpublishLowStream();
              e2 && await this._gateway.unpublish(e2, this._joinInfo.stringUid || this._joinInfo.uid);
            } catch (e2) {
              throw eI.streamSwitch(this._sessionId, { lts: Date.now(), isdual: false, succ: false }), e2;
            }
            this._isDualStreamEnabled = false, eI.streamSwitch(this._sessionId, { lts: Date.now(), isdual: false, succ: true }), jC.info("[".concat(this._clientId, "] disable dual stream"));
          }
        }
        async setClientRole(e2, t2) {
          if (function(e3) {
            qg(e3, "role", ["audience", "host"]);
          }(e2), t2 && IT(t2), "rtc" === this.mode || "p2p" === this.mode) throw jC.warning("[".concat(this._clientId, "]").concat(this.mode, " mode can not use setClientRole")), new LI(Hg.INVALID_OPERATION, "".concat(this.mode, " mode can not use setClientRole"));
          if (t2 && t2.level && "host" === e2) throw new LI(Hg.INVALID_OPERATION, "host mode can not set audience latency level");
          if ("audience" === e2 && this._p2pChannel.hasLocalMedia()) throw new LI(Hg.INVALID_OPERATION, "can not set client role to audience when publishing stream");
          await this._gateway.setClientRole(e2, t2), this._config.role = e2, jC.info("[".concat(this._clientId, "] set client role to ").concat(e2, ", level: ").concat(t2 && t2.level));
        }
        getRemoteInboundOffset() {
          var e2;
          const t2 = null === (e2 = this._p2pChannel.getStats()) || void 0 === e2 ? void 0 : e2.audioSend[0];
          if (!t2 || !t2.timestamp) return 0;
          const i2 = t2.timestamp - Date.now();
          return Math.abs(i2) > 1e3 + t2.rttMs + 100 ? this.ntpAlignErrorCount += 1 : this.ntpAlignErrorCount = 0, this.ntpAlignErrorCount >= 3 ? i2 : 0;
        }
        getNtpWallTimeInMs() {
          return "visible" === document.visibilityState && (this.remoteInboundOffset = this.getRemoteInboundOffset()), this.remoteInboundOffset + Date.now() + this._gateway.ntpOffset;
        }
        setProxyServer(e2, t2) {
          if (Xg(e2, "proxyServer"), !t2) {
            if ("DISCONNECTED" !== this.connectionState) throw new LI(Hg.INVALID_OPERATION, "Set proxy server before join channel");
            if ("disabled" !== this._cloudProxyServerMode || this._useLocalAccessPoint) throw new LI(Hg.INVALID_OPERATION, "You have already set the proxy");
          }
          this._proxyServer = e2, eI.setProxyServer(this._proxyServer), jC.setProxyServer(this._proxyServer), jC.info("[".concat(this._clientId, "] Set proxy server ").concat(t2 ? "by initialize call" : "", " success."));
        }
        setTurnServer(e2, t2) {
          if (Array.isArray(e2) || (e2 = [e2]), !t2) {
            if ("DISCONNECTED" !== this.connectionState) throw new LI(Hg.INVALID_OPERATION, "Set turn server before join channel");
            if ("disabled" !== this._cloudProxyServerMode || this._useLocalAccessPoint) throw new LI(Hg.INVALID_OPERATION, "You have already set the proxy");
          }
          if (RT(e2)) return this._turnServer = { servers: e2, mode: "original-manual" }, void jC.info("[".concat(this._clientId, "] Set original turnserver ").concat(t2 ? "by initialize call" : "", " success: ").concat(e2.map((e3) => e3.urls).join(","), "."));
          e2.forEach((e3) => CT(e3)), this._turnServer = { servers: e2, mode: "manual" }, jC.info("[".concat(this._clientId, "] Set turnserver ").concat(t2 ? "by initialize call" : "", " success."));
        }
        setLicense(e2) {
          if ("DISCONNECTED" !== this.connectionState) {
            throw new LI(Hg.INVALID_OPERATION, "you should set license before join channel");
          }
          if (Xg(e2, "license", 32, 32), !/^[A-Za-z\d]+$/.test(e2)) throw new LI(Hg.INVALID_PARAMS, "license should only contains characters from A-Z a-z 0-9");
          this._license = e2, jC.info("[".concat(this._clientId, "] set license success"), e2);
        }
        startProxyServer(e2) {
          if ("DISCONNECTED" !== this.connectionState) throw new LI(Hg.INVALID_OPERATION, "Start proxy server before join channel");
          if (this._proxyServer || "manual" === this._turnServer.mode || this._useLocalAccessPoint) throw new LI(Hg.INVALID_OPERATION, "You have already set the proxy");
          const t2 = [3, 4, 5];
          let i2;
          switch (void 0 === e2 && (e2 = 3), e2) {
            case 1:
            case 2:
              throw new LI(Hg.NOT_SUPPORTED, "proxy mode 1/2 has been deprecated and not supported.");
            case 3:
              i2 = "proxy3";
              break;
            case 4:
              i2 = "proxy4";
              break;
            case 5:
              i2 = "proxy5";
              break;
            default:
              throw new LI(Hg.INVALID_PARAMS, "proxy server mode must be ".concat(t2.join("|")));
          }
          this._cloudProxyServerMode = i2, this.store.cloudProxyServerMode = i2, jC.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode);
        }
        stopProxyServer() {
          if ("DISCONNECTED" !== this.connectionState) throw new LI(Hg.INVALID_OPERATION, "Stop proxy server after leave channel");
          eI.setProxyServer(), jC.setProxyServer(), this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled", jC.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode), this._proxyServer = void 0, this._turnServer = { mode: "auto", servers: [] };
        }
        setLocalAccessPointsV2(e2) {
          if (!e2.accessPoints) throw new LI(Hg.INVALID_PARAMS, "accessPoints is required.");
          Qg(e2.accessPoints.serverList, "accessPoints.serverList"), Xg(e2.accessPoints.domain, "accessPoints.domain");
          const t2 = (e3, t3) => {
            zg(e3, t3, 0, 65535, true);
          };
          let i2 = 443;
          if (e2.accessPoints.port && (t2(e2.accessPoints.port, "accessPoints.port"), i2 = e2.accessPoints.port), this._proxyServer || "disabled" !== this._cloudProxyServerMode) throw new LI(Hg.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
          RC("CLOSE_AFB_FOR_LOCAL_AP") && (SC("JOIN_WITH_FALLBACK_SIGNAL_PROXY", false), SC("JOIN_WITH_FALLBACK_MEDIA_PROXY", false));
          const n2 = /^((\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/, r2 = e2.accessPoints.domain, s2 = e2.accessPoints.serverList.map((e3) => n2.test(e3) ? "".concat(e3.replace(/\./g, "-"), ".").concat(r2) : e3), o2 = s2.map((e3) => "".concat(e3, ":").concat(i2));
          this._useLocalAccessPoint = true, this._setLocalAPVersion = 2, SC("WEBCS_DOMAIN", o2), SC("WEBCS_DOMAIN_BACKUP_LIST", o2), SC("GATEWAY_DOMAINS", [r2]), e2.report && e2.report.hostname && Array.isArray(e2.report.hostname) && e2.report.hostname.length ? (Qg(e2.report.hostname, "report.hostname"), SC("EVENT_REPORT_DOMAIN", e2.report.hostname[0]), SC("EVENT_REPORT_BACKUP_DOMAIN", e2.report.hostname[1] || e2.report.hostname[0])) : (SC("EVENT_REPORT_DOMAIN", s2[0]), SC("EVENT_REPORT_BACKUP_DOMAIN", s2[1] || s2[0]));
          let a2 = 6443;
          e2.report && e2.report.port && (t2(e2.report.port, "report.port"), a2 = e2.report.port), SC("STATS_COLLECTOR_PORT", a2), e2.report ? SC("ENABLE_EVENT_REPORT", true) : SC("ENABLE_EVENT_REPORT", false);
          let c2 = "";
          e2.log && e2.log.hostname && Array.isArray(e2.log.hostname) && e2.log.hostname.length ? (Qg(e2.log.hostname, "log.hostname"), c2 = e2.log.hostname[0]) : c2 = s2[0];
          let d2 = 6444;
          e2.log && e2.log.port && (t2(e2.log.port, "log.port"), d2 = e2.log.port), SC("LOG_UPLOAD_SERVER", "".concat(c2, ":").concat(d2));
          let l2 = [];
          e2.cds && e2.cds.hostname && Array.isArray(e2.cds.hostname) && e2.cds.hostname.length ? (Qg(e2.cds.hostname, "cds.hostname"), l2 = e2.cds.hostname) : l2 = s2;
          let u2 = 443;
          e2.cds && e2.cds.port && (t2(e2.cds.port, "cds.port"), u2 = e2.cds.port), SC("CDS_AP", l2.map((e3) => "".concat(e3, ":").concat(u2))), e2.cds ? SC("ENABLE_CONFIG_DISTRIBUTE", true) : SC("ENABLE_CONFIG_DISTRIBUTE", false), jC.info("set local access point v2 success");
        }
        setLocalAccessPoints(e2, t2) {
          if (Qg(e2, "serverList"), Xg(t2, "domain"), this._proxyServer || "disabled" !== this._cloudProxyServerMode) throw new LI(Hg.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
          const i2 = /^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/;
          e2 = e2.map((e3) => i2.test(e3) ? "".concat(e3.replace(/\./g, "-"), ".").concat(t2) : e3), this._useLocalAccessPoint = true, this._setLocalAPVersion = 1, SC("WEBCS_DOMAIN", e2), SC("WEBCS_DOMAIN_BACKUP_LIST", e2), SC("GATEWAY_DOMAINS", [t2]), SC("EVENT_REPORT_DOMAIN", e2[0]), SC("EVENT_REPORT_BACKUP_DOMAIN", e2[1] || e2[0]), SC("LOG_UPLOAD_SERVER", "".concat(e2[0], ":6444")), jC.info("[".concat(this._clientId, "] set local access point success"));
        }
        async setRemoteDefaultVideoStreamType(e2) {
          if (qg(e2, "streamType", [0, 1]), this._remoteDefaultVideoStreamType = e2, this._joinInfo) try {
            await this._gateway.setDefaultRemoteVideoStreamType(e2), this._joinInfo.defaultVideoStream = this._remoteDefaultVideoStreamType;
          } catch (e3) {
            throw jC.error("[".concat(this._clientId, "] set default remote video stream type error"), e3.toString()), e3;
          }
          else jC.debug("[".concat(this._clientId, "] haven't joined yet, cache remoteDefaultVideoStreamType ").concat(e2));
        }
        async setRemoteVideoStreamType(e2, t2) {
          qg(t2, "streamType", [0, 1]);
          try {
            await this._gateway.setRemoteVideoStreamType(e2, t2), setTimeout(() => {
              const t3 = this._users.find((t4) => t4.uid === e2);
              t3 && t3.videoTrack && t3.videoTrack.updateMediaStreamTrackResolution();
            }, 2e3);
          } catch (e3) {
            throw jC.error("[".concat(this._clientId, "] set remote video stream type error"), e3.toString()), e3;
          }
          jC.info("[".concat(this._clientId, "] set remote ").concat(e2, " video stream type to ").concat(t2)), this._remoteStreamTypeCacheMap.set(e2, t2);
        }
        async setStreamFallbackOption(e2, t2) {
          qg(t2, "fallbackType", [0, 1, 2]);
          try {
            await this._gateway.setStreamFallbackOption(e2, t2);
          } catch (e3) {
            throw jC.error("[".concat(this._clientId, "] set stream fallback option"), e3.toString()), e3;
          }
          jC.info("[".concat(this._clientId, "] set remote ").concat(e2, " stream fallback type to ").concat(t2)), this._streamFallbackTypeCacheMap.set(e2, t2);
        }
        setEncryptionConfig(e2, t2, i2, n2) {
          !function(e3) {
            qg(e3, "encryptionMode", ["aes-128-xts", "aes-256-xts", "aes-128-ecb", "sm4-128-ecb", "aes-128-gcm", "aes-256-gcm", "aes-128-gcm2", "aes-256-gcm2", "none"]);
          }(e2), Xg(t2, "secret");
          const r2 = ["aes-128-gcm2", "aes-256-gcm2"];
          if (bn(r2).call(r2, e2)) {
            if (!i2 || !(i2 instanceof Uint8Array && 32 === i2.length)) throw new LI(Hg.INVALID_PARAMS, "salt must be an Uint8Array and exactly equal to 32 bytes");
          } else if (i2) throw new LI(Hg.INVALID_PARAMS, "current encrypt mode does not need salt");
          if (n2) {
            if (Yg(n2, "encryptDataStream"), !bn(r2).call(r2, e2)) throw new LI(Hg.INVALID_PARAMS, "current encrypt mode does not support data stream");
            this._encryptDataStream = true;
          }
          new RegExp(`^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*,.<>?/:;'"|{}\\[\\]])(?=.{8,})`).test(t2) || jC.warning("The secret is not strong:\n      The secret must contain at least 1 lowercase alphabetical character,\n      The secret must contain at least 1 uppercase alphabetical character,\n      The secret must contain at least 1 numeric character,\n      The secret must contain at least one special character,\n      The secret must be eight characters or longer.\n      "), this._encryptionMode = e2, this._encryptionSecret = t2, i2 && (this._encryptionSalt = QT(i2));
        }
        async renewToken(e2) {
          if (Xg(e2, "token", 1, 2047), !this._key || !this._joinInfo) throw new LI(Hg.INVALID_OPERATION, "renewToken should not be called before user join");
          const t2 = this._key;
          this._key = e2, this._joinInfo && (this._joinInfo.token = e2);
          const i2 = await this._renewTokenMutex.lock();
          try {
            if (RC("USE_NEW_TOKEN")) {
              jC.debug("[".concat(this._clientId, "] start renew token with ticket from unilbs"));
              const t3 = await gA(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || ES);
              jC.debug("[".concat(this._clientId, "] get ticket from unilbs success")), await this._gateway.renewToken({ token: e2, ticket: t3 });
            } else jC.debug("[".concat(this._clientId, "] start renew token without ticket")), await this._gateway.renewToken({ token: e2 });
            jC.debug("[".concat(this._clientId, "] renewToken success"));
          } catch (e3) {
            throw this._key = t2, this._joinInfo.token = t2, jC.error("[".concat(this._clientId, "] renewToken failed"), e3.toString()), e3;
          } finally {
            i2();
          }
        }
        enableAudioVolumeIndicator() {
          this._audioVolumeIndicationInterval ? jC.warning("you have already enabled audio volume indicator!") : this._audioVolumeIndicationInterval = window.setInterval(() => {
            const e2 = this._p2pChannel.getAudioLevels();
            this.safeEmit(mT.VOLUME_INDICATOR, e2);
          }, RC("AUDIO_VOLUME_INDICATION_INTERVAL") || 2e3);
        }
        getRTCStats() {
          const e2 = this._statsCollector.getRTCStats(), t2 = this._gateway.getInChannelInfo();
          return e2.Duration = Math.round(t2.duration / 1e3), e2;
        }
        async startLiveStreaming(e2, t2) {
          if (!t2) {
            if ("h264" !== this.codec) throw new LI(Hg.LIVE_STREAMING_INVALID_RAW_STREAM, "raw streaming is only support h264");
            if (!this._p2pChannel.hasLocalMedia()) throw new LI(Hg.LIVE_STREAMING_INVALID_RAW_STREAM, "can not find stream to raw streaming");
          }
          if (this._liveRawStreamingClient && this._liveRawStreamingClient.hasUrl(e2) || this._liveTranscodeStreamingClient && this._liveTranscodeStreamingClient.hasUrl(e2)) throw new LI(Hg.LIVE_STREAMING_TASK_CONFLICT);
          const i2 = t2 ? RI.TRANSCODE : RI.RAW;
          return this._createLiveStreamingClient(i2).startLiveStreamingTask(e2, i2);
        }
        setLiveTranscoding(e2) {
          return this._createLiveStreamingClient(RI.TRANSCODE).setTranscodingConfig(e2);
        }
        async stopLiveStreaming(e2) {
          const t2 = [this._liveRawStreamingClient, this._liveTranscodeStreamingClient].filter((t3) => t3 && t3.hasUrl(e2));
          if (!t2.length) throw new LI(Hg.INVALID_PARAMS, "can not find live streaming url to stop");
          await cg.all(t2.map((t3) => t3 && t3.stopLiveStreamingTask(e2)));
        }
        async addInjectStreamUrl(e2, t2) {
          if (!this._joinInfo) throw new LI(Hg.INVALID_OPERATION, "can not addInjectStreamUrl, no joininfo");
          const i2 = this._createLiveStreamingClient(RI.INJECT);
          i2.setInjectStreamConfig(t2, 0), await i2.startLiveStreamingTask(e2, RI.INJECT);
        }
        async removeInjectStreamUrl() {
          var e2;
          const t2 = this._createLiveStreamingClient(RI.INJECT), i2 = Array.from(NI(e2 = t2.streamingTasks).call(e2)).find((e3) => e3.mode === RI.INJECT);
          if (!this._joinInfo || !i2) throw new LI(Hg.INVALID_OPERATION, "can remove addInjectStreamUrl, no joininfo or inject task");
          await t2.stopLiveStreamingTask(i2.url);
        }
        async startChannelMediaRelay(e2) {
          vV(e2);
          const t2 = this._createChannelMediaRelayClient();
          await t2.startChannelMediaRelay(e2);
        }
        async updateChannelMediaRelay(e2) {
          vV(e2);
          const t2 = this._createChannelMediaRelayClient();
          await t2.updateChannelMediaRelay(e2);
        }
        async stopChannelMediaRelay() {
          const e2 = this._createChannelMediaRelayClient();
          await e2.stopChannelMediaRelay(), this._statsCollector.onStatsChanged && (this._statsCollector.onStatsChanged = void 0);
        }
        async sendStreamMessage(e2) {
          var t2;
          let i2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (!this._joinInfo) throw new LI(Hg.INVALID_OPERATION, "can not send data stream, not joined");
          if (("string" == typeof e2 || e2 instanceof Uint8Array) && (e2 = { payload: e2 }), "string" == typeof e2.payload) {
            const t3 = new TextEncoder();
            e2.payload = t3.encode(e2.payload);
          }
          let n2 = false;
          this._encryptDataStream && this._encryptDataStreamIv && this._encryptDataStreamKey && window.crypto.subtle && bn(t2 = ["aes-128-gcm2", "aes-256-gcm2"]).call(t2, this._encryptionMode) && (n2 = true, e2.payload = await async function(e3, t3, i3) {
            var n3;
            const r2 = BT(n3 = Array.from(i3)).call(n3, (e4, t4) => e4 + t4, 0), s2 = { serverTs: 0, seq: LC++, length: i3.length, checkSum: r2 }, o2 = new Uint8Array(lS(r2, 2)), a2 = new ArrayBuffer(PC), c2 = new DataView(a2);
            c2.setUint32(0, s2.serverTs), c2.setUint16(4, s2.seq), c2.setUint16(6, s2.length), c2.setUint16(8, s2.checkSum);
            const d2 = 16 - i3.length % 16;
            i3 = ZT(i3, new Uint8Array(d2));
            const l2 = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: e3, tagLength: OC, additionalData: o2 }, t3, i3);
            return ZT(new Uint8Array(a2), new Uint8Array(l2));
          }(this._encryptDataStreamIv, this._encryptDataStreamKey, e2.payload));
          if (new Blob([e2.payload]).size > 1024) throw new LI(Hg.INVALID_PARAMS, n2 ? "encrypted stream message out of range." : "stream message out of range.");
          return this._gateway.signal.request(EI.DATA_STREAM, { payload: QT(e2.payload), syncWithAudio: e2.syncWithAudio, sendTs: Date.now() - RB }, !i2);
        }
        sendMetadata(e2) {
          if (!this._joinInfo) throw new LI(Hg.INVALID_OPERATION, "can not send metadata, not joined");
          if (new Blob([e2]).size > 1024) throw new LI(Hg.METADATA_OUT_OF_RANGE);
          return this._gateway.signal.request(EI.SEND_METADATA, { session_id: this._joinInfo.sid, metadata: QT(e2) });
        }
        async sendCustomReportMessage(e2) {
          if (Array.isArray(e2) || (e2 = [e2]), e2.forEach(HC), !this._joinInfo) throw new LI(Hg.INVALID_OPERATION, "can not send custom report, not joined");
          await eI.sendCustomReportMessage(this._joinInfo.sid, e2);
        }
        getLocalAudioStats() {
          return this._statsCollector.getLocalAudioTrackStats();
        }
        getRemoteAudioStats() {
          return this._statsCollector.getRemoteAudioTrackStats();
        }
        getLocalVideoStats() {
          return this._statsCollector.getLocalVideoTrackStats();
        }
        getRemoteVideoStats() {
          return this._statsCollector.getRemoteVideoTrackStats();
        }
        getRemoteNetworkQuality() {
          return this._statsCollector.getRemoteNetworkQualityStats();
        }
        async pickSVCLayer(e2, t2) {
          qg(t2.spatialLayer, "spatialLayer", [0, 1, 2, 3]), qg(t2.temporalLayer, "temporalLayer", [0, 1, 2, 3]);
          try {
            await this._gateway.pickSVCLayer(e2, t2);
          } catch (e3) {
            throw jC.error("[".concat(this._clientId, "] pick SVC layer failed"), e3.toString()), e3;
          }
        }
        async setRTMConfig(e2) {
          const { apRTM: t2 = false, rtmFlag: i2 } = e2;
          if (Yg(t2, "apRTM"), zg(i2, "rtmFlag", 0), this._rtmConfig.apRTM = t2, this._rtmConfig.rtmFlag = i2, jC.debug("[".concat(this._clientId, "] setRTMconfig ").concat(JSON.stringify(e2), " in ").concat(this.connectionState, " state")), ("CONNECTED" === this.connectionState || "RECONNECTING" === this.connectionState) && this._joinInfo) return this._joinInfo.apRTM = t2, this._joinInfo.rtmFlag = i2, this._gateway.setRTM2Flag(i2);
        }
        _reset() {
          if (jC.debug("[".concat(this._clientId, "] reset client")), this._axiosCancelSource.cancel(), this._axiosCancelSource = sC.CancelToken.source(), this._streamFallbackTypeCacheMap = /* @__PURE__ */ new Map(), this._remoteStreamTypeCacheMap = /* @__PURE__ */ new Map(), this._configDistribute.stopGetConfigDistribute(), this._joinInfo = void 0, this._proxyServer = void 0, this._defaultStreamFallbackType = void 0, this._sessionId = null, this.store.sessionId = null, this._statsCollector.reset(), this._key = void 0, this._appId = void 0, this._uid = void 0, this.store.uid = void 0, this._channelName = void 0, this._encryptionMode = "none", this._encryptionSecret = null, this._encryptionSalt = null, this._encryptDataStreamKey = null, this._encryptDataStreamIv = null, this._pendingPublishedUsers = [], this._users.forEach((e2) => {
            e2._audioTrack && e2._audioTrack._destroy(), e2._videoTrack && e2._videoTrack._destroy(), e2._dataChannels && (e2._dataChannels.forEach((e3) => e3._close()), e2._dataChannels.length = 0);
          }), this._users = [], this._audioVolumeIndicationInterval && (window.clearInterval(this._audioVolumeIndicationInterval), this._audioVolumeIndicationInterval = void 0), "fallback" === this._cloudProxyServerMode && (this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled"), this._p2pChannel.reset(), this._publishMutex = new pS("client-publish"), this._subscribeMutex = new pS("client-subscribe"), this._networkQualityInterval && (window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = void 0), this._injectStreamingClient && (this._injectStreamingClient.terminate(), this._injectStreamingClient.removeAllListeners(), this._injectStreamingClient = void 0), this._liveRawStreamingClient && (this._liveRawStreamingClient.terminate(), this._liveRawStreamingClient.removeAllListeners(), this._liveRawStreamingClient = void 0), this._liveTranscodeStreamingClient && (this._liveTranscodeStreamingClient.terminate(), this._liveTranscodeStreamingClient.removeAllListeners(), this._liveTranscodeStreamingClient = void 0), this._channelMediaRelayClient && (this._channelMediaRelayClient.dispose(), this._channelMediaRelayClient = void 0), this._inspect) try {
            this._inspect.close(), this._inspect = void 0;
          } catch (e2) {
          }
          if (this._moderation) try {
            this.setImageModeration(false);
          } catch (e2) {
          }
        }
        _startSession(e2, t2) {
          var i2;
          const n2 = e2 || rS();
          e2 ? jC.debug("[".concat(this._clientId, "] new Session ").concat(n2)) : jC.debug("[".concat(this._clientId, "] renewSession ").concat(this._sessionId, " => ").concat(n2));
          const r2 = e2 ? "" : this._sessionId || "";
          this._sessionId = n2, this.store.sessionId = n2;
          const s2 = { lts: (/* @__PURE__ */ new Date()).getTime(), mode: this.mode, stringUid: (null == t2 ? void 0 : t2.stringUid) || (null === (i2 = this._joinInfo) || void 0 === i2 ? void 0 : i2.stringUid), channelProfile: "live" === this.mode ? 1 : 0, channelMode: 0, isABTestSuccess: Number(this._configDistribute.isSuccess), lsid: r2, clientRole: "audience" === this.role ? 2 : 1 };
          t2 ? eI.sessionInit(this._sessionId, DB({ cname: t2.channel, appid: t2.appId }, s2)) : this._joinInfo ? eI.sessionInit(this._sessionId, DB({ cname: this._joinInfo.cname, appid: this._joinInfo.appId }, s2)) : this._gateway.joinInfo && eI.sessionInit(this._sessionId, DB({ cname: this._gateway.joinInfo.cname, appid: this._gateway.joinInfo.appId }, s2)), this._joinInfo && (this._joinInfo.sid = n2), this._gateway.joinInfo && (this._gateway.joinInfo.sid = n2);
        }
        async _publishHighStream(e2) {
          if (!this._joinInfo || void 0 === this._uid) throw new LI(Hg.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new LI(Hg.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
          if ("auto" === this._turnServer.mode && RC("FORCE_TURN") && !RC("TURN_ENABLE_TCP") && !RC("TURN_ENABLE_UDP")) throw new LI(Hg.UNEXPECTED_ERROR, "force TURN With No TURN Configuration");
          jC.debug("[".concat(this._clientId, "] publish high stream"));
          try {
            const i2 = await this._p2pChannel.publish(e2, this._isDualStreamEnabled, this._lowStreamParameter);
            if (this._p2pChannel instanceof hV) {
              const e3 = (await i2.next()).value;
              if (e3) {
                try {
                  await this._gateway.sendExtensionMessage(vv.PUBLISH, e3, true);
                } catch (e4) {
                  throw i2.throw(e4), e4;
                }
                await i2.next();
              }
              this._p2pChannel.reportPublishEvent(true, null);
            } else {
              const n2 = (await i2.next()).value;
              if (n2) {
                var t2;
                let e3;
                try {
                  e3 = await this._gateway.publish(this._uid, n2, true);
                } catch (e4) {
                  if (e4.code !== Hg.DISCONNECT_P2P) throw i2.throw(e4), e4;
                }
                await i2.next((null === (t2 = e3) || void 0 === t2 ? void 0 : t2.ortc) || []);
              }
              this._p2pChannel.reportPublishEvent(true, null);
              for (const t3 of e2) t3 instanceof Rw && t3._encoderConfig && this._gateway.setVideoProfile(t3._encoderConfig), !t3.muted && t3.enabled || await this._p2pChannel.muteLocalTrack(t3);
            }
          } catch (t3) {
            if (this._p2pChannel.reportPublishEvent(false, null == t3 ? void 0 : t3.code, e2), (null == t3 ? void 0 : t3.code) === Hg.WS_ABORT) return;
            throw t3;
          }
        }
        async _publishLowStream() {
          if (!this._joinInfo || void 0 === this._uid) throw new LI(Hg.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new LI(Hg.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
          jC.debug("[".concat(this._clientId, "] publish low stream"));
          const e2 = this._configDistribute.getLowStreamConfigDistribute();
          e2 && e2.bitrate && (this._lowStreamParameter || (this._lowStreamParameter = { width: 160, height: 120, framerate: 15, bitrate: 50 }), this._lowStreamParameter && this._lowStreamParameter.bitrate && e2.bitrate < this._lowStreamParameter.bitrate && (this._lowStreamParameter.bitrate = e2.bitrate));
          try {
            const e3 = await this._p2pChannel.publishLowStream(this._lowStreamParameter), i2 = (await e3.next()).value;
            if (i2) {
              var t2;
              let n2;
              try {
                n2 = await this._gateway.publish(this._uid, i2, true);
              } catch (t3) {
                if (t3.code !== Hg.DISCONNECT_P2P) throw e3.throw(t3), t3;
              }
              e3.next((null === (t2 = n2) || void 0 === t2 ? void 0 : t2.ortc) || []), this._p2pChannel.reportPublishEvent(true, null, void 0, true);
            }
          } catch (e3) {
            if (this._p2pChannel.reportPublishEvent(false, null == e3 ? void 0 : e3.code, void 0, true), (null == e3 ? void 0 : e3.code) === Hg.WS_ABORT) return;
            throw e3;
          }
        }
        _createLiveStreamingClient(e2) {
          if (!this._joinInfo || !this._appId) {
            return new LI(Hg.INVALID_OPERATION, "can not create live streaming client, please join channel first").throw();
          }
          const t2 = () => new CV(this._joinInfo, this._config.websocketRetryConfig || ES, this._config.httpRetryConfig || ES), i2 = (e3) => {
            e3.onLiveStreamError = (e4, t3) => {
              eI.reportApiInvoke(this._sessionId, { name: hT.ON_LIVE_STREAM_ERROR, options: [e4, t3], tag: pT.TRACER }).onSuccess(), this.safeEmit(mT.LIVE_STREAMING_ERROR, e4, t3);
            }, e3.onLiveStreamWarning = (e4, t3) => {
              eI.reportApiInvoke(this._sessionId, { name: hT.ON_LIVE_STREAM_WARNING, options: [e4, t3], tag: pT.TRACER }).onSuccess(), this.safeEmit(mT.LIVE_STREAMING_WARNING, e4, t3);
            }, e3.on(GI.REQUEST_WORKER_MANAGER_LIST, (e4, t3, i3) => {
              if (!this._joinInfo) return i3(new LI(Hg.INVALID_OPERATION, "can not find join info to get worker manager"));
              mA(e4, this._joinInfo, this._axiosCancelSource.token, ES).then(t3).catch(i3);
            });
          };
          switch (e2) {
            case RI.RAW:
              return this._liveRawStreamingClient || (this._liveRawStreamingClient = t2(), i2(this._liveRawStreamingClient)), this._liveRawStreamingClient;
            case RI.TRANSCODE:
              return this._liveTranscodeStreamingClient || (this._liveTranscodeStreamingClient = t2(), i2(this._liveTranscodeStreamingClient)), this._liveTranscodeStreamingClient;
            case RI.INJECT:
              return this._injectStreamingClient || (this._injectStreamingClient = t2(), this._injectStreamingClient.on(GI.REQUEST_WORKER_MANAGER_LIST, (e3, t3, i3) => {
                if (!this._joinInfo) return i3(new LI(Hg.INVALID_OPERATION, "can not find join info to get worker manager"));
                mA(e3, this._joinInfo, this._axiosCancelSource.token, ES).then(t3).catch(i3);
              }), this._injectStreamingClient.onInjectStatusChange = (e3, t3, i3) => {
                this.safeEmit(mT.INJECT_STREAM_STATUS, e3, t3, i3);
              }), this._injectStreamingClient;
          }
        }
        _createChannelMediaRelayClient() {
          if (!this._joinInfo) {
            return new LI(Hg.INVALID_OPERATION, "can not create channel media relay client, please join channel first").throw();
          }
          if (!this._channelMediaRelayClient) {
            const { sendResolutionWidth: e2, sendResolutionHeight: t2 } = this.getLocalVideoStats(), i2 = { width: e2, height: t2 };
            this._channelMediaRelayClient = new AV(this._joinInfo, this._clientId, this._config.websocketRetryConfig || ES, this._config.httpRetryConfig || ES, i2), this._channelMediaRelayClient.on("state", (e3) => {
              e3 === qI.RELAY_STATE_FAILURE && this._channelMediaRelayClient && this._channelMediaRelayClient.dispose(), this.safeEmit(mT.CHANNEL_MEDIA_RELAY_STATE, e3);
            }), this._channelMediaRelayClient.on("event", (e3) => {
              this.safeEmit(mT.CHANNEL_MEDIA_RELAY_EVENT, e3);
            }), this._statsCollector.onStatsChanged = (e3, t3) => {
              var i3;
              "resolution" === e3 && (null === (i3 = this._channelMediaRelayClient) || void 0 === i3 || i3.setVideoProfile(t3));
            };
          }
          return this._channelMediaRelayClient;
        }
        _handleUpdateDataChannel(e2, t2) {
          const { added: i2, deleted: n2 } = e2, r2 = [];
          Array.isArray(i2) && i2.length > 0 && i2.forEach((e3) => {
            const { uid: i3, stream_id: n3, ordered: s2, max_retrans_times: o2, metadata: a2 } = e3, c2 = this._users.find((e4) => e4._uintid === i3);
            if (!c2) return void jC.error("[".concat(this._clientId, "] can not find target user!(on_add_data_channel)"));
            jC.debug("[".concat(this._clientId, "] data_channel added with uid ").concat(i3)), bn(r2).call(r2, c2) || r2.push(c2), c2._uintid || (c2._uintid = i3);
            if (!(-1 !== c2._dataChannels.findIndex((t3) => t3.id === e3.stream_id))) {
              const e4 = { id: n3, ordered: !!s2, maxRetransmits: o2, metadata: a2 }, i4 = new oP(e4);
              c2._dataChannels.push(i4), jC.info("[".concat(this._clientId, "] remote user ").concat(c2.uid, " published datachannel")), t2 || this.safeEmit(mT.USER_PUBLISHED, c2, "datachannel", e4);
            }
            this._p2pChannel.hasPendingRemoteDataChannel(c2, e3.stream_id) && (jC.debug("[".concat(this._clientId, "] resubscribe datachannel for user ").concat(c2.uid, " after reconnect.")), this._subscribeDataChannel(c2, e3.stream_id).catch((e4) => {
              jC.error("[".concat(this._clientId, "] resubscribe datachannel error"), e4.toString());
            }));
          }), t2 && (this.safeEmit(mT.PUBLISHED_USER_LIST, this._pendingPublishedUsers), this._pendingPublishedUsers = []), Array.isArray(n2) && n2.length > 0 && n2.forEach((e3) => {
            const { uid: t3, stream_id: i3 } = e3, n3 = this._users.find((e4) => e4._uintid === t3);
            if (!n3) return void jC.error("[".concat(this._clientId, "] can not find target user!(on_delete_data_channel)"));
            const r3 = n3._dataChannels.find((t4) => t4.id === e3.stream_id);
            r3 && (jC.debug("[".concat(this._clientId, "] data_stream delete with uid ").concat(t3)), this._p2pChannel.unsubscribeDataChannel(n3, [r3]).then((e4) => {
              if (n3._dataChannels = n3._dataChannels.filter((e5) => e5 !== r3), e4) return this._gateway.unsubscribeDataChannel(e4, n3.uid);
            }), jC.info("[".concat(this._clientId, "] remote user ").concat(t3, " unpublished datachannel ,id:").concat(r3.id)), this.safeEmit(mT.USER_UNPUBLISHED, n3, "datachannel", r3._config));
          });
        }
        _handleRemoveDataChannels(e2) {
          const t2 = this._users.find((t3) => t3.uid === e2.uid);
          if (t2) {
            if (void 0 !== t2._dataChannels && t2._dataChannels.length > 0) {
              jC.debug("[".concat(this._clientId, "] datachannel removed with uid ").concat(e2.uid));
              const i2 = () => {
                jC.info("[".concat(this._clientId, "] remote user ").concat(t2.uid, " unpublished datachannel")), t2._dataChannels.forEach((e3) => {
                  this.safeEmit(mT.USER_UNPUBLISHED, t2, "datachannel", e3._config);
                });
              };
              this._p2pChannel.unsubscribeDataChannel(t2, t2._dataChannels).then((e3) => {
                if (e3) return this._gateway.unsubscribeDataChannel(e3, t2.uid);
              }), i2();
            }
          } else jC.warning("[".concat(this._clientId, "] can not find target user!(on_remove_datachannel)"));
        }
        _handleGatewayEvents() {
          this._gateway.on(XI.DISCONNECT_P2P, async () => {
            await this._p2pChannel.disconnectForReconnect();
          }), this._gateway.on(XI.CONNECTION_STATE_CHANGE, (e2, t2, i2) => {
            var n2;
            if (i2 === ET.FALLBACK) return;
            const r2 = () => {
              this.safeEmit(mT.CONNECTION_STATE_CHANGE, e2, t2, i2);
            };
            if (eI.reportApiInvoke(this._sessionId || (null === (n2 = this._gateway.joinInfo) || void 0 === n2 ? void 0 : n2.sid) || null, { name: hT.CONNECTION_STATE_CHANGE, options: [e2, t2, i2], tag: pT.TRACER }).onSuccess(JSON.stringify({ cur: e2, prev: t2, reason: i2 })), jC.info("[".concat(this._clientId, "] connection state change: ").concat(t2, " -> ").concat(e2)), "DISCONNECTED" === e2) return this._reset(), void r2();
            if ("RECONNECTING" === e2) this._users.forEach((e3) => {
              e3._trust_in_room_ = false, e3._trust_audio_enabled_state_ = false, e3._trust_video_enabled_state_ = false, e3._trust_audio_mute_state_ = false, e3._trust_video_mute_state_ = false, e3._trust_audio_stream_added_state_ = false, e3._trust_video_stream_added_state_ = false, e3._is_pre_created || (e3._audio_pre_subscribed || (e3._audioSSRC = void 0, e3._audioOrtc = void 0), e3._video_pre_subscribed || (e3._videoSSRC = void 0, e3._videoOrtc = void 0, e3._rtxSsrcId = void 0), e3._cname = void 0);
            }), this._userOfflineTimeout && window.clearTimeout(this._userOfflineTimeout), this._streamRemovedTimeout && window.clearTimeout(this._streamRemovedTimeout), this._userOfflineTimeout = void 0, this._streamRemovedTimeout = void 0;
            else if ("CONNECTED" === e2) {
              var s2;
              this._streamFallbackTypeCacheMap.forEach((e3, t3) => {
                this._gateway.setStreamFallbackOption(t3, e3).catch((e4) => {
                  jC.warning("[".concat(this._clientId, "] auto set stream fallback option failed"), e4);
                });
              }), this._remoteStreamTypeCacheMap.forEach((e3, t3) => {
                this._gateway.setRemoteVideoStreamType(t3, e3).catch((e4) => {
                  jC.warning("[".concat(this._clientId, "] auto set remote stream type failed"), e4);
                });
              }), void 0 !== this._remoteDefaultVideoStreamType && void 0 === (null === (s2 = this._joinInfo) || void 0 === s2 ? void 0 : s2.defaultVideoStream) && this.setRemoteDefaultVideoStreamType(this._remoteDefaultVideoStreamType).then(() => {
                jC.debug("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway connected"));
              }).catch((e3) => {
                jC.error("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway failed, ").concat(e3));
              }), this.store.useP2P || (this._p2pChannel.republish(), this._userOfflineTimeout = window.setTimeout(() => {
                if ("CONNECTED" !== this.connectionState) return;
                this._userOfflineTimeout = void 0;
                this._users.filter((e3) => !e3._trust_in_room_).forEach((e3) => {
                  jC.debug("[".concat(this._clientId, "] user offline timeout, emit user offline ").concat(e3.uid)), this._handleUserOffline({ uid: e3.uid });
                });
              }, 3e3), this._streamRemovedTimeout = window.setTimeout(() => {
                "CONNECTED" === this.connectionState && (this._streamRemovedTimeout = void 0, this._users.forEach((e3) => {
                  e3._trust_audio_mute_state_ || (jC.debug("[".concat(this._clientId, "] auto dispatch audio unmute event ").concat(e3.uid)), this._handleMuteStream(e3.uid, av.AUDIO, false)), e3._trust_video_mute_state_ || (jC.debug("[".concat(this._clientId, "] auto dispatch video unmute event ").concat(e3.uid)), this._handleMuteStream(e3.uid, av.VIDEO, false)), e3._trust_audio_enabled_state_ || (jC.debug("[".concat(this._clientId, "] auto dispatch enable local audio ").concat(e3.uid)), this._handleSetStreamLocalEnable("audio", e3.uid, true)), e3._trust_video_enabled_state_ || (jC.debug("[".concat(this._clientId, "] auto dispatch enable local video ").concat(e3.uid)), this._handleSetStreamLocalEnable("video", e3.uid, true)), e3._trust_video_stream_added_state_ || (jC.debug("[".concat(this._clientId, "] auto dispatch reset video stream added ").concat(e3.uid)), this._handleResetAddStream(e3, "video")), e3._trust_audio_stream_added_state_ || (jC.debug("[".concat(this._clientId, "] auto dispatch reset audio stream added ").concat(e3.uid)), this._handleResetAddStream(e3, "audio")), e3._video_added_ || e3._audio_added_ || (jC.debug("[".concat(this._clientId, "] auto dispatch stream remove ").concat(e3.uid)), this._handleRemoveStream({ uid: e3.uid, uint_id: e3._uintid }));
                }));
              }, 1e3));
            }
            r2();
          }), this._gateway.on(XI.REQUEST_NEW_GATEWAY_LIST, (e2, t2) => {
            if (!this._joinInfo) return t2(new LI(Hg.UNEXPECTED_ERROR, "can not recover, no join info"));
            uA(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || ES, this.store).then((t3) => {
              this._joinInfo && (this._joinInfo.apResponse = t3.gatewayInfo.res, this._joinInfo.gatewayAddrs = t3.gatewayInfo.gatewayAddrs, this._joinInfo.uni_lbs_ip = t3.gatewayInfo.uni_lbs_ip);
              const i2 = [];
              t3.gatewayInfo.gatewayAddrs.forEach((e3) => {
                let { address: t4 } = e3;
                const [n2, r2] = t4.split(":");
                this._joinInfo && this._joinInfo.proxyServer ? i2.push({ proxy: this._joinInfo.proxyServer, host: n2, port: r2 }) : i2.push({ host: n2, port: r2 });
              }), e2(i2);
            }).catch(t2);
          }), this._gateway.on(XI.NETWORK_QUALITY, (e2) => {
            "normal" === this._networkQualitySensitivity && this.safeEmit(mT.NETWORK_QUALITY, e2);
          }), this._gateway.on(XI.STREAM_TYPE_CHANGE, (e2, t2) => {
            this.safeEmit(mT.STREAM_TYPE_CHANGED, e2, t2);
            eI.reportApiInvoke(this._sessionId, { name: hT.STREAM_TYPE_CHANGE, options: [e2, t2], tag: pT.TRACER }).onSuccess(JSON.stringify({ uid: e2, streamType: t2 }));
          }), this._gateway.on(XI.IS_P2P_DISCONNECTED, (e2) => {
            this._p2pChannel.isP2PDisconnected() ? e2(true) : this._p2pChannel.hasLocalMedia() || this._p2pChannel.hasRemoteMedia() ? e2(false) : e2(true);
          }), this._gateway.on(XI.NEED_RENEW_SESSION, () => {
            this._startSession();
          }), this._gateway.on(XI.REQUEST_P2P_CONNECTION_PARAMS, async (e2, t2, i2) => {
            try {
              t2(await this._p2pChannel.startP2PConnection(e2));
            } catch (e3) {
              i2(e3);
            }
          }), this._gateway.on(XI.JOIN_RESPONSE, (e2, t2) => {
            if (this.store.useP2P) return;
            const { dtlsParameters: i2, iceParameters: n2, candidates: r2, rtpCapabilities: s2, setup: o2, cname: a2 } = Rx(e2.ortc, t2);
            this._p2pChannel.connect(n2, i2, r2, s2, o2, a2);
          }), this._gateway.on(XI.REQUEST_DC_CONNECTION_PARAMS, (e2) => {
            e2(this._p2pChannel.getEstablishParams());
          }), this._gateway.on(XI.RESET_SIGNAL, (e2) => {
            this._p2pChannel.resetConnection(e2), this._handleGatewaySignalEvents();
          }), this._gateway.on(XI.DATACHANNEL_FAILBACK, () => {
            this._joinGateway();
          }), this._gateway.on(XI.DATACHANNEL_PRECONNECT, async (e2, t2, i2, n2) => {
            var r2, s2, o2, a2, c2, d2;
            await this._p2pChannel.startP2PConnection({ turnServer: null === (r2 = this._joinInfo) || void 0 === r2 ? void 0 : r2.turnServer }, true);
            const l2 = function(e3, t3) {
              let i3;
              return t3 && t3.ip && "number" == typeof t3.port ? (i3 = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t3.ip, port: t3.port.toString(), type: "host", extension: {} }], jC.debug("Using remote candidate from AP ".concat(t3.ip, ":").concat(t3.port)), t3.ip6 && (i3.push({ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t3.ip6, port: t3.port.toString(), type: "host", extension: {} }), jC.debug("Using IPV6 remote candidate from AP ".concat(t3.ip6, ":").concat(t3.port)))) : i3 = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: e3.ip, port: e3.port.toString(), type: "host", extension: {} }], i3;
            }(e2, t2);
            return this._p2pChannel.preConnect({ iceUfrag: "".concat(null === (s2 = this._joinInfo) || void 0 === s2 ? void 0 : s2.apResponse.cid, "_").concat(null === (o2 = this._joinInfo) || void 0 === o2 ? void 0 : o2.apResponse.cert), icePwd: "".concat(null === (a2 = this._joinInfo) || void 0 === a2 ? void 0 : a2.apResponse.cid, "_").concat(null === (c2 = this._joinInfo) || void 0 === c2 ? void 0 : c2.apResponse.cert) }, { fingerprints: [{ hashFunction: "sha-256", fingerprint: null !== (d2 = RC("FINGERPRINT")) && void 0 !== d2 ? d2 : e2.fingerprint }] }, l2, { send: { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, recv: { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] } }, "active", "o/i14u9pJrxRKAsu").then(i2).catch(n2);
          });
        }
        _handleGatewaySignalEvents() {
          this._gateway.signal.on(fI.ON_USER_ONLINE, this._handleUserOnline), this._gateway.signal.on(fI.ON_USER_OFFLINE, this._handleUserOffline), this._gateway.signal.on(fI.ON_ADD_AUDIO_STREAM, (e2) => this._handleAddAudioOrVideoStream("audio", e2.uid, e2.ssrcId, e2.cname, e2.uint_id, e2.ortc)), this._gateway.signal.on(fI.ON_ADD_VIDEO_STREAM, (e2) => this._handleAddAudioOrVideoStream("video", e2.uid, e2.ssrcId, e2.cname, e2.uint_id, e2.ortc, e2.rtxSsrcId)), this._gateway.signal.on(fI.ON_REMOTE_DATASTREAM_UPDATE, (e2) => {
            this._handleUpdateDataChannel(e2);
          }), this._gateway.signal.on(fI.ON_REMOTE_FULL_DATASTREAM_INFO, (e2) => {
            this._handleUpdateDataChannel({ added: e2.datastreams, deleted: [] }, true);
          }), this._gateway.signal.on(fI.ON_REMOVE_STREAM, this._handleRemoveStream), this._gateway.signal.on(fI.ON_P2P_LOST, this._handleP2PLost), this._gateway.signal.on(fI.MUTE_AUDIO, (e2) => this._handleMuteStream(e2.uid, av.AUDIO, true)), this._gateway.signal.on(fI.UNMUTE_AUDIO, (e2) => this._handleMuteStream(e2.uid, av.AUDIO, false)), this._gateway.signal.on(fI.MUTE_VIDEO, (e2) => this._handleMuteStream(e2.uid, av.VIDEO, true)), this._gateway.signal.on(fI.UNMUTE_VIDEO, (e2) => this._handleMuteStream(e2.uid, av.VIDEO, false)), this._gateway.signal.on(fI.RECEIVE_METADATA, (e2) => {
            const t2 = XT(e2.metadata);
            this.safeEmit(mT.RECEIVE_METADATA, e2.uid, t2);
          }), this._gateway.signal.on(fI.ON_DATA_STREAM, async (e2) => {
            var t2;
            if (!e2) return;
            let i2 = XT(e2.payload);
            if (this._encryptDataStream && this._encryptDataStreamIv && this._encryptDataStreamKey && window.crypto.subtle && bn(t2 = ["aes-128-gcm2", "aes-256-gcm2"]).call(t2, this._encryptionMode)) {
              if (e2.payload.length < PC) throw new LI(Hg.UNEXPECTED_RESPONSE, "payload length ".concat(e2.payload.length, " is less than header length ").concat(PC));
              const t3 = await async function(e3, t4, i3) {
                const n3 = i3.subarray(0, PC), r2 = n3.slice(8, PC), s2 = (r2[0] << 8) + r2[1], o2 = (n3[6] << 8) + n3[7], a2 = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: e3, tagLength: OC, additionalData: new Uint8Array(lS(s2, 2)) }, t4, i3.subarray(PC));
                return new Uint8Array(a2).subarray(0, o2);
              }(this._encryptDataStreamIv, this._encryptDataStreamKey, i2);
              i2 = t3;
            }
            let n2 = 0;
            if (e2.ordered || e2.syncWithAudio) {
              const t3 = this._p2pChannel.getStats(), i3 = this.remoteUsers.find((t4) => t4.uid === e2.uid), r2 = null == t3 ? void 0 : t3.audioRecv.find((e3) => e3.ssrc === (null == i3 ? void 0 : i3._audioSSRC));
              n2 = null == r2 ? void 0 : r2.jitterBufferMs;
            }
            null == n2 && (n2 = 0), bB(DB(DB({}, e2), {}, { payload: i2 }), n2, { id: this._clientId, onStreamMessage: "function" == typeof this.onStreamMessage ? this.onStreamMessage.bind(this) : void 0, safeEmit: this.safeEmit.bind(this) });
          }), this._gateway.signal.on(fI.ON_CRYPT_ERROR, () => {
            JT(() => {
              jC.warning("[".concat(this._clientId, "] on crypt error")), this.safeEmit(mT.CRYPT_ERROR);
            }, this._sessionId);
          }), this._gateway.signal.on(fI.ON_TOKEN_PRIVILEGE_WILL_EXPIRE, this._handleTokenWillExpire), this._gateway.signal.on(fI.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
            jC.warning("[".concat(this._clientId, "] received message onTokenPrivilegeDidExpire, please get new token and join again")), this._gateway.leave(true, ET.TOKEN_EXPIRE), this.safeEmit(mT.ON_TOKEN_PRIVILEGE_DID_EXPIRE), this._reset();
          }), this._gateway.signal.on(fI.ON_STREAM_FALLBACK_UPDATE, (e2) => {
            jC.debug("[".concat(this._clientId, "] stream fallback peerId: ").concat(e2.stream_id, ", attr: ").concat(e2.stream_type)), this.safeEmit(mT.STREAM_FALLBACK, e2.stream_id, 1 === e2.stream_type ? "fallback" : "recover");
          }), this._gateway.signal.on(fI.ON_PUBLISH_STREAM, (e2) => {
            this.uid === this._uid && (this._p2pChannel.reportPublishEvent(true, null, void 0, false, JSON.stringify({ proxy: e2.proxy })), jC.info("[".concat(this._clientId, "] on publish stream, ").concat(JSON.stringify(e2))));
          }), this._gateway.signal.on(fI.ENABLE_LOCAL_VIDEO, (e2) => {
            this._handleSetStreamLocalEnable("video", e2.uid, true);
          }), this._gateway.signal.on(fI.DISABLE_LOCAL_VIDEO, (e2) => {
            this._handleSetStreamLocalEnable("video", e2.uid, false);
          }), this._gateway.signal.on(_I.REQUEST_TIMEOUT, (e2, t2) => {
            if (this._joinInfo) switch (e2) {
              case EI.PUBLISH: {
                if (!t2) return;
                const e3 = t2.ortc;
                if (e3) {
                  var i2, n2;
                  const r2 = e3.some((e4) => {
                    let { stream_type: t3 } = e4;
                    return t3 === JI.Audio;
                  }), s2 = e3.some((e4) => {
                    let { stream_type: t3 } = e4;
                    return t3 !== JI.Audio;
                  }), o2 = e3.some((e4) => {
                    let { stream_type: t3 } = e4;
                    return t3 === JI.Screen || t3 === JI.ScreenLow;
                  });
                  "offer" === t2.state && eI.publish(this._joinInfo.sid, { eventElapse: RU.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: false, ec: Hg.TIMEOUT, audio: r2, video: s2, p2pid: t2.p2p_id, publishRequestid: this.store.pubId, screenshare: o2, audioName: r2 ? null === (i2 = e3.find((e4) => {
                    let { stream_type: t3 } = e4;
                    return t3 === JI.Audio;
                  })) || void 0 === i2 || null === (i2 = i2.ssrcs[0]) || void 0 === i2 ? void 0 : i2.ssrcId.toString() : void 0, videoName: s2 ? null === (n2 = e3.find((e4) => {
                    let { stream_type: t3 } = e4;
                    return t3 !== JI.Audio;
                  })) || void 0 === n2 || null === (n2 = n2.ssrcs[0]) || void 0 === n2 ? void 0 : n2.ssrcId.toString() : void 0 });
                }
                break;
              }
              case EI.SUBSCRIBE:
                t2 && eI.subscribe(this._joinInfo.sid, { succ: false, ec: Hg.TIMEOUT, audio: t2.stream_type === av.AUDIO, video: t2.stream_type === av.VIDEO, peerid: t2.stream_id, subscribeRequestid: t2.ssrcId, p2pid: this.store.p2pId, eventElapse: RU.measureFromSubscribeStart(this.store.clientId, t2.ssrcId) });
            }
          }), this._gateway.signal.on(fI.ON_P2P_OK, (e2) => {
            this.uid, this._uid;
          }), this._gateway.signal.on(fI.ON_PUBLISHED_USER_LIST, (e2) => {
            if (null == e2 || !e2.users) return;
            RC("BLOCK_LOCAL_CLIENT") && (e2.users = e2.users.filter((e3) => !sI(e3.string_id || e3.stream_id, this.channelName)));
            const t2 = [], i2 = [];
            for (const n2 of e2.users) {
              let e3 = this._users.find((e4) => e4._uintid === n2.stream_id);
              e3 ? e3._trust_in_room_ = true : (e3 = new sV(n2.string_id || n2.stream_id, n2.stream_id), this._users.push(e3), 0 === this.getListeners(mT.PUBLISHED_USER_LIST).length && (jC.debug("[".concat(this._clientId, "] user online"), n2.stream_id), this.safeEmit(mT.USER_JOINED, e3)));
              const r2 = ZI.Audio & n2.stream_type, s2 = (ZI.Video | ZI.LwoVideo) & n2.stream_type, o2 = 0 != (65280 & n2.stream_type), a2 = r2 && e3.hasAudio, c2 = s2 && e3.hasVideo;
              s2 && (e3._trust_video_stream_added_state_ = true, e3._video_added_ = true, e3._videoSSRC = n2.video_ssrc, e3._rtxSsrcId = n2.video_rtx), r2 && (e3._trust_audio_stream_added_state_ = true, e3._audio_added_ = true, e3._audioSSRC = n2.audio_ssrc), r2 && !a2 && 0 === this.getListeners(mT.PUBLISHED_USER_LIST).length && (jC.info("[".concat(this._clientId, "] remote user ").concat(e3.uid, " published audio")), this.safeEmit(mT.USER_PUBLISHED, e3, "audio")), s2 && !c2 && 0 === this.getListeners(mT.PUBLISHED_USER_LIST).length && (jC.info("[".concat(this._clientId, "] remote user ").concat(e3.uid, " published video")), this.safeEmit(mT.USER_PUBLISHED, e3, "video")), (r2 && !a2 || s2 && !c2 || o2) && t2.push(e3), s2 && this._p2pChannel.hasPendingRemoteMedia(e3, "video") && i2.push({ user: e3, mediaType: "video" }), r2 && this._p2pChannel.hasPendingRemoteMedia(e3, "audio") && i2.push({ user: e3, mediaType: "audio" });
            }
            i2.length > 0 && (jC.debug("[".concat(this._clientId, "] RE massSubscribe after reconnect ").concat(i2.map((e3) => "user: ".concat(e3.user.uid, ", mediaType: ").concat(e3.mediaType)).join("; "), " ")), this.massSubscribe(i2).catch((e3) => {
              jC.error("[".concat(this._clientId, "] mass resubscribe error"), e3.toString());
            })), this.getListeners(mT.PUBLISHED_USER_LIST).length > 0 ? RC("ENABLE_DATASTREAM_2") ? this._pendingPublishedUsers = t2 : (jC.info("[".concat(this._clientId, "] client emit user-list event, users: ").concat(t2.map((e3) => e3.uid).join(", "))), this.safeEmit(mT.PUBLISHED_USER_LIST, t2)) : jC.info("[".concat(this._clientId, "] client not emit user-list event case there is no user-list listener, users: ").concat(t2.map((e3) => e3.uid).join(", ")));
          }), this._gateway.signal.on(fI.ON_RTP_CAPABILITY_CHANGE, (e2) => {
            const { video_codec: t2 } = e2;
            this._p2pChannel instanceof cF && this._p2pChannel.updateRemoteRTPCapabilities(t2.map((e3) => e3.toLowerCase()).filter((e3) => {
              var t3;
              return bn(t3 = Object.keys(bC)).call(t3, e3);
            }));
          });
        }
        _handleP2PEvents() {
          this._gateway.signal.on(fI.ON_USER_OFFLINE, () => {
            this._p2pChannel.disconnectForReconnect();
          }), this._gateway.signal.on(vv.PUBLISH, (e2, t2, i2) => {
            const { uid: n2 } = e2;
            e2.forEach((e3) => {
              const { kind: r2, ssrcs: s2, mid: o2, isMuted: a2 } = e3;
              this._handleP2PAddAudioOrVideoStream(r2, n2, s2[0].ssrcId, o2);
              const c2 = this._users.find((e4) => e4.uid === n2);
              return c2 && this._p2pChannel instanceof hV ? this._p2pChannel.mockSubscribe(c2, r2, s2[0].ssrcId, o2).then(() => {
                t2();
              }).catch(i2) : t2(), this._handleMuteStream(n2, r2, !!a2);
            });
          }), this._gateway.signal.on(vv.CALL, async (e2, t2, i2) => {
            if (this._p2pChannel instanceof hV) try {
              var n2;
              t2(await this._p2pChannel.startP2P({ turnServer: null === (n2 = this._joinInfo) || void 0 === n2 ? void 0 : n2.turnServer }, e2));
            } catch (e3) {
              i2(e3);
            }
          }), this._gateway.signal.on(_I.P2P_CONNECTION, async (e2) => {
            this._p2pChannel instanceof hV && await this._p2pChannel.p2pConnect(e2);
          }), this._gateway.signal.on(vv.UNPUBLISH, async (e2, t2, i2) => {
            if (this._p2pChannel instanceof hV) {
              const { unpubMsg: n2, uid: r2 } = e2, s2 = this._users.find((e3) => e3.uid === r2);
              if (!s2) return jC.warning("[".concat(this._clientId, "] can not find remote user, ignore mute event, uid: ").concat(r2)), void t2();
              try {
                n2.forEach(async (e3) => {
                  let { stream_type: t3 } = e3;
                  const i3 = t3 === JI.Audio ? av.AUDIO : av.VIDEO;
                  await this._p2pChannel.unsubscribe(s2, i3), this._handleMuteStream(r2, i3, true);
                }), t2();
              } catch (e3) {
                i2(e3);
              }
            }
          }), this._gateway.signal.on(vv.CONTROL, async (e2, t2) => {
            const { action: i2 } = e2;
            switch (i2) {
              case Av.MUTE_LOCAL_VIDEO:
                this._handleMuteStream(t2, av.VIDEO, true);
                break;
              case Av.MUTE_LOCAL_AUDIO:
                this._handleMuteStream(t2, av.AUDIO, true);
                break;
              case Av.UNMUTE_LOCAL_VIDEO:
                this._handleP2PAddAudioOrVideoStream("video", t2), this._handleMuteStream(t2, av.VIDEO, false);
                break;
              case Av.UNMUTE_LOCAL_AUDIO:
                this._handleP2PAddAudioOrVideoStream("audio", t2), this._handleMuteStream(t2, av.AUDIO, false);
            }
          }), this._gateway.signal.on(vv.RESTART_ICE, async (e2, t2, i2) => {
            if (this._p2pChannel instanceof hV) try {
              const { direction: i3, iceParameter: n2 } = e2;
              if (i3 !== TI.SEND_ONLY || n2) {
                t2(await this._p2pChannel.restartICE(i3, n2));
              } else this._p2pChannel.handleDisconnect(i3), t2();
            } catch (e3) {
              i2(e3);
            }
          }), this._gateway.signal.on(vv.CANDIDATE, (e2) => {
            if (this._p2pChannel instanceof hV) {
              const { candidate: t2, direction: i2 } = e2;
              this._p2pChannel.addRemoteCandidate(t2, i2);
            }
          }), this._p2pChannel.on(hv.RequestP2PRestartICE, async (e2, t2, i2) => {
            try {
              const { direction: i3 } = e2;
              t2(await this._gateway.sendExtensionMessage(vv.RESTART_ICE, e2, i3 === TI.SEND_ONLY));
            } catch (e3) {
              i2(e3);
            }
          }), this._p2pChannel.on(hv.LocalCandidate, (e2) => {
            this._gateway.sendExtensionMessage(vv.CANDIDATE, JSON.stringify(e2), true);
          }), this._p2pChannel.on(hv.RequestP2PMuteLocal, async (e2, t2, i2) => {
            try {
              await this._gateway.sendExtensionMessage(vv.CONTROL, e2, true), t2();
            } catch (e3) {
              i2(e3);
            }
          }), this._p2pChannel.on(hv.RequestP2PUnmuteRemote, async (e2, t2, i2) => {
            if (this._joinInfo) try {
              await this._gateway.unmuteRemote(e2, this._joinInfo.stringUid || this._joinInfo.uid), t2();
            } catch (e3) {
              e3.code === Hg.DISCONNECT_P2P ? t2() : i2(e3);
            }
            else t2();
          }), this._p2pChannel.on(hv.RequestP2PMuteRemote, async (e2, t2, i2) => {
            if (this._joinInfo) try {
              await this._gateway.muteRemote(e2, this._joinInfo.stringUid || this._joinInfo.uid), t2();
            } catch (e3) {
              e3.code === Hg.DISCONNECT_P2P ? t2() : i2(e3);
            }
            else t2();
          }), this._p2pChannel.on(hv.StateChange, (e2, t2) => {
            t2 === uv.Connected && this._p2pChannel.republish();
          });
        }
        _handleP2PChannelEvents() {
          this._p2pChannel.on(hv.RequestMuteLocal, async (e2, t2, i2) => {
            if (this._joinInfo) try {
              await this._gateway.muteLocal(e2, this._joinInfo.stringUid || this._joinInfo.uid), t2();
            } catch (e3) {
              e3.code === Hg.DISCONNECT_P2P ? t2() : i2(e3);
            }
            else t2();
          }), this._p2pChannel.on(hv.RequestUnmuteLocal, async (e2, t2, i2) => {
            if (this._joinInfo) try {
              await this._gateway.unmuteLocal(e2, this._joinInfo.stringUid || this._joinInfo.uid), t2();
            } catch (e3) {
              e3.code === Hg.DISCONNECT_P2P ? t2() : i2(e3);
            }
            else t2();
          }), this._p2pChannel.on(hv.RequestRePublish, (e2, t2, i2) => {
            this.publish(e2, false).then(t2).catch(i2);
          }), this._p2pChannel.on(hv.RequestRePublishDataChannel, (e2, t2, i2) => {
            cg.all(e2.map(async (e3) => {
              await this._p2pChannel.publishDataChannel([e3]);
              const t3 = { streamId: e3.id, ordered: e3.ordered, maxRetransmits: e3.maxRetransmits, metadata: e3.metadata, channelId: e3._originDataChannelId };
              try {
                await this._gateway.publishDataChannel(this._uid, t3, true);
              } catch (e4) {
                if (e4.code !== Hg.DISCONNECT_P2P) throw e4;
              }
            })).then(t2).catch(i2);
          }), this._p2pChannel.on(hv.RequestReSubscribe, async (e2, t2, i2) => {
            try {
              for (const { user: t3, kind: i3 } of e2) i3 === av.VIDEO ? await this.subscribe(t3, "video") : await this.subscribe(t3, "audio");
              t2();
            } catch (e3) {
              i2(e3);
            }
          }), this._p2pChannel.on(hv.RequestUpload, (e2, t2) => {
            this._gateway.upload(e2, t2);
          }), this._p2pChannel.on(hv.RequestUploadStats, (e2) => {
            this._gateway.uploadWRTCStats(e2);
          }), this._p2pChannel.on(hv.MediaReconnectStart, (e2) => {
            this.safeEmit(mT.MEDIA_RECONNECT_START, e2);
          }), this._p2pChannel.on(hv.MediaReconnectEnd, (e2) => {
            this.safeEmit(mT.MEDIA_RECONNECT_END, e2);
          }), this._p2pChannel.on(hv.NeedSignalRTT, (e2) => {
            e2(this._gateway.getSignalRTT());
          }), this._p2pChannel.on(hv.RequestRestartICE, async (e2) => {
            if (this._p2pChannel instanceof hV) return;
            const t2 = await this._p2pChannel.restartICE(e2), i2 = await t2.next();
            if (i2.done) return;
            const n2 = i2.value;
            let r2;
            try {
              r2 = await this._gateway.restartICE({ iceParameters: n2 });
            } catch (e3) {
              return void t2.throw(e3);
            }
            const { iceParameters: s2 } = function(e3) {
              const t3 = e3.iceParameters;
              return { iceParameters: { iceUfrag: t3.iceUfrag, icePwd: t3.icePwd } };
            }(r2);
            await t2.next({ remoteIceParameters: s2 });
          }), this._p2pChannel.on(hv.RequestReconnect, async () => {
            this._gateway.reconnect();
          }), this._p2pChannel.on(hv.RequestReconnectPC, async () => {
            var e2;
            const { iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 } = await this._p2pChannel.startP2PConnection({ turnServer: null === (e2 = this._joinInfo) || void 0 === e2 ? void 0 : e2.turnServer }), { gatewayEstablishParams: r2, gatewayAddress: s2 } = await this._gateway.reconnectPC({ iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 }), { dtlsParameters: o2, iceParameters: a2, candidates: c2, rtpCapabilities: d2, setup: l2, cname: u2 } = Rx(r2, s2);
            await this._p2pChannel.connect(a2, o2, c2, d2, l2, u2), await this._p2pChannel.republish(), await this._p2pChannel.reSubscribe();
          }), this._p2pChannel.on(hv.RequestUnpublishForReconnectPC, async (e2, t2, i2) => {
            this._joinInfo && void 0 !== this._uid ? (await this._gateway.unpublish(e2, this._uid), t2()) : i2();
          }), this._p2pChannel.on(hv.P2PLost, () => {
            this.safeEmit(mT.P2P_LOST, this.store.uid);
          }), this._p2pChannel.on(hv.UpdateVideoEncoder, (e2) => {
            e2._encoderConfig && this._gateway.setVideoProfile(e2._encoderConfig);
          }), this._p2pChannel.on(hv.ConnectionTypeChange, (e2) => {
            this.safeEmit(mT.IS_USING_CLOUD_PROXY, e2);
          }), this._p2pChannel.on(hv.RequestLowStreamParameter, (e2) => {
            e2(this._lowStreamParameter || { width: 160, height: 120, framerate: 15, bitrate: 50 });
          }), this._p2pChannel.on(hv.QueryClientConnectionState, (e2) => {
            e2(this.connectionState);
          });
        }
        getKeyMetrics() {
          return this.store.keyMetrics;
        }
        async enableContentInspect(e2) {
          if ("CONNECTED" !== this.connectionState || !this._joinInfo) throw new LI(Hg.INVALID_OPERATION, "[".concat(this._clientId, "] Client did not join channel"));
          if (this._inspect) throw new LI(Hg.INVALID_OPERATION, "[".concat(this._clientId, "] Inspect content service already in connecting/connected state"));
          if (!e2) throw new LI(Hg.INVALID_PARAMS, "[".concat(this._clientId, "] inspectConfig is necessary"));
          if (!e2.inspectType || !Array.isArray(e2.inspectType)) throw new LI(Hg.INVALID_PARAMS, "[".concat(this._clientId, "] inspectConfig.inspectType is necessary and is an instance of Array."));
          {
            const t2 = [...new Set(e2.inspectType)];
            t2.forEach((e3) => {
              var t3;
              if (!bn(t3 = ["supervise", "moderation"]).call(t3, e3)) throw new LI(Hg.INVALID_PARAMS, "[".concat(this._clientId, "] ").concat(e3, " is not a valid inspect type."));
            }), e2.inspectType = t2;
          }
          if (e2 && e2.extraInfo && e2.extraInfo.length > 1024) throw new LI(Hg.INVALID_PARAMS, "[".concat(this._clientId, "] inspectConfig.extraInfo length cannot exceed 1024 bytes"));
          try {
            const t2 = new FF(e2);
            this._inspect = t2, this.handleVideoInspectEvents(this._inspect), await t2.init({ appId: this._joinInfo.appId, areaCode: "", cname: this._joinInfo.cname, sid: this._joinInfo.sid, token: this._joinInfo.token, uid: this._joinInfo.uid, cid: this._joinInfo.cid, vid: this._joinInfo.vid ? Number(this._joinInfo.vid) : 0 }, ES);
          } catch (e3) {
            throw Array.isArray(e3) ? e3[0] : e3;
          }
        }
        async disableContentInspect() {
          if (!this._inspect) throw new LI(Hg.INVALID_OPERATION, "[".concat(this._clientId, "] inspectVideoContent not started"));
          try {
            this._inspect.close(), this._inspect = void 0;
          } catch (e2) {
            throw Array.isArray(e2) ? e2[0] : e2;
          }
        }
        async setImageModeration(e2, t2) {
          if (Yg(e2, "enabled"), e2) {
            if (!t2) throw new LI(Hg.INVALID_PARAMS, "[".concat(this._clientId, "] config is necessary"));
            if (zg(t2.interval, "interval", 1e3, 1 / 0), t2 && t2.extraInfo && t2.extraInfo.length > 1024) throw new LI(Hg.INVALID_PARAMS, "[".concat(this._clientId, "] config.extraInfo length cannot exceed 1024 bytes"));
            if (t2 && t2.vendor && t2.vendor.length > 1024) throw new LI(Hg.INVALID_PARAMS, "[".concat(this._clientId, "] config.vendor length cannot exceed 1024 bytes"));
            if ("CONNECTED" !== this.connectionState || !this._joinInfo) throw new LI(Hg.INVALID_OPERATION, "[".concat(this._clientId, '] can not enable image moderation, not joined"'));
            try {
              if (this._moderation) return void this._moderation.updateConfig(t2);
              const e3 = new gB(t2);
              this._moderation = e3, this.handleImageModerationEvents(this._moderation), await e3.init({ appId: this._joinInfo.appId, areaCode: "", cname: this._joinInfo.cname, sid: this._joinInfo.sid, token: this._joinInfo.token, uid: this._joinInfo.uid, cid: this._joinInfo.cid, vid: this._joinInfo.vid ? Number(this._joinInfo.vid) : 0 }, ES);
            } catch (e3) {
              throw Array.isArray(e3) ? e3[0] : e3;
            }
          } else {
            if (!this._moderation) throw new LI(Hg.INVALID_OPERATION, "[".concat(this._clientId, "] image moderation not started"));
            try {
              this._moderation.close(), this._moderation.removeAllListeners(), this._moderation = void 0;
            } catch (e3) {
              throw Array.isArray(e3) ? e3[0] : e3;
            }
          }
        }
        setP2PTransport(e2) {
          if (function(e3) {
            qg(e3, "transport", ["default", "auto", "relay", "sd-rtn"]);
          }(e2), "p2p" !== this.mode) throw new LI(Hg.INVALID_OPERATION, "only p2p mode can set p2pTransport");
          this.store.p2pTransport = e2, jC.info("[".concat(this._clientId, "] set client p2pTransport to ").concat(e2));
        }
        handleImageModerationEvents(e2) {
          e2.on(Cv.CONNECTION_STATE_CHANGE, (t2, i2) => {
            if (this.safeEmit(mT.IMAGE_MODERATION_CONNECTION_STATE_CHANGE, t2, i2), t2 === Rv.CONNECTED) {
              if ("CONNECTED" !== this.connectionState) throw this.setImageModeration(false), new LI(Hg.OPERATION_ABORTED, "Image moderation was cancelled because it left the channel");
              e2.inspectImage();
            }
          }), e2.on(Cv.CLIENT_LOCAL_VIDEO_TRACK, (e3) => {
            e3(this.localTracks.filter((e4) => "video" === e4.trackMediaType)[0]);
          });
        }
        handleVideoInspectEvents(e2) {
          e2.on(mv.CONNECTION_STATE_CHANGE, (t2, i2) => {
            if (this.safeEmit(mT.CONTENT_INSPECT_CONNECTION_STATE_CHANGE, t2, i2), i2 === _v.CONNECTED) {
              if ("CONNECTED" !== this.connectionState) return void this.safeEmit(mT.CONTENT_INSPECT_ERROR, new LI(Hg.OPERATION_ABORTED, "Content inspect was cancelled because it left the channel"));
              e2.inspectImage();
            }
          }), e2.on(mv.INSPECT_RESULT, (e3, t2) => {
            var i2;
            if ((null == t2 ? void 0 : t2.code) === Hg.INVALID_OPERATION && "DISCONNECTED" === this.connectionState) return jC.debug("Stop inspect content because that has left channel"), null == this || null === (i2 = this._inspect) || void 0 === i2 || i2.close(), void (this._inspect = void 0);
            this.safeEmit(mT.CONTENT_INSPECT_RESULT, e3, t2);
          }), e2.on(mv.CLIENT_LOCAL_VIDEO_TRACK, (e3) => {
            e3(this.localTracks.filter((e4) => "video" === e4.trackMediaType)[0]);
          });
        }
        getJoinChannelServiceRecords() {
          return jC.debug("getJoinChannelServiceRecords"), this.store.joinChannelServiceRecords;
        }
        async setPublishAudioFilterEnabled(e2) {
          Yg(e2, "enabled"), SC("ENABLE_PUBLISH_AUDIO_FILTER", e2), this._joinInfo && await this._gateway.setPublishAudioFilterEnabled(e2);
        }
        _handleResetAddStream(e2, t2) {
          switch (t2) {
            case "audio":
              e2._audio_added_ = false, e2._trust_audio_stream_added_state_ = true;
              break;
            case "video":
              e2._video_added_ = false, e2._trust_video_stream_added_state_ = true;
          }
        }
      }
      DI([$C(), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", cg)], PB.prototype, "leave", null), DI([$C({ argsMap: (e2, t2) => {
        if (!Array.isArray(t2)) {
          if (!(t2 instanceof lb)) return [t2];
          t2 = [t2];
        }
        return t2.map((e3) => e3 ? Object(e3).toString() : "null");
      } }), PI("design:type", Function), PI("design:paramtypes", [Object, Boolean]), PI("design:returntype", cg)], PB.prototype, "publish", null), DI([$C({ argsMap: (e2, t2) => (t2 || (t2 = []), t2 instanceof aP ? [t2.getChannelId()] : (Array.isArray(t2) || (t2 = [t2]), t2.map((e3) => e3.getTrackId()))) }), PI("design:type", Function), PI("design:paramtypes", [Object]), PI("design:returntype", cg)], PB.prototype, "unpublish", null), DI([$C({ argsMap: (e2, t2, i2, n2) => [t2.uid, i2, n2] }), PI("design:type", Function), PI("design:paramtypes", [sV, String, Number]), PI("design:returntype", cg)], PB.prototype, "subscribe", null), DI([$C({ argsMap: (e2, t2, i2) => [t2, i2] }), PI("design:type", Function), PI("design:paramtypes", [Object, String]), PI("design:returntype", cg)], PB.prototype, "presubscribe", null), DI([$C({ argsMap: (e2, t2) => t2.map((e3) => {
        let { user: t3, mediaType: i2 } = e3;
        return [null == t3 ? void 0 : t3.uid, i2];
      }) }), PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], PB.prototype, "massSubscribe", null), DI([$C({ argsMap: (e2, t2, i2, n2) => [t2.uid, i2, n2] }), PI("design:type", Function), PI("design:paramtypes", [sV, String, Number]), PI("design:returntype", cg)], PB.prototype, "unsubscribe", null), DI([$C({ argsMap: (e2, t2) => t2.map((e3) => {
        let { user: t3, mediaType: i2 } = e3;
        return { uid: null == t3 ? void 0 : t3.uid, mediaType: i2 };
      }) }), PI("design:type", Function), PI("design:paramtypes", [Array]), PI("design:returntype", cg)], PB.prototype, "massUnsubscribe", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [Object]), PI("design:returntype", cg)], PB.prototype, "setLowStreamParameter", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", cg)], PB.prototype, "enableDualStream", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", cg)], PB.prototype, "disableDualStream", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [String, Object]), PI("design:returntype", cg)], PB.prototype, "setClientRole", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [String, Boolean]), PI("design:returntype", void 0)], PB.prototype, "setProxyServer", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [Object, Boolean]), PI("design:returntype", void 0)], PB.prototype, "setTurnServer", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [String]), PI("design:returntype", void 0)], PB.prototype, "setLicense", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [Number]), PI("design:returntype", void 0)], PB.prototype, "startProxyServer", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], PB.prototype, "stopProxyServer", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [Object]), PI("design:returntype", void 0)], PB.prototype, "setLocalAccessPointsV2", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [Array, String]), PI("design:returntype", void 0)], PB.prototype, "setLocalAccessPoints", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [Number]), PI("design:returntype", cg)], PB.prototype, "setRemoteDefaultVideoStreamType", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [Object, Number]), PI("design:returntype", cg)], PB.prototype, "setRemoteVideoStreamType", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [Object, Number]), PI("design:returntype", cg)], PB.prototype, "setStreamFallbackOption", null), DI([$C({ argsMap: (e2, t2) => [t2] }), PI("design:type", Function), PI("design:paramtypes", [String, String, Uint8Array, Boolean]), PI("design:returntype", void 0)], PB.prototype, "setEncryptionConfig", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [String]), PI("design:returntype", cg)], PB.prototype, "renewToken", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", void 0)], PB.prototype, "enableAudioVolumeIndicator", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [String, Boolean]), PI("design:returntype", cg)], PB.prototype, "startLiveStreaming", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [Object]), PI("design:returntype", cg)], PB.prototype, "setLiveTranscoding", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [String]), PI("design:returntype", cg)], PB.prototype, "stopLiveStreaming", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [String, Object]), PI("design:returntype", cg)], PB.prototype, "addInjectStreamUrl", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", cg)], PB.prototype, "removeInjectStreamUrl", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [IV]), PI("design:returntype", cg)], PB.prototype, "startChannelMediaRelay", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [IV]), PI("design:returntype", cg)], PB.prototype, "updateChannelMediaRelay", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", cg)], PB.prototype, "stopChannelMediaRelay", null), DI([$C({ argsMap: (e2, t2) => (Array.isArray(t2) || (t2 = [t2]), [JSON.stringify(t2)]) }), PI("design:type", Function), PI("design:paramtypes", [Object]), PI("design:returntype", cg)], PB.prototype, "sendCustomReportMessage", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [Object, Object]), PI("design:returntype", cg)], PB.prototype, "pickSVCLayer", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [Object]), PI("design:returntype", cg)], PB.prototype, "setRTMConfig", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [Object]), PI("design:returntype", cg)], PB.prototype, "enableContentInspect", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", cg)], PB.prototype, "disableContentInspect", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [Boolean, Object]), PI("design:returntype", cg)], PB.prototype, "setImageModeration", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [String]), PI("design:returntype", void 0)], PB.prototype, "setP2PTransport", null), DI([$C({ reportResult: true }), PI("design:type", Function), PI("design:paramtypes", []), PI("design:returntype", Array)], PB.prototype, "getJoinChannelServiceRecords", null), DI([$C(), PI("design:type", Function), PI("design:paramtypes", [Boolean]), PI("design:returntype", cg)], PB.prototype, "setPublishAudioFilterEnabled", null);
      class LB {
        constructor(e2, t2) {
          sh(this, "id", 0), sh(this, "element", void 0), sh(this, "peerPair", void 0), sh(this, "context", void 0), sh(this, "audioPlayerElement", void 0), sh(this, "audioTrack", void 0), LB.count += 1, this.id = LB.count, this.element = e2, this.context = t2;
        }
        initPeers() {
          this.peerPair = [new RTCPeerConnection(), new RTCPeerConnection()], this.peerPair[1].ontrack = (e2) => {
            const t2 = document.createElement("audio");
            t2.srcObject = new MediaStream([e2.track]), t2.play(), this.audioPlayerElement = t2;
          };
        }
        async switchSdp() {
          if (!this.peerPair) return;
          const e2 = async (e3, t3) => {
            const i2 = "offer" === t3 ? await e3.createOffer() : await e3.createAnswer();
            return await e3.setLocalDescription(i2), "complete" === e3.iceGatheringState ? e3.localDescription : new cg((t4) => {
              e3.onicegatheringstatechange = () => {
                "complete" === e3.iceGatheringState && t4(e3.localDescription);
              };
            });
          }, t2 = async (e3, t3) => await e3.setRemoteDescription(t3);
          try {
            const i2 = await e2(this.peerPair[0], "offer");
            await t2(this.peerPair[1], i2);
            const n2 = await e2(this.peerPair[1], "answer");
            await t2(this.peerPair[0], n2);
          } catch (e3) {
            throw new LI(Hg.LOCAL_AEC_ERROR, e3.toString()).print();
          }
        }
        async getTracksFromMediaElement(e2) {
          if (this.audioTrack) return this.audioTrack;
          let t2;
          try {
            e2 instanceof HTMLVideoElement && (e2.captureStream ? e2.captureStream() : e2.mozCaptureStream()), t2 = this.context.createMediaStreamDestination();
            this.context.createMediaElementSource(e2).connect(t2);
          } catch (e3) {
            throw new LI(Hg.LOCAL_AEC_ERROR, e3.toString()).print();
          }
          if (!t2) {
            throw new LI(Hg.LOCAL_AEC_ERROR, "no dest node when local aec").print();
          }
          const i2 = t2.stream.getAudioTracks()[0];
          return this.audioTrack = i2, i2;
        }
        getElement() {
          return this.element;
        }
        async startEchoCancellation() {
          this.context.resume(), this.peerPair && this.close(), this.initPeers();
          const e2 = this.element, t2 = await this.getTracksFromMediaElement(e2);
          this.peerPair && this.peerPair[0].addTrack(t2), await this.switchSdp();
        }
        close() {
          jC.debug("close echo cancellation unit, id is", this.id), this.audioPlayerElement && this.audioPlayerElement.pause(), this.peerPair && this.peerPair.forEach((e2) => {
            e2.close();
          }), this.peerPair = void 0, this.audioPlayerElement = void 0;
        }
      }
      sh(LB, "count", 0);
      const kB = window.AudioContext || window.webkitAudioContext;
      class MB {
        constructor() {
          sh(this, "units", []), sh(this, "context", void 0);
        }
        processExternalMediaAEC(e2) {
          if (!this._doesEnvironmentNeedAEC()) return jC.debug("the system does not need to process local aec"), -1;
          this.context || (this.context = new kB());
          let t2 = this.units.find((t3) => t3 && t3.getElement() === e2);
          return t2 || (t2 = new LB(e2, this.context), this.units.push(t2)), t2.startEchoCancellation(), jC.debug("start processing local audio echo cancellation, id is", t2.id), t2.id;
        }
        _doesEnvironmentNeedAEC() {
          return Sg().name !== Eg.SAFARI;
        }
      }
      DI([$C({ report: eI }), PI("design:type", Function), PI("design:paramtypes", [HTMLAudioElement]), PI("design:returntype", Number)], MB.prototype, "processExternalMediaAEC", null);
      const UB = new MB();
      function xB(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function VB(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? xB(Object(i2), true).forEach(function(t3) {
            sh(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : xB(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      const FB = window || document;
      function BB(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        if (!FB) return;
        const i2 = GB._cspEventHandlerPointer;
        if (i2 && t2) return void console.error(i2, t2);
        const n2 = (e3) => {
          if (!(e3 && e3.blockedURI && (GB.onSecurityPolicyViolation || GB.getListeners(Tv.SECURITY_POLICY_VIOLATION).length > 0))) return;
          const t3 = e3.blockedURI;
          RC("CSP_DETECTED_HOSTNAME_LIST").some((e4) => bn(t3).call(t3, e4)) && (GB.onSecurityPolicyViolation && "function" == typeof GB.onSecurityPolicyViolation && GB.onSecurityPolicyViolation(e3), GB.getListeners(Tv.SECURITY_POLICY_VIOLATION).length > 0 && GB.safeEmit(Tv.SECURITY_POLICY_VIOLATION, e3));
        };
        i2 && FB.removeEventListener("securitypolicyviolation", i2), (t2 || e2 && "function" == typeof e2 || GB.getListeners(Tv.SECURITY_POLICY_VIOLATION).length > 0) && FB.addEventListener("securitypolicyviolation", n2), GB._cspEventHandlerPointer = n2;
      }
      SC("PROCESS_ID", "process-".concat(nS(8, ""), "-").concat(nS(4, ""), "-").concat(nS(4, ""), "-").concat(nS(4, ""), "-").concat(nS(12, ""))), function() {
        let e2;
        try {
          e2 = window.localStorage.getItem("websdk_ng_global_parameter");
        } catch (e3) {
          return void jC.error("Error loading sdk config", e3.message);
        }
        if (e2) try {
          const t2 = JSON.parse(window.atob(e2)), i2 = Date.now();
          jC.debug("Loading global parameters from cache", t2), Object.keys(t2).forEach((e3) => {
            if (Object.prototype.hasOwnProperty.call(TC, e3)) {
              const { value: n2, expires: r2 } = t2[e3];
              if (r2 && r2 <= i2) return;
              CC[e3] = n2, TC[e3] = n2;
            }
          });
        } catch (t2) {
          jC.error("Error loading mutableParamsCache: ".concat(e2), t2.message);
        }
      }(), Array.isArray(CC.AREAS) && CC.AREAS.length > 0 && Jy(CC.AREAS, true);
      const jB = (e2, t2, i2) => {
        jC.debug("setParameter key:".concat(e2, ", value:").concat(JSON.stringify(t2))), SC(e2, t2, i2);
      }, GB = function(e2) {
        const t2 = new dT(), i2 = e2, n2 = { getListeners: t2.getListeners.bind(t2), on: (e3, i3) => (function(e4, t3) {
          e4 === Tv.SECURITY_POLICY_VIOLATION && BB(t3, true);
        }(e3, i3), t2.on.bind(t2)(e3, i3)), addListener: t2.addListener.bind(t2), once: t2.once.bind(t2), off: t2.off.bind(t2), removeAllListeners: t2.removeAllListeners.bind(t2), emit: t2.emit.bind(t2), safeEmit: t2.safeEmit.bind(t2) };
        return VB(VB({}, i2), n2);
      }({ __TRACK_LIST__: VA, VERSION: EC, BUILD: gC, ESM_BUNDLER: false, ESM: false, UMD: true, DEV: false, setParameter: jB, getParameter: RC, getSupportedCodec: async function() {
        let e2 = { audio: [], video: [] };
        try {
          let t2 = new RTCPeerConnection();
          t2.addTransceiver("video", { direction: "recvonly" }), t2.addTransceiver("audio", { direction: "recvonly" });
          const i2 = (await t2.createOffer()).sdp;
          if (!i2) return e2;
          t2.close(), t2 = null, e2 = function(e3) {
            const t3 = { video: [], audio: [] };
            return e3.match(/ VP8/i) && t3.video.push("VP8"), e3.match(/ VP9/i) && t3.video.push("VP9"), e3.match(/ AV1/i) && t3.video.push("AV1"), e3.match(/ H264/i) && t3.video.push("H264"), e3.match(/ H265/i) && t3.video.push("H265"), e3.match(/ opus/i) && t3.audio.push("OPUS"), e3.match(/ PCMU/i) && t3.audio.push("PCMU"), e3.match(/ PCMA/i) && t3.audio.push("PCMA"), e3.match(/ G722/i) && t3.audio.push("G722"), t3;
          }(i2);
        } catch (e3) {
          throw new LI(Hg.CREATE_OFFER_FAILED, e3.toString && e3.toString()).print();
        }
        return e2;
      }, checkSystemRequirements: function() {
        const e2 = eI.reportApiInvoke(null, { name: hT.CHECK_SYSTEM_REQUIREMENTS, options: [], tag: pT.TRACER });
        let t2 = false;
        try {
          const e3 = window.RTCPeerConnection, i3 = navigator.mediaDevices && navigator.mediaDevices.getUserMedia, n3 = window.WebSocket;
          t2 = !!(e3 && i3 && n3);
        } catch (e3) {
          return jC.error("check system requirement failed: ", e3), false;
        }
        let i2 = false;
        const n2 = Sg();
        n2.name === Eg.CHROME && Number(n2.version) >= 58 && (!yg() || vg()) && (i2 = true), n2.name === Eg.FIREFOX && Number(n2.version) >= 56 && (i2 = true), n2.name === Eg.OPERA && Number(n2.version) >= 45 && (i2 = true), n2.name === Eg.SAFARI && Number(n2.version) >= 11 && (i2 = true), (Fg() || Sg().name === Eg.QQ) && (i2 = true), jC.debug("checkSystemRequirements, api:", t2, "browser", i2);
        const r2 = t2 && i2;
        return e2.onSuccess(r2), r2;
      }, getDevices: function(e2) {
        return kb.enumerateDevices(true, true, e2);
      }, getMicrophones: function(e2) {
        return kb.getRecordingDevices(e2);
      }, getCameras: function(e2) {
        return kb.getCamerasDevices(e2);
      }, getElectronScreenSources: yb, getPlaybackDevices: function(e2) {
        return kb.getSpeakers(e2);
      }, createClient: function() {
        var e2;
        let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { codec: "vp8", audioCodec: "opus", mode: "rtc" };
        const i2 = eI.reportApiInvoke(null, { name: hT.CREATE_CLIENT, options: [t2], tag: pT.TRACER });
        try {
          !function(e3) {
            qg(e3.codec, "config.codec", ["vp8", "vp9", "av1", "h264", "h265"]), qg(e3.mode, "config.mode", ["rtc", "live", "p2p"]), void 0 !== e3.audioCodec && qg(e3.audioCodec, "config.audioCodec", ["opus", "pcmu", "pcma", "g722"]), void 0 !== e3.proxyServer && Xg(e3.proxyServer, "config.proxyServer", 1, 1e4), void 0 !== e3.turnServer && CT(e3.turnServer), void 0 !== e3.httpRetryConfig && ST(e3.httpRetryConfig), void 0 !== e3.websocketRetryConfig && ST(e3.websocketRetryConfig);
          }(t2);
        } catch (e3) {
          throw i2.onError(e3), e3;
        }
        return OB() || ("vp9" === t2.codec && (t2.codec = "vp8", jC.debug("browser not support vp9, force use vp8")), SC("UNSUPPORTED_VIDEO_CODEC", ["vp9"])), void 0 === t2.audioCodec && (t2.audioCodec = "opus"), i2.onSuccess(), new PB(DB(DB({ forceWaitGatewayResponse: true }, t2), {}, { role: bn(e2 = ["rtc", "p2p"]).call(e2, t2.mode) ? "host" : t2.role || "audience" }));
      }, createCameraVideoTrack: async function() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        const t2 = eI.reportApiInvoke(null, { tag: pT.TRACER, name: hT.CREATE_CAM_VIDEO_TRACK, options: [vw({}, e2)] }), i2 = rw(e2), n2 = nS(8, "track-cam-");
        let r2 = null;
        const s2 = "720p_auto" === e2.encoderConfig;
        jC.info("start create camera video track with config", JSON.stringify(e2), "trackId", n2);
        try {
          r2 = (await Nb({ video: i2 }, n2)).getVideoTracks()[0] || null;
        } catch (e3) {
          throw t2.onError(e3), e3;
        }
        if (!r2) {
          const e3 = new Kg(Hg.UNEXPECTED_ERROR, "can not find track in media stream");
          return t2.onError(e3), e3.throw(jC);
        }
        e2.optimizationMode && yw(n2, r2, e2, LA(e2.encoderConfig));
        const o2 = new Cw(r2, e2, i2, e2.scalabiltyMode ? MA(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, n2);
        return s2 && o2.startMonitorStats(), t2.onSuccess(o2.getTrackId()), jC.info("create camera video success, trackId:", n2), o2;
      }, createCustomVideoTrack: function(e2) {
        const t2 = eI.reportApiInvoke(null, { tag: pT.TRACER, name: hT.CREATE_CUSTOM_VIDEO_TRACK, options: [e2] }), i2 = new Rw(e2.mediaStreamTrack, { width: e2.width, height: e2.height, frameRate: e2.frameRate, bitrateMax: e2.bitrateMax, bitrateMin: e2.bitrateMin }, e2.scalabiltyMode ? MA(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, nS(8, "track-cus-"), [jA.CUSTOM_TRACK]);
        return t2.onSuccess(i2.getTrackId()), jC.info("create custom video track success with config", e2, "trackId", i2.getTrackId()), i2;
      }, createScreenVideoTrack: async function() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "disable";
        const i2 = eI.reportApiInvoke(null, { tag: pT.TRACER, name: hT.CREATE_SCREEN_VIDEO_TRACK, options: [vw({}, e2), t2] }), n2 = "720p_auto" === e2.encoderConfig;
        e2.encoderConfig ? "string" == typeof e2.encoderConfig || e2.encoderConfig.width && e2.encoderConfig.height || (e2.encoderConfig.width = { max: 1920 }, e2.encoderConfig.height = { max: 1080 }) : e2.encoderConfig = "1080p_2";
        const r2 = function(e3) {
          const t3 = {};
          e3.screenSourceType && (t3.mediaSource = e3.screenSourceType), e3.extensionId && Ag() && (t3.extensionId = e3.extensionId);
          const { displaySurface: i3, selfBrowserSurface: n3, surfaceSwitching: r3, systemAudio: s3 } = e3;
          (Ng(107) || Dg(107) || Pg(93)) && (i3 && (qg(i3, "displaySurface", ["browser", "window", "monitor"]), t3.displaySurface = i3), n3 ? (qg(n3, "selfBrowserSurface", ["exclude", "include"]), t3.selfBrowserSurface = n3) : t3.selfBrowserSurface = "include", r3 && (qg(r3, "surfaceSwitching", ["exclude", "include"]), t3.surfaceSwitching = r3)), (Ng(105) || Dg(105) || Pg(91)) && s3 && (qg(s3, "systemAudio", ["exclude", "include"]), t3.systemAudio = s3), e3.electronScreenSourceId && (t3.sourceId = e3.electronScreenSourceId);
          const o3 = e3.encoderConfig ? kA(e3.encoderConfig) : null;
          return t3.mandatory = { chromeMediaSource: "desktop", maxWidth: o3 ? o3.width : void 0, maxHeight: o3 ? o3.height : void 0 }, o3 && (o3.frameRate && ("number" == typeof o3.frameRate ? (t3.mandatory.maxFrameRate = o3.frameRate, t3.mandatory.minFrameRate = o3.frameRate) : (t3.mandatory.maxFrameRate = o3.frameRate.max || o3.frameRate.ideal || o3.frameRate.exact || void 0, t3.mandatory.minFrameRate = o3.frameRate.min || o3.frameRate.ideal || o3.frameRate.exact || void 0), t3.frameRate = o3.frameRate), o3.width && (t3.width = o3.width), o3.height && (t3.height = o3.height)), t3;
        }(e2), s2 = nS(8, "track-scr-v-");
        let o2 = null, a2 = null;
        const c2 = IA();
        if (!c2.supportShareAudio && "enable" === t2) {
          const e3 = new Kg(Hg.NOT_SUPPORTED, "your browser or platform is not support share-screen with audio");
          return i2.onError(e3), e3.throw(jC);
        }
        jC.info("start create screen video track with config", e2, "withAudio", t2, "trackId", s2);
        try {
          const e3 = await Nb({ screen: r2, screenAudio: "auto" === t2 ? c2.supportShareAudio : "enable" === t2 }, s2);
          o2 = e3.getVideoTracks()[0] || null, a2 = e3.getAudioTracks()[0] || null;
        } catch (e3) {
          throw i2.onError(e3), e3;
        }
        if (!o2) {
          const e3 = new Kg(Hg.UNEXPECTED_ERROR, "can not find track in media stream");
          return i2.onError(e3), e3.throw(jC);
        }
        if (!a2 && "enable" === t2) {
          o2 && o2.stop();
          const e3 = new Kg(Hg.SHARE_AUDIO_NOT_ALLOWED);
          return i2.onError(e3), e3.throw(jC);
        }
        if (e2.optimizationMode || (e2.optimizationMode = "detail"), e2.optimizationMode) {
          yw(s2, o2, e2, e2.encoderConfig && kA(e2.encoderConfig) || void 0), e2.encoderConfig && "string" != typeof e2.encoderConfig && (e2.encoderConfig.bitrateMin = e2.encoderConfig.bitrateMax);
        }
        const d2 = new Rw(o2, e2.encoderConfig ? kA(e2.encoderConfig) : {}, e2.scalabiltyMode ? MA(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, s2, [jA.SCREEN_TRACK]);
        if (n2 && d2.startMonitorStats(), !a2) return i2.onSuccess(d2.getTrackId()), jC.info("create screen video track success", "video:", d2.getTrackId()), d2;
        const l2 = new ew(a2, void 0, nS(8, "track-scr-a-"), false);
        return i2.onSuccess([d2.getTrackId(), l2.getTrackId()]), jC.info("create screen video track success", "video:", d2.getTrackId(), "audio:", l2.getTrackId()), [d2, l2];
      }, createMicrophoneAndCameraTracks: async function() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const i2 = eI.reportApiInvoke(null, { tag: pT.TRACER, name: hT.CREATE_MIC_AND_CAM_TRACKS, options: [e2, t2] }), n2 = "720p_auto" === t2.encoderConfig, r2 = rw(t2), s2 = sw(e2), o2 = nS(8, "track-mic-"), a2 = nS(8, "track-cam-");
        let c2 = null, d2 = null;
        jC.info("start create camera video track(".concat(a2, ") and microphone audio track(").concat(o2, ") with config, audio: ").concat(JSON.stringify(e2), ", video: ").concat(JSON.stringify(t2)));
        try {
          const e3 = await Nb({ audio: s2, video: r2 }, "".concat(o2, "-").concat(a2));
          c2 = e3.getAudioTracks()[0], d2 = e3.getVideoTracks()[0];
        } catch (e3) {
          throw i2.onError(e3), e3;
        }
        if (!c2 || !d2) {
          const e3 = new Kg(Hg.UNEXPECTED_ERROR, "can not find tracks in media stream");
          return i2.onError(e3), e3.throw(jC);
        }
        t2.optimizationMode && yw(a2, d2, t2, LA(t2.encoderConfig));
        const l2 = new tw(c2, e2, s2, o2), u2 = new Cw(d2, t2, r2, t2.scalabiltyMode ? MA(t2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, t2.optimizationMode, a2);
        return n2 && u2.startMonitorStats(), i2.onSuccess([l2.getTrackId(), u2.getTrackId()]), jC.info("create camera video track(".concat(a2, ") and microphone audio track(").concat(o2, ") success")), [l2, u2];
      }, createMicrophoneAudioTrack: async function() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        const t2 = eI.reportApiInvoke(null, { tag: pT.TRACER, name: hT.CREATE_MIC_AUDIO_TRACK, options: [e2] }), i2 = sw(e2), n2 = nS(8, "track-mic-");
        let r2 = null;
        jC.info("start create microphone audio track with config", JSON.stringify(e2), "trackId", n2);
        try {
          r2 = (await Nb({ audio: i2 }, n2)).getAudioTracks()[0] || null;
        } catch (e3) {
          throw t2.onError(e3), e3;
        }
        if (!r2) {
          const e3 = new Kg(Hg.UNEXPECTED_ERROR, "can not find track in media stream");
          return t2.onError(e3), e3.throw(jC);
        }
        const s2 = new tw(r2, e2, i2, n2);
        return t2.onSuccess(s2.getTrackId()), jC.info("create microphone audio track success, trackId:", n2), s2;
      }, createCustomAudioTrack: function(e2) {
        const t2 = eI.reportApiInvoke(null, { tag: pT.TRACER, name: hT.CREATE_CUSTOM_AUDIO_TRACK, options: [e2] }), i2 = new ew(e2.mediaStreamTrack, e2.encoderConfig ? xA(e2.encoderConfig) : {}, nS(8, "track-cus-"), false);
        return jC.info("create custom audio track success with config", e2, "trackId", i2.getTrackId()), t2.onSuccess(i2.getTrackId()), i2;
      }, createBufferSourceAudioTrack: async function(e2) {
        var t2;
        const { cacheOnlineFile: i2, encoderConfig: n2 } = e2;
        let { source: r2 } = e2;
        const s2 = { source: r2 instanceof AudioBuffer ? "AudioBuffer" : r2 instanceof File ? null !== (t2 = File.name) && void 0 !== t2 ? t2 : "File" : r2, cacheOnlineFile: i2, encoderConfig: n2 }, o2 = eI.reportApiInvoke(null, { tag: pT.TRACER, name: hT.CREATE_BUFFER_AUDIO_TRACK, options: [s2] });
        if (RC("DISABLE_WEBAUDIO")) throw new Kg(Hg.NOT_SUPPORTED, "can not create BufferSourceAudioTrack when WebAudio disabled");
        const a2 = nS(8, "track-buf-");
        jC.info("start create buffer source audio track with config", JSON.stringify(s2), "trackId", a2);
        const c2 = r2;
        if (!(r2 instanceof AudioBuffer)) try {
          r2 = await cw(r2, i2);
        } catch (e3) {
          return o2.onError(e3), e3.throw(jC);
        }
        const d2 = new ow(r2), l2 = new iw(c2, d2, n2 ? xA(n2) : {}, a2);
        return jC.info("create buffer source audio track success, trackId:", a2), o2.onSuccess(l2.getTrackId()), l2;
      }, setAppType: function(e2) {
        if (jC.debug("setAppType: ".concat(e2)), !(Number.isInteger(e2) && e2 >= 0)) throw jC.debug("Invalid appType"), new LI(Hg.INVALID_PARAMS, "invalid app type", e2);
        SC("APP_TYPE", Math.floor(e2));
      }, setLogLevel: function(e2) {
        jC.setLogLevel(e2);
      }, enableLogUpload: function() {
        RC("USE_NEW_LOG") ? SC("UPLOAD_LOG", true) : jC.enableLogUpload();
      }, disableLogUpload: function() {
        RC("USE_NEW_LOG") ? SC("UPLOAD_LOG", false) : jC.disableLogUpload();
      }, createChannelMediaRelayConfiguration: function() {
        return new IV();
      }, checkAudioTrackIsActive: async function(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
        const i2 = eI.reportApiInvoke(null, { tag: pT.TRACER, name: hT.CHECK_AUDIO_TRACK_IS_ACTIVE, options: [t2] });
        if (!(e2 instanceof ew || e2 instanceof Nw)) {
          const e3 = new LI(Hg.INVALID_TRACK, "the parameter is not a audio track");
          return i2.onError(e3), e3.throw();
        }
        t2 && t2 < 1e3 && (t2 = 1e3);
        const n2 = e2 instanceof ew ? e2.getTrackLabel() : "remote_track", r2 = e2.getVolumeLevel();
        let s2 = r2, o2 = r2;
        const a2 = Date.now();
        return new cg((r3) => {
          const c2 = setInterval(() => {
            const d2 = e2.getVolumeLevel();
            s2 = d2 > s2 ? d2 : s2, o2 = d2 < o2 ? d2 : o2;
            const l2 = s2 - o2 > 1e-4, u2 = Date.now() - a2;
            if (l2 || u2 > t2) {
              clearInterval(c2);
              const t3 = l2, o3 = { duration: u2, deviceLabel: n2, maxVolumeLevel: s2, result: t3 };
              jC.info("[track-".concat(e2.getTrackId(), "] check audio track active completed. ").concat(JSON.stringify(o3))), i2.onSuccess(o3), r3(t3);
            }
          }, 200);
        });
      }, checkVideoTrackIsActive: async function(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
        const i2 = eI.reportApiInvoke(null, { tag: pT.TRACER, name: hT.CHECK_VIDEO_TRACK_IS_ACTIVE, options: [t2] });
        if (!(e2 instanceof Rw || e2 instanceof Ow)) {
          const e3 = new LI(Hg.INVALID_TRACK, "the parameter is not a video track");
          return i2.onError(e3), e3.throw();
        }
        t2 && t2 < 1e3 && (t2 = 1e3);
        const n2 = e2 instanceof Rw ? e2.getTrackLabel() : "remote_track", r2 = e2.getMediaStreamTrack(true), s2 = document.createElement("video");
        s2.style.width = "1px", s2.style.height = "1px", s2.setAttribute("muted", ""), s2.muted = true, s2.setAttribute("playsinline", ""), s2.controls = false, (bg() || Ig()) && (s2.style.opacity = "0.01", s2.style.position = "fixed", s2.style.left = "0", s2.style.top = "0", document.body.appendChild(s2)), s2.srcObject = new MediaStream([r2]), s2.play();
        const o2 = document.createElement("canvas");
        o2.width = 160, o2.height = 120;
        let a2 = 0, c2 = 0;
        try {
          const e3 = Date.now();
          a2 = await function(e4, t3, i3, n3) {
            let r3, s3 = 0, o3 = null;
            return new cg((a3, c3) => {
              function d3() {
                s3 > n3 && r3 && (r3(), a3(s3));
                const t4 = i3.getContext("2d");
                if (!t4) {
                  const e5 = new LI(Hg.UNEXPECTED_ERROR, "can not get canvas 2d context.");
                  return jC.error(e5.toString()), void c3(e5);
                }
                t4.drawImage(e4, 0, 0, 160, 120);
                const d4 = t4.getImageData(0, 0, i3.width, i3.height), l3 = Math.floor(d4.data.length / 3);
                if (o3) {
                  for (let e5 = 0; e5 < l3; e5 += 3) if (d4.data[e5] !== o3[e5]) return s3 += 1, void (o3 = d4.data);
                  o3 = d4.data;
                } else o3 = d4.data;
              }
              setTimeout(() => {
                r3 && (r3(), a3(s3));
              }, t3), r3 = Tb(() => {
                d3();
              }, 30);
            });
          }(s2, t2, o2, 4), c2 = Date.now() - e3;
        } catch (e3) {
          throw i2.onError(e3), e3;
        }
        wB === Eg.SAFARI && (s2.pause(), s2.remove()), s2.srcObject = null;
        const d2 = a2 > 4, l2 = { duration: c2, changedPicNum: a2, deviceLabel: n2, result: d2 };
        return jC.info("[track-".concat(e2.getTrackId(), "] check video track active completed. ").concat(JSON.stringify(l2))), i2.onSuccess(l2), d2;
      }, setArea: Jy, audioElementPlayCenter: Gb, resumeAudioContext: function() {
        Gb.autoResumeAfterInterruption(true);
      }, processExternalMediaAEC: function(e2) {
        UB.processExternalMediaAEC(e2);
      }, registerExtensions: function(e2) {
        const t2 = RC("PLUGIN_INFO") || [];
        e2.forEach((e3) => {
          "name" in e3 && !bn(t2).call(t2, e3.name) && t2.push(e3.name);
          const i2 = e3;
          i2.__registered__ = true, i2.logger.hookLog = jC.extLog, i2.reporter.hookApiInvoke = eI.extApiInvoke, i2.parameters && Object.keys(i2.parameters).forEach((e4) => {
            i2.parameters[e4] = RC(e4);
          });
        }), jB("PLUGIN_INFO", t2);
      }, ChannelMediaRelayError: zI, ChannelMediaRelayEvent: YI, ChannelMediaRelayState: qI, RemoteStreamFallbackType: HA, RemoteStreamType: WA, ConnectionDisconnectedReason: ET, AudienceLatencyLevelType: _T, AREAS: ev });
      return Object.defineProperties(GB, { onAudioAutoplayFailed: { get: () => Ub.onAudioAutoplayFailed, set: (e2) => {
        Ub.onAudioAutoplayFailed = e2;
      } }, onAutoplayFailed: { get: () => Ub.onAutoplayFailed, set: (e2) => {
        Ub.onAutoplayFailed = e2;
      } }, _onSecurityPolicyViolation: { value: void 0, writable: true }, _cspEventHandlerPointer: { value: void 0, writable: true }, onSecurityPolicyViolation: { get: () => GB._onSecurityPolicyViolation, set(e2) {
        GB._onSecurityPolicyViolation = e2, BB(e2);
      } }, __CLIENT_LIST__: { get: () => RC("SHOW_GLOBAL_CLIENT_LIST") ? rI : [] } }), kb.on(rb.CAMERA_DEVICE_CHANGED, (e2) => {
        jC.info("camera device changed", JSON.stringify(e2)), GB.onCameraChanged && GB.onCameraChanged(e2), GB.safeEmit(Tv.CAMERA_CHANGED, e2);
      }), kb.on(rb.RECORDING_DEVICE_CHANGED, (e2) => {
        jC.info("microphone device changed", JSON.stringify(e2)), GB.onMicrophoneChanged && GB.onMicrophoneChanged(e2), GB.safeEmit(Tv.MICROPHONE_CHANGED, e2);
      }), kb.on(rb.PLAYOUT_DEVICE_CHANGED, (e2) => {
        jC.debug("playout device changed", JSON.stringify(e2)), GB.onPlaybackDeviceChanged && GB.onPlaybackDeviceChanged(e2), GB.safeEmit(Tv.PLAYBACK_DEVICE_CHANGED, e2);
      }), Gb.onAutoplayFailed = () => {
        jC.info("detect audio element autoplay failed"), Ub.onAudioAutoplayFailed && Ub.onAudioAutoplayFailed();
      }, _b.on("autoplay-failed", () => {
        jC.info("detect webaudio autoplay failed"), Ub.onAudioAutoplayFailed && Ub.onAudioAutoplayFailed(), GB.safeEmit(Tv.AUTOPLAY_FAILED);
      }), _b.on(vA.STATE_CHANGE, (e2, t2) => {
        jC.info("audio context state changed: ".concat(t2, " => ").concat(e2)), GB.onAudioContextStateChanged && GB.onAudioContextStateChanged(e2, t2), GB.safeEmit(Tv.AUDIO_CONTEXT_STATE_CHANGED, e2, t2);
      }), wT.on(TT.NETWORK_STATE_CHANGE, (e2, t2) => {
        jC.info("[network-indicator] network state changed, ".concat(t2, " => ").concat(e2));
      }), window && (window.__ARTC__ = GB), GB;
    });
  }
});

// node_modules/@facephi/sdk-video-recording/dist/hooks/useVideoRecording.js
var import_agora_rtc_sdk_ng = __toESM(require_AgoraRTC_N_production(), 1);

// node_modules/@facephi/sdk-video-recording/dist/hooks/useRecordingWs.js
var WsMessage;
(function(WsMessage2) {
  WsMessage2["CREDENTIALS_REQUEST"] = "CREDENTIALS_REQUEST";
  WsMessage2["CREDENTIALS_RESPONSE"] = "CREDENTIALS_RESPONSE";
  WsMessage2["WAITING_CONFIRMATION"] = "WAITING_CONFIRMATION";
  WsMessage2["IDENTIFICATION_STARTED"] = "IDENTIFICATION_STARTED";
  WsMessage2["STOP"] = "STOP";
  WsMessage2["IDENTIFICATION_STOPPED"] = "IDENTIFICATION_STOPPED";
})(WsMessage || (WsMessage = {}));
var useRecordingWs = ({ apiUrl, apiKey, handleRecording, handleCredentials, handleError }) => {
  let websocket;
  let error = false;
  let enabled = false;
  let idTimeout;
  let operationId;
  let tenantId;
  const setParams = ({ operation, tenant }) => {
    tenantId = tenant;
    if (operationId !== operation) {
      operationId = operation;
      setWebsocket();
    }
  };
  const setWebsocket = () => {
    if (websocket && websocket.readyState === websocket.OPEN) {
      closeWebSocket(false);
    }
    websocket = null;
    if (enabled && operationId) {
      const ws = new WebSocket(apiUrl);
      ws.onerror = () => setError(true);
      ws.onmessage = (lastMessage) => handleMessage(lastMessage.data);
      ws.onopen = () => sendCredentials();
      websocket = ws;
    }
  };
  const setError = (value) => {
    error = value;
    if (error) {
      closeWebSocket();
    }
    handleError(value);
  };
  const sendWs = (data) => {
    if (websocket && websocket.readyState === websocket.OPEN) {
      websocket.send(JSON.stringify(data));
    }
  };
  const handleMessage = (data) => {
    if (data) {
      const message = JSON.parse(data);
      switch (message.type) {
        case WsMessage.CREDENTIALS_RESPONSE:
          handleCredentials(message.credentials);
          break;
        case WsMessage.IDENTIFICATION_STARTED:
          handleLoading(false);
          handleRecording === null || handleRecording === void 0 ? void 0 : handleRecording(true);
          break;
      }
    }
  };
  const sendCredentials = () => {
    sendWs({
      type: WsMessage.CREDENTIALS_REQUEST,
      apiKey,
      sessionId: operationId
    });
  };
  const handleLoading = (isLoading) => {
    idTimeout && clearTimeout(idTimeout);
    idTimeout = null;
    if (isLoading) {
      idTimeout = setTimeout(() => {
        setError(true);
      }, 15e3);
    }
  };
  const setEnabled = (value) => {
    if (enabled !== value) {
      enabled = value;
      setWebsocket();
    }
  };
  const getCredentials = () => {
    setEnabled(true);
    handleLoading(true);
  };
  const startRecord = () => {
    sendWs({
      type: WsMessage.WAITING_CONFIRMATION,
      sessionId: operationId,
      tenantId
    });
  };
  const stopRecord = () => {
    sendWs({
      type: WsMessage.STOP,
      apiKey,
      sessionId: operationId,
      tenantId
    });
  };
  const resetVariables = () => {
    setError(false);
    handleRecording === null || handleRecording === void 0 ? void 0 : handleRecording(false);
    handleLoading(false);
    handleCredentials(void 0);
  };
  const closeWebSocket = (enabled2 = true) => {
    if (websocket) {
      stopRecord();
      websocket.close();
    }
    resetVariables();
    if (enabled2) {
      setEnabled(false);
    }
  };
  return {
    setParams,
    getCredentials,
    startRecord,
    stopRecord: closeWebSocket
  };
};

// node_modules/@facephi/sdk-video-recording/dist/hooks/useVideoRecording.js
import_agora_rtc_sdk_ng.default.setLogLevel(4);
var useVideo = ({ baseUrl, apiKey, audio, video = true, setChannel, handleRecording, handleError }) => {
  let tracksRef = [];
  let error = false;
  let errorWs = false;
  const agoraClient = import_agora_rtc_sdk_ng.default.createClient({
    mode: "rtc",
    codec: "vp8"
  });
  let hasAudio = audio;
  let hasVideo = video;
  const setAudio = (enabledAudio) => {
    hasAudio = enabledAudio;
  };
  const setVideo = (enabledVideo) => {
    hasVideo = enabledVideo;
  };
  const handleVideoError = () => {
    handleError === null || handleError === void 0 ? void 0 : handleError(error || errorWs);
  };
  const setError = (hasError) => {
    error = hasError;
    handleVideoError();
  };
  const handleCredentials = (credentials) => {
    if (credentials) {
      joinToChannel(credentials);
    }
  };
  const handleErrorWs = (hasError) => {
    errorWs = hasError;
    if (hasError) {
      closeTracks();
    }
    handleVideoError();
  };
  const { setParams: setParamsWs, getCredentials, startRecord, stopRecord } = useRecordingWs({
    apiUrl: `wss://${baseUrl}/identification`,
    apiKey,
    handleRecording,
    handleCredentials,
    handleError: handleErrorWs
  });
  const setParams = ({ autoStart, tenantId, operationId }) => {
    handleStop();
    if (operationId) {
      setParamsWs({ operation: operationId, tenant: tenantId });
      if (autoStart) {
        handleStart();
      }
    }
  };
  const handleMuted = () => {
    var _a, _b;
    if (!hasAudio) {
      (_a = tracksRef[0]) === null || _a === void 0 ? void 0 : _a.setMuted(true);
    }
    if (!hasVideo) {
      (_b = tracksRef[1]) === null || _b === void 0 ? void 0 : _b.setMuted(true);
    }
  };
  const onChangeChannel = () => {
    const channel = {
      audio: tracksRef[0] || null,
      video: tracksRef[1] || null
    };
    const hasTrack = Object.values(channel).some((item) => item);
    setChannel === null || setChannel === void 0 ? void 0 : setChannel(hasTrack ? channel : void 0);
  };
  const handleStart = async () => {
    setError(false);
    try {
      const [audioTrack, videoTrack] = await import_agora_rtc_sdk_ng.default.createMicrophoneAndCameraTracks(void 0, {
        encoderConfig: "720p_2",
        facingMode: "environment"
      });
      tracksRef = [audioTrack, videoTrack];
      handleMuted();
      onChangeChannel();
      getCredentials();
    } catch (_a) {
      setError(true);
    }
  };
  const joinToChannel = async (credentials) => {
    try {
      await agoraClient.join(credentials.appId, credentials.channel, credentials.cameraToken, credentials.cameraUid);
      tracksRef === null || tracksRef === void 0 ? void 0 : tracksRef.forEach(async (item) => {
        if (item) {
          await agoraClient.publish(item);
        }
      });
      startRecord();
    } catch (_a) {
      setError(true);
    }
  };
  const closeTracks = () => {
    tracksRef === null || tracksRef === void 0 ? void 0 : tracksRef.forEach(async (item) => {
      item === null || item === void 0 ? void 0 : item.stop();
      item === null || item === void 0 ? void 0 : item.close();
    });
    tracksRef = [];
    onChangeChannel();
    if (agoraClient.connectionState === "CONNECTED") {
      agoraClient.unpublish();
      agoraClient.leave();
    }
  };
  const handleStop = () => {
    stopRecord();
    closeTracks();
  };
  const getCameras = async () => {
    const cameras = await import_agora_rtc_sdk_ng.default.getCameras();
    return cameras.map(({ deviceId, label }) => ({
      deviceId,
      label
    }));
  };
  const getTypeCameras = async (facingMode) => {
    const cameras = await getCameras();
    return cameras.reduce(async (acc, item) => {
      const rest = await acc;
      try {
        const camera = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: { exact: facingMode },
            deviceId: { exact: item.deviceId }
          }
        });
        if (camera) {
          rest.push(item.deviceId);
        }
      } catch (_a) {
      }
      return rest;
    }, Promise.resolve([]));
  };
  const setCamera = async (facingMode) => {
    var _a, _b, _c, _d;
    const availableCameras = await getTypeCameras(facingMode);
    const currentDeviceId = (_c = (_b = (_a = tracksRef[1]) === null || _a === void 0 ? void 0 : _a.getMediaStreamTrack()) === null || _b === void 0 ? void 0 : _b.getSettings()) === null || _c === void 0 ? void 0 : _c.deviceId;
    if ((availableCameras === null || availableCameras === void 0 ? void 0 : availableCameras.length) && currentDeviceId !== availableCameras[0]) {
      await ((_d = tracksRef[1]) === null || _d === void 0 ? void 0 : _d.setDevice(availableCameras[0]));
      handleMuted();
      onChangeChannel();
    }
  };
  return {
    setAudio,
    setVideo,
    setParams,
    handleStop,
    getCameras,
    getTypeCameras,
    handleStart,
    setCameraRear: () => setCamera("environment"),
    setCameraFront: () => setCamera("user")
  };
};

// node_modules/@facephi/sdk-web-wc/dist/esm/facephi-video-provider.entry.js
var videoProviderCss = ":host{display:flex;width:100%;height:100%;flex:1;margin:0;padding:0}";
var VideoProvider = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.changeChannel = createEvent(this, "changeChannel", 7);
    this.changeLoading = createEvent(this, "changeLoading", 7);
    this.handleChannel = (channel) => {
      this.channel = channel;
      this.changeChannel.emit(this.channel);
    };
    this.loading = true;
    this.tenantId = void 0;
    this.operationId = void 0;
    this.videoOptions = void 0;
    this.component = void 0;
  }
  updateComponent(newValue) {
    if (newValue) {
      this.videoOptions = Object.assign(Object.assign({}, this.videoOptions), { apiKey: newValue.parameters.apiKey, baseUrl: newValue.parameters.baseUrl });
    }
  }
  updateTenantId(newValue) {
    if (newValue) {
      this.videoOptions = Object.assign(Object.assign({}, this.videoOptions), { tenantId: newValue });
    }
  }
  updateOperationId(newValue) {
    if (newValue) {
      this.videoOptions = Object.assign(Object.assign({}, this.videoOptions), { operationId: newValue });
    }
  }
  checkVideoOptions(newValue) {
    if (newValue.apiKey && newValue.baseUrl && newValue.tenantId && newValue.operationId) {
      this.handleVideo(newValue.operationId, newValue.tenantId);
      this.startVideo();
      this.loading = false;
    }
  }
  connectedCallback() {
    this.disconnectComponent = onChange("components", (components) => {
      var _a, _b;
      this.component = components[LicenseComponents.videoRecording];
      this.tenantId = (_b = (_a = components[LicenseComponents.tracking]) === null || _a === void 0 ? void 0 : _a.parameters) === null || _b === void 0 ? void 0 : _b.tenantId;
    });
    this.disconnectComponent = onChange("tenantId", (tenantId) => {
      this.tenantId = tenantId;
    });
    this.disconnectComponent = onChange("operationId", (operationId) => {
      this.operationId = operationId;
    });
  }
  handleVideo(operationId, tenantId) {
    if (this.videoOptions.baseUrl && this.videoOptions.apiKey) {
      const { setParams, handleStart, handleStop, setCameraFront, setCameraRear } = useVideo({
        baseUrl: this.videoOptions.baseUrl,
        apiKey: this.videoOptions.apiKey,
        audio: true,
        setChannel: this.handleChannel
      });
      this.startVideo = handleStart;
      this.handleStopVideo = handleStop;
      this.handleCameraRear = setCameraRear;
      this.handleCameraFront = setCameraFront;
      setParams({ operationId, tenantId });
    }
  }
  handleLoading() {
    this.changeLoading.emit(this.loading);
  }
  disconnectedCallback() {
    this.handleStopVideo();
    this.disconnectComponent();
  }
  async stopVideo() {
    var _a;
    (_a = this.handleStopVideo) === null || _a === void 0 ? void 0 : _a.call(this);
  }
  async setCameraRear() {
    var _a;
    return (_a = this.handleCameraRear) === null || _a === void 0 ? void 0 : _a.call(this);
  }
  async setCameraFront() {
    var _a;
    return (_a = this.handleCameraFront) === null || _a === void 0 ? void 0 : _a.call(this);
  }
  async getChannel() {
    return this.channel;
  }
  render() {
    return this.loading ? null : h(Host, null, h("slot", null));
  }
  get host() {
    return getElement(this);
  }
  static get watchers() {
    return {
      "component": ["updateComponent"],
      "tenantId": ["updateTenantId"],
      "operationId": ["updateOperationId"],
      "videoOptions": ["checkVideoOptions"],
      "loading": ["handleLoading"]
    };
  }
};
VideoProvider.style = videoProviderCss;
export {
  VideoProvider as facephi_video_provider
};
/*! Bundled license information:

agora-rtc-sdk-ng/AgoraRTC_N-production.js:
  (*! formdata-polyfill. MIT License. Jimmy W?rting <https://jimmy.warting.se/opensource> *)
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)
*/
//# sourceMappingURL=facephi-video-provider.entry-ZGYSXBD2.js.map
